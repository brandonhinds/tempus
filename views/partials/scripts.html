<script>
  // Layout navigation
  const pageTime = document.getElementById('page-time');
  const pageContracts = document.getElementById('page-contracts');
  const pageHourTypes = document.getElementById('page-hour-types');
  const pageSettings = document.getElementById('page-settings');
  const navToggle = document.getElementById('nav-toggle');
  const navMenu = document.getElementById('nav-menu');
  const navTimeBtn = document.getElementById('nav-time');
  const navContractsBtn = document.getElementById('nav-contracts');
  const navHourTypesBtn = document.getElementById('nav-hour-types');
  const navSettingsBtn = document.getElementById('nav-settings');

  const state = {
    cacheKey: 'ts_cache',
    entries: [],
    settings: {},
    contracts: [],
    contractMap: {},
    hourTypes: [],
    hourTypeMap: {},
    featureFlags: {},
    editingEntryId: null,
    editingEntryType: null,
    editingContractId: null,
    editingHourTypeId: null,
    contractFormMode: 'hidden',
    calendar: null,
    selectedCalendarDate: null,
    showZeroHours: false,
    currentPage: 'time',
    incomeSummary: null,
    pendingTaxRequest: null,
    selectedContractId: '',
    punchDraft: null,
    currentTab: 'manual'
  };

  const PAGE_KEYS = ['time', 'contracts', 'hour-types', 'settings'];
  const LAST_PAGE_KEY = 'ts_last_page';

  function persistLastPage(page) {
    if (!PAGE_KEYS.includes(page)) return;
    try {
      if (state.featureFlags.remember_last_page) {
        localStorage.setItem(LAST_PAGE_KEY, page);
      } else {
        localStorage.removeItem(LAST_PAGE_KEY);
      }
    } catch (e) {}
  }

  function showPage(target, options) {
    const opts = options || {};
    const normalized = PAGE_KEYS.includes(target) ? target : 'time';
    const pages = {
      time: pageTime,
      contracts: pageContracts,
      'hour-types': pageHourTypes,
      settings: pageSettings
    };
    Object.keys(pages).forEach((key) => {
      const page = pages[key];
      if (page) page.style.display = key === normalized ? 'block' : 'none';
    });
    state.currentPage = normalized;
    if (!opts.skipRemember) {
      persistLastPage(normalized);
    }
  }

  function closeNavMenu() {
    if (!navMenu) return;
    navMenu.hidden = true;
    if (navToggle) navToggle.setAttribute('aria-expanded', 'false');
  }

  function openNavMenu() {
    if (!navMenu) return;
    navMenu.hidden = false;
    if (navToggle) navToggle.setAttribute('aria-expanded', 'true');
  }

  function toggleNavMenu() {
    if (!navMenu) return;
    const expanded = navToggle && navToggle.getAttribute('aria-expanded') === 'true';
    if (expanded) {
      closeNavMenu();
    } else {
      openNavMenu();
    }
  }

  if (navToggle && navMenu) {
    navToggle.addEventListener('click', (event) => {
      event.stopPropagation();
      toggleNavMenu();
    });
  }

  if (navMenu) {
    navMenu.addEventListener('click', (event) => {
      if ((event.target instanceof HTMLElement) && event.target.tagName === 'BUTTON') {
        closeNavMenu();
      }
    });
  }

  document.addEventListener('click', (event) => {
    if (!navMenu || navMenu.hidden) return;
    if (navToggle && (event.target === navToggle || navToggle.contains(event.target))) return;
    if (navMenu.contains(event.target)) return;
    closeNavMenu();
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') closeNavMenu();
  });

  if (navTimeBtn) navTimeBtn.onclick = () => { closeNavMenu(); showPage('time'); };
  if (navContractsBtn) navContractsBtn.onclick = () => { closeNavMenu(); showPage('contracts'); };
  if (navHourTypesBtn) navHourTypesBtn.onclick = () => { closeNavMenu(); showPage('hour-types'); };
  if (navSettingsBtn) navSettingsBtn.onclick = () => { closeNavMenu(); showPage('settings'); };
  closeNavMenu();
  showPage('time', { skipRemember: true });

  // Helpers

  const $ = (selector) => document.querySelector(selector);
  const $$ = (selector) => Array.from(document.querySelectorAll(selector));
  const fmt = (minutes) => {
    const total = Number(minutes) || 0;
    const h = Math.floor(total / 60);
    const mm = total % 60;
    return (h > 0 ? h + ':' : '') + String(mm).padStart(2, '0');
  };
  const setStatus = (text, cls) => {
    const el = document.getElementById('status');
    el.textContent = text;
    el.className = 'ts-badge ' + (cls || '');
  };
  const isoDate = (date) => {
    const d = new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };
  const isoDateTime = (date) => new Date(date).toISOString().replace(/\.\d{3}Z$/, 'Z');
  const parseIsoDate = (value) => {
    const [y, m, d] = value.split('-').map(Number);
    return new Date(y, m - 1, d);
  };
  const todayIso = () => isoDate(new Date());
  const MONTH_ABBREVIATIONS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const formatMonthShortYear = (dateObj) => {
    if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) return '';
    const month = MONTH_ABBREVIATIONS[dateObj.getMonth()] || '';
    const year = dateObj.getFullYear();
    return `${month} ${String(year).slice(-2)}`;
  };
  const formatHours = (minutes) => {
    const hrs = (Number(minutes) || 0) / 60;
    let out = (Math.round(hrs * 100) / 100).toFixed(2);
    out = out.replace(/\.00$/, '');
    out = out.replace(/(\.\d)0$/, '$1');
    return out === '' ? '0' : out;
  };
  const minutesToTime = (minutes) => {
    const mins = Math.max(0, Math.round(Number(minutes) || 0));
    if (mins >= 24 * 60) return '23:59';
    const h = Math.floor(mins / 60);
    const m = mins % 60;
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
  };
  const DEFAULT_SUPER_RATE = 0.12;
  const currencyFormatter = new Intl.NumberFormat(undefined, {
    style: 'currency',
    currency: 'AUD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
  const formatCurrency = (value) => {
    const num = Number(value);
    if (!Number.isFinite(num)) return '--';
    return currencyFormatter.format(num);
  };
  const getSuperRateSetting = () => {
    const raw = state.settings ? state.settings.superannuation_rate : undefined;
    const num = Number(raw);
    if (Number.isFinite(num) && num >= 0) {
      return num > 1 ? num / 100 : num;
    }
    return DEFAULT_SUPER_RATE;
  };
  const getSuperRatePercentage = () => Math.round(getSuperRateSetting() * 1000) / 10;
  const sanitizeSuperRateInputValue = (value) => {
    const num = Number(value);
    if (Number.isFinite(num) && num >= 0) return Math.round(num * 10) / 10;
    return Math.round(DEFAULT_SUPER_RATE * 1000) / 10;
  };
  const getSalarySacrificePlaceholder = () => 0; // Stub for salary sacrifice configuration.
  const getExtraSuperPlaceholder = () => 0; // Stub for future extra super contributions.

  const getRoundInterval = () => {
    const value = Number(state.settings.round_to_nearest);
    return Number.isFinite(value) && value > 1 ? value : 0;
  };
  const roundDuration = (minutes) => {
    const base = Math.max(0, Math.round(Number(minutes) || 0));
    const interval = getRoundInterval();
    if (!interval) return Math.max(1, base);
    const rounded = Math.round(base / interval) * interval;
    return Math.max(interval, rounded);
  };

  const TIME_PATTERN = /^\d{2}:\d{2}$/;
  const normalizeTimeValue = (value) => {
    if (!value && value !== 0) return '';
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (TIME_PATTERN.test(trimmed)) return trimmed;
      const parsed = new Date(`1970-01-01T${trimmed}:00`);
      if (!Number.isNaN(parsed.getTime())) return parsed.toTimeString().slice(0, 5);
    } else if (value instanceof Date) {
      return value.toTimeString().slice(0, 5);
    }
    const coerced = new Date(value);
    if (!Number.isNaN(coerced.getTime())) return coerced.toTimeString().slice(0, 5);
    return '';
  };
  const timeToMinutes = (time) => {
    if (!time || !TIME_PATTERN.test(time)) return null;
    const parts = time.split(':');
    return Number(parts[0]) * 60 + Number(parts[1]);
  };
  const clonePunches = (punches) => (Array.isArray(punches) ? punches.map((p) => ({ in: p.in || '', out: p.out || '' })) : []);
  const normalizePunchList = (value) => {
    if (!value) return [];
    let source = value;
    if (typeof source === 'string') {
      try {
        source = JSON.parse(source);
      } catch (e) {
        source = [];
      }
    }
    if (!Array.isArray(source)) source = source ? [source] : [];
    const punches = source.reduce((acc, raw) => {
      if (!raw) return acc;
      const start = normalizeTimeValue(raw.in || raw.start || raw.start_time || raw.startTime);
      if (!start) return acc;
      let end = normalizeTimeValue(raw.out || raw.stop || raw.end || raw.end_time || raw.endTime);
      if (end && timeToMinutes(end) !== null && timeToMinutes(start) !== null && timeToMinutes(end) < timeToMinutes(start)) {
        end = '';
      }
      acc.push({ in: start, out: end || '' });
      return acc;
    }, []);
    punches.sort((a, b) => {
      if (a.in === b.in) return (a.out || '').localeCompare(b.out || '');
      return a.in.localeCompare(b.in);
    });
    return punches;
  };
  const summarizePunches = (punches) => {
    if (!Array.isArray(punches) || !punches.length) {
      return { totalMinutes: 0, earliest: '', latest: '', openCount: 0 };
    }
    let earliest = '';
    let latest = '';
    let total = 0;
    let openCount = 0;
    punches.forEach((punch) => {
      if (!punch || !punch.in) return;
      if (!earliest || punch.in < earliest) earliest = punch.in;
      if (punch.out) {
        if (!latest || punch.out > latest) latest = punch.out;
        const startMinutes = timeToMinutes(punch.in);
        const endMinutes = timeToMinutes(punch.out);
        if (startMinutes !== null && endMinutes !== null && endMinutes > startMinutes) {
          total += endMinutes - startMinutes;
        }
      } else {
        openCount += 1;
      }
    });
    return { totalMinutes: total, earliest, latest, openCount };
  };
  const validatePunches = (punches, options = {}) => {
    const { allowOpen = true, requireClosed = false } = options;
    const sorted = normalizePunchList(punches);
    let lastEnd = null;
    let openCount = 0;
    for (let idx = 0; idx < sorted.length; idx += 1) {
      const punch = sorted[idx];
      const startMinutes = timeToMinutes(punch.in);
      if (startMinutes === null) {
        return 'Each punch needs a valid start time.';
      }
      if (!punch.out) {
        openCount += 1;
        if (requireClosed) {
          return 'Please enter an end time for each punch.';
        }
        if (!allowOpen && openCount > 0) {
          return 'Close any open punches before saving.';
        }
        if (lastEnd !== null && startMinutes < lastEnd) {
          return 'Punch ranges cannot overlap.';
        }
        lastEnd = startMinutes;
        continue;
      }
      const endMinutes = timeToMinutes(punch.out);
      if (endMinutes === null || endMinutes <= startMinutes) {
        return 'Punch out must be later than punch in.';
      }
      if (lastEnd !== null && startMinutes < lastEnd) {
        return 'Punch ranges cannot overlap.';
      }
      lastEnd = endMinutes;
    }
    return null;
  };

  const entryPunches = (entry) => {
    if (entry && Array.isArray(entry.punches) && entry.punches.length) {
      return entry.punches.map((punch) => ({ in: punch.in || '', out: punch.out || '' }));
    }
    if (entry && entry.start_time && entry.end_time) {
      return [{ in: entry.start_time, out: entry.end_time }];
    }
    return [];
  };
  const entryFirstPunchMinutes = (entry) => {
    const punches = entryPunches(entry);
    if (punches.length) {
      const mins = timeToMinutes(punches[0].in);
      if (mins !== null) return mins;
    }
    const fallback = timeToMinutes(entry && entry.start_time ? entry.start_time : '');
    return fallback !== null ? fallback : 24 * 60;
  };
  const getEntryPunchSummary = (entry) => {
    const punches = entryPunches(entry);
    if (!punches.length) {
      const start = entry && entry.start_time ? entry.start_time : '--:--';
      const end = entry && entry.end_time ? entry.end_time : '--:--';
      return `${start} - ${end}`;
    }
    const summary = summarizePunches(punches);
    const start = summary.earliest || '--:--';
    const end = summary.openCount > 0 ? 'Open' : (summary.latest || '--:--');
    return `${start} - ${end}`;
  };
  const getEntryPunchDetail = (entry) => {
    const punches = entryPunches(entry);
    if (!punches.length) return '';
    return punches.map((punch) => `${punch.in || '--:--'} - ${punch.out || 'Open'}`).join(', ');
  };

  const sanitizeEntry = (entry) => {
    if (!entry) return entry;
    const clone = { ...entry };
    const punches = normalizePunchList(clone.punches != null ? clone.punches : clone.punches_json);
    clone.punches = clonePunches(punches);
    clone.punches_json = JSON.stringify(clone.punches);
    const summary = summarizePunches(clone.punches);
    if (clone.punches.length) {
      let worked = summary.totalMinutes;
      if (clone.duration_minutes != null && Number.isFinite(Number(clone.duration_minutes))) {
        clone.duration_minutes = Math.max(0, Math.round(Number(clone.duration_minutes)));
      } else {
        clone.duration_minutes = Math.max(0, Math.round(worked));
      }
    } else {
      clone.duration_minutes = Math.max(0, Math.round(Number(clone.duration_minutes) || 0));
    }
    clone.open_punch_count = summary.openCount || 0;
    delete clone.break;
    delete clone.description;
    const contractId = clone.contract_id || clone.contractId || clone.project || '';
    clone.contract_id = contractId ? String(contractId).trim() : '';
    delete clone.project;
    delete clone.contractId;
    // Preserve entry_type if it exists
    if (clone.entry_type) {
      clone.entry_type = String(clone.entry_type).trim();
    }
    return clone;
  };

  const sanitizeContract = (contract) => {
    if (!contract) return contract;
    const clone = { ...contract };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.start_date = clone.start_date || clone.startDate || '';
    clone.end_date = clone.end_date || clone.endDate || '';
    clone.hourly_rate = Number(clone.hourly_rate != null ? clone.hourly_rate : 0);
    if (Number.isNaN(clone.hourly_rate)) clone.hourly_rate = 0;
    clone.total_hours = Number(clone.total_hours != null ? clone.total_hours : (clone.totalHours != null ? clone.totalHours : 0));
    if (Number.isNaN(clone.total_hours) || clone.total_hours < 0) clone.total_hours = 0;
    delete clone.startDate;
    delete clone.endDate;
    delete clone.hourlyRate;
    delete clone.totalHours;
    return clone;
  };

  const sanitizeHourType = (hourType) => {
    if (!hourType) return hourType;
    const clone = { ...hourType };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.slug = clone.slug ? String(clone.slug).trim() : '';
    clone.color = clone.color ? String(clone.color).trim() : '#6b7280';
    clone.contributes_to_income = Boolean(clone.contributes_to_income === 'TRUE' || clone.contributes_to_income === true);
    clone.requires_contract = Boolean(clone.requires_contract === 'TRUE' || clone.requires_contract === true);
    clone.is_default = Boolean(clone.is_default === 'TRUE' || clone.is_default === true);
    clone.created_at = clone.created_at || '';
    return clone;
  };

  const DEFAULT_FEATURE_FLAGS = {
    remember_last_page: {
      name: 'Remember last page on refresh',
      description: 'When enabled, the app reopens on the most recently viewed page.'
    },
    show_clear_cache: {
      name: 'Show cache clear button',
      description: 'Displays a button that lets you clear cached entries and settings from this browser.'
    },
    show_zero_hours: {
      name: 'Show zero hours on empty days',
      description: 'When enabled, days without logged time display a 0 instead of being blank.'
    },
    hour_types: {
      name: 'Hour Types',
      description: 'Enables tracking different types of hours (work, annual, sick, training, etc.) with configurable income contribution and visualization.'
    }
  };

  const THEME_KEYS = ['dark', 'light', 'rose', 'og'];

  function applyTheme(theme) {
    const normalized = THEME_KEYS.includes(theme) ? theme : 'dark';
    const body = document.body;
    THEME_KEYS.forEach((key) => body.classList.remove('ts-theme-' + key));
    body.classList.add('ts-theme-' + normalized);
    state.settings = { ...state.settings, theme: normalized };
    if (themeSelect) themeSelect.value = normalized;
  }

  const normalizeFeatureFlags = (raw) => {
    const out = {};
    if (raw && typeof raw === 'object') {
      Object.keys(raw).forEach((key) => {
        const value = raw[key];
        const enabled = value && typeof value === 'object' ? !!value.enabled : !!value;
        const name = value && typeof value === 'object' && value.name ? String(value.name) : '';
        const description = value && typeof value === 'object' && value.description ? String(value.description) : '';
        out[key] = {
          enabled,
          name,
          description
        };
      });
    }
    Object.keys(DEFAULT_FEATURE_FLAGS).forEach((key) => {
      if (!out[key]) {
        out[key] = {
          enabled: false,
          name: DEFAULT_FEATURE_FLAGS[key].name,
          description: DEFAULT_FEATURE_FLAGS[key].description
        };
      } else {
        out[key].name = out[key].name || DEFAULT_FEATURE_FLAGS[key].name;
        out[key].description = out[key].description || DEFAULT_FEATURE_FLAGS[key].description;
      }
    });
    return out;
  };

  function updateContractMap() {
    state.contractMap = state.contracts.reduce((map, contract) => {
      map[contract.id] = contract;
      return map;
    }, {});
  }

  function updateHourTypeMap() {
    state.hourTypeMap = state.hourTypes.reduce((map, hourType) => {
      map[hourType.id] = hourType;
      return map;
    }, {});
  }

  const contractIsValid = (contract, dateIso) => {
    if (!contract || !dateIso) return false;
    if (contract.start_date && contract.start_date > dateIso) return false;
    if (contract.end_date && contract.end_date !== '' && contract.end_date < dateIso) return false;
    return true;
  };

  function validContractsForDate(dateIso) {
    if (!dateIso) return [];
    return state.contracts.filter((contract) => contractIsValid(contract, dateIso));
  }

  function getContractName(id) {
    if (!id) return '';
    const match = state.contractMap[id];
    if (match) return match.name;
    return '';
  }

  const contractBadge = (entry) => {
    const name = getContractName(entry.contract_id);
    if (name) return `<span class="ts-badge">${name}</span>`;
    if (entry.contract_id) return `<span class="ts-badge warn">Unknown contract</span>`;
    return `<span class="ts-badge warn">No contract</span>`;
  };

  function loadCache() {
    try {
      const raw = localStorage.getItem(state.cacheKey);
      if (!raw) return;
      const obj = JSON.parse(raw);
      state.entries = Array.isArray(obj.entries) ? obj.entries.map(sanitizeEntry) : [];
      state.settings = obj.settings || {};
      state.contracts = Array.isArray(obj.contracts) ? obj.contracts.map(sanitizeContract) : [];
      state.hourTypes = Array.isArray(obj.hourTypes) ? obj.hourTypes.map(sanitizeHourType) : [];
      state.featureFlags = normalizeFeatureFlags(obj.featureFlags);

      // Set initial tab based on today's entry type
      const today = todayIso();
      const todayEntry = state.entries.find(entry => entry.date === today);
      if (todayEntry && todayEntry.entry_type === 'advanced') {
        activateTab('punch');
        if (punchDate) punchDate.value = today;
        ensurePunchDraft(todayEntry.contract_id);
      }
      updateTabStates();
      updateContractMap();
      updateHourTypeMap();
      applyTheme((state.settings && state.settings.theme) || 'dark');
    } catch (e) {}
  }
  function saveCache() {
    try {
      const payload = {
        entries: state.entries.map(sanitizeEntry),
        settings: state.settings,
        contracts: state.contracts.map(sanitizeContract),
        hourTypes: state.hourTypes.map(sanitizeHourType),
        featureFlags: normalizeFeatureFlags(state.featureFlags)
      };
      localStorage.setItem(state.cacheKey, JSON.stringify(payload));
    } catch (e) {}
  }

  // Tabs
  function activateTab(id) {
    // Prevent switching tabs when editing an existing entry or when punch draft has changes
    const isEditingEntry = state.editingEntryId && state.currentTab !== id;
    const isEditingPunch = state.punchDraft && state.punchDraft.dirty && state.currentTab !== id;
    
    // Also prevent switching if we're editing a basic entry and trying to switch to advanced, or vice versa
    const isWrongEntryType = state.editingEntryId && (
      (state.editingEntryType === 'basic' && id === 'punch') ||
      (state.editingEntryType === 'advanced' && id === 'manual')
    );

    // Prevent switching tabs if the selected date already has data in the opposite format
    const hasConflictingData = (() => {
      if (!state.selectedCalendarDate) return false;
      const existingEntry = state.entries.find(entry => entry.date === state.selectedCalendarDate);
      if (!existingEntry) return false;

      // Prevent switching to basic if date has advanced entry
      if (id === 'manual' && existingEntry.entry_type === 'advanced') return true;
      // Prevent switching to advanced if date has basic entry
      if (id === 'punch' && existingEntry.entry_type === 'basic') return true;

      return false;
    })();

    if (isEditingEntry || isEditingPunch || isWrongEntryType || hasConflictingData) {
      return;
    }
    
    // Update tab visual states
    $$('.ts-tab').forEach((tab) => {
      const target = tab.getAttribute('data-tab');
      tab.classList.toggle('active', target === id);
    });
    updateTabStates();
    ['manual', 'punch'].forEach((pane) => {
      const el = document.getElementById('tab-' + pane);
      if (el) el.style.display = pane === id ? 'block' : 'none';
    });

    // When switching to advanced mode, sync the punch date with the selected calendar date
    if (id === 'punch' && state.selectedCalendarDate && punchDate) {
      punchDate.value = state.selectedCalendarDate;
      // Clear any existing draft to prevent inheriting data from other dates
      state.punchDraft = null;
      ensurePunchDraft();
    }

    state.currentTab = id;
  }
  $$('.ts-tab').forEach((tab) => {
    tab.addEventListener('click', () => activateTab(tab.getAttribute('data-tab')));
  });

  // Function to update tab disabled states
  function updateTabStates() {
    $$('.ts-tab').forEach((tab) => {
      const target = tab.getAttribute('data-tab');

      // Check if this tab should be disabled
      let isDisabled = false;
      let disabledReason = '';
      if (state.selectedCalendarDate) {
        const existingEntry = state.entries.find(entry => entry.date === state.selectedCalendarDate);
        if (existingEntry) {
          // Disable basic tab if date has advanced entry
          if (target === 'manual' && existingEntry.entry_type === 'advanced') {
            isDisabled = true;
            disabledReason = 'This date already has an advanced entry';
          }
          // Disable advanced tab if date has basic entry
          if (target === 'punch' && existingEntry.entry_type === 'basic') {
            isDisabled = true;
            disabledReason = 'This date already has a basic entry';
          }
        }
      }

      tab.style.opacity = isDisabled ? '0.4' : '1';
      tab.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
      tab.title = disabledReason;
    });
  }

  // Default to manual tab initially (will be updated after cache loads)
  activateTab('manual');

  // Punch controls
  const punchDate = document.getElementById('punch-date');
  const punchHourType = document.getElementById('punch-hour-type');
  const punchHourTypeCol = document.getElementById('punch-hour-type-col');
  const punchContract = document.getElementById('punch-contract');
  const punchContractWarning = document.getElementById('punch-contract-warning');
  const punchToggleBtn = document.getElementById('btn-punch-toggle');
  const punchSaveBtn = document.getElementById('btn-punch-save');
  const punchCancelBtn = document.getElementById('btn-punch-cancel');
  const punchDeleteBtn = document.getElementById('btn-delete-punch');
  const punchList = document.getElementById('punch-range-list');
  const punchOpenWarning = document.getElementById('punch-open-warning');
  const punchSummary = document.getElementById('punch-summary');

  function currentPunchDate() {
    return punchDate && punchDate.value ? punchDate.value : todayIso();
  }

  function updatePunchContractOptions(preferredContractId) {
    if (!punchContract) return '';
    const dateIso = currentPunchDate();
    const valid = validContractsForDate(dateIso);
    const currentValue = preferredContractId != null ? preferredContractId : punchContract.value;
    const options = [...valid];
    if (currentValue && !options.some((contract) => contract.id === currentValue)) {
      const fallback = state.contractMap[currentValue];
      if (fallback) options.push(fallback);
    }
    options.sort((a, b) => a.name.localeCompare(b.name));
    punchContract.innerHTML = '';
    if (!options.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts';
      punchContract.appendChild(placeholder);
      punchContract.value = '';
      punchContract.disabled = true;
      if (punchContractWarning) punchContractWarning.style.display = 'block';
      return '';
    }
    if (options.length > 1) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select contract';
      punchContract.appendChild(placeholder);
    }
    options.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      punchContract.appendChild(opt);
    });
    let selected = currentValue && options.some((contract) => contract.id === currentValue) ? currentValue : '';
    if (!selected && valid.length === 1) {
      selected = valid[0].id;
    }
    punchContract.value = selected;
    punchContract.disabled = valid.length === 1 && options.length === valid.length;
    if (punchContractWarning) punchContractWarning.style.display = selected ? 'none' : 'block';
    return punchContract.value;
  }

  function setPunchDate(dateIso, preferredContractId) {
    if (!punchDate) return;
    punchDate.value = dateIso || todayIso();
    updatePunchContractOptions(preferredContractId != null ? preferredContractId : (punchContract ? punchContract.value : ''));
  }

  function ensurePunchDraft(preferredContractId) {
    const selected = updatePunchContractOptions(preferredContractId);
    const contractId = selected || '';
    const dateIso = currentPunchDate();
    
    // If we're switching dates and there's no contract selected, start fresh
    if (!contractId) {
      state.punchDraft = {
        entryId: null,
        contractId: '',
        date: dateIso,
        punches: [{ in: '', out: '' }],
        dirty: false
      };
      renderPunchDraft();
      return;
    }
    
    // Look for existing entry for this specific date and contract
    const entry = state.entries.find((e) => e.date === dateIso && e.contract_id === contractId) || null;
    state.punchDraft = {
      entryId: entry ? entry.id : null,
      contractId,
      date: dateIso,
      punches: entry ? clonePunches(entry.punches || []) : [{ in: '', out: '' }],
      dirty: false
    };

    // Set hour type if editing existing entry
    if (punchHourType && entry && entry.hour_type_id) {
      punchHourType.value = entry.hour_type_id;
      updatePunchContractVisibility();
    }

    renderPunchDraft();
  }

  function setPunchDraftDirty() {
    if (!state.punchDraft) return;
    state.punchDraft.dirty = true;
  }

  function renderPunchDraft() {
    if (!punchList) return;
    punchList.innerHTML = '';
    const draft = state.punchDraft || { punches: [], contractId: '' };
    const punches = draft.punches || [];
    if (!draft.contractId) {
      const note = document.createElement('div');
      note.className = 'ts-note';
      note.textContent = 'Select a contract to view today\'s punches.';
      punchList.appendChild(note);
    } else if (!punches.length || (punches.length === 1 && !punches[0].in)) {
      // Show an empty range for new entries
      const emptyRange = document.createElement('div');
      emptyRange.className = 'ts-punch-row';
      const startInput = document.createElement('input');
      startInput.type = 'time';
      startInput.value = punches.length > 0 ? (punches[0].in || '') : '';
      startInput.className = 'ts-punch-input';
      startInput.onchange = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches[0].in = startInput.value;
        setPunchDraftDirty();
        updatePunchSummary();
      };
      const endInput = document.createElement('input');
      endInput.type = 'time';
      endInput.value = punches.length > 0 ? (punches[0].out || '') : '';
      endInput.className = 'ts-punch-input';
      endInput.onchange = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches[0].out = endInput.value;
        setPunchDraftDirty();
        updatePunchSummary();
      };
      const addBtn = document.createElement('button');
      addBtn.type = 'button';
      addBtn.className = 'ghost';
      addBtn.textContent = 'Add';
      addBtn.onclick = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches.push({ in: '', out: '' });
        setPunchDraftDirty();
        renderPunchDraft();
        // Focus on the new row's start input
        setTimeout(() => {
          const newRow = punchList.children[punchList.children.length - 1];
          const newStartInput = newRow.querySelector('input[type="time"]');
          if (newStartInput) newStartInput.focus();
        }, 0);
      };
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'ghost';
      removeBtn.textContent = 'Remove';
      removeBtn.onclick = () => {
        if (draft.punches.length) draft.punches.splice(0, 1);
        setPunchDraftDirty();
        renderPunchDraft();
      };
      emptyRange.appendChild(startInput);
      emptyRange.appendChild(document.createTextNode(' to '));
      emptyRange.appendChild(endInput);
      emptyRange.appendChild(addBtn);
      emptyRange.appendChild(removeBtn);
      punchList.appendChild(emptyRange);
    } else {
      punches.forEach((punch, index) => {
        const row = document.createElement('div');
        row.className = 'ts-punch-row';
        const startInput = document.createElement('input');
        startInput.type = 'time';
        startInput.value = punch.in || '';
        startInput.className = 'ts-punch-input';
        startInput.onchange = () => {
          draft.punches[index].in = startInput.value;
          setPunchDraftDirty();
          updatePunchSummary();
        };
        const endInput = document.createElement('input');
        endInput.type = 'time';
        endInput.value = punch.out || '';
        endInput.className = 'ts-punch-input';
        endInput.onchange = () => {
          draft.punches[index].out = endInput.value;
          setPunchDraftDirty();
          updatePunchSummary();
        };
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'ghost';
        addBtn.textContent = 'Add';
        addBtn.onclick = () => {
          // Insert new punch after current index
          draft.punches.splice(index + 1, 0, { in: '', out: '' });
          setPunchDraftDirty();
          renderPunchDraft();
          // Focus on the new row's start input
          setTimeout(() => {
            const allRows = punchList.children;
            const newRowIndex = index + 1;
            if (allRows[newRowIndex]) {
              const newStartInput = allRows[newRowIndex].querySelector('input[type="time"]');
              if (newStartInput) newStartInput.focus();
            }
          }, 0);
        };
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'ghost';
        removeBtn.textContent = 'Remove';
        removeBtn.onclick = () => {
          draft.punches.splice(index, 1);
          setPunchDraftDirty();
          renderPunchDraft();
        };
        row.appendChild(startInput);
        row.appendChild(document.createTextNode(' to '));
        row.appendChild(endInput);
        row.appendChild(addBtn);
        row.appendChild(removeBtn);
        punchList.appendChild(row);
      });
    }
    updatePunchSummary();
    const hasContract = !!draft.contractId;
    const hasPunches = punches.length > 0;
    const openCount = summarizePunches(punches).openCount;
    if (punchToggleBtn) {
      punchToggleBtn.textContent = openCount > 0 ? 'Punch Out' : 'Punch In';
      punchToggleBtn.disabled = !hasContract;
    }
    if (punchSaveBtn) {
      punchSaveBtn.disabled = !hasContract || !hasPunches;
      punchSaveBtn.textContent = draft.entryId ? 'Update Entry' : 'Add Entry';
    }
    if (punchCancelBtn) {
      punchCancelBtn.disabled = !hasContract || !draft.dirty;
      punchCancelBtn.style.display = draft.dirty ? 'inline-flex' : 'none';
    }
    if (punchDeleteBtn) {
      punchDeleteBtn.style.display = draft.entryId ? 'inline-flex' : 'none';
    }
  }

  function updatePunchSummary() {
    if (!punchSummary || !punchOpenWarning) return;
    const draft = state.punchDraft || { punches: [] };
    const punches = normalizePunchList(draft.punches || []);
    const summary = summarizePunches(punches);
    if (punches.length) {
      const rounded = summary.totalMinutes > 0 ? roundDuration(summary.totalMinutes) : 0;
      punchSummary.textContent = `Recorded: ${formatHours(rounded)} hours`;
    } else {
      punchSummary.textContent = '';
    }
    if (summary.openCount > 0) {
      const lastOpen = punches.find((p) => !p.out);
      punchOpenWarning.textContent = lastOpen && lastOpen.in ? `Open punch since ${lastOpen.in}. Remember to punch out.` : 'Open punch detected. Please punch out when you finish.';
      punchOpenWarning.style.display = 'block';
    } else {
      punchOpenWarning.style.display = 'none';
    }
  }

  function addPunchRow() {
    if (!state.punchDraft) return;
    state.punchDraft.punches.push({ in: '', out: '' });
    setPunchDraftDirty();
    renderPunchDraft();
  }

  function persistPunchDraft(options = {}) {
    const { requireClosed = false } = options;
    const draft = state.punchDraft;

    // Get hour type
    const hourTypeId = punchHourType ? punchHourType.value : getDefaultHourTypeId();
    const selectedHourType = state.hourTypeMap[hourTypeId];

    // Validate contract based on hour type
    if (selectedHourType && selectedHourType.requires_contract) {
      if (!draft || !draft.contractId) {
        alert('Select a contract before saving punches.');
        return;
      }
    }

    const punches = normalizePunchList(draft.punches || []);
    const validationError = validatePunches(punches, { allowOpen: !requireClosed, requireClosed });
    if (validationError) {
      alert(validationError);
      return;
    }
    const summary = summarizePunches(punches);
    const roundedMinutes = summary.totalMinutes > 0 ? roundDuration(summary.totalMinutes) : 0;
    const payload = {
      date: draft.date,
      contract_id: draft.contractId || '',
      hour_type_id: hourTypeId,
      punches,
      duration_minutes: roundedMinutes,
      round_interval: getRoundInterval(),
      entry_type: 'advanced'
    };
    if (draft.entryId) payload.id = draft.entryId;

    // Optimistic update: Add entry to UI immediately for new entries
    let optimisticEntry = null;
    if (!draft.entryId) {
      optimisticEntry = {
        id: 'temp_' + Date.now(),
        ...payload,
        created_at: isoDateTime(new Date())
      };
      state.entries.unshift(sanitizeEntry(optimisticEntry));
      saveCache();
      renderEntries();
    }

    setStatus('Saving punches...', 'warn');
    renderPunchDraft();

    const onSuccess = (res) => {
      if (res && res.success && res.entry) {
        const sanitized = sanitizeEntry(res.entry);
        if (optimisticEntry) {
          // Replace optimistic entry with real one
          const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
          if (idx > -1) {
            state.entries[idx] = sanitized;
          }
        } else {
          // Update existing entry
          const idx = state.entries.findIndex((e) => e.id === sanitized.id);
          if (idx > -1) {
            state.entries[idx] = sanitized;
          } else {
            state.entries.push(sanitized);
          }
        }
        state.punchDraft = {
          entryId: sanitized.id,
          contractId: sanitized.contract_id,
          date: sanitized.date,
          punches: clonePunches(sanitized.punches || []),
          dirty: false
        };
        saveCache();
        renderEntries();
        setStatus('Punches saved', 'success');
      } else {
        // Remove optimistic entry on failure
        if (optimisticEntry) {
          const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
          if (idx > -1) {
            state.entries.splice(idx, 1);
            saveCache();
            renderEntries();
          }
        }
        setStatus('Punch save failed', 'error');
      }
      renderPunchDraft();
    };

    const onFailure = () => {
      // Remove optimistic entry on failure
      if (optimisticEntry) {
        const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
        if (idx > -1) {
          state.entries.splice(idx, 1);
          saveCache();
          renderEntries();
        }
      }
      setStatus('Punch save failed', 'error');
      renderPunchDraft();
    };

    if (draft.entryId) {
      google.script.run
        .withSuccessHandler(onSuccess)
        .withFailureHandler(onFailure)
        .api_updateEntry(payload);
    } else {
      google.script.run
        .withSuccessHandler(onSuccess)
        .withFailureHandler(onFailure)
        .api_addEntry(payload);
    }
  }

  function handlePunchToggle() {
    const draft = state.punchDraft;
    if (!draft || !draft.contractId) {
      alert('Select a contract before punching in.');
      return;
    }
    const now = new Date();
    const currentTime = now.toTimeString().slice(0, 5);
    const punches = draft.punches || [];
    
    // Look for an open punch (has in but no out)
    const openIndex = punches.findIndex((punch) => punch && punch.in && !punch.out);
    if (openIndex !== -1) {
      // Punch out - close the open punch
      draft.punches[openIndex].out = currentTime;
    } else {
      // Punch in - add a new punch or populate the first empty range
      if (punches.length === 0) {
        draft.punches.push({ in: currentTime, out: '' });
      } else {
        // Find the first empty range (no in time) and populate it
        const firstEmpty = punches.findIndex(punch => !punch.in);
        if (firstEmpty !== -1) {
          draft.punches[firstEmpty].in = currentTime;
        } else {
          draft.punches.push({ in: currentTime, out: '' });
        }
      }
    }
    setPunchDraftDirty();
    renderPunchDraft();
    persistPunchDraft({ requireClosed: false });
  }

  function handlePunchSave() {
    persistPunchDraft({ requireClosed: false });
  }

  function handlePunchDiscard() {
    if (!state.punchDraft) return;
    ensurePunchDraft(state.punchDraft.contractId);
  }

  function handlePunchDelete() {
    if (!state.punchDraft || !state.punchDraft.entryId) return;

    if (!confirm('Are you sure you want to delete this entry? This action cannot be undone.')) {
      return;
    }

    const entryId = state.punchDraft.entryId;
    const currentDate = state.punchDraft.date;

    setStatus('Deleting entry...', 'warn');

    google.script.run
      .withSuccessHandler(() => {
        // Remove from local state
        const idx = state.entries.findIndex(e => e.id === entryId);
        if (idx > -1) {
          state.entries.splice(idx, 1);
        }

        // Clear punch draft and start fresh
        state.punchDraft = null;
        if (punchDate) punchDate.value = currentDate;
        ensurePunchDraft();

        saveCache();
        renderEntries();
        updateTabStates();
        setStatus('Entry deleted', 'success');
      })
      .withFailureHandler(() => {
        setStatus('Delete failed', 'error');
      })
      .api_deleteEntry(entryId);
  }

  if (punchToggleBtn) punchToggleBtn.onclick = handlePunchToggle;
  if (punchSaveBtn) punchSaveBtn.onclick = handlePunchSave;
  if (punchCancelBtn) punchCancelBtn.onclick = handlePunchDiscard;
  if (punchDeleteBtn) punchDeleteBtn.onclick = handlePunchDelete;
  if (punchDate) {
    punchDate.addEventListener('change', () => {
      state.selectedCalendarDate = punchDate.value;
      // Clear any existing draft when date changes
      state.punchDraft = null;
      updatePunchContractOptions();
      ensurePunchDraft();
    });
  }
  if (punchContract) {
    punchContract.addEventListener('change', () => {
      ensurePunchDraft(punchContract.value);
    });
  }

  // Manual form helpers
  const manualDate = document.getElementById('manual-date');
  const manualHourType = document.getElementById('manual-hour-type');
  const manualHourTypeCol = document.getElementById('manual-hour-type-col');
  const manualContract = document.getElementById('manual-contract');
  const manualContractWarning = document.getElementById('manual-contract-warning');
  const manualHoursInput = document.getElementById('manual-hours');
  const manualSaveBtn = document.getElementById('btn-add-manual');
  const manualCancelBtn = document.getElementById('btn-cancel-edit');
  const manualDeleteBtn = document.getElementById('btn-delete-manual');

  function updateBasicSaveEnabled() {
    if (!manualSaveBtn) return;

    const hours = Number(manualHoursInput ? manualHoursInput.value : '');
    const validHours = Number.isFinite(hours) && hours > 0;

    // Check if contract is required based on hour type
    let contractValid = true;
    if (manualHourType && manualHourType.value) {
      const selectedHourType = state.hourTypeMap[manualHourType.value];
      if (selectedHourType && selectedHourType.requires_contract) {
        contractValid = !!(manualContract && manualContract.value);
      }
    } else {
      // Default behavior when no hour type selected or feature disabled
      contractValid = !!(manualContract && manualContract.value);
    }

    manualSaveBtn.disabled = !(contractValid && validHours);
  }

  function updateManualContractOptions(preferredContractId) {
    if (!manualContract) return '';
    const dateIso = manualDate && manualDate.value ? manualDate.value : todayIso();
    const valid = validContractsForDate(dateIso);
    const currentValue = preferredContractId != null ? preferredContractId : manualContract.value;
    const options = [...valid];
    if (currentValue && !options.some((contract) => contract.id === currentValue)) {
      const fallback = state.contractMap[currentValue];
      if (fallback) options.push(fallback);
    }
    options.sort((a, b) => a.name.localeCompare(b.name));
    manualContract.innerHTML = '';
    if (!options.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts';
      manualContract.appendChild(placeholder);
      manualContract.value = '';
      manualContract.disabled = true;
      if (manualContractWarning) manualContractWarning.style.display = 'block';
      updateBasicSaveEnabled();
      return '';
    }
    if (options.length > 1) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select contract';
      manualContract.appendChild(placeholder);
    }
    options.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      manualContract.appendChild(opt);
    });
    let selected = currentValue && options.some((contract) => contract.id === currentValue) ? currentValue : '';
    if (!selected && valid.length === 1) {
      selected = valid[0].id;
    }
    manualContract.value = selected;
    manualContract.disabled = valid.length === 1 && options.length === valid.length;
    if (manualContractWarning) manualContractWarning.style.display = manualContract.value ? 'none' : 'block';
    updateBasicSaveEnabled();
    return manualContract.value;
  }

  function refreshContractBindings(preferredManualContractId, preferredPunchContractId) {
    updateContractMap();
    const manualDateIso = manualDate && manualDate.value ? manualDate.value : todayIso();
    const manualPreferred = preferredManualContractId && contractIsValid(state.contractMap[preferredManualContractId], manualDateIso)
      ? preferredManualContractId
      : undefined;
    const punchPreferred = preferredPunchContractId && contractIsValid(state.contractMap[preferredPunchContractId], currentPunchDate())
      ? preferredPunchContractId
      : undefined;
    updateManualContractOptions(manualPreferred);
    ensurePunchDraft(punchPreferred);
    renderContractsUI();
  }

  function setManualDate(dateIso, preferredContractId) {
    if (!manualDate) return;
    manualDate.value = dateIso || todayIso();
    updateManualContractOptions(preferredContractId != null ? preferredContractId : (manualContract ? manualContract.value : ''));
  }

  function setManualMode(isEdit) {
    if (manualSaveBtn) manualSaveBtn.textContent = isEdit ? 'Update Entry' : 'Add Entry';
    if (manualCancelBtn) manualCancelBtn.style.display = isEdit ? 'inline-flex' : 'none';
    if (manualDeleteBtn) manualDeleteBtn.style.display = isEdit ? 'inline-flex' : 'none';
  }

  function populateManualForm(entry, isEdit) {
    showPage('time');
    state.currentTab = 'manual';
    activateTab('manual');
    const preferredDate = entry.date || todayIso();
    const preferredContractId = entry.contract_id || '';
    setManualDate(preferredDate, preferredContractId);
    const punches = entryPunches(entry);
    let totalMinutes = punches.reduce((acc, punch) => {
      const start = timeToMinutes(punch.in);
      const end = timeToMinutes(punch.out);
      if (start === null || end === null || end <= start) return acc;
      return acc + (end - start);
    }, 0);
    if (!totalMinutes && entry.duration_minutes != null) {
      totalMinutes = Number(entry.duration_minutes);
    }
    if (manualHoursInput) {
      const hoursValue = totalMinutes > 0 ? formatDecimalHours(totalMinutes / 60) : '';
      manualHoursInput.value = hoursValue ? hoursValue : '';
    }
    // Set hour type
    if (manualHourType && entry.hour_type_id) {
      manualHourType.value = entry.hour_type_id;
      updateManualContractVisibility();
    }

    state.editingEntryId = isEdit ? entry.id : null;
    state.editingEntryType = isEdit ? (entry.entry_type || 'basic') : null;
    setManualMode(!!isEdit);
    if (isEdit && manualHoursInput) manualHoursInput.focus();
    updateBasicSaveEnabled();
  }

  function clearManualEditing() {
    state.editingEntryId = null;
    state.editingEntryType = null;
    state.currentTab = 'manual';
    setManualMode(false);
    if (manualHoursInput) manualHoursInput.value = '';
    updateManualContractOptions();
    updateBasicSaveEnabled();
  }

  function getManualPayload() {
    const date = manualDate.value || todayIso();
    if (!date) {
      alert('Date is required.');
      return null;
    }
    const hoursRaw = manualHoursInput ? manualHoursInput.value.trim() : '';
    const totalHours = Number(hoursRaw);
    if (!Number.isFinite(totalHours) || totalHours <= 0) {
      alert('Enter the total number of hours worked.');
      return null;
    }
    const totalMinutes = Math.round(totalHours * 60);
    if (totalMinutes > 24 * 60) {
      alert('Total hours must be within a single day (24 hours or less).');
      return null;
    }
    if (totalMinutes <= 0) {
      alert('Total hours must be greater than zero.');
      return null;
    }
    // Get hour type
    const hourTypeId = manualHourType ? manualHourType.value : getDefaultHourTypeId();
    const selectedHourType = state.hourTypeMap[hourTypeId];

    // Validate contract based on hour type
    const contractId = manualContract ? manualContract.value : '';
    if (selectedHourType && selectedHourType.requires_contract) {
      if (!contractId) {
        alert('Select a contract for this date.');
        return null;
      }
      const contract = state.contractMap[contractId];
      if (!contract) {
        alert('Selected contract is no longer available.');
        return null;
      }
      if (!contractIsValid(contract, date) && !state.editingEntryId) {
        alert('Selected contract is not valid for this date.');
        return null;
      }
    }

    const punches = [{ in: '00:00', out: minutesToTime(totalMinutes) }];
    const roundedMinutes = roundDuration(totalMinutes);
    return {
      date,
      punches,
      duration_minutes: roundedMinutes,
      contract_id: contractId,
      hour_type_id: hourTypeId,
      round_interval: getRoundInterval(),
      entry_type: 'basic'
    };
  }

  manualSaveBtn.onclick = function () {
    const payload = getManualPayload();
    if (!payload) return;
    if (state.editingEntryId) {
      const idx = state.entries.findIndex((e) => e.id === state.editingEntryId);
      if (idx === -1) return;
      const backup = { ...state.entries[idx] };
      const update = { id: state.editingEntryId, ...payload };
      state.entries[idx] = sanitizeEntry({ ...backup, ...update });
      saveCache();
      renderEntries();
      setStatus('Saving...', 'warn');
      google.script.run
        .withSuccessHandler((res) => {
          if (res && res.success) {
            state.entries[idx] = sanitizeEntry(res.entry);
            clearManualEditing();
            saveCache();
            renderEntries();
            ensurePunchDraft(payload.contract_id);
            setStatus('Saved', 'success');
          } else {
            state.entries[idx] = backup;
            saveCache();
            renderEntries();
            setStatus('Save failed', 'error');
          }
        })
        .withFailureHandler(() => {
          state.entries[idx] = backup;
          saveCache();
          renderEntries();
          setStatus('Save failed', 'error');
        })
        .api_updateEntry(update);
    } else {
      const now = new Date();
      const entry = {
        id: 'temp_' + Date.now(),
        ...payload,
        created_at: isoDateTime(now)
      };
      state.entries.unshift(sanitizeEntry(entry));
      saveCache();
      renderEntries();
      clearManualEditing();
      setStatus('Saving...', 'warn');
      google.script.run
        .withSuccessHandler((res) => {
          if (res && res.success) {
            const idx = state.entries.findIndex((e) => e.id === entry.id);
            if (idx > -1) state.entries[idx] = sanitizeEntry(res.entry);
            saveCache();
            renderEntries();
            ensurePunchDraft(payload.contract_id);
            setStatus('Saved', 'success');
          } else {
            setStatus('Save failed', 'error');
          }
        })
        .withFailureHandler(() => setStatus('Save failed (offline?)', 'error'))
        .api_addEntry(entry);
    }
    state.selectedCalendarDate = payload.date;
    setManualDate(state.selectedCalendarDate, payload.contract_id);
    renderCalendar();
  };
  manualCancelBtn.onclick = function () {
    clearManualEditing();
    activateTab('manual');
  };

  if (manualDeleteBtn) {
    manualDeleteBtn.onclick = function () {
      if (!state.editingEntryId) return;

      if (!confirm('Are you sure you want to delete this entry? This action cannot be undone.')) {
        return;
      }

      const entryId = state.editingEntryId;
      const currentDate = manualDate ? manualDate.value : todayIso();

      setStatus('Deleting entry...', 'warn');

      google.script.run
        .withSuccessHandler(() => {
          // Remove from local state
          const idx = state.entries.findIndex(e => e.id === entryId);
          if (idx > -1) {
            state.entries.splice(idx, 1);
          }

          // Clear editing state and reset form
          clearManualEditing();
          setManualDate(currentDate);

          saveCache();
          renderEntries();
          updateTabStates();
          setStatus('Entry deleted', 'success');
        })
        .withFailureHandler(() => {
          setStatus('Delete failed', 'error');
        })
        .api_deleteEntry(entryId);
    };
  }

  if (manualDate) {
    manualDate.addEventListener('change', () => {
      const newDate = manualDate.value;
      const oldDate = state.selectedCalendarDate;
      
      // If we're editing an entry and the date changed, assume changes were discarded
      if (state.editingEntryId && newDate !== oldDate) {
        clearManualEditing();
        state.selectedCalendarDate = newDate;
        setManualDate(newDate);
        updateManualContractOptions();
        renderCalendar();
        return;
      }
      
      state.selectedCalendarDate = newDate;
      updateManualContractOptions();
      renderCalendar();
    });
  }

  if (manualContract) {
    manualContract.addEventListener('change', updateBasicSaveEnabled);
  }

  if (manualHoursInput) manualHoursInput.addEventListener('input', updateBasicSaveEnabled);

  if (manualHourType) {
    manualHourType.addEventListener('change', updateBasicSaveEnabled);
  }

  if (manualHoursInput) manualHoursInput.value = '';
  updateBasicSaveEnabled();
  setManualDate(todayIso());

  const incomeNetBadge = document.getElementById('calendar-net-income');
  const incomeToggleBtn = incomeNetBadge;
  const incomeBreakdownEl = document.getElementById('income-breakdown');
  const incomeTotalPackageEl = document.getElementById('income-total-package');
  const incomeGrossEl = document.getElementById('income-gross');
  const incomeSuperGuaranteeEl = document.getElementById('income-super-guarantee');
  const incomeExtraSuperEl = document.getElementById('income-extra-super');
  const incomeOtherDeductionsEl = document.getElementById('income-other-deductions');
  const incomeTaxableEl = document.getElementById('income-taxable');
  const incomeTaxEl = document.getElementById('income-tax');
  const incomeNetDetailEl = document.getElementById('income-net');
  let incomeBreakdownExpanded = false;
  if (incomeToggleBtn) {
    incomeToggleBtn.addEventListener('click', () => {
      incomeBreakdownExpanded = !incomeBreakdownExpanded;
      applyIncomeBreakdownVisibility();
    });
  }
  applyIncomeBreakdownVisibility();

  const featureFlagsListEl = document.getElementById('feature-flags-list');
  const roundInput = document.getElementById('set-round');
  const themeSelect = document.getElementById('set-theme');
  const superRateInput = document.getElementById('set-super-rate');
  const contractNameInput = document.getElementById('contract-name');
  const contractStartInput = document.getElementById('contract-start');
  const contractEndInput = document.getElementById('contract-end');
  const contractRateInput = document.getElementById('contract-rate');
  const contractTotalHoursInput = document.getElementById('contract-total-hours');
  const contractSaveBtn = document.getElementById('contract-save');
  const contractCancelBtn = document.getElementById('contract-cancel');
  const contractAddToggle = document.getElementById('contract-toggle-add');
  const contractFormContainer = document.getElementById('contract-form-container');
  const contractSelector = document.getElementById('contract-selector');
  const contractDetailEl = document.getElementById('contract-detail');
  const contractBurndownEl = document.getElementById('contract-burndown');
  const contractUnlimitedNote = document.getElementById('contract-unlimited-note');
  const contractFormDefaultParent = contractFormContainer ? contractFormContainer.parentElement : null;
  const contractFormPlaceholder = contractFormContainer && contractFormDefaultParent
    ? (function () {
        const placeholder = document.createComment('contract-form-home');
        contractFormDefaultParent.insertBefore(placeholder, contractFormContainer.nextSibling);
        return placeholder;
      })()
    : null;
  const clearCacheWrapper = document.getElementById('clear-cache-wrapper');
  const clearCacheBtn = document.getElementById('btn-clear-cache');

  const DECIMAL_HOURS_FORMATTER = new Intl.NumberFormat(undefined, {
    minimumFractionDigits: 0,
    maximumFractionDigits: 2
  });

  function formatDecimalHours(value) {
    return DECIMAL_HOURS_FORMATTER.format(Math.max(0, Math.round((Number(value) || 0) * 100) / 100));
  }

  function resetContractFormFields() {
    if (contractNameInput) contractNameInput.value = '';
    if (contractStartInput) contractStartInput.value = '';
    if (contractEndInput) contractEndInput.value = '';
    if (contractRateInput) contractRateInput.value = '';
    if (contractTotalHoursInput) contractTotalHoursInput.value = '';
  }

  function placeContractFormAtDefault() {
    if (!contractFormContainer || !contractFormPlaceholder || !contractFormPlaceholder.parentNode) return;
    if (contractFormContainer.parentElement !== contractFormPlaceholder.parentNode) {
      contractFormPlaceholder.parentNode.insertBefore(contractFormContainer, contractFormPlaceholder);
    }
  }

  function placeContractFormInDetail() {
    if (!contractFormContainer || !contractDetailEl) return;
    if (contractFormContainer.parentElement !== contractDetailEl) {
      contractDetailEl.appendChild(contractFormContainer);
    }
  }

  function setContractFormMode(mode) {
    state.contractFormMode = mode;
    const visible = mode === 'create' || mode === 'edit';
    if (contractFormContainer) contractFormContainer.style.display = visible ? 'block' : 'none';
    if (contractSaveBtn) contractSaveBtn.textContent = mode === 'edit' ? 'Save Changes' : 'Save';
    if (contractCancelBtn) contractCancelBtn.style.display = visible ? 'inline-flex' : 'none';
  }

  function showContractForm(mode) {
    if (mode === 'create') {
      state.editingContractId = null;
      resetContractFormFields();
      placeContractFormInDetail();
      if (contractAddToggle) contractAddToggle.textContent = 'Close';
    }
    setContractFormMode(mode);
    if (mode === 'create' && contractNameInput) contractNameInput.focus();
    renderContractDetail();
  }

  function hideContractForm() {
    resetContractFormFields();
    state.editingContractId = null;
    setContractFormMode('hidden');
    placeContractFormAtDefault();
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
  }

  function getContractFormPayload() {
    const name = contractNameInput ? contractNameInput.value.trim() : '';
    const startDate = contractStartInput ? contractStartInput.value : '';
    const endDate = contractEndInput ? contractEndInput.value : '';
    const hourlyRateRaw = contractRateInput ? contractRateInput.value : '';
    const hourlyRate = Number(hourlyRateRaw || 0);
    const totalHoursRaw = contractTotalHoursInput ? contractTotalHoursInput.value : '';
    const totalHoursValue = totalHoursRaw === '' ? 0 : Number(totalHoursRaw);
    if (!name) {
      alert('Contract name is required.');
      return null;
    }
    if (!startDate) {
      alert('Contract start date is required.');
      return null;
    }
    if (endDate && endDate < startDate) {
      alert('End date must be on or after the start date.');
      return null;
    }
    if (hourlyRate < 0) {
      alert('Hourly rate must be zero or greater.');
      return null;
    }
    if (Number.isNaN(totalHoursValue) || totalHoursValue < 0) {
      alert('Total hours must be zero or greater.');
      return null;
    }
    const totalHours = Math.round(Number(totalHoursValue || 0) * 100) / 100;
    return {
      name,
      start_date: startDate,
      end_date: endDate,
      hourly_rate: Math.round(hourlyRate * 100) / 100,
      total_hours: totalHours
    };
  }

  function populateContractForm(contract) {
    state.editingContractId = contract.id;
    if (contractNameInput) contractNameInput.value = contract.name || '';
    if (contractStartInput) contractStartInput.value = contract.start_date || '';
    if (contractEndInput) contractEndInput.value = contract.end_date || '';
    if (contractRateInput) contractRateInput.value = contract.hourly_rate != null ? Number(contract.hourly_rate).toFixed(2) : '';
    if (contractTotalHoursInput) {
      const totalHours = Number(contract.total_hours || 0);
      contractTotalHoursInput.value = totalHours > 0 ? String(totalHours) : '';
    }
    placeContractFormInDetail();
    setContractFormMode('edit');
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
    if (contractNameInput) contractNameInput.focus();
    renderContractDetail();
  }

  function getContractById(id) {
    return id ? state.contractMap[id] : undefined;
  }

  function contractEndSortValue(contract) {
    return contract.end_date && contract.end_date !== '' ? contract.end_date : '9999-12-31';
  }

  function renderContractSelectorOptions() {
    if (!contractSelector) return;
    const previousSelection = state.selectedContractId;
    contractSelector.innerHTML = '';
    if (!state.contracts.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts yet';
      contractSelector.appendChild(placeholder);
      contractSelector.disabled = true;
      state.selectedContractId = '';
      return;
    }
    contractSelector.disabled = false;
    const sorted = [...state.contracts].sort((a, b) => {
      const endA = contractEndSortValue(a);
      const endB = contractEndSortValue(b);
      if (endA !== endB) return endB.localeCompare(endA);
      const startA = a.start_date || '';
      const startB = b.start_date || '';
      if (startA !== startB) return startB.localeCompare(startA);
      return a.name.localeCompare(b.name);
    });
    const todayContracts = validContractsForDate(todayIso());
    const soleCurrentContractId = (!state.editingContractId && todayContracts.length === 1)
      ? todayContracts[0].id
      : '';
    if (!state.selectedContractId || !getContractById(state.selectedContractId)) {
      state.selectedContractId = soleCurrentContractId
        || (previousSelection && getContractById(previousSelection) ? previousSelection : '')
        || (sorted.length ? sorted[0].id : '');
    }
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select a contract...';
    contractSelector.appendChild(placeholder);
    sorted.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name || 'Untitled contract';
      contractSelector.appendChild(opt);
    });
    contractSelector.value = state.selectedContractId || '';
  }

  function computeContractUsage(contract) {
    const monthlyHours = {};
    let total = 0;
    if (contract) {
      state.entries.forEach((entry) => {
        if (entry.contract_id !== contract.id || !entry.date) return;
        const monthKey = entry.date.slice(0, 7);
        const hours = (Number(entry.duration_minutes) || 0) / 60;
        total += hours;
        monthlyHours[monthKey] = (monthlyHours[monthKey] || 0) + hours;
      });
    }
    return { totalHours: total, monthlyHours };
  }

  function contractMonthRange(contract) {
    if (!contract) return [];
    const startDate = contract.start_date ? parseIsoDate(contract.start_date) : parseIsoDate(todayIso());
    if (!startDate || Number.isNaN(startDate.getTime())) return [];
    const start = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
    const today = new Date();
    const endSource = contract.end_date ? parseIsoDate(contract.end_date) : today;
    const effectiveEndDate = (!endSource || Number.isNaN(endSource.getTime())) ? today : endSource;
    const end = new Date(effectiveEndDate.getFullYear(), effectiveEndDate.getMonth(), 1);
    const months = [];
    const cursor = new Date(start.getFullYear(), start.getMonth(), 1);
    if (cursor > end) {
      months.push(new Date(cursor));
      return months;
    }
    while (cursor <= end) {
      months.push(new Date(cursor));
      cursor.setMonth(cursor.getMonth() + 1);
    }
    if (!months.length) months.push(new Date(start));
    return months;
  }

  function renderContractDetail() {
    if (!contractDetailEl) return;
    contractDetailEl.innerHTML = '';
    if (state.contractFormMode === 'create') {
      if (contractSelector) contractSelector.value = '';
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (contractAddToggle) contractAddToggle.textContent = 'Close';
      const heading = document.createElement('div');
      heading.className = 'ts-note';
      heading.textContent = 'Creating new contract';
      contractDetailEl.appendChild(heading);
      placeContractFormInDetail();
      return;
    }
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
    if (contractSelector) contractSelector.value = state.selectedContractId || '';
    if (!state.selectedContractId) {
      const note = document.createElement('div');
      note.className = 'ts-note';
      note.textContent = state.contracts.length ? 'Select a contract to see its detail and burndown.' : 'Add a contract to get started.';
      contractDetailEl.appendChild(note);
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (!state.editingContractId) placeContractFormAtDefault();
      return;
    }
    const contract = getContractById(state.selectedContractId);
    if (!contract) {
      state.selectedContractId = '';
      if (contractSelector) contractSelector.value = '';
      renderContractDetail();
      return;
    }
    const isEditing = state.editingContractId === contract.id;
    if (!isEditing) {
      placeContractFormAtDefault();
      if (contractFormContainer && contractFormContainer.style.display === 'block' && !state.editingContractId) {
        // create mode already visible in default location
      }
    }
    const usage = computeContractUsage(contract);
    if (isEditing) {
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      placeContractFormInDetail();
      setContractFormMode('edit');
      const heading = document.createElement('div');
      heading.className = 'ts-note';
      heading.textContent = 'Editing contract';
      contractDetailEl.appendChild(heading);
      contractDetailEl.appendChild(contractFormContainer);
      renderContractBurndown(contract, usage);
      return;
    }

    const grid = document.createElement('div');
    grid.className = 'contract-detail-grid';

    const addDetail = (label, value) => {
      const item = document.createElement('div');
      item.className = 'contract-detail-item';
      const labelEl = document.createElement('div');
      labelEl.className = 'contract-detail-label';
      labelEl.textContent = label;
      const valueEl = document.createElement('div');
      valueEl.className = 'contract-detail-value';
      valueEl.textContent = value || '';
      item.append(labelEl, valueEl);
      grid.appendChild(item);
    };

    const rangeLabel = contract.end_date
      ? `${contract.start_date || ''}  ${contract.end_date}`
      : `${contract.start_date || ''}  Present`;
    const totalHoursValue = Number(contract.total_hours || 0);
    addDetail('Contract name', contract.name || 'Untitled contract');
    addDetail('Date range', rangeLabel);
    addDetail('Hourly rate', `${Number(contract.hourly_rate || 0).toFixed(2)} / hr`);
    addDetail('Total hours', totalHoursValue > 0 ? `${formatDecimalHours(totalHoursValue)} hrs` : 'Unlimited');
    addDetail('Hours logged', `${formatDecimalHours(usage.totalHours)} hrs`);

    contractDetailEl.appendChild(grid);

    const actions = document.createElement('div');
    actions.className = 'contract-detail-actions';
    const editBtn = document.createElement('button');
    editBtn.textContent = 'Edit';
    editBtn.className = 'ghost';
    editBtn.onclick = () => handleContractEdit(contract.id);
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    deleteBtn.className = 'danger';
    deleteBtn.onclick = () => handleContractDelete(contract.id);
    actions.append(editBtn, deleteBtn);
    contractDetailEl.appendChild(actions);

    renderContractBurndown(contract, usage);
  }

  function renderContractBurndown(contract, usage) {
    if (!contractBurndownEl) return;
    contractBurndownEl.innerHTML = '';
    const totalHours = Number(contract.total_hours || 0);
    if (!usage) usage = computeContractUsage(contract);
    if (totalHours <= 0) {
      if (contractUnlimitedNote) {
        contractUnlimitedNote.style.display = 'block';
        contractUnlimitedNote.textContent = `This contract is unlimited. Hours logged so far: ${formatDecimalHours(usage.totalHours)} hrs. Burndown charts require a total hour cap.`;
      }
      const monthsEntries = Object.keys(usage.monthlyHours).sort();
      if (usage.totalHours > 0 && monthsEntries.length) {
        const heading = document.createElement('div');
        heading.className = 'ts-note';
        heading.textContent = 'Monthly hours logged';
        contractBurndownEl.appendChild(heading);
        const table = document.createElement('table');
        table.className = 'contract-burndown-table';
        table.innerHTML = '<thead><tr><th>Month</th><th>Hours logged</th></tr></thead>';
        const tbody = document.createElement('tbody');
        monthsEntries.forEach((monthKey) => {
          const tr = document.createElement('tr');
          const monthCell = document.createElement('td');
          const parts = monthKey.split('-');
          const dateObj = new Date(Number(parts[0]), Number(parts[1]) - 1, 1);
          monthCell.textContent = formatMonthShortYear(dateObj);
          const valueCell = document.createElement('td');
          valueCell.textContent = `${formatDecimalHours(usage.monthlyHours[monthKey])} hrs`;
          tr.append(monthCell, valueCell);
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        contractBurndownEl.appendChild(table);
      } else {
        const empty = document.createElement('div');
        empty.className = 'contract-burndown-empty';
        empty.textContent = 'No time has been logged for this contract yet.';
        contractBurndownEl.appendChild(empty);
      }
      return;
    }
    if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';

    const months = contractMonthRange(contract);
    if (!months.length) {
      const empty = document.createElement('div');
      empty.className = 'contract-burndown-empty';
      empty.textContent = 'Not enough data to build a burndown chart.';
      contractBurndownEl.appendChild(empty);
      return;
    }

    const avgBurn = totalHours / months.length;
    const expectedPoints = [{ label: 'Start', value: totalHours }];
    const actualPathPoints = [{ label: 'Start', value: totalHours }];
    const tableRows = [];
    const today = new Date();
    const todayIsoString = todayIso();
    const contractStarted = !contract.start_date || contract.start_date <= todayIsoString;
    const contractActive = contractStarted && (!contract.end_date || contract.end_date >= todayIsoString);
    const currentMonthKey = monthKeyFor(today.getFullYear(), today.getMonth());
    const currentIdx = months.findIndex((monthDate) => monthKeyFor(monthDate.getFullYear(), monthDate.getMonth()) === currentMonthKey);
    let latestDataIdx = -1;
    months.forEach((monthDate, idx) => {
      const key = monthKeyFor(monthDate.getFullYear(), monthDate.getMonth());
      if ((usage.monthlyHours[key] || 0) > 0) latestDataIdx = idx;
    });
    let actualEndIndex = months.length - 1;
    if (contractActive && currentIdx !== -1) {
      actualEndIndex = Math.max(latestDataIdx, currentIdx);
      if (actualEndIndex < 0) actualEndIndex = currentIdx;
      actualEndIndex = Math.min(actualEndIndex, months.length - 1);
    }
    if (actualEndIndex < 0) actualEndIndex = months.length - 1;

    const monthContributions = months.map((monthDate, idx) => {
      if (idx === currentIdx && contractActive && latestDataIdx <= currentIdx) {
        const daysInMonth = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0).getDate();
        const daysElapsed = Math.min(daysInMonth, Math.max(1, today.getDate()));
        return Math.min(1, daysElapsed / daysInMonth);
      }
      return 1;
    });

    let actualConsumedForAverage = 0;
    let monthsContributionUsed = 0;
    let cumulativeConsumed = 0;
    months.forEach((monthDate, idx) => {
      const key = monthKeyFor(monthDate.getFullYear(), monthDate.getMonth());
      const expectedRemaining = Math.max(0, totalHours - avgBurn * (idx + 1));
      const hoursThisMonth = usage.monthlyHours[key] || 0;
      cumulativeConsumed += hoursThisMonth;
      const actualRemaining = Math.max(0, totalHours - cumulativeConsumed);
      expectedPoints.push({ label: monthDate, value: expectedRemaining });
      if (idx <= actualEndIndex) {
        actualPathPoints.push({ label: monthDate, value: actualRemaining });
        actualConsumedForAverage += hoursThisMonth;
        monthsContributionUsed += monthContributions[idx];
      }
      tableRows.push({
        monthLabel: formatMonthShortYear(monthDate),
        hoursLogged: hoursThisMonth,
        expectedRemaining,
        actualRemaining
      });
    });

    const avgActualMonthlyBurn = monthsContributionUsed > 0 ? actualConsumedForAverage / monthsContributionUsed : 0;
    const totalContribution = monthContributions.reduce((sum, value) => sum + value, 0);
    const actualAveragePoints = [{ label: 'Start', value: totalHours }];
    if (avgActualMonthlyBurn > 0) {
      let cumulativeContribution = 0;
      months.forEach((monthDate, idx) => {
        cumulativeContribution += monthContributions[idx];
        const projectedRemaining = Math.max(0, totalHours - avgActualMonthlyBurn * cumulativeContribution);
        actualAveragePoints.push({ label: monthDate, value: projectedRemaining });
      });
    }

    const pointGroups = [expectedPoints, actualPathPoints];
    if (actualAveragePoints.length > 1) pointGroups.push(actualAveragePoints);
    const maxValue = Math.max(totalHours, ...pointGroups.flat().map((p) => p.value));
    const containerRect = contractBurndownEl.getBoundingClientRect();
    const detailRect = contractDetailEl ? contractDetailEl.getBoundingClientRect() : null;
    const measuredWidth = containerRect.width || (detailRect && detailRect.width) || 720;
    const width = Math.max(480, Math.floor(measuredWidth));
    const height = 320;
    const margin = { top: 20, right: 28, bottom: 44, left: 56 };
    const plotWidth = width - margin.left - margin.right;
    const plotHeight = height - margin.top - margin.bottom;
    const stepX = expectedPoints.length > 1 ? plotWidth / (expectedPoints.length - 1) : 0;
    const scaleX = (index) => margin.left + stepX * index;
    const scaleY = (value) => {
      if (maxValue === 0) return margin.top + plotHeight;
      return margin.top + plotHeight - (value / maxValue) * plotHeight;
    };
    const buildPath = (points) => points.map((point, idx) => {
      const x = scaleX(idx).toFixed(2);
      const y = scaleY(point.value).toFixed(2);
      return `${idx === 0 ? 'M' : 'L'}${x},${y}`;
    }).join(' ');

    const styles = getComputedStyle(document.body);
    const borderColor = (styles.getPropertyValue('--border') || '#1e293b').trim();
    const mutedColor = (styles.getPropertyValue('--muted') || '#94a3b8').trim();
    const primaryColor = (styles.getPropertyValue('--primary') || '#3b82f6').trim();
    const successColor = (styles.getPropertyValue('--success') || '#10b981').trim();
    const textColor = mutedColor || '#94a3b8';

    const expectedPath = buildPath(expectedPoints);
    const actualPath = buildPath(actualPathPoints);
    const actualAveragePath = actualAveragePoints.length > 1 ? buildPath(actualAveragePoints) : '';
    const xAxisY = margin.top + plotHeight;
    const svgParts = [];
    svgParts.push(`<path d="M${margin.left},${xAxisY} L${margin.left + plotWidth},${xAxisY}" stroke="${borderColor}" stroke-width="1" fill="none" />`);
    svgParts.push(`<path d="M${margin.left},${margin.top} L${margin.left},${xAxisY}" stroke="${borderColor}" stroke-width="1" fill="none" />`);
    svgParts.push(`<path d="${expectedPath}" stroke="${mutedColor}" stroke-width="2" fill="none" />`);
    svgParts.push(`<path d="${actualPath}" stroke="${primaryColor}" stroke-width="2" fill="none" />`);
    if (actualAveragePath) svgParts.push(`<path d="${actualAveragePath}" stroke="${successColor}" stroke-width="2" fill="none" stroke-dasharray="6 4" />`);

    expectedPoints.forEach((point, idx) => {
      const x = scaleX(idx);
      const y = scaleY(point.value);
      svgParts.push(`<circle cx="${x}" cy="${y}" r="3" fill="${mutedColor}" />`);
    });
    actualPathPoints.forEach((point, idx) => {
      const x = scaleX(idx);
      const y = scaleY(point.value);
      svgParts.push(`<circle cx="${x}" cy="${y}" r="3" fill="${primaryColor}" />`);
    });
    if (actualAveragePath) {
      actualAveragePoints.forEach((point, idx) => {
        const x = scaleX(idx);
        const y = scaleY(point.value);
        svgParts.push(`<circle cx="${x}" cy="${y}" r="3" fill="${successColor}" />`);
      });
    }

    const labelGroup = months.map((monthDate, idx) => {
      const x = scaleX(idx + 1);
      const label = formatMonthShortYear(monthDate);
      return `<text x="${x}" y="${xAxisY + 18}" text-anchor="middle" font-size="11" fill="${textColor}">${label}</text>`;
    }).join('');

    const svg = `<svg viewBox="0 0 ${width} ${height}" role="img" aria-label="Contract burndown chart"><g>${svgParts.join('')} ${labelGroup}</g></svg>`;

    const avgSummary = document.createElement('div');
    avgSummary.className = 'ts-note contract-burndown-summary';
    const summaryParts = [`Average burn required: ${formatDecimalHours(avgBurn)} hrs/month.`];
    if (avgActualMonthlyBurn > 0) {
      summaryParts.push(`Actual average to date: ${formatDecimalHours(avgActualMonthlyBurn)} hrs/month (${monthsContributionUsed.toFixed(2)} months measured).`);
    }
    avgSummary.textContent = summaryParts.join(' ');
    contractBurndownEl.appendChild(avgSummary);

    if (contractActive && avgActualMonthlyBurn > avgBurn + 0.01 && monthsContributionUsed > 0) {
      const projectedTotalUsage = avgActualMonthlyBurn * totalContribution;
      const overageHours = projectedTotalUsage - totalHours;
      if (overageHours > 0.5) {
        const warning = document.createElement('div');
        warning.className = 'ts-warning contract-burndown-warning';
        warning.textContent = `At the current pace you're on track to exceed this contract by approximately ${formatDecimalHours(overageHours)} hrs.`;
        contractBurndownEl.appendChild(warning);
      }
    }

    const plotWrapper = document.createElement('div');
    plotWrapper.className = 'contract-burndown-plot';
    plotWrapper.innerHTML = svg;
    contractBurndownEl.appendChild(plotWrapper);

    const legend = document.createElement('div');
    legend.className = 'contract-burndown-legend';
    legend.innerHTML = `<span><span class="line" style="background:${mutedColor};"></span>Expected remaining</span><span><span class="line" style="background:${primaryColor};"></span>Actual remaining</span>${actualAveragePath ? `<span><span class="line" style="background:transparent; border-bottom:2px dashed ${successColor}; height:0;"></span>Actual average (projection)</span>` : ''}`;
    contractBurndownEl.appendChild(legend);

    const table = document.createElement('table');
    table.className = 'contract-burndown-table';
    table.innerHTML = '<thead><tr><th>Month</th><th>Hours logged</th><th>Expected remaining</th><th>Actual remaining</th></tr></thead>';
    const tbody = document.createElement('tbody');
    tableRows.forEach((row) => {
      const tr = document.createElement('tr');
      const monthCell = document.createElement('td');
      monthCell.textContent = row.monthLabel;
      const loggedCell = document.createElement('td');
      loggedCell.textContent = `${formatDecimalHours(row.hoursLogged)} hrs`;
      const expectedCell = document.createElement('td');
      expectedCell.textContent = `${formatDecimalHours(row.expectedRemaining)} hrs`;
      const actualCell = document.createElement('td');
      actualCell.textContent = `${formatDecimalHours(row.actualRemaining)} hrs`;
      tr.append(monthCell, loggedCell, expectedCell, actualCell);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    contractBurndownEl.appendChild(table);
  }

  function renderContractsUI() {
    renderContractSelectorOptions();
    renderContractDetail();
  }

  function handleContractSave() {
    if (!contractSaveBtn) return;
    const payload = getContractFormPayload();
    if (!payload) return;
    contractSaveBtn.disabled = true;
    const isEdit = !!state.editingContractId;
    setStatus(isEdit ? 'Updating contract...' : 'Saving contract...', 'warn');
    const handler = (res) => {
      contractSaveBtn.disabled = false;
      if (res && res.success && res.contract) {
        const normalized = sanitizeContract(res.contract);
        state.contracts = [...state.contracts.filter((c) => c.id !== normalized.id), normalized];
        state.selectedContractId = normalized.id;
        refreshContractBindings(normalized.id, normalized.id);
        saveCache();
        hideContractForm();
        renderContractDetail();
        setStatus(isEdit ? 'Contract updated' : 'Contract saved', 'success');
      } else {
        setStatus('Contract save failed', 'error');
      }
    };
    const failure = () => {
      contractSaveBtn.disabled = false;
      setStatus('Contract save failed', 'error');
    };
    if (isEdit) {
      google.script.run
        .withSuccessHandler(handler)
        .withFailureHandler(failure)
        .api_updateContract({ id: state.editingContractId, ...payload });
    } else {
      google.script.run
        .withSuccessHandler(handler)
        .withFailureHandler(failure)
        .api_addContract(payload);
    }
  }

  function handleContractEdit(id) {
    const contract = state.contracts.find((c) => c.id === id);
    if (!contract) return;
    populateContractForm(contract);
    showPage('contracts');
  }

  function handleContractDelete(id) {
    if (!id) return;
    const hasEntries = state.entries.some((entry) => entry.contract_id === id);
    if (hasEntries) {
      alert('This contract already has time entries and cannot be deleted.');
      return;
    }
    if (!confirm('Delete this contract?')) return;
    setStatus('Deleting contract...', 'warn');
    google.script.run
      .withSuccessHandler(() => {
        state.contracts = state.contracts.filter((contract) => contract.id !== id);
        if (state.editingContractId === id) {
          hideContractForm();
        }
        if (state.selectedContractId === id) {
          state.selectedContractId = '';
        }
        refreshContractBindings();
        saveCache();
        setStatus('Contract deleted', 'success');
      })
      .withFailureHandler(() => setStatus('Contract delete failed', 'error'))
      .api_deleteContract(id);
  }

  function renderFeatureFlags() {
    if (!featureFlagsListEl) return;
    featureFlagsListEl.innerHTML = '';
    const entries = Object.keys(state.featureFlags).map((key) => ({
      key,
      enabled: !!state.featureFlags[key].enabled,
      name: state.featureFlags[key].name || key,
      description: state.featureFlags[key].description || ''
    })).sort((a, b) => a.name.localeCompare(b.name));
    if (!entries.length) {
      const empty = document.createElement('div');
      empty.className = 'ts-note';
      empty.textContent = 'No feature flags configured.';
      featureFlagsListEl.appendChild(empty);
      return;
    }
    entries.forEach((flag) => {
      const row = document.createElement('div');
      row.className = 'ts-flag-row';

      const meta = document.createElement('div');
      meta.className = 'ts-flag-meta';
      meta.innerHTML = `<div class="ts-flag-title">${flag.name}</div>` + (flag.description ? `<div class="ts-flag-desc">${flag.description}</div>` : '');

      const toggleLabel = document.createElement('label');
      toggleLabel.className = 'ts-toggle';
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = flag.enabled;
      input.dataset.flag = flag.key;
      input.setAttribute('aria-label', flag.name);
      const track = document.createElement('span');
      track.className = 'ts-toggle-track';
      const thumb = document.createElement('span');
      thumb.className = 'ts-toggle-thumb';
      track.appendChild(thumb);
      toggleLabel.appendChild(input);
      toggleLabel.appendChild(track);

      input.addEventListener('change', () => {
        if (!!state.featureFlags[flag.key]?.enabled === input.checked) return;
        updateFeatureFlag(flag.key, input.checked);
      });

      row.append(meta, toggleLabel);
      featureFlagsListEl.appendChild(row);
    });
  }

  function updateFeatureFlag(featureKey, enabled) {
    const toggleInput = featureFlagsListEl ? featureFlagsListEl.querySelector(`input[data-flag="${featureKey}"]`) : null;
    if (toggleInput) toggleInput.disabled = true;
    const currentMeta = state.featureFlags[featureKey] || DEFAULT_FEATURE_FLAGS[featureKey] || { name: featureKey, description: '' };
    setStatus('Updating feature flags...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (toggleInput) toggleInput.disabled = false;
        if (res && res.success && res.flags) {
          state.featureFlags = normalizeFeatureFlags(res.flags);
          saveCache();
          renderFeatureFlags();
          applyFeatureFlags();
          setStatus('Feature flags updated', 'success');
        } else {
          if (toggleInput) toggleInput.checked = !!currentMeta.enabled;
          setStatus('Feature flag update failed', 'error');
        }
      })
      .withFailureHandler(() => {
        if (toggleInput) {
          toggleInput.disabled = false;
          toggleInput.checked = !!currentMeta.enabled;
        }
        setStatus('Feature flag update failed', 'error');
      })
      .api_setFeatureFlag({
        feature: featureKey,
        enabled: enabled,
        name: currentMeta.name || featureKey,
        description: currentMeta.description || ''
      });
  }

  function applyFeatureFlags() {
    const rememberFlag = state.featureFlags.remember_last_page || DEFAULT_FEATURE_FLAGS.remember_last_page || { enabled: false };
    if (rememberFlag.enabled) {
      let stored = null;
      try {
        stored = localStorage.getItem(LAST_PAGE_KEY);
      } catch (e) {}
      if (!stored) {
        persistLastPage(state.currentPage);
      } else if (stored && PAGE_KEYS.includes(stored) && stored !== state.currentPage) {
        showPage(stored);
      }
    } else {
      try {
        localStorage.removeItem(LAST_PAGE_KEY);
      } catch (e) {}
    }
    const zeroFlag = state.featureFlags.show_zero_hours || DEFAULT_FEATURE_FLAGS.show_zero_hours || { enabled: false };
    state.showZeroHours = !!zeroFlag.enabled;
    renderCalendar();
    updateClearCacheVisibility();

    // Show/hide hour types navigation
    const hourTypesFlag = state.featureFlags.hour_types || DEFAULT_FEATURE_FLAGS.hour_types || { enabled: false };
    if (navHourTypesBtn) {
      navHourTypesBtn.style.display = hourTypesFlag.enabled ? 'block' : 'none';
    }
    if (hourTypesFlag.enabled) {
      loadHourTypes();
    }
    updateHourTypeFormVisibility();
  }

  if (contractSaveBtn) {
    contractSaveBtn.onclick = handleContractSave;
  }
  if (contractCancelBtn) {
    contractCancelBtn.onclick = () => {
      hideContractForm();
      renderContractDetail();
    };
  }
  if (contractAddToggle) {
    contractAddToggle.addEventListener('click', () => {
      showPage('contracts');
      if (state.contractFormMode === 'create') {
        hideContractForm();
        renderContractDetail();
        return;
      }
      if (state.contractFormMode === 'edit') {
        hideContractForm();
      }
      showContractForm('create');
    });
  }
  if (contractSelector) {
    contractSelector.addEventListener('change', () => {
      const nextId = contractSelector.value || '';
      if (state.contractFormMode === 'create' || (state.contractFormMode === 'edit' && state.editingContractId && state.editingContractId !== nextId)) {
        hideContractForm();
      }
      state.selectedContractId = nextId;
      renderContractDetail();
    });
  }
  setContractFormMode('hidden');

  function updateClearCacheVisibility() {
    if (!clearCacheWrapper) return;
    const enabled = !!(state.featureFlags.show_clear_cache && state.featureFlags.show_clear_cache.enabled);
    clearCacheWrapper.style.display = enabled ? 'block' : 'none';
  }

  if (clearCacheBtn) {
    clearCacheBtn.addEventListener('click', () => {
      if (!confirm('Clear cached entries and settings from this browser?')) return;
      try {
        localStorage.removeItem(state.cacheKey);
        localStorage.removeItem(LAST_PAGE_KEY);
      } catch (e) {}
      setStatus('Local cache cleared. Data will be reloaded from the server on next sync.', 'success');
    });
  }

  // Entries & KPIs
  function minutesForDate(date) {
    return state.entries
      .filter((e) => e.date === date)
      .reduce((acc, entry) => acc + (Number(entry.duration_minutes) || 0), 0);
  }
  const monthKeyFor = (year, month) => `${year}-${String(month + 1).padStart(2, '0')}`;
  function entriesForMonth(year, month) {
    const prefix = monthKeyFor(year, month);
    return state.entries.filter((entry) => entry.date && entry.date.startsWith(prefix));
  }
  function buildIncomeSummary(year, month) {
    const allEntries = entriesForMonth(year, month);
    // Filter to only include entries from hour types that contribute to income
    const entries = allEntries.filter(entry => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      const hourType = state.hourTypeMap[hourTypeId];
      return hourType ? hourType.contributes_to_income : true; // Default to true for backwards compatibility
    });
    const periodStart = new Date(year, month, 1);
    const salarySacrifice = getSalarySacrificePlaceholder();
    const extraSuper = getExtraSuperPlaceholder();
    const superRate = getSuperRateSetting();
    if (!entries.length) {
      return {
        monthKey: monthKeyFor(year, month),
        periodStart,
        hasEntries: false,
        totalMinutes: 0,
        totalHours: 0,
        totalPackage: 0,
        grossIncome: 0,
        superRate,
        superGuarantee: 0,
        extraSuper,
        otherDeductions: salarySacrifice,
        taxableIncome: 0,
        taxStatus: 'resolved',
        tax: 0,
        netIncome: 0,
        requestKey: `${monthKeyFor(year, month)}:0`
      };
    }
    const totalMinutes = entries.reduce((acc, entry) => acc + (Number(entry.duration_minutes) || 0), 0);
    const totalHours = totalMinutes / 60;
    const validContractsUsed = entries.reduce((set, entry) => {
      const contract = state.contractMap[entry.contract_id];
      if (contract && contractIsValid(contract, entry.date)) set.add(contract.id);
      return set;
    }, new Set());
    const validContractsAcrossDates = entries.reduce((set, entry) => {
      const valids = validContractsForDate(entry.date);
      valids.forEach((contract) => set.add(contract.id));
      return set;
    }, new Set());
    let totalPackage = 0;
    if (validContractsUsed.size === 1) {
      const onlyId = Array.from(validContractsUsed)[0];
      const contract = state.contractMap[onlyId];
      const rate = contract ? Number(contract.hourly_rate || 0) : 0;
      totalPackage = totalHours * rate;
    } else if (!validContractsUsed.size && validContractsAcrossDates.size === 1) {
      const fallbackId = Array.from(validContractsAcrossDates)[0];
      const contract = state.contractMap[fallbackId];
      const rate = contract ? Number(contract.hourly_rate || 0) : 0;
      totalPackage = totalHours * rate;
    } else {
      totalPackage = entries.reduce((acc, entry) => {
        const minutes = Number(entry.duration_minutes) || 0;
        let rate = 0;
        const contract = state.contractMap[entry.contract_id];
        if (contract && contractIsValid(contract, entry.date)) {
          rate = Number(contract.hourly_rate || 0);
        } else {
          const valids = validContractsForDate(entry.date);
          if (valids.length === 1) rate = Number(valids[0].hourly_rate || 0);
        }
        return acc + (minutes / 60) * rate;
      }, 0);
    }
    const denominator = 1 + superRate;
    const grossIncome = denominator !== 0 ? totalPackage / denominator : totalPackage;
    const superGuarantee = Math.max(0, (grossIncome - salarySacrifice) * superRate);
    const taxableIncome = grossIncome - extraSuper - salarySacrifice;
    const requestKey = `${monthKeyFor(year, month)}:${Math.round(taxableIncome * 100)}`;
    return {
      monthKey: monthKeyFor(year, month),
      periodStart,
      hasEntries: entries.length > 0,
      totalMinutes,
      totalHours,
      totalPackage,
      grossIncome,
      superRate,
      superGuarantee,
      extraSuper,
      otherDeductions: salarySacrifice,
      taxableIncome,
      taxStatus: taxableIncome > 0 ? 'pending' : 'resolved',
      tax: taxableIncome > 0 ? null : 0,
      netIncome: taxableIncome > 0 ? null : taxableIncome,
      requestKey
    };
  }
  function applyIncomeBreakdownVisibility() {
    if (!incomeBreakdownEl) return;
    incomeBreakdownEl.hidden = !incomeBreakdownExpanded;
    if (incomeToggleBtn) {
      incomeToggleBtn.dataset.expanded = incomeBreakdownExpanded ? 'true' : 'false';
      incomeToggleBtn.setAttribute('aria-expanded', incomeBreakdownExpanded ? 'true' : 'false');
    }
  }
  function updateIncomeSummaryUI(summary) {
    if (!incomeNetBadge && !incomeBreakdownEl) return;
    if (!summary) {
      if (incomeNetBadge) incomeNetBadge.textContent = 'Net income: --';
      if (incomeNetDetailEl) incomeNetDetailEl.textContent = '--';
      if (incomeTotalPackageEl) incomeTotalPackageEl.textContent = '--';
      if (incomeGrossEl) incomeGrossEl.textContent = '--';
      if (incomeSuperGuaranteeEl) incomeSuperGuaranteeEl.textContent = '--';
      if (incomeExtraSuperEl) incomeExtraSuperEl.textContent = '--';
      if (incomeOtherDeductionsEl) incomeOtherDeductionsEl.textContent = '--';
      if (incomeTaxableEl) incomeTaxableEl.textContent = '--';
      if (incomeTaxEl) incomeTaxEl.textContent = '--';
      return;
    }
    const netValue = summary.netIncome != null ? summary.netIncome : summary.taxableIncome;
    const netDisplay = (() => {
      if (summary.taxStatus === 'pending') return 'Calculating...';
      if (summary.taxStatus === 'error') return 'Tax unavailable';
      return formatCurrency(netValue);
    })();
    const taxText = (() => {
      if (summary.taxStatus === 'pending') return 'Calculating...';
      if (summary.taxStatus === 'error') return 'Tax unavailable';
      return formatCurrency(summary.tax || 0);
    })();
    if (incomeNetBadge) incomeNetBadge.textContent = `Net income: ${netDisplay}`;
    if (incomeNetDetailEl) incomeNetDetailEl.textContent = netDisplay;
    if (incomeTotalPackageEl) incomeTotalPackageEl.textContent = formatCurrency(summary.totalPackage);
    if (incomeGrossEl) incomeGrossEl.textContent = formatCurrency(summary.grossIncome);
    if (incomeSuperGuaranteeEl) incomeSuperGuaranteeEl.textContent = formatCurrency(summary.superGuarantee);
    if (incomeExtraSuperEl) incomeExtraSuperEl.textContent = formatCurrency(summary.extraSuper);
    if (incomeOtherDeductionsEl) incomeOtherDeductionsEl.textContent = formatCurrency(summary.otherDeductions);
    if (incomeTaxableEl) incomeTaxableEl.textContent = formatCurrency(summary.taxableIncome);
    if (incomeTaxEl) incomeTaxEl.textContent = taxText;
  }
  function handleTaxSuccess(requestId, taxValue) {
    if (!state.pendingTaxRequest || state.pendingTaxRequest.id !== requestId) return;
    const summary = state.incomeSummary;
    if (!summary || summary.monthKey !== state.pendingTaxRequest.monthKey) {
      state.pendingTaxRequest = null;
      return;
    }
    const computedTax = Math.max(0, Number(taxValue) || 0);
    summary.tax = computedTax;
    summary.taxStatus = 'resolved';
    summary.netIncome = summary.taxableIncome - computedTax;
    state.pendingTaxRequest = null;
    updateIncomeSummaryUI(summary);
  }
  function handleTaxFailure(requestId) {
    if (!state.pendingTaxRequest || state.pendingTaxRequest.id !== requestId) return;
    const summary = state.incomeSummary;
    if (!summary || summary.monthKey !== state.pendingTaxRequest.monthKey) {
      state.pendingTaxRequest = null;
      return;
    }
    summary.tax = 0;
    summary.taxStatus = 'error';
    summary.netIncome = summary.taxableIncome;
    state.pendingTaxRequest = null;
    updateIncomeSummaryUI(summary);
  }
  function requestTaxEstimate(summary) {
    if (!summary || summary.taxStatus !== 'pending') return;
    if (!summary.taxableIncome || summary.taxableIncome <= 0) {
      summary.taxStatus = 'resolved';
      summary.tax = 0;
      summary.netIncome = summary.taxableIncome;
      updateIncomeSummaryUI(summary);
      return;
    }
    if (state.pendingTaxRequest && state.pendingTaxRequest.key === summary.requestKey) return;
    if (typeof google === 'undefined' || !google.script || !google.script.run) {
      summary.taxStatus = 'error';
      summary.tax = 0;
      summary.netIncome = summary.taxableIncome;
      updateIncomeSummaryUI(summary);
      state.pendingTaxRequest = null;
      return;
    }
    const requestId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    state.pendingTaxRequest = {
      id: requestId,
      key: summary.requestKey,
      monthKey: summary.monthKey
    };
    google.script.run
      .withSuccessHandler((value) => handleTaxSuccess(requestId, value))
      .withFailureHandler(() => handleTaxFailure(requestId))
      .estimateTax(Number(summary.taxableIncome) || 0, summary.periodStart.toISOString());
  }
  function renderIncomeSummary() {
    if (!incomeNetBadge && !incomeBreakdownEl) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const summary = buildIncomeSummary(year, month);
    state.incomeSummary = summary;
    updateIncomeSummaryUI(summary);
    applyIncomeBreakdownVisibility();
    if (summary.taxStatus === 'pending') {
      requestTaxEstimate(summary);
    } else {
      state.pendingTaxRequest = null;
    }
  }
  function renderEntries() {
    renderCalendar();
    renderContractsUI();
  }
  function deleteEntry(id) {
    const idx = state.entries.findIndex((e) => e.id === id);
    if (idx === -1) return;
    const backup = state.entries[idx];
    state.entries.splice(idx, 1);
    saveCache();
    renderEntries();
    setStatus('Deleting...', 'warn');
    google.script.run
      .withSuccessHandler(() => setStatus('Deleted', 'success'))
      .withFailureHandler(() => {
        state.entries.splice(idx, 0, backup);
        saveCache();
        renderEntries();
        setStatus('Delete failed', 'error');
      })
      .api_deleteEntry(id);
  }
  function editEntry(id) {
    const entry = state.entries.find((e) => e.id === id);
    if (!entry) return;
    state.selectedCalendarDate = entry.date;
    populateManualForm(entry, true);
    renderCalendar();
  }

  // Calendar rendering
  function ensureCalendarState() {
    if (!state.calendar) {
      const today = new Date();
      state.calendar = { year: today.getFullYear(), month: today.getMonth() };
    }
    if (!state.selectedCalendarDate) {
      state.selectedCalendarDate = todayIso();
      if (!state.editingEntryId) setManualDate(state.selectedCalendarDate);
    }
  }
  function calendarStartDate(year, month) {
    const first = new Date(year, month, 1);
    const offset = (first.getDay() + 6) % 7; // shift so Monday=0
    return new Date(year, month, 1 - offset);
  }
  function minutesByDate() {
    return state.entries.reduce((map, entry) => {
      if (!entry.date) return map;
      const key = entry.date;
      map[key] = (map[key] || 0) + (Number(entry.duration_minutes) || 0);
      return map;
    }, {});
  }

  function minutesByDateAndHourType() {
    return state.entries.reduce((map, entry) => {
      if (!entry.date) return map;
      const date = entry.date;
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();

      if (!map[date]) map[date] = {};
      if (!map[date][hourTypeId]) map[date][hourTypeId] = 0;

      map[date][hourTypeId] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});
  }

  function getDefaultHourType() {
    if (!state.hourTypes.length) return null;
    return state.hourTypes.find(ht => ht.is_default) || state.hourTypes[0];
  }

  function getFeatureFlag(flagKey) {
    const flag = state.featureFlags[flagKey] || DEFAULT_FEATURE_FLAGS[flagKey];
    return flag ? flag.enabled : false;
  }
  function renderCalendar() {
    ensureCalendarState();
    const totals = minutesByDate();
    const hourTypeTotals = minutesByDateAndHourType();
    const defaultHourType = getDefaultHourType();
    const defaultHourTypeId = defaultHourType?.id || getDefaultHourTypeId();
    const grid = document.getElementById('calendar-grid');
    const label = document.getElementById('calendar-label');
    const monthTotalEl = document.getElementById('calendar-month-total');
    const activeMonth = new Date(state.calendar.year, state.calendar.month, 1);
    label.textContent = activeMonth.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    const monthKey = `${activeMonth.getFullYear()}-${String(activeMonth.getMonth() + 1).padStart(2, '0')}`;
    const monthTotalMinutes = Object.keys(totals).reduce((acc, key) => {
      if (key.startsWith(monthKey)) {
        acc += totals[key];
      }
      return acc;
    }, 0);

    // If hour types are enabled, also calculate income-contributing hours
    let monthIncomeMinutes = 0;
    if (getFeatureFlag('hour_types') && state.hourTypes.length > 0) {
      const monthEntries = state.entries.filter(entry =>
        entry.date && entry.date.startsWith(monthKey)
      );
      monthIncomeMinutes = monthEntries.reduce((acc, entry) => {
        const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
        const hourType = state.hourTypeMap[hourTypeId];
        const contributesToIncome = hourType ? hourType.contributes_to_income : true;
        if (contributesToIncome) {
          acc += Number(entry.duration_minutes) || 0;
        }
        return acc;
      }, 0);
    }

    const roundedMonthTotal = roundDuration(monthTotalMinutes);
    if (getFeatureFlag('hour_types') && state.hourTypes.length > 0 && monthIncomeMinutes !== monthTotalMinutes) {
      const roundedIncomeTotal = roundDuration(monthIncomeMinutes);
      monthTotalEl.textContent = `Total hours: ${formatHours(roundedMonthTotal)} (${formatHours(roundedIncomeTotal)} billable)`;
    } else {
      monthTotalEl.textContent = `Total hours: ${formatHours(roundedMonthTotal)}`;
    }
    grid.innerHTML = '';
    const start = calendarStartDate(state.calendar.year, state.calendar.month);
    for (let i = 0; i < 42; i++) {
      const current = new Date(start.getFullYear(), start.getMonth(), start.getDate() + i);
      const iso = isoDate(current);
      const cell = document.createElement('div');
      cell.className = 'ts-calendar-cell';
      if (current.getMonth() !== state.calendar.month) cell.classList.add('inactive');
      if (iso === todayIso()) cell.classList.add('today');
      const totalMinutes = totals[iso] || 0;
      if (totalMinutes > 0) cell.classList.add('has-entries');
      if (iso === state.selectedCalendarDate) cell.classList.add('selected');
      const dayEl = document.createElement('div');
      dayEl.className = 'ts-calendar-day';
      dayEl.textContent = current.getDate();

      // Check if hour types feature is enabled and we have multiple hour types
      const showHourTypes = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
      const dayHourTypes = hourTypeTotals[iso] || {};

      if (showHourTypes && Object.keys(dayHourTypes).length > 0) {
        // Show default hour type as main total
        const defaultMinutes = dayHourTypes[defaultHourTypeId] || 0;
        const totalEl = document.createElement('div');
        totalEl.className = 'ts-calendar-total';
        if (defaultMinutes === 0) totalEl.classList.add('empty');
        if (defaultMinutes === 0) {
          totalEl.textContent = state.showZeroHours ? '0' : '';
        } else {
          const roundedMinutes = roundDuration(defaultMinutes);
          totalEl.textContent = formatHours(roundedMinutes);
        }

        // Show other hour types as small colored indicators
        const otherTypesEl = document.createElement('div');
        otherTypesEl.className = 'ts-calendar-hour-types';
        Object.keys(dayHourTypes).forEach(hourTypeId => {
          if (hourTypeId !== defaultHourTypeId && dayHourTypes[hourTypeId] > 0) {
            const hourType = state.hourTypeMap[hourTypeId];
            if (hourType) {
              const minutes = dayHourTypes[hourTypeId];
              const roundedMinutes = roundDuration(minutes);
              const indicator = document.createElement('span');
              indicator.className = 'ts-calendar-hour-type-indicator';
              indicator.style.color = hourType.color;
              indicator.textContent = formatHours(roundedMinutes);
              indicator.title = `${hourType.name}: ${formatHours(roundedMinutes)}`;
              otherTypesEl.appendChild(indicator);
            }
          }
        });

        cell.append(dayEl, totalEl, otherTypesEl);
      } else {
        // Original behavior - show total hours
        const totalEl = document.createElement('div');
        totalEl.className = 'ts-calendar-total';
        if (totalMinutes === 0) totalEl.classList.add('empty');
        if (totalMinutes === 0) {
          totalEl.textContent = state.showZeroHours ? '0' : '';
        } else {
          const roundedMinutes = roundDuration(totalMinutes);
          totalEl.textContent = formatHours(roundedMinutes);
        }
        cell.append(dayEl, totalEl);
      }

      cell.onclick = () => handleCalendarClick(iso);
      grid.appendChild(cell);
    }
    renderIncomeSummary();
  }
  function handleCalendarClick(dateIso) {
    state.selectedCalendarDate = dateIso;
    setManualDate(dateIso);
    updateTabStates();
    renderCalendar();
    
    // Check if there's an existing entry for this date
    const existingEntry = state.entries.find(entry => entry.date === dateIso);
    if (existingEntry) {
      console.log('Found existing entry:', existingEntry.entry_type, existingEntry);
      
      // Determine entry type - if not set, try to detect from data structure
      let entryType = existingEntry.entry_type;
      if (!entryType) {
        // Basic entries typically have a single punch from 00:00 to total time
        const punches = existingEntry.punches || [];
        if (punches.length === 1 && punches[0].in === '00:00') {
          entryType = 'basic';
        } else {
          entryType = 'advanced';
        }
        console.log('Detected entry type:', entryType);
      }
      
      // Prepopulate the form with the existing entry
      if (entryType === 'basic') {
        populateManualForm(existingEntry, true);
      } else {
        // For advanced entries, switch to advanced tab and populate
        state.currentTab = 'punch';
        state.editingEntryType = entryType;
        activateTab('punch');
        if (punchDate) punchDate.value = existingEntry.date;
        ensurePunchDraft(existingEntry.contract_id);
        if (state.punchDraft) {
          state.punchDraft.entryId = existingEntry.id;
          state.punchDraft.contractId = existingEntry.contract_id;
          state.punchDraft.date = existingEntry.date;
          state.punchDraft.punches = clonePunches(existingEntry.punches || []);
          state.punchDraft.dirty = false;
          renderPunchDraft();
        }
      }
    } else {
      // No existing entry, keep current tab but clear editing state
      if (state.currentTab === 'manual') {
        clearManualEditing();
      } else {
        // For advanced mode, just clear the editing state without changing tabs
        state.editingEntryId = null;
        state.editingEntryType = null;
        setPunchDate(dateIso);
        ensurePunchDraft();
      }
    }
  }
  function changeCalendarMonth(delta) {
    ensureCalendarState();
    const next = new Date(state.calendar.year, state.calendar.month + delta, 1);
    state.calendar.year = next.getFullYear();
    state.calendar.month = next.getMonth();
    if (state.selectedCalendarDate) {
      const selected = parseIsoDate(state.selectedCalendarDate);
      if (selected.getFullYear() !== state.calendar.year || selected.getMonth() !== state.calendar.month) {
        state.selectedCalendarDate = null;
      }
    }
    renderCalendar();
  }
  document.getElementById('calendar-prev').onclick = () => changeCalendarMonth(-1);
  document.getElementById('calendar-next').onclick = () => changeCalendarMonth(1);

  // Settings persistence
  document.getElementById('btn-save-settings').onclick = function () {
    const nextTheme = themeSelect ? themeSelect.value : (state.settings.theme || 'dark');
    const superRatePercent = superRateInput ? sanitizeSuperRateInputValue(superRateInput.value) : Math.round(getSuperRateSetting() * 1000) / 10;
    const next = {
      round_to_nearest: parseInt((roundInput && roundInput.value) || '0', 10) || 0,
      theme: nextTheme,
      superannuation_rate: superRatePercent
    };
    applyTheme(nextTheme);
    if (superRateInput) superRateInput.value = String(next.superannuation_rate);
    state.settings = { ...state.settings, ...next };
    saveCache();
    renderCalendar();
    setStatus('Saving settings...', 'warn');
    google.script.run
      .withSuccessHandler(() => setStatus('Settings saved', 'success'))
      .withFailureHandler(() => setStatus('Settings failed', 'error'))
      .api_updateSettings(next);
  };

  if (themeSelect) {
    themeSelect.addEventListener('change', () => {
      applyTheme(themeSelect.value);
      saveCache();
    });
  }

  // Initial load
  function init() {
    loadCache();
    if (superRateInput) superRateInput.value = String(getSuperRatePercentage());
    renderEntries();
    if (roundInput) roundInput.value = state.settings.round_to_nearest || 0;
    applyTheme(state.settings.theme || 'dark');
    renderContractsUI();
    hideContractForm();
    refreshContractBindings();
    state.featureFlags = normalizeFeatureFlags(state.featureFlags);
    renderFeatureFlags();
    applyFeatureFlags();
    setStatus('Syncing...', 'warn');
    google.script.run
      .withSuccessHandler((entries) => {
        state.entries = (entries || []).map(sanitizeEntry);
        saveCache();
        renderEntries();
        updateTabStates();
        ensurePunchDraft(state.punchDraft ? state.punchDraft.contractId : undefined);
        setStatus('Synced', 'success');
      })
      .withFailureHandler(() => setStatus('Entries sync failed', 'error'))
      .api_getEntries({});
    google.script.run
      .withSuccessHandler((settings) => {
        state.settings = settings || {};
        saveCache();
        if (roundInput) roundInput.value = state.settings.round_to_nearest || 0;
        if (superRateInput) superRateInput.value = String(getSuperRatePercentage());
        applyTheme(state.settings.theme || 'dark');
        renderCalendar();
      })
      .withFailureHandler(() => {})
      .api_getSettings();
    google.script.run
      .withSuccessHandler((contracts) => {
        state.contracts = (contracts || []).map(sanitizeContract);
        refreshContractBindings();
        saveCache();
        renderCalendar();
      })
      .withFailureHandler(() => setStatus('Contracts sync failed', 'error'))
      .api_getContracts();
    google.script.run
      .withSuccessHandler((flags) => {
        state.featureFlags = normalizeFeatureFlags(flags);
        saveCache();
        renderFeatureFlags();
        applyFeatureFlags();
      })
      .withFailureHandler(() => {})
      .api_getFeatureFlags();
  }

  // Default Entries Functionality
  const state_defaults = {
    entryDefaults: { basic: [], advanced: [] },
    currentDefaultType: null,
    editingDefaultName: null
  };

  // Default entry UI elements
  const createManualDefaultBtn = document.getElementById('btn-create-manual-default');
  const enterManualDefaultBtn = document.getElementById('btn-enter-manual-default');
  const editManualDefaultsBtn = document.getElementById('btn-edit-manual-defaults');
  const createPunchDefaultBtn = document.getElementById('btn-create-punch-default');
  const enterPunchDefaultBtn = document.getElementById('btn-enter-punch-default');
  const editPunchDefaultsBtn = document.getElementById('btn-edit-punch-defaults');


  // Modal elements
  const createDefaultModal = document.getElementById('modal-create-default');
  const selectDefaultModal = document.getElementById('modal-select-default');
  const editDefaultsModal = document.getElementById('modal-edit-defaults');
  const editDefaultDetailsModal = document.getElementById('modal-edit-default-details');

  function updateDefaultButtonsVisibility() {
    const featureEnabled = state.featureFlags.default_inputs && state.featureFlags.default_inputs.enabled;

    if (!featureEnabled) {
      // Hide all default buttons if feature is disabled
      [createManualDefaultBtn, enterManualDefaultBtn, editManualDefaultsBtn,
       createPunchDefaultBtn, enterPunchDefaultBtn, editPunchDefaultsBtn].forEach(btn => {
        if (btn) btn.style.display = 'none';
      });
      return;
    }

    const defaults = state_defaults.entryDefaults;
    const hasBasicDefaults = defaults.basic.length > 0;
    const hasAdvancedDefaults = defaults.advanced.length > 0;

    // Basic/Manual tab buttons
    if (createManualDefaultBtn) createManualDefaultBtn.style.display = 'inline-flex';
    if (enterManualDefaultBtn) enterManualDefaultBtn.style.display = hasBasicDefaults ? 'inline-flex' : 'none';
    if (editManualDefaultsBtn) editManualDefaultsBtn.style.display = hasBasicDefaults ? 'inline-flex' : 'none';

    // Advanced/Punch tab buttons
    if (createPunchDefaultBtn) createPunchDefaultBtn.style.display = 'inline-flex';
    if (enterPunchDefaultBtn) enterPunchDefaultBtn.style.display = hasAdvancedDefaults ? 'inline-flex' : 'none';
    if (editPunchDefaultsBtn) editPunchDefaultsBtn.style.display = hasAdvancedDefaults ? 'inline-flex' : 'none';
  }

  function loadEntryDefaults() {
    google.script.run
      .withSuccessHandler((result) => {
        state_defaults.entryDefaults = result || { basic: [], advanced: [] };
        updateDefaultButtonsVisibility();
      })
      .withFailureHandler(() => {
        console.log('Failed to load entry defaults');
      })
      .api_getEntryDefaults();
  }

  function showModal(modal) {
    if (modal) modal.style.display = 'flex';
  }

  function hideModal(modal) {
    if (modal) modal.style.display = 'none';
  }

  function getCurrentFormData(type) {
    if (type === 'basic') {
      const hours = Number(manualHoursInput ? manualHoursInput.value : '');
      return {
        duration_minutes: Math.round(hours * 60)
      };
    } else if (type === 'advanced') {
      const draft = state.punchDraft;
      if (!draft || !draft.punches) return { punches: [] };
      return {
        punches: draft.punches.filter(p => p.in && p.out) // Only include closed punches
      };
    }
    return null;
  }

  function applyDefaultToForm(defaultData, type) {
    if (type === 'basic') {
      const hours = (defaultData.duration_minutes || 0) / 60;
      if (manualHoursInput) manualHoursInput.value = hours > 0 ? hours.toString() : '';
      updateBasicSaveEnabled();
    } else if (type === 'advanced') {
      // Apply punches to advanced form
      ensurePunchDraft();
      if (state.punchDraft) {
        state.punchDraft.punches = [...(defaultData.punches || [])];
        setPunchDraftDirty();
        renderPunchDraft();
        updatePunchSummary();
      }
    }
  }

  function handleCreateDefault(type) {
    const formData = getCurrentFormData(type);
    if (!formData) {
      setStatus('Please enter some time data first', 'warn');
      return;
    }

    if (type === 'basic' && (!formData.duration_minutes || formData.duration_minutes <= 0)) {
      setStatus('Please enter a valid number of hours', 'warn');
      return;
    }

    if (type === 'advanced' && (!formData.punches || formData.punches.length === 0)) {
      setStatus('Please add some punch times first', 'warn');
      return;
    }

    state_defaults.currentDefaultType = type;
    state_defaults.currentFormData = formData;

    const nameInput = document.getElementById('default-name');
    if (nameInput) nameInput.value = '';
    showModal(createDefaultModal);
    if (nameInput) nameInput.focus();
  }

  function handleEnterDefault(type) {
    const defaults = state_defaults.entryDefaults[type] || [];

    if (defaults.length === 0) {
      setStatus('No defaults available', 'warn');
      return;
    }

    if (defaults.length === 1) {
      // Single default - apply directly and submit
      applyDefaultToForm(defaults[0], type);

      // Trigger the appropriate save handler
      setTimeout(() => {
        if (type === 'basic' && manualSaveBtn) {
          manualSaveBtn.click();
        } else if (type === 'advanced' && punchSaveBtn) {
          punchSaveBtn.click();
        }
      }, 100);
    } else {
      // Multiple defaults - show selection modal
      state_defaults.currentDefaultType = type;
      renderDefaultSelection(defaults);
      showModal(selectDefaultModal);
    }
  }

  function renderDefaultSelection(defaults) {
    const listEl = document.getElementById('default-selection-list');
    if (!listEl) return;

    listEl.innerHTML = '';
    defaults.forEach((defaultData, index) => {
      const item = document.createElement('div');
      item.className = 'ts-default-item';
      item.style.cssText = 'padding: 12px; margin: 8px 0; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; transition: background-color 0.2s;';

      const title = document.createElement('div');
      title.style.fontWeight = 'bold';
      title.textContent = defaultData.name;

      const details = document.createElement('div');
      details.style.fontSize = '0.9em';
      details.style.color = 'var(--text-secondary)';
      details.style.marginTop = '4px';

      if (state_defaults.currentDefaultType === 'basic') {
        const hours = (defaultData.duration_minutes || 0) / 60;
        details.textContent = `${hours} hours`;
      } else {
        const punchCount = (defaultData.punches || []).length;
        details.textContent = `${punchCount} punch ${punchCount === 1 ? 'range' : 'ranges'}`;
      }

      item.appendChild(title);
      item.appendChild(details);

      item.addEventListener('click', () => {
        applyDefaultToForm(defaultData, state_defaults.currentDefaultType);
        hideModal(selectDefaultModal);

        // Trigger the appropriate save handler
        setTimeout(() => {
          if (state_defaults.currentDefaultType === 'basic' && manualSaveBtn) {
            manualSaveBtn.click();
          } else if (state_defaults.currentDefaultType === 'advanced' && punchSaveBtn) {
            punchSaveBtn.click();
          }
        }, 100);
      });

      item.addEventListener('mouseenter', () => {
        item.style.backgroundColor = 'var(--hover-bg)';
      });

      item.addEventListener('mouseleave', () => {
        item.style.backgroundColor = '';
      });

      listEl.appendChild(item);
    });
  }

  function handleEditDefaults(type) {
    state_defaults.currentDefaultType = type;
    renderEditDefaultsList();
    showModal(editDefaultsModal);
  }

  function renderEditDefaultsList() {
    const listEl = document.getElementById('edit-defaults-list');
    if (!listEl) return;

    const defaults = state_defaults.entryDefaults[state_defaults.currentDefaultType] || [];

    listEl.innerHTML = '';

    if (defaults.length === 0) {
      listEl.innerHTML = '<div class="ts-note">No defaults created yet.</div>';
      return;
    }

    defaults.forEach((defaultData, index) => {
      const item = document.createElement('div');
      item.className = 'ts-edit-default-item';
      item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px; margin: 8px 0; border: 1px solid var(--border-color); border-radius: 4px;';

      const content = document.createElement('div');
      content.style.flex = '1';
      content.style.cursor = 'pointer';

      const title = document.createElement('div');
      title.style.fontWeight = 'bold';
      title.textContent = defaultData.name;

      const details = document.createElement('div');
      details.style.fontSize = '0.9em';
      details.style.color = 'var(--text-secondary)';
      details.style.marginTop = '4px';

      if (state_defaults.currentDefaultType === 'basic') {
        const hours = (defaultData.duration_minutes || 0) / 60;
        details.textContent = `${hours} hours`;
      } else {
        const punchCount = (defaultData.punches || []).length;
        details.textContent = `${punchCount} punch ${punchCount === 1 ? 'range' : 'ranges'}`;
      }

      content.appendChild(title);
      content.appendChild(details);

      content.addEventListener('click', () => {
        openEditDefaultDetails(defaultData);
      });

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.className = 'ghost';
      deleteBtn.style.marginLeft = '12px';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        if (confirm(`Delete the "${defaultData.name}" default?`)) {
          deleteEntryDefault(defaultData.name, deleteBtn);
        }
      });

      item.appendChild(content);
      item.appendChild(deleteBtn);
      listEl.appendChild(item);
    });
  }

  function openEditDefaultDetails(defaultData) {
    state_defaults.editingDefaultName = defaultData.name;

    const nameInput = document.getElementById('edit-default-name');
    if (nameInput) nameInput.value = defaultData.name;

    const formEl = document.getElementById('edit-default-form');
    if (!formEl) return;

    formEl.innerHTML = '';

    if (state_defaults.currentDefaultType === 'basic') {
      const hours = (defaultData.duration_minutes || 0) / 60;

      formEl.innerHTML = `
        <div class="ts-row">
          <div class="ts-col">
            <label>Total hours</label>
            <input type="number" id="edit-default-hours" min="0" step="0.01" value="${hours}" />
          </div>
        </div>
      `;
    } else {
      const punchesHtml = (defaultData.punches || []).map((punch, i) => `
        <div class="ts-row" style="margin-top: 8px;">
          <div class="ts-col">
            <label>Punch ${i + 1} In</label>
            <input type="time" id="edit-punch-${i}-in" value="${punch.in || ''}" />
          </div>
          <div class="ts-col">
            <label>Punch ${i + 1} Out</label>
            <input type="time" id="edit-punch-${i}-out" value="${punch.out || ''}" />
          </div>
          <div class="ts-col" style="display:flex; align-items:flex-end;">
            <button type="button" class="ghost" onclick="removePunchRow(${i})">Remove</button>
          </div>
        </div>
      `).join('');

      formEl.innerHTML = `
        <div id="edit-punch-rows">
          ${punchesHtml}
        </div>
        <div style="margin-top: 12px;">
          <button type="button" class="ghost" onclick="addEditPunchRow()">Add Punch Range</button>
        </div>
      `;
    }

    hideModal(editDefaultsModal);
    showModal(editDefaultDetailsModal);
  }

  // Global functions for punch editing (needed for onclick handlers)
  window.addEditPunchRow = function() {
    const container = document.getElementById('edit-punch-rows');
    if (!container) return;

    const existingRows = container.children.length;
    const newRow = document.createElement('div');
    newRow.className = 'ts-row';
    newRow.style.marginTop = '8px';
    newRow.innerHTML = `
      <div class="ts-col">
        <label>Punch ${existingRows + 1} In</label>
        <input type="time" id="edit-punch-${existingRows}-in" />
      </div>
      <div class="ts-col">
        <label>Punch ${existingRows + 1} Out</label>
        <input type="time" id="edit-punch-${existingRows}-out" />
      </div>
      <div class="ts-col" style="display:flex; align-items:flex-end;">
        <button type="button" class="ghost" onclick="removePunchRow(${existingRows})">Remove</button>
      </div>
    `;
    container.appendChild(newRow);
  };

  window.removePunchRow = function(index) {
    const container = document.getElementById('edit-punch-rows');
    if (!container || container.children.length <= 1) return;

    if (container.children[index]) {
      container.removeChild(container.children[index]);

      // Update labels and IDs
      Array.from(container.children).forEach((row, i) => {
        const labels = row.querySelectorAll('label');
        const inputs = row.querySelectorAll('input');
        const button = row.querySelector('button');

        if (labels[0]) labels[0].textContent = `Punch ${i + 1} In`;
        if (labels[1]) labels[1].textContent = `Punch ${i + 1} Out`;
        if (inputs[0]) inputs[0].id = `edit-punch-${i}-in`;
        if (inputs[1]) inputs[1].id = `edit-punch-${i}-out`;
        if (button) button.setAttribute('onclick', `removePunchRow(${i})`);
      });
    }
  };

  function saveDefaultFromModal() {
    const nameInput = document.getElementById('default-name');
    const name = nameInput ? nameInput.value.trim() : '';
    const saveBtn = document.getElementById('btn-save-default');

    if (!name) {
      setStatus('Please enter a name for the default', 'warn');
      return;
    }

    const type = state_defaults.currentDefaultType;
    const formData = state_defaults.currentFormData;

    if (!type || !formData) {
      setStatus('Invalid default data', 'error');
      return;
    }

    // Disable save button and show saving state
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }
    setStatus('Saving default...', 'warn');

    google.script.run
      .withSuccessHandler((result) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Default';
        }

        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          hideModal(createDefaultModal);
          setStatus(`Default "${name}" created`, 'success');
        } else {
          setStatus('Failed to create default', 'error');
        }
      })
      .withFailureHandler((error) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Default';
        }
        setStatus('Failed to create default: ' + error.message, 'error');
      })
      .api_saveEntryDefault(type, name, formData);
  }

  function saveDefaultDetails() {
    const nameInput = document.getElementById('edit-default-name');
    const newName = nameInput ? nameInput.value.trim() : '';

    if (!newName) {
      setStatus('Please enter a name for the default', 'warn');
      return;
    }

    const type = state_defaults.currentDefaultType;
    const oldName = state_defaults.editingDefaultName;

    let formData;
    if (type === 'basic') {
      const hoursInput = document.getElementById('edit-default-hours');
      const hours = Number(hoursInput ? hoursInput.value : '');

      if (!Number.isFinite(hours) || hours <= 0) {
        setStatus('Please enter valid hours', 'warn');
        return;
      }

      formData = {
        duration_minutes: Math.round(hours * 60)
      };
    } else {
      const container = document.getElementById('edit-punch-rows');
      if (!container) return;

      const punches = [];
      Array.from(container.children).forEach((row, i) => {
        const inInput = document.getElementById(`edit-punch-${i}-in`);
        const outInput = document.getElementById(`edit-punch-${i}-out`);
        const inTime = inInput ? inInput.value : '';
        const outTime = outInput ? outInput.value : '';

        if (inTime && outTime) {
          punches.push({ in: inTime, out: outTime });
        }
      });

      if (punches.length === 0) {
        setStatus('Please add at least one complete punch range', 'warn');
        return;
      }

      formData = { punches };
    }

    // Disable save button and show saving state
    const saveBtn = document.getElementById('btn-save-default-details');
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }
    setStatus('Updating default...', 'warn');

    google.script.run
      .withSuccessHandler((result) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Changes';
        }

        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          hideModal(editDefaultDetailsModal);
          setStatus(`Default "${newName}" updated`, 'success');
          // Refresh the edit list if still open
          if (editDefaultsModal && editDefaultsModal.style.display !== 'none') {
            renderEditDefaultsList();
            showModal(editDefaultsModal);
          }
        } else {
          setStatus('Failed to update default', 'error');
        }
      })
      .withFailureHandler((error) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Changes';
        }
        setStatus('Failed to update default: ' + error.message, 'error');
      })
      .api_updateEntryDefault(type, oldName, newName, formData);
  }

  function deleteEntryDefault(name, deleteBtn) {
    const type = state_defaults.currentDefaultType;

    // Disable delete button and show deleting state
    if (deleteBtn) {
      deleteBtn.disabled = true;
      deleteBtn.textContent = 'Deleting...';
    }
    setStatus('Deleting default...', 'warn');

    google.script.run
      .withSuccessHandler((result) => {
        // Re-enable delete button
        if (deleteBtn) {
          deleteBtn.disabled = false;
          deleteBtn.textContent = 'Delete';
        }

        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          renderEditDefaultsList();
          setStatus(`Default "${name}" deleted`, 'success');
        } else {
          setStatus('Failed to delete default', 'error');
        }
      })
      .withFailureHandler((error) => {
        // Re-enable delete button
        if (deleteBtn) {
          deleteBtn.disabled = false;
          deleteBtn.textContent = 'Delete';
        }
        setStatus('Failed to delete default: ' + error.message, 'error');
      })
      .api_deleteEntryDefault(type, name);
  }

  // Event handlers for default entry buttons
  if (createManualDefaultBtn) {
    createManualDefaultBtn.addEventListener('click', () => handleCreateDefault('basic'));
  }

  if (enterManualDefaultBtn) {
    enterManualDefaultBtn.addEventListener('click', () => handleEnterDefault('basic'));
  }

  if (editManualDefaultsBtn) {
    editManualDefaultsBtn.addEventListener('click', () => handleEditDefaults('basic'));
  }

  if (createPunchDefaultBtn) {
    createPunchDefaultBtn.addEventListener('click', () => handleCreateDefault('advanced'));
  }

  if (enterPunchDefaultBtn) {
    enterPunchDefaultBtn.addEventListener('click', () => handleEnterDefault('advanced'));
  }

  if (editPunchDefaultsBtn) {
    editPunchDefaultsBtn.addEventListener('click', () => handleEditDefaults('advanced'));
  }

  // Modal event handlers
  function setupModalHandlers() {
    // Close buttons
    document.querySelectorAll('.ts-modal-close').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const modal = e.target.closest('.ts-modal');
        hideModal(modal);
      });
    });

    // Click outside to close
    document.querySelectorAll('.ts-modal').forEach(modal => {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          hideModal(modal);
        }
      });
    });

    // Specific button handlers
    const cancelCreateBtn = document.getElementById('btn-cancel-create-default');
    if (cancelCreateBtn) {
      cancelCreateBtn.addEventListener('click', () => hideModal(createDefaultModal));
    }

    const saveDefaultBtn = document.getElementById('btn-save-default');
    if (saveDefaultBtn) {
      saveDefaultBtn.addEventListener('click', saveDefaultFromModal);
    }

    const cancelSelectBtn = document.getElementById('btn-cancel-select-default');
    if (cancelSelectBtn) {
      cancelSelectBtn.addEventListener('click', () => hideModal(selectDefaultModal));
    }

    const closeEditBtn = document.getElementById('btn-close-edit-defaults');
    if (closeEditBtn) {
      closeEditBtn.addEventListener('click', () => hideModal(editDefaultsModal));
    }

    const cancelEditDetailsBtn = document.getElementById('btn-cancel-edit-default-details');
    if (cancelEditDetailsBtn) {
      cancelEditDetailsBtn.addEventListener('click', () => {
        hideModal(editDefaultDetailsModal);
        if (editDefaultsModal) showModal(editDefaultsModal);
      });
    }

    const saveDetailsBtn = document.getElementById('btn-save-default-details');
    if (saveDetailsBtn) {
      saveDetailsBtn.addEventListener('click', saveDefaultDetails);
    }

    // Enter key handlers
    const defaultNameInput = document.getElementById('default-name');
    if (defaultNameInput) {
      defaultNameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          saveDefaultFromModal();
        }
      });
    }
  }

  setupModalHandlers();

  // Initialize default entries after all functions are defined
  updateDefaultButtonsVisibility();
  loadEntryDefaults();

  // Hour Types Management
  function generateRandomColor() {
    const colors = [
      '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16', '#22c55e',
      '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', '#3b82f6', '#6366f1',
      '#8b5cf6', '#a855f7', '#d946ef', '#ec4899', '#f43f5e'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  function loadHourTypes() {
    if (!state.featureFlags.hour_types) return;

    setStatus('Loading hour types...', 'warn');
    google.script.run
      .withSuccessHandler((hourTypes) => {
        state.hourTypes = Array.isArray(hourTypes) ? hourTypes.map(sanitizeHourType) : [];
        updateHourTypeMap();
        renderHourTypes();
        updateHourTypeFormVisibility();
        saveCache();
        setStatus('Idle');
      })
      .withFailureHandler((error) => {
        console.error('Failed to load hour types:', error);
        setStatus('Error loading hour types', 'error');
      })
      .api_getHourTypes();
  }

  function renderHourTypes() {
    const container = document.getElementById('hour-types-list');
    if (!container) return;

    if (state.hourTypes.length === 0) {
      container.innerHTML = '<div class="ts-note">No hour types configured. Click "Add Hour Type" to create your first one.</div>';
      return;
    }

    const html = state.hourTypes.map(hourType => {
      const badges = [];
      if (hourType.is_default) badges.push('<span class="ts-hour-type-badge default">Default</span>');
      if (hourType.contributes_to_income) badges.push('<span class="ts-hour-type-badge income">Income</span>');

      const isWork = hourType.slug === 'work';
      const editText = isWork ? 'Settings' : 'Edit';

      return `
        <div class="ts-hour-type-item ${isWork ? 'work' : ''}" data-id="${hourType.id}">
          <div class="ts-hour-type-color" style="background-color: ${hourType.color}"></div>
          <div class="ts-hour-type-info">
            <h4 class="ts-hour-type-name">${hourType.name}${isWork ? ' (Built-in)' : ''}</h4>
            <p class="ts-hour-type-details">Slug: ${hourType.slug}</p>
            <div class="ts-hour-type-badges">${badges.join('')}</div>
          </div>
          <div class="ts-hour-type-actions">
            <button class="ghost small" onclick="editHourType('${hourType.id}')">${editText}</button>
            <button class="ghost small danger" onclick="deleteHourType('${hourType.id}')" ${isWork ? 'style="display:none;"' : ''}>Delete</button>
          </div>
        </div>
      `;
    }).join('');

    container.innerHTML = html;
  }

  function showHourTypeModal(hourType = null) {
    const modal = document.getElementById('modal-hour-type');
    const title = document.getElementById('hour-type-modal-title');
    const nameInput = document.getElementById('hour-type-name');
    const slugInput = document.getElementById('hour-type-slug');
    const colorInput = document.getElementById('hour-type-color');
    const contributesInput = document.getElementById('hour-type-contributes-income');
    const defaultInput = document.getElementById('hour-type-is-default');

    if (!modal) return;

    state.editingHourTypeId = hourType ? hourType.id : null;
    const isWork = hourType && hourType.slug === 'work';

    title.textContent = isWork ? 'Work Hour Type Settings' : (hourType ? 'Edit Hour Type' : 'Add Hour Type');
    nameInput.value = hourType ? hourType.name : '';
    slugInput.value = hourType ? hourType.slug : '';
    colorInput.value = hourType ? hourType.color : generateRandomColor();
    contributesInput.checked = hourType ? hourType.contributes_to_income : false;
    defaultInput.checked = hourType ? hourType.is_default : false;

    // Disable editing core properties of work hour type
    nameInput.disabled = isWork;
    slugInput.disabled = isWork;
    contributesInput.disabled = isWork;

    // For work hour type, only allow changing default status and color
    if (isWork) {
      nameInput.style.opacity = '0.6';
      slugInput.style.opacity = '0.6';
      contributesInput.parentElement.style.opacity = '0.6';
    } else {
      nameInput.style.opacity = '1';
      slugInput.style.opacity = '1';
      contributesInput.parentElement.style.opacity = '1';
    }

    modal.style.display = 'flex';
  }

  function hideHourTypeModal() {
    const modal = document.getElementById('modal-hour-type');
    if (modal) modal.style.display = 'none';
    state.editingHourTypeId = null;
  }

  function saveHourType() {
    const nameInput = document.getElementById('hour-type-name');
    const slugInput = document.getElementById('hour-type-slug');
    const colorInput = document.getElementById('hour-type-color');
    const contributesInput = document.getElementById('hour-type-contributes-income');
    const defaultInput = document.getElementById('hour-type-is-default');
    const saveBtn = document.getElementById('btn-save-hour-type');

    const name = nameInput.value.trim();
    const slug = slugInput.value.trim().toLowerCase();
    const color = colorInput.value;
    const contributesToIncome = contributesInput.checked;
    const isDefault = defaultInput.checked;

    if (!name || !slug) {
      alert('Name and slug are required');
      return;
    }

    // Check slug uniqueness
    const existingType = state.hourTypes.find(ht => ht.slug === slug && ht.id !== state.editingHourTypeId);
    if (existingType) {
      alert('A hour type with this slug already exists');
      return;
    }

    saveBtn.textContent = 'Saving...';
    saveBtn.disabled = true;

    const data = {
      name,
      slug,
      color,
      contributes_to_income: contributesToIncome,
      is_default: isDefault
    };

    if (state.editingHourTypeId) {
      // Update existing
      google.script.run
        .withSuccessHandler((result) => {
          const index = state.hourTypes.findIndex(ht => ht.id === state.editingHourTypeId);
          if (index !== -1) {
            state.hourTypes[index] = sanitizeHourType(result);
          }
          updateHourTypeMap();
          renderHourTypes();
          saveCache();
          hideHourTypeModal();
          setStatus('Hour type updated');
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .withFailureHandler((error) => {
          console.error('Failed to update hour type:', error);
          alert('Failed to update hour type: ' + error.message);
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .api_updateHourType(state.editingHourTypeId, data);
    } else {
      // Create new
      google.script.run
        .withSuccessHandler((result) => {
          state.hourTypes.push(sanitizeHourType(result));
          updateHourTypeMap();
          renderHourTypes();
          saveCache();
          hideHourTypeModal();
          setStatus('Hour type created');
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .withFailureHandler((error) => {
          console.error('Failed to create hour type:', error);
          alert('Failed to create hour type: ' + error.message);
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .api_createHourType(data);
    }
  }

  function editHourType(id) {
    const hourType = state.hourTypes.find(ht => ht.id === id);
    if (hourType) {
      showHourTypeModal(hourType);
    }
  }

  function deleteHourType(id) {
    const hourType = state.hourTypes.find(ht => ht.id === id);
    if (!hourType) return;

    const modal = document.getElementById('modal-delete-hour-type');
    const nameSpan = document.getElementById('delete-hour-type-name');

    if (!modal || !nameSpan) return;

    nameSpan.textContent = hourType.name;
    modal.style.display = 'flex';

    // Store the ID for the confirm handler
    modal.dataset.hourTypeId = id;
  }

  function confirmDeleteHourType() {
    const modal = document.getElementById('modal-delete-hour-type');
    const confirmBtn = document.getElementById('btn-confirm-delete-hour-type');
    const id = modal.dataset.hourTypeId;

    if (!id) return;

    confirmBtn.textContent = 'Deleting...';
    confirmBtn.disabled = true;

    google.script.run
      .withSuccessHandler(() => {
        state.hourTypes = state.hourTypes.filter(ht => ht.id !== id);
        updateHourTypeMap();
        renderHourTypes();
        saveCache();
        modal.style.display = 'none';
        setStatus('Hour type deleted');
        confirmBtn.textContent = 'Delete Hour Type';
        confirmBtn.disabled = false;
      })
      .withFailureHandler((error) => {
        console.error('Failed to delete hour type:', error);
        alert('Failed to delete hour type: ' + error.message);
        confirmBtn.textContent = 'Delete Hour Type';
        confirmBtn.disabled = false;
      })
      .api_deleteHourType(id);
  }

  // Hour Types Event Listeners
  const btnAddHourType = document.getElementById('btn-add-hour-type');
  const btnSaveHourType = document.getElementById('btn-save-hour-type');
  const btnCancelHourType = document.getElementById('btn-cancel-hour-type');
  const btnConfirmDeleteHourType = document.getElementById('btn-confirm-delete-hour-type');
  const btnCancelDeleteHourType = document.getElementById('btn-cancel-delete-hour-type');

  if (btnAddHourType) {
    btnAddHourType.addEventListener('click', () => showHourTypeModal());
  }

  if (btnSaveHourType) {
    btnSaveHourType.addEventListener('click', saveHourType);
  }

  if (btnCancelHourType) {
    btnCancelHourType.addEventListener('click', hideHourTypeModal);
  }

  if (btnConfirmDeleteHourType) {
    btnConfirmDeleteHourType.addEventListener('click', confirmDeleteHourType);
  }

  if (btnCancelDeleteHourType) {
    btnCancelDeleteHourType.addEventListener('click', () => {
      document.getElementById('modal-delete-hour-type').style.display = 'none';
    });
  }

  // Auto-generate slug from name
  const hourTypeNameInput = document.getElementById('hour-type-name');
  const hourTypeSlugInput = document.getElementById('hour-type-slug');

  if (hourTypeNameInput && hourTypeSlugInput) {
    hourTypeNameInput.addEventListener('input', () => {
      if (!state.editingHourTypeId) { // Only auto-generate for new hour types
        const slug = hourTypeNameInput.value
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .replace(/^-|-$/g, '');
        hourTypeSlugInput.value = slug;
      }
    });
  }

  // Close modals when clicking close button or outside
  document.addEventListener('click', (event) => {
    if (event.target.classList.contains('ts-modal-close')) {
      const modal = event.target.closest('.ts-modal');
      if (modal) modal.style.display = 'none';
    }
    if (event.target.classList.contains('ts-modal')) {
      event.target.style.display = 'none';
    }
  });

  // Hour Type Form Management
  function updateHourTypeFormVisibility() {
    const hourTypesEnabled = !!(state.featureFlags.hour_types && state.featureFlags.hour_types.enabled);
    const hasMultipleTypes = state.hourTypes.length > 1;
    const shouldShow = hourTypesEnabled && hasMultipleTypes;

    if (manualHourTypeCol) {
      manualHourTypeCol.style.display = shouldShow ? 'block' : 'none';
    }
    if (punchHourTypeCol) {
      punchHourTypeCol.style.display = shouldShow ? 'block' : 'none';
    }

    if (shouldShow) {
      populateHourTypeOptions();
    }
  }

  function populateHourTypeOptions() {
    if (!state.hourTypes.length) return;

    [manualHourType, punchHourType].forEach(select => {
      if (!select) return;

      const currentValue = select.value;
      select.innerHTML = '';

      state.hourTypes.forEach(hourType => {
        const option = document.createElement('option');
        option.value = hourType.id;
        option.textContent = hourType.name;
        if (hourType.is_default && !currentValue) {
          option.selected = true;
        }
        select.appendChild(option);
      });

      // Restore previous selection if it still exists
      if (currentValue && state.hourTypeMap[currentValue]) {
        select.value = currentValue;
      }

      // Update contract visibility when hour type changes
      if (select === manualHourType) {
        updateManualContractVisibility();
      } else if (select === punchHourType) {
        updatePunchContractVisibility();
      }
    });
  }

  function updateManualContractVisibility() {
    if (!manualHourType || !manualContract) return;

    const selectedHourType = state.hourTypeMap[manualHourType.value];
    if (selectedHourType && !selectedHourType.requires_contract) {
      // Show "Not required" for non-contract hour types
      manualContract.innerHTML = '<option value="">Not required (optional)</option>';
      const validContracts = validContractsForDate(manualDate ? manualDate.value : todayIso());
      validContracts.forEach(contract => {
        const option = document.createElement('option');
        option.value = contract.id;
        option.textContent = contract.name;
        manualContract.appendChild(option);
      });
      manualContract.style.fontStyle = 'italic';
      manualContract.style.opacity = '0.8';
    } else {
      // Normal contract requirement
      manualContract.style.fontStyle = 'normal';
      manualContract.style.opacity = '1';
      updateManualContractOptions();
    }
    updateBasicSaveEnabled();
  }

  function updatePunchContractVisibility() {
    if (!punchHourType || !punchContract) return;

    const selectedHourType = state.hourTypeMap[punchHourType.value];
    if (selectedHourType && !selectedHourType.requires_contract) {
      // Show "Not required" for non-contract hour types
      punchContract.innerHTML = '<option value="">Not required (optional)</option>';
      const validContracts = validContractsForDate(punchDate ? punchDate.value : todayIso());
      validContracts.forEach(contract => {
        const option = document.createElement('option');
        option.value = contract.id;
        option.textContent = contract.name;
        punchContract.appendChild(option);
      });
      punchContract.style.fontStyle = 'italic';
      punchContract.style.opacity = '0.8';
    } else {
      // Normal contract requirement
      punchContract.style.fontStyle = 'normal';
      punchContract.style.opacity = '1';
      updatePunchContractOptions();
    }
  }

  function getDefaultHourTypeId() {
    if (!state.hourTypes.length) return null;
    const defaultType = state.hourTypes.find(ht => ht.is_default);
    return defaultType ? defaultType.id : state.hourTypes[0].id;
  }

  // Event listeners for hour type changes
  if (manualHourType) {
    manualHourType.addEventListener('change', updateManualContractVisibility);
  }

  if (punchHourType) {
    punchHourType.addEventListener('change', updatePunchContractVisibility);
  }

  // Call the main init function
  init();
</script>
