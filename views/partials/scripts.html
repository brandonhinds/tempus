<script>
  // Layout navigation
  const pageTime = document.getElementById('page-time');
  const pageContracts = document.getElementById('page-contracts');
  const pageHourTypes = document.getElementById('page-hour-types');
  const pageDeductions = document.getElementById('page-deductions');
  const pageBas = document.getElementById('page-bas');
  const pageAnnualViews = document.getElementById('page-annual-views');
  const pageRatePreview = document.getElementById('page-rate-preview');
  const pageSettings = document.getElementById('page-settings');
  const pageInvoices = document.getElementById('page-invoices');
  const pageAbout = document.getElementById('page-about');
  const aboutVersionDisplay = document.getElementById('about-version-display');
  const aboutVersionStatus = document.getElementById('about-version-status');
  const navToggle = document.getElementById('nav-toggle');
  const navHomeBtn = document.getElementById('nav-home');
  const navMenu = document.getElementById('nav-menu');
  const navTimeBtn = document.getElementById('nav-time');
  const navContractsBtn = document.getElementById('nav-contracts');
  const navRatePreviewBtn = document.getElementById('nav-rate-preview');
  const navHourTypesBtn = document.getElementById('nav-hour-types');
  const navDeductionsBtn = document.getElementById('nav-deductions');
  const navBasBtn = document.getElementById('nav-bas');
  const navAnnualViewsBtn = document.getElementById('nav-annual-views');
  const navInvoicesBtn = document.getElementById('nav-invoices');
  const navSettingsBtn = document.getElementById('nav-settings');
  const navAboutBtn = document.getElementById('nav-about');
  const ratePreviewContractSelect = document.getElementById('rate-preview-contract');
  const ratePreviewPercentInput = document.getElementById('rate-preview-percent');
  const ratePreviewRateInput = document.getElementById('rate-preview-rate');
  const ratePreviewResetBtn = document.getElementById('rate-preview-reset');
  const ratePreviewEmpty = document.getElementById('rate-preview-empty');
  const ratePreviewContent = document.getElementById('rate-preview-content');
  const ratePreviewLoadingOverlay = document.getElementById('rate-preview-loading');
  const ratePreviewAdjustedRateEl = document.getElementById('rate-preview-adjusted-rate');
  const ratePreviewCurrentRateEl = document.getElementById('rate-preview-current-rate');
  const ratePreviewRateDeltaEl = document.getElementById('rate-preview-rate-delta');
  const ratePreviewTotalHoursEl = document.getElementById('rate-preview-total-hours');
  const ratePreviewTotalEarnScenarioEl = document.getElementById('rate-preview-total-earn-scenario');
  const ratePreviewTotalEarnCurrentEl = document.getElementById('rate-preview-total-earn-current');
  const ratePreviewTotalEarnVarianceEl = document.getElementById('rate-preview-total-earn-variance');
  const ratePreviewTotalSuperScenarioEl = document.getElementById('rate-preview-total-super-scenario');
  const ratePreviewTotalSuperCurrentEl = document.getElementById('rate-preview-total-super-current');
  const ratePreviewTotalSuperVarianceEl = document.getElementById('rate-preview-total-super-variance');
  const ratePreviewTotalTaxScenarioEl = document.getElementById('rate-preview-total-tax-scenario');
  const ratePreviewTotalTaxCurrentEl = document.getElementById('rate-preview-total-tax-current');
  const ratePreviewTotalTaxVarianceEl = document.getElementById('rate-preview-total-tax-variance');
  const ratePreviewTotalNetScenarioEl = document.getElementById('rate-preview-total-net-scenario');
  const ratePreviewTotalNetCurrentEl = document.getElementById('rate-preview-total-net-current');
  const ratePreviewTotalNetVarianceEl = document.getElementById('rate-preview-total-net-variance');
  const ratePreviewRemainingCard = document.getElementById('rate-preview-remaining-card');
  const ratePreviewRemainingScenarioEl = document.getElementById('rate-preview-remaining-scenario');
  const ratePreviewRemainingCurrentEl = document.getElementById('rate-preview-remaining-current');
const ratePreviewRemainingVarianceEl = document.getElementById('rate-preview-remaining-variance');
const ratePreviewContractHoursEl = document.getElementById('rate-preview-contract-hours');
const ratePreviewRemainingSuperScenarioEl = document.getElementById('rate-preview-remaining-super-scenario');
const ratePreviewRemainingSuperCurrentEl = document.getElementById('rate-preview-remaining-super-current');
const ratePreviewRemainingSuperVarianceEl = document.getElementById('rate-preview-remaining-super-variance');
  const ratePreviewRemainingTaxScenarioEl = document.getElementById('rate-preview-remaining-tax-scenario');
  const ratePreviewRemainingTaxCurrentEl = document.getElementById('rate-preview-remaining-tax-current');
  const ratePreviewRemainingTaxVarianceEl = document.getElementById('rate-preview-remaining-tax-variance');
  const ratePreviewRemainingNetScenarioEl = document.getElementById('rate-preview-remaining-net-scenario');
  const ratePreviewRemainingNetCurrentEl = document.getElementById('rate-preview-remaining-net-current');
  const ratePreviewRemainingNetVarianceEl = document.getElementById('rate-preview-remaining-net-variance');
  const ratePreviewSummaryFootnote = document.getElementById('rate-preview-summary-footnote');
  const ratePreviewNoEntriesNote = document.getElementById('rate-preview-no-entries');
  const ratePreviewMonthlyBody = document.getElementById('rate-preview-monthly-body');
  const invoiceConfigNote = document.getElementById('invoice-config-note');
  const invoiceSelector = document.getElementById('invoice-selector');
  const btnInvoiceNew = document.getElementById('btn-invoice-new');
  const invoiceNavPrev = document.getElementById('invoice-nav-prev');
  const invoiceNavNext = document.getElementById('invoice-nav-next');
  const invoiceNavJump = document.getElementById('invoice-nav-jump');
const invoiceDetailEmpty = document.getElementById('invoice-detail-empty');
const invoiceDetailEmptyText = document.getElementById('invoice-detail-empty-text');
  const invoiceDetail = document.getElementById('invoice-detail');
  const invoiceDetailNumberInput = document.getElementById('invoice-detail-number');
  const invoiceDetailDateInput = document.getElementById('invoice-detail-date');
  const invoiceDetailStatusSelect = document.getElementById('invoice-detail-status');
  const btnInvoiceDelete = document.getElementById('btn-invoice-delete');
  const btnInvoiceSave = document.getElementById('btn-invoice-save');
  const btnInvoiceGenerate = document.getElementById('btn-invoice-generate');
  const invoiceLineSummary = document.getElementById('invoice-line-summary');
  const invoiceLineEmpty = document.getElementById('invoice-line-empty');
  const btnInvoiceAddLine = document.getElementById('btn-invoice-add-line');
  const invoiceLineFormAnchor = document.getElementById('invoice-line-form-anchor');
  const invoiceLineForm = document.getElementById('invoice-line-form');
  const invoiceLineDateInput = document.getElementById('invoice-line-date');
  const invoiceLineDescriptionInput = document.getElementById('invoice-line-description');
  const invoiceLineAmountModeSelect = document.getElementById('invoice-line-amount-mode');
  const invoiceLineHoursInput = document.getElementById('invoice-line-hours');
  const invoiceLineContractCol = document.getElementById('invoice-line-contract-col');
  const invoiceLineHoursCol = document.getElementById('invoice-line-hours-col');
  const invoiceLineHourTypeSelect = document.getElementById('invoice-line-hour-type');
  const invoiceLineHourTypeCol = document.getElementById('invoice-line-hour-type-col');
  const invoiceLineAmountInput = document.getElementById('invoice-line-amount');
  const invoiceLineAmountCol = document.getElementById('invoice-line-amount-col');
  const invoiceLineContractSelect = document.getElementById('invoice-line-contract');
  const btnInvoiceLineCancel = document.getElementById('btn-invoice-line-cancel');
  const btnInvoiceLineSave = document.getElementById('btn-invoice-line-save');
  const invoiceLineItemsBody = document.getElementById('invoice-line-items');
  const invoiceLineSubtotal = document.getElementById('invoice-line-subtotal');
  const invoiceLineGst = document.getElementById('invoice-line-gst');
  const invoiceLineTotal = document.getElementById('invoice-line-total');
  const invoiceDefaultList = document.getElementById('invoice-default-list');
const invoiceDefaultEmpty = document.getElementById('invoice-default-empty');
  const btnInvoiceDefaultNew = document.getElementById('btn-invoice-default-new');
  const invoiceDefaultFormAnchor = document.getElementById('invoice-default-form-anchor');
  const invoiceDefaultForm = document.getElementById('invoice-default-form');
  const invoiceDefaultLabelInput = document.getElementById('invoice-default-label');
  const invoiceDefaultDescriptionInput = document.getElementById('invoice-default-description');
  const invoiceDefaultAmountModeSelect = document.getElementById('invoice-default-amount-mode');
  const invoiceDefaultHoursInput = document.getElementById('invoice-default-hours');
  const invoiceDefaultAmountInput = document.getElementById('invoice-default-amount');
  const invoiceDefaultHourTypeSelect = document.getElementById('invoice-default-hour-type');
  const invoiceDefaultHourTypeCol = document.getElementById('invoice-default-hour-type-col');
  const invoiceDefaultContractCol = document.getElementById('invoice-default-contract-col');
  const invoiceDefaultAmountCol = document.getElementById('invoice-default-amount-col');
  const invoiceDefaultHoursCol = document.getElementById('invoice-default-hours-col');
  const invoiceDefaultContractSelect = document.getElementById('invoice-default-contract');
  const btnInvoiceDefaultCancel = document.getElementById('btn-invoice-default-cancel');
  const btnInvoiceDefaultSave = document.getElementById('btn-invoice-default-save');
  const invoiceTemplateInput = document.getElementById('set-invoice-template');
  const invoiceOutputFolderInput = document.getElementById('set-invoice-output-folder');
  const invoiceLineLimitInput = document.getElementById('set-invoice-line-limit');
  const invoiceTemplateCol = document.getElementById('invoice-template-col');
  const invoiceOutputFolderCol = document.getElementById('invoice-output-folder-col');
  const invoiceLineLimitCol = document.getElementById('invoice-line-limit-col');
  const invoiceMonthPickerModal = document.getElementById('modal-invoice-month-picker');
  const invoiceMonthPickerYearDisplay = document.getElementById('invoice-month-picker-year-display');
  const invoiceMonthPickerYearPrev = document.getElementById('invoice-month-picker-year-prev');
  const invoiceMonthPickerYearNext = document.getElementById('invoice-month-picker-year-next');
  const invoiceMonthPickerGrid = document.getElementById('invoice-month-picker-grid');
  const deductionsListEl = document.getElementById('deductions-list');
  const deductionsEmptyEl = document.getElementById('deductions-empty');
  const deductionCompanyDisabledNote = document.getElementById('deduction-company-disabled-note');
  const btnAddDeduction = document.getElementById('btn-add-deduction');
  const btnManageDeductionCategories = document.getElementById('btn-manage-deduction-categories');
  const deductionCategoryCollapseControls = document.getElementById('deduction-category-collapse-controls');
  const btnExpandAllDeductionCategories = document.getElementById('btn-expand-all-deduction-categories');
  const btnCollapseAllDeductionCategories = document.getElementById('btn-collapse-all-deduction-categories');
  const deductionFormModal = document.getElementById('modal-deduction-form');
  const deductionFormTitle = document.getElementById('deduction-form-title');
  const deductionNameInput = document.getElementById('deduction-name');
  const deductionCategorySelect = document.getElementById('deduction-category');
  const deductionCategoryColumn = document.getElementById('deduction-category-column');
const deductionCategoryEmptyNote = document.getElementById('deduction-category-empty-note');
  const deductionTypeSelect = document.getElementById('deduction-type');
  const deductionAmountInput = document.getElementById('deduction-amount');
  const deductionPercentInput = document.getElementById('deduction-percent');
  const deductionAmountModeWrapper = document.getElementById('deduction-amount-mode-wrapper');
  const deductionAmountModeSelect = document.getElementById('deduction-amount-mode');
  const deductionAmountWrapper = document.getElementById('deduction-amount-wrapper');
  const deductionPercentWrapper = document.getElementById('deduction-percent-wrapper');
  const deductionGstWrapper = document.getElementById('deduction-gst-wrapper');
  const deductionGstToggle = document.getElementById('deduction-gst');
  const deductionCompanyWrapper = document.getElementById('deduction-company-wrapper');
  const deductionCompanyToggle = document.getElementById('deduction-company-expense');
  const deductionCompanyGstNote = document.getElementById('deduction-company-gst-note');
  const deductionFrequencySelect = document.getElementById('deduction-frequency');
  const deductionStartDateInput = document.getElementById('deduction-start-date');
  const deductionEndDateInput = document.getElementById('deduction-end-date');
  const deductionEndDateWrapper = document.getElementById('deduction-end-date-wrapper');
  const deductionNotesInput = document.getElementById('deduction-notes');
  const deductionOccurrencePreview = document.getElementById('deduction-occurrence-preview');
  const btnCancelDeduction = document.getElementById('btn-cancel-deduction');
  const btnSaveDeduction = document.getElementById('btn-save-deduction');
  const modalDeductionCategories = document.getElementById('modal-deduction-categories');
  const deductionCategoryListWrapper = document.getElementById('deduction-category-list-wrapper');
  const deductionCategoryList = document.getElementById('deduction-category-list');
  const deductionCategoryEmptyState = document.getElementById('deduction-category-empty-state');
  const deductionCategoryFormWrapper = document.getElementById('deduction-category-form-wrapper');
  const deductionCategoryNameInput = document.getElementById('deduction-category-name');
  const deductionCategoryColorInput = document.getElementById('deduction-category-color');
  const deductionCategoryListFooter = document.getElementById('deduction-category-list-footer');
  const deductionCategoryFormFooter = document.getElementById('deduction-category-form-footer');
  const btnAddDeductionCategory = document.getElementById('btn-add-deduction-category');
  const btnCloseDeductionCategories = document.getElementById('btn-close-deduction-categories');
  const btnCancelDeductionCategory = document.getElementById('btn-cancel-deduction-category');
  const btnSaveDeductionCategory = document.getElementById('btn-save-deduction-category');
  const modalSplitDeduction = document.getElementById('modal-split-deduction');
  const btnCancelSplit = document.getElementById('btn-cancel-split');
  const btnConfirmSplit = document.getElementById('btn-confirm-split');
  let pendingDeductionPayload = null;
  let originalDeductionForSplit = null;
  const basFySelect = document.getElementById('bas-fy-select');
  const basTableBody = document.getElementById('bas-table-body');
  const basQuarterlyNote = document.getElementById('bas-quarterly-note');
  const basEmptyNote = document.getElementById('bas-empty');
  const basInvoiceSection = document.getElementById('bas-invoice-section');
  const basInvoiceEmpty = document.getElementById('bas-invoice-empty');
  const basInvoiceEmptyText = document.getElementById('bas-invoice-empty-text');
  const basInvoiceTableBody = document.getElementById('bas-invoice-table-body');
  const RATE_PREVIEW_DEBOUNCE_MS = 350;
let ratePreviewDebounceTimer = null;
let ratePreviewInputSyncing = false;

  const state = {
    cacheKey: 'ts_cache',
    entries: [],
    settings: {},
    contracts: [],
    contractMap: {},
    hourTypes: [],
    hourTypeMap: {},
    deductions: [],
    deductionCategories: [],
    deductionCategoryMap: {},
    deductionCategoryCollapse: {},
    featureFlagCollapse: {},
    deductionExceptions: [],
    deductionExceptionsMap: {},
    actualIncome: [],
    actualIncomeMap: {},
    editingActualIncomeId: null,
    featureFlags: {},
    publicHolidays: [],
    publicHolidayMap: {},
    editingEntryId: null,
    editingEntryType: null,
    editingContractId: null,
    editingHourTypeId: null,
    editingDeductionId: null,
    contractFormMode: 'hidden',
    calendar: null,
    selectedCalendarDate: null,
    showZeroHours: false,
    currentPage: 'time',
    incomeSummary: null,
    pendingTaxRequest: null,
    selectedContractId: '',
    punchDraft: null,
    currentTab: 'manual',
    calendarFilteredHourTypes: null,
    expectedHoursSummary: null,
    companyTrackingEnabled: false,
    companyBasQuarterly: false,
    basCurrentFy: null,
    basSubmissions: [],
    entriesLoaded: false,
    isAutoPopulatingPublicHolidays: false,
    annualYearType: 'financial',
    annualCurrentYear: null,
    annualFilteredContracts: [],
    annualCategoryFilters: [],
    annualCategoryExpansion: {},
    annualData: null,
    invoices: [],
    invoiceMap: {},
    invoiceDefaults: [],
    invoiceDefaultMap: {},
    invoiceFilters: {
      year: '',
      month: ''
    },
    invoiceSelectedId: '',
    invoiceDetail: null,
    invoiceDetailLoading: false,
    invoiceListLoading: false,
    invoiceLineForm: {
      mode: 'hidden',
      editingId: null,
      draft: {},
      amountMode: 'hours'
    },
    invoiceDefaultForm: {
      mode: 'hidden',
      editingId: null,
      draft: {},
      amountMode: 'hours'
    },
    invoicePending: {
      savingInvoice: false,
      generating: false
    },
    invoicesInitialized: false,
    annualCharts: {
      income: null,
      incomePie: null,
      contractPie: null,
      hourTypesPie: null,
      totalHoursPie: null,
      totalHoursByTypePie: null
    },
    contractCharts: {
      monthlyHours: null
    },
    ratePreview: {
      selectedContractId: '',
      data: null,
      loading: false,
      requestToken: 0,
      inputs: {
        percentChange: null,
        newRate: null
      }
    }
  };

  const deductionFormState = {
    mode: 'create',
    editingId: null,
    original: null
  };

  const deductionCategoryFormState = {
    mode: 'list',
    editingId: null
  };

  let loadingDeductionCategories = false;
  let deductionCategoryDeleteId = null;
  let deductionCategorySavePending = false;

  const PAGE_KEYS = ['time', 'contracts', 'rate-preview', 'hour-types', 'deductions', 'bas', 'annual-views', 'invoices', 'settings', 'about'];
  const LAST_PAGE_KEY = 'ts_last_page';

  function persistLastPage(page) {
    if (!PAGE_KEYS.includes(page)) return;
    try {
      if (state.featureFlags.remember_last_page) {
        localStorage.setItem(LAST_PAGE_KEY, page);
      } else {
        localStorage.removeItem(LAST_PAGE_KEY);
      }
    } catch (e) {}
  }

  async function showPage(target, options) {
    const opts = options || {};
    const normalized = PAGE_KEYS.includes(target) ? target : 'time';

    // Check if leaving settings page with unsaved changes
    if (state.currentPage === 'settings' && normalized !== 'settings') {
      if (typeof checkSettingsDirty === 'function' && checkSettingsDirty()) {
        const confirmed = await customConfirm(
          'You have unsaved changes in Settings. Do you want to discard them and continue?',
          {
            title: 'Unsaved Changes',
            okText: 'Discard and Continue',
            cancelText: 'Stay on Settings',
            danger: true
          }
        );
        if (!confirmed) {
          return; // Stay on settings page
        }
        // Discard changes and continue
        if (typeof resetSettingsToInitial === 'function') {
          resetSettingsToInitial();
        }
      }
    }

    const pages = {
      time: pageTime,
      contracts: pageContracts,
      'rate-preview': pageRatePreview,
      'hour-types': pageHourTypes,
      deductions: pageDeductions,
      bas: pageBas,
      'annual-views': pageAnnualViews,
      invoices: pageInvoices,
      settings: pageSettings,
      about: pageAbout
    };
    Object.keys(pages).forEach((key) => {
      const page = pages[key];
      if (page) page.style.display = key === normalized ? 'block' : 'none';
    });
    state.currentPage = normalized;
    if (normalized === 'bas') {
      renderBasReporting();
    }
    if (normalized === 'rate-preview') {
      renderRatePreviewPage();
    }
    if (normalized === 'annual-views') {
      renderAnnualViews();
    }
    if (normalized === 'invoices') {
      renderInvoicesPage();
    }
    if (normalized === 'about') {
      loadScriptId();
      loadBuildMeta();
    }
    if (!opts.skipRemember) {
      persistLastPage(normalized);
    }
  }

  function loadScriptId() {
    const scriptIdDisplay = document.getElementById('script-id-display');
    const scriptIdValue = document.getElementById('script-id-value');

    if (scriptIdDisplay && scriptIdValue) {
      google.script.run
        .withSuccessHandler((scriptId) => {
          scriptIdDisplay.textContent = scriptId;
          scriptIdValue.textContent = scriptId;
        })
        .withFailureHandler(() => {
          scriptIdDisplay.textContent = '[Error loading Script ID]';
          scriptIdValue.textContent = 'Unable to load';
        })
        .api_getScriptId();
    }
  }

  function loadBuildMeta() {
    if (!aboutVersionDisplay) return;
    aboutVersionDisplay.textContent = 'Loading...';
    if (aboutVersionStatus) {
      aboutVersionStatus.textContent = 'Checking...';
      aboutVersionStatus.style.color = 'var(--muted)';
    }

    google.script.run
      .withSuccessHandler((meta) => {
        if (!meta || typeof meta !== 'object') {
          aboutVersionDisplay.textContent = 'Unavailable';
          return;
        }

        const commit = String(meta.commit || '').trim();
        const timestamp = String(meta.timestamp || '').trim();
        if (!commit) {
          aboutVersionDisplay.textContent = 'Unavailable';
          return;
        }

        let formatted = 'Build ' + commit;
        if (timestamp) {
          const parsed = new Date(timestamp);
          if (!Number.isNaN(parsed.valueOf())) {
            formatted += ' Â· ' + parsed.toLocaleString();
          }
        }

        aboutVersionDisplay.textContent = formatted;
      })
      .withFailureHandler(() => {
        aboutVersionDisplay.textContent = 'Unavailable';
      })
      .api_getBuildMeta();

    google.script.run
      .withSuccessHandler((result) => {
        if (!aboutVersionStatus) return;
        if (!result || (result.error && result.error.length)) {
          aboutVersionStatus.textContent = 'Status unavailable';
          aboutVersionStatus.style.color = 'var(--danger)';
          return;
        }
        if (result.hasUpdate) {
          aboutVersionStatus.textContent = 'Update available';
          aboutVersionStatus.style.color = 'var(--warning)';
        } else if (result.upstreamCommit) {
          aboutVersionStatus.textContent = 'Up to date';
          aboutVersionStatus.style.color = 'var(--success)';
        } else {
          aboutVersionStatus.textContent = 'Status unavailable';
          aboutVersionStatus.style.color = 'var(--muted)';
        }
      })
      .withFailureHandler(() => {
        if (!aboutVersionStatus) return;
        aboutVersionStatus.textContent = 'Status unavailable';
        aboutVersionStatus.style.color = 'var(--danger)';
      })
      .api_checkForUpdate();
  }

  // Backup sheet functionality
  const backupSheetBtn = document.getElementById('backup-sheet-btn');
  if (backupSheetBtn) {
    backupSheetBtn.onclick = function() {
      const originalText = backupSheetBtn.textContent;
      backupSheetBtn.disabled = true;
      backupSheetBtn.textContent = 'Creating backup...';

      google.script.run
        .withSuccessHandler((result) => {
          backupSheetBtn.disabled = false;
          backupSheetBtn.textContent = originalText;

          if (result.success) {
            setStatus('Backup created: ' + result.name, 'success');
            customAlert(
              'Your spreadsheet has been backed up successfully!\n\n' +
              'Backup name: ' + result.name + '\n\n' +
              'The backup is saved in the same folder as your original sheet.',
              { title: 'Backup Created' }
            );
          } else {
            setStatus('Backup failed: ' + result.error, 'error');
            customAlert(
              'Failed to create backup:\n\n' + result.error,
              { title: 'Backup Failed' }
            );
          }
        })
        .withFailureHandler((error) => {
          backupSheetBtn.disabled = false;
          backupSheetBtn.textContent = originalText;
          setStatus('Backup failed', 'error');
          customAlert(
            'Failed to create backup:\n\n' + error,
            { title: 'Backup Failed' }
          );
        })
        .api_backupSpreadsheet();
    };
  }

  // Copy-to-clipboard functionality for code blocks
  const copyButtons = document.querySelectorAll('.ts-copy-btn');
  copyButtons.forEach((button) => {
    button.addEventListener('click', function() {
      const codeBlock = this.parentElement.querySelector('code');
      if (!codeBlock) return;

      const textToCopy = codeBlock.textContent;
      const originalText = this.textContent;

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(textToCopy)
          .then(() => {
            this.textContent = 'Copied!';
            setTimeout(() => {
              this.textContent = originalText;
            }, 2000);
          })
          .catch((err) => {
            console.warn('Failed to copy text:', err);
            this.textContent = 'Failed';
            setTimeout(() => {
              this.textContent = originalText;
            }, 2000);
          });
      } else {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = textToCopy;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();

        try {
          document.execCommand('copy');
          this.textContent = 'Copied!';
          setTimeout(() => {
            this.textContent = originalText;
          }, 2000);
        } catch (err) {
          console.warn('Failed to copy text:', err);
          this.textContent = 'Failed';
          setTimeout(() => {
            this.textContent = originalText;
          }, 2000);
        }

        document.body.removeChild(textarea);
      }
    });
  });

  // Tab switching functionality for About page
  const tabButtons = document.querySelectorAll('.ts-tab-btn');
  tabButtons.forEach((button) => {
    button.addEventListener('click', function() {
      const targetTabId = this.getAttribute('data-tab');
      if (!targetTabId) return;

      // Get the parent tabs container to scope our selection
      const tabsContainer = this.parentElement;
      const contentContainer = tabsContainer.nextElementSibling.parentElement;

      // Remove active class from all tab buttons in this container
      tabsContainer.querySelectorAll('.ts-tab-btn').forEach((btn) => {
        btn.classList.remove('active');
      });

      // Add active class to clicked button
      this.classList.add('active');

      // Hide all tab content panels
      contentContainer.querySelectorAll('.ts-tab-content').forEach((content) => {
        content.classList.remove('active');
      });

      // Show the target tab content
      const targetContent = document.getElementById(targetTabId);
      if (targetContent) {
        targetContent.classList.add('active');
      }
    });
  });

  function closeNavMenu() {
    if (!navMenu) return;
    navMenu.hidden = true;
    if (navToggle) navToggle.setAttribute('aria-expanded', 'false');
  }

  function openNavMenu() {
    if (!navMenu) return;
    navMenu.hidden = false;
    if (navToggle) navToggle.setAttribute('aria-expanded', 'true');
  }

  function toggleNavMenu() {
    if (!navMenu) return;
    const expanded = navToggle && navToggle.getAttribute('aria-expanded') === 'true';
    if (expanded) {
      closeNavMenu();
    } else {
      openNavMenu();
    }
  }

  if (navToggle && navMenu) {
    navToggle.addEventListener('click', (event) => {
      event.stopPropagation();
      toggleNavMenu();
    });
  }

  if (navMenu) {
    navMenu.addEventListener('click', (event) => {
      if ((event.target instanceof HTMLElement) && event.target.tagName === 'BUTTON') {
        closeNavMenu();
      }
    });
  }

  document.addEventListener('click', (event) => {
    if (!navMenu || navMenu.hidden) return;
    if (navToggle && (event.target === navToggle || navToggle.contains(event.target))) return;
    if (navMenu.contains(event.target)) return;
    closeNavMenu();
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') closeNavMenu();
  });

  if (navHomeBtn) {
    navHomeBtn.addEventListener('click', async () => {
      closeNavMenu();
      await showPage('time');
      if (state.currentPage !== 'time') return;

      ensureCalendarState();
      const now = new Date();
      const previousYear = state.calendar.year;
      const targetYear = now.getFullYear();
      const targetMonth = now.getMonth();
      const yearChanged = previousYear !== targetYear;
      state.calendar.year = targetYear;
      state.calendar.month = targetMonth;

      const today = todayIso();
      if (yearChanged && getFeatureFlag('enable_public_holidays')) {
        loadPublicHolidays(true);
      }
      handleCalendarClick(today);
    });
  }

  if (navTimeBtn) navTimeBtn.onclick = () => { closeNavMenu(); showPage('time'); };
  if (navContractsBtn) navContractsBtn.onclick = () => { closeNavMenu(); showPage('contracts'); };
  if (navRatePreviewBtn) navRatePreviewBtn.onclick = () => { closeNavMenu(); showPage('rate-preview'); };
  if (navHourTypesBtn) navHourTypesBtn.onclick = () => { closeNavMenu(); showPage('hour-types'); };
  if (navDeductionsBtn) navDeductionsBtn.onclick = () => { closeNavMenu(); showPage('deductions'); };
  if (navBasBtn) navBasBtn.onclick = () => { closeNavMenu(); showPage('bas'); };
  if (navAnnualViewsBtn) navAnnualViewsBtn.onclick = () => { closeNavMenu(); showPage('annual-views'); };
  if (navInvoicesBtn) navInvoicesBtn.onclick = () => { closeNavMenu(); showPage('invoices'); };
  if (navSettingsBtn) navSettingsBtn.onclick = () => { closeNavMenu(); showPage('settings'); };
  if (navAboutBtn) navAboutBtn.onclick = () => { closeNavMenu(); showPage('about'); };
  if (ratePreviewContractSelect) ratePreviewContractSelect.addEventListener('change', handleRatePreviewContractChange);
  if (ratePreviewPercentInput) {
    ratePreviewPercentInput.addEventListener('input', handleRatePreviewPercentInput);
    ratePreviewPercentInput.addEventListener('blur', handleRatePreviewPercentBlur);
  }
  if (ratePreviewRateInput) {
    ratePreviewRateInput.addEventListener('input', handleRatePreviewRateInput);
    ratePreviewRateInput.addEventListener('blur', handleRatePreviewRateBlur);
  }
  if (ratePreviewResetBtn) {
    ratePreviewResetBtn.addEventListener('click', (event) => {
      event.preventDefault();
      resetRatePreviewInputs();
    });
  }
  closeNavMenu();
  showPage('time', { skipRemember: true });

  if (btnAddDeduction) {
    btnAddDeduction.addEventListener('click', () => openDeductionForm('create'));
  }
  if (btnCancelDeduction) {
    btnCancelDeduction.addEventListener('click', (event) => {
      event.preventDefault();
      closeDeductionForm();
    });
  }
  if (btnSaveDeduction) {
    btnSaveDeduction.addEventListener('click', (event) => {
      event.preventDefault();
      handleSaveDeduction();
    });
  }

  if (btnInvoiceNew) btnInvoiceNew.addEventListener('click', (event) => { event.preventDefault(); startCreateInvoice(); });
  if (invoiceSelector) invoiceSelector.addEventListener('change', (event) => {
    const invoiceId = event.target.value;
    if (invoiceId) {
      selectInvoice(invoiceId);
    } else {
      state.invoiceSelectedId = '';
      state.invoiceDetail = null;
      renderInvoiceDetail();
    }
  });
  if (invoiceNavPrev) invoiceNavPrev.addEventListener('click', () => changeInvoiceMonth(-1));
  if (invoiceNavNext) invoiceNavNext.addEventListener('click', () => changeInvoiceMonth(1));
  if (invoiceNavJump) invoiceNavJump.addEventListener('click', openInvoiceMonthPicker);
  if (invoiceMonthPickerYearPrev) invoiceMonthPickerYearPrev.addEventListener('click', () => { invoiceMonthPickerState.year--; renderInvoiceMonthPicker(); });
  if (invoiceMonthPickerYearNext) invoiceMonthPickerYearNext.addEventListener('click', () => { invoiceMonthPickerState.year++; renderInvoiceMonthPicker(); });
  if (invoiceMonthPickerModal) {
    const invoiceMonthPickerClose = invoiceMonthPickerModal.querySelector('.ts-modal-close');
    if (invoiceMonthPickerClose) {
      invoiceMonthPickerClose.addEventListener('click', closeInvoiceMonthPicker);
    }
    invoiceMonthPickerModal.addEventListener('click', (event) => {
      if (event.target === invoiceMonthPickerModal) closeInvoiceMonthPicker();
    });
  }
  if (btnInvoiceSave) btnInvoiceSave.addEventListener('click', handleInvoiceSave);
  if (btnInvoiceDelete) btnInvoiceDelete.addEventListener('click', (event) => { event.preventDefault(); handleInvoiceDelete(); });
  if (btnInvoiceGenerate) btnInvoiceGenerate.addEventListener('click', handleInvoiceGenerate);
  if (btnInvoiceAddLine) btnInvoiceAddLine.addEventListener('click', handleInvoiceAddLine);
  if (btnInvoiceLineSave) btnInvoiceLineSave.addEventListener('click', handleInvoiceLineSave);
  if (btnInvoiceLineCancel) btnInvoiceLineCancel.addEventListener('click', handleInvoiceLineCancel);
  if (invoiceLineItemsBody) invoiceLineItemsBody.addEventListener('click', handleInvoiceLineItemAction);
  if (invoiceLineAmountModeSelect) invoiceLineAmountModeSelect.addEventListener('change', handleInvoiceLineAmountModeChange);
  if (btnInvoiceDefaultNew) btnInvoiceDefaultNew.addEventListener('click', handleInvoiceDefaultNew);
  if (btnInvoiceDefaultCancel) btnInvoiceDefaultCancel.addEventListener('click', handleInvoiceDefaultCancel);
  if (btnInvoiceDefaultSave) btnInvoiceDefaultSave.addEventListener('click', handleInvoiceDefaultSave);
  if (invoiceDefaultList) invoiceDefaultList.addEventListener('click', handleInvoiceDefaultAction);
  if (invoiceDefaultAmountModeSelect) invoiceDefaultAmountModeSelect.addEventListener('change', handleInvoiceDefaultAmountModeChange);
  if (deductionTypeSelect) deductionTypeSelect.addEventListener('change', updateDeductionFormVisibility);
  if (deductionCategorySelect) deductionCategorySelect.addEventListener('change', () => {
    updateDeductionFormVisibility();
  });
  if (deductionAmountModeSelect) deductionAmountModeSelect.addEventListener('change', updateDeductionFormVisibility);
  if (deductionFrequencySelect) deductionFrequencySelect.addEventListener('change', updateDeductionFormVisibility);
  if (deductionCompanyToggle) deductionCompanyToggle.addEventListener('change', updateDeductionFormVisibility);
  if (deductionStartDateInput) deductionStartDateInput.addEventListener('change', updateDeductionOccurrencePreview);
  if (deductionEndDateInput) deductionEndDateInput.addEventListener('change', updateDeductionOccurrencePreview);
  if (basFySelect) {
    basFySelect.addEventListener('change', () => {
      state.basCurrentFy = Number(basFySelect.value);
      renderBasReporting();
    });
  }
  if (btnManageDeductionCategories) {
    btnManageDeductionCategories.addEventListener('click', (event) => {
      event.preventDefault();
      loadDeductionCategories();
      openDeductionCategoryModal();
    });
  }
  if (btnCloseDeductionCategories) {
    btnCloseDeductionCategories.addEventListener('click', (event) => {
      event.preventDefault();
      closeDeductionCategoryModal();
    });
  }
  if (btnAddDeductionCategory) {
    btnAddDeductionCategory.addEventListener('click', (event) => {
      event.preventDefault();
      showDeductionCategoryForm('create', null);
    });
  }
  if (btnCancelDeductionCategory) {
    btnCancelDeductionCategory.addEventListener('click', (event) => {
      event.preventDefault();
      hideDeductionCategoryForm();
    });
  }
  if (btnSaveDeductionCategory) {
    btnSaveDeductionCategory.addEventListener('click', handleSaveDeductionCategory);
  }
  if (btnExpandAllDeductionCategories) {
    btnExpandAllDeductionCategories.addEventListener('click', (event) => {
      event.preventDefault();
      setAllDeductionCategoryCollapse(false);
    });
  }
  if (btnCollapseAllDeductionCategories) {
    btnCollapseAllDeductionCategories.addEventListener('click', (event) => {
      event.preventDefault();
      setAllDeductionCategoryCollapse(true);
    });
  }
  if (btnCancelSplit) {
    btnCancelSplit.addEventListener('click', (event) => {
      event.preventDefault();
      hideModal(modalSplitDeduction);
      pendingDeductionPayload = null;
      originalDeductionForSplit = null;
    });
  }
  if (btnConfirmSplit) {
    btnConfirmSplit.addEventListener('click', (event) => {
      event.preventDefault();
      const splitDecisionRadios = document.getElementsByName('split-decision');
      let selectedDecision = 'split'; // default
      for (let i = 0; i < splitDecisionRadios.length; i++) {
        if (splitDecisionRadios[i].checked) {
          selectedDecision = splitDecisionRadios[i].value;
          break;
        }
      }

      hideModal(modalSplitDeduction);

      if (selectedDecision === 'split') {
        performSplitDeduction(originalDeductionForSplit, pendingDeductionPayload);
      } else {
        performOverrideDeduction(pendingDeductionPayload, originalDeductionForSplit);
      }

      // Clear state
      pendingDeductionPayload = null;
      originalDeductionForSplit = null;
    });
  }

  // Helpers

  const $ = (selector) => document.querySelector(selector);
  const $$ = (selector) => Array.from(document.querySelectorAll(selector));
  const toastContainer = document.getElementById('ts-toast-container');
  const TOAST_CLASS_MAP = {
    success: 'ts-toast--success',
    warn: 'ts-toast--warn',
    error: 'ts-toast--error',
    info: ''
  };
  const fmt = (minutes) => {
    const total = Number(minutes) || 0;
    const h = Math.floor(total / 60);
    const mm = total % 60;
    return (h > 0 ? h + ':' : '') + String(mm).padStart(2, '0');
  };
  function getStatusPreference() {
    const selectValue = statusNotificationSelect && typeof statusNotificationSelect.value === 'string'
      ? statusNotificationSelect.value.trim()
      : '';
    if (selectValue) return selectValue;
    const stateValue = (typeof state !== 'undefined' && state.settings && typeof state.settings.status_notification_mode === 'string')
      ? state.settings.status_notification_mode
      : '';
    if (stateValue) return stateValue;
    return 'status_bar';
  }

  function applyStatusDisplay() {
    const el = document.getElementById('status');
    if (!el) return;
    const mode = getStatusPreference();
    const showStatus = mode === 'status_bar' || mode === 'both';
    el.style.display = showStatus ? '' : 'none';
  }

  const setStatus = (text, cls) => {
    const mode = getStatusPreference();
    const showStatus = mode === 'status_bar' || mode === 'both';
    const showToast = mode === 'toast' || mode === 'both';
    const el = document.getElementById('status');
    if (el) {
      el.textContent = text;
      el.className = 'ts-badge ' + (cls || '');
      el.style.display = showStatus ? '' : 'none';
    }
    if (showToast && toastContainer && text) {
      const toast = document.createElement('div');
      toast.className = 'ts-toast';
      if (cls && TOAST_CLASS_MAP[cls]) {
        toast.classList.add(TOAST_CLASS_MAP[cls]);
      }
      toast.textContent = text;
      toastContainer.appendChild(toast);
      requestAnimationFrame(() => toast.classList.add('ts-toast--visible'));
      setTimeout(() => {
        toast.classList.remove('ts-toast--visible');
        setTimeout(() => toast.remove(), 200);
      }, 3200);
    }
  };
  const isoDate = (date) => {
    const d = new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };
  const normalizeHolidayDate = (value) => {
    if (!value && value !== 0) return '';
    if (value instanceof Date) return isoDate(value);
    if (typeof value === 'number') {
      return isoDate(new Date(value));
    }
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (trimmed === '') return '';
      if (!trimmed.includes('T')) return trimmed;
      const parsed = new Date(trimmed);
      if (!Number.isNaN(parsed.getTime())) {
        return isoDate(parsed);
      }
      return trimmed.split('T')[0];
    }
    return '';
  };
  const isoDateTime = (date) => new Date(date).toISOString().replace(/\.\d{3}Z$/, 'Z');
  const parseIsoDate = (value) => {
    const [y, m, d] = value.split('-').map(Number);
    return new Date(y, m - 1, d);
  };
  const todayIso = () => isoDate(new Date());
  const MONTH_ABBREVIATIONS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const formatMonthShortYear = (dateObj) => {
    if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) return '';
    const month = MONTH_ABBREVIATIONS[dateObj.getMonth()] || '';
    const year = dateObj.getFullYear();
    return `${month} ${String(year).slice(-2)}`;
  };
  const formatHours = (minutes) => {
    const hrs = (Number(minutes) || 0) / 60;
    let out = (Math.round(hrs * 100) / 100).toFixed(2);
    out = out.replace(/\.00$/, '');
    out = out.replace(/(\.\d)0$/, '$1');
    return out === '' ? '0' : out;
  };
  const startOfDay = (date) => new Date(date.getFullYear(), date.getMonth(), date.getDate());
  const isWeekendDate = (date) => {
    const day = date.getDay();
    return day === 0 || day === 6;
  };
  function collectBusinessDays(startDate, endDate, includeWeekends) {
    if (!(startDate instanceof Date) || Number.isNaN(startDate.getTime())) return [];
    if (!(endDate instanceof Date) || Number.isNaN(endDate.getTime())) return [];
    const start = startOfDay(startDate);
    const end = startOfDay(endDate);
    if (end < start) return [];
    const days = [];
    const cursor = new Date(start);
    while (cursor <= end) {
      if (includeWeekends || !isWeekendDate(cursor)) {
        days.push(isoDate(cursor));
      }
      cursor.setDate(cursor.getDate() + 1);
    }
    return days;
  }
  const minutesToTime = (minutes) => {
    const mins = Math.max(0, Math.round(Number(minutes) || 0));
    if (mins >= 24 * 60) return '23:59';
    const h = Math.floor(mins / 60);
    const m = mins % 60;
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
  };
  const DEFAULT_SUPER_RATE = 0.12;
  const GST_RATE = 0.1;
  const currencyFormatter = new Intl.NumberFormat(undefined, {
    style: 'currency',
    currency: 'AUD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
  const formatCurrency = (value) => {
    if (value === null || value === undefined || value === '') return '--';
    const num = Number(value);
    if (!Number.isFinite(num)) return '--';
    return currencyFormatter.format(num);
  };
  const formatSignedCurrency = (value) => {
    const num = Math.round((Number(value) || 0) * 100) / 100;
    if (num === 0) return formatCurrency(0);
    const abs = Math.abs(num);
    const formattedAbs = currencyFormatter.format(abs);
    return num > 0 ? `+${formattedAbs}` : `-${formattedAbs}`;
  };
  const formatPercentValue = (value, decimals = 2) => {
    if (!Number.isFinite(value)) return '--';
    const factor = Math.pow(10, decimals);
    const rounded = Math.round(Number(value) * factor) / factor;
    if (rounded === 0) return '0%';
    const abs = Math.abs(rounded).toFixed(decimals).replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
    return `${rounded > 0 ? '+' : '-'}${abs}%`;
  };

  // Restripe table rows based on visible rows only
  // This is needed because CSS nth-child counts hidden rows
  const restripeTable = (tableBodyId) => {
    const tbody = document.getElementById(tableBodyId);
    if (!tbody) return;

    const rows = Array.from(tbody.querySelectorAll('tr'));
    let visibleIndex = 0;

    rows.forEach((row) => {
      // Check if row is visible (not display:none)
      const isVisible = row.style.display !== 'none' && window.getComputedStyle(row).display !== 'none';

      if (isVisible) {
        // Apply stripe class to even visible rows (0-indexed, so 1, 3, 5... get striped)
        if (visibleIndex % 2 === 1) {
          row.classList.add('ts-stripe');
        } else {
          row.classList.remove('ts-stripe');
        }
        visibleIndex++;
      } else {
        // Hidden rows shouldn't have stripe class
        row.classList.remove('ts-stripe');
      }
    });
  };

  function resolveInvoiceDate(invoice) {
    if (!invoice) return null;
    if (invoice.invoice_date) {
      const parsed = new Date(invoice.invoice_date);
      if (!Number.isNaN(parsed.getTime())) {
        return parsed;
      }
    }
    if (invoice.year != null && invoice.month != null) {
      const parsedFallback = new Date(Number(invoice.year), Number(invoice.month) - 1, 1);
      if (!Number.isNaN(parsedFallback.getTime())) {
        return parsedFallback;
      }
    }
    return null;
  }

  const formatDate = (value) => {
    if (!value) return '';
    const date = value instanceof Date ? value : new Date(value);
    if (Number.isNaN(date.getTime())) return '';
    return DATE_FULL_FORMATTER.format(date);
  };
  const addDays = (date, amount) => {
    const next = new Date(date.getTime());
    next.setDate(next.getDate() + amount);
    return next;
  };
  const addMonthsClamped = (date, amount) => {
    const year = date.getFullYear();
    const month = date.getMonth();
    const day = date.getDate();
    const target = new Date(year, month + amount + 1, 0);
    const maxDay = target.getDate();
    target.setDate(Math.min(day, maxDay));
    return startOfDay(target);
  };
  const getSuperRateSetting = () => {
    const raw = state.settings ? state.settings.superannuation_rate : undefined;
    const num = Number(raw);
    if (Number.isFinite(num) && num >= 0) {
      return num > 1 ? num / 100 : num;
    }
    return DEFAULT_SUPER_RATE;
  };
  const getSuperRatePercentage = () => Math.round(getSuperRateSetting() * 1000) / 10;

  // Super Guarantee Rates Cache Functions
  const cacheSuperGuaranteeRates = (rates) => {
    try {
      localStorage.setItem('super_guarantee_rates', JSON.stringify(rates));
    } catch (e) {
      console.warn('Failed to cache super guarantee rates:', e);
    }
  };

  const getCachedSuperGuaranteeRates = () => {
    try {
      const cached = localStorage.getItem('super_guarantee_rates');
      return cached ? JSON.parse(cached) : null;
    } catch (e) {
      return null;
    }
  };

  // Get super guarantee rate for a specific date
  const getSuperGuaranteeRateForDate = (targetDate) => {
    const cached = getCachedSuperGuaranteeRates();
    const rates = cached || [];

    if (rates.length === 0) {
      // Fallback to old setting or default
      return getSuperRateSetting();
    }

    // Parse target date as yyyy-MM-dd
    const targetStr = String(targetDate).substring(0, 10);

    const matchingRates = [];
    for (const rate of rates) {
      const startDate = String(rate.start_date).substring(0, 10);
      const endDate = rate.end_date ? String(rate.end_date).substring(0, 10) : null;

      // Check if target date falls within this rate's range
      if (targetStr >= startDate) {
        if (endDate === null || targetStr <= endDate) {
          matchingRates.push(rate);
        }
      }
    }

    if (matchingRates.length === 0) {
      // No matching rate found, return default
      return DEFAULT_SUPER_RATE;
    }

    // If multiple matches, use the one with the most recent start date
    if (matchingRates.length > 1) {
      matchingRates.sort((a, b) => String(b.start_date).localeCompare(String(a.start_date)));
    }

    const percentage = matchingRates[0].percentage;
    // Convert percentage to decimal (e.g., 12 -> 0.12)
    return percentage > 1 ? percentage / 100 : percentage;
  };
  const sanitizeSuperRateInputValue = (value) => {
    const num = Number(value);
    if (Number.isFinite(num) && num >= 0) return Math.round(num * 10) / 10;
    return Math.round(DEFAULT_SUPER_RATE * 1000) / 10;
  };
  const deriveGrossFromPackage = (packageAmount, superRate) => {
    const total = Math.max(0, Number(packageAmount) || 0);
    const rate = Math.max(0, Number(superRate) || 0);
    if (!Number.isFinite(rate) || rate === 0) return total;
    const denominator = 1 + rate;
    if (denominator <= 0) return total;
    return total / denominator;
  };

  const getRoundInterval = () => {
    const value = Number(state.settings.round_to_nearest);
    return Number.isFinite(value) && value > 1 ? value : 0;
  };
  const roundDuration = (minutes) => {
    const base = Math.max(0, Math.round(Number(minutes) || 0));
    const interval = getRoundInterval();
    if (!interval) return Math.max(1, base);
    const rounded = Math.round(base / interval) * interval;
    return Math.max(interval, rounded);
  };

  const TIME_PATTERN = /^\d{2}:\d{2}$/;
  const normalizeTimeValue = (value) => {
    if (!value && value !== 0) return '';
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (TIME_PATTERN.test(trimmed)) return trimmed;
      const parsed = new Date(`1970-01-01T${trimmed}:00`);
      if (!Number.isNaN(parsed.getTime())) return parsed.toTimeString().slice(0, 5);
    } else if (value instanceof Date) {
      return value.toTimeString().slice(0, 5);
    }
    const coerced = new Date(value);
    if (!Number.isNaN(coerced.getTime())) return coerced.toTimeString().slice(0, 5);
    return '';
  };
  const timeToMinutes = (time) => {
    if (!time || !TIME_PATTERN.test(time)) return null;
    const parts = time.split(':');
    return Number(parts[0]) * 60 + Number(parts[1]);
  };
  const clonePunches = (punches) => (Array.isArray(punches) ? punches.map((p) => ({ in: p.in || '', out: p.out || '' })) : []);
  const normalizePunchList = (value) => {
    if (!value) return [];
    let source = value;
    if (typeof source === 'string') {
      try {
        source = JSON.parse(source);
      } catch (e) {
        source = [];
      }
    }
    if (!Array.isArray(source)) source = source ? [source] : [];
    const punches = source.reduce((acc, raw) => {
      if (!raw) return acc;
      const start = normalizeTimeValue(raw.in || raw.start || raw.start_time || raw.startTime);
      if (!start) return acc;
      let end = normalizeTimeValue(raw.out || raw.stop || raw.end || raw.end_time || raw.endTime);
      if (end && timeToMinutes(end) !== null && timeToMinutes(start) !== null && timeToMinutes(end) < timeToMinutes(start)) {
        end = '';
      }
      acc.push({ in: start, out: end || '' });
      return acc;
    }, []);
    punches.sort((a, b) => {
      if (a.in === b.in) return (a.out || '').localeCompare(b.out || '');
      return a.in.localeCompare(b.in);
    });
    return punches;
  };
  const summarizePunches = (punches) => {
    if (!Array.isArray(punches) || !punches.length) {
      return { totalMinutes: 0, earliest: '', latest: '', openCount: 0 };
    }
    let earliest = '';
    let latest = '';
    let total = 0;
    let openCount = 0;
    punches.forEach((punch) => {
      if (!punch || !punch.in) return;
      if (!earliest || punch.in < earliest) earliest = punch.in;
      if (punch.out) {
        if (!latest || punch.out > latest) latest = punch.out;
        const startMinutes = timeToMinutes(punch.in);
        const endMinutes = timeToMinutes(punch.out);
        if (startMinutes !== null && endMinutes !== null && endMinutes > startMinutes) {
          total += endMinutes - startMinutes;
        }
      } else {
        openCount += 1;
      }
    });
    return { totalMinutes: total, earliest, latest, openCount };
  };
  const validatePunches = (punches, options = {}) => {
    const { allowOpen = true, requireClosed = false } = options;
    const sorted = normalizePunchList(punches);
    let lastEnd = null;
    let openCount = 0;
    for (let idx = 0; idx < sorted.length; idx += 1) {
      const punch = sorted[idx];
      const startMinutes = timeToMinutes(punch.in);
      if (startMinutes === null) {
        return 'Each punch needs a valid start time.';
      }
      if (!punch.out) {
        openCount += 1;
        if (requireClosed) {
          return 'Please enter an end time for each punch.';
        }
        if (!allowOpen && openCount > 0) {
          return 'Close any open punches before saving.';
        }
        if (lastEnd !== null && startMinutes < lastEnd) {
          return 'Punch ranges cannot overlap.';
        }
        lastEnd = startMinutes;
        continue;
      }
      const endMinutes = timeToMinutes(punch.out);
      if (endMinutes === null || endMinutes <= startMinutes) {
        return 'Punch out must be later than punch in.';
      }
      if (lastEnd !== null && startMinutes < lastEnd) {
        return 'Punch ranges cannot overlap.';
      }
      lastEnd = endMinutes;
    }
    return null;
  };

  const entryPunches = (entry) => {
    if (entry && Array.isArray(entry.punches) && entry.punches.length) {
      return entry.punches.map((punch) => ({ in: punch.in || '', out: punch.out || '' }));
    }
    if (entry && entry.start_time && entry.end_time) {
      return [{ in: entry.start_time, out: entry.end_time }];
    }
    return [];
  };
  function resolveEntryType(entry) {
    if (!entry) return null;
    if (entry.entry_type) return entry.entry_type;
    const punches = entryPunches(entry);
    if (!punches.length) return 'basic';
    if (punches.length === 1 && punches[0].in === '00:00') {
      return 'basic';
    }
    return 'advanced';
  }
  const entryFirstPunchMinutes = (entry) => {
    const punches = entryPunches(entry);
    if (punches.length) {
      const mins = timeToMinutes(punches[0].in);
      if (mins !== null) return mins;
    }
    const fallback = timeToMinutes(entry && entry.start_time ? entry.start_time : '');
    return fallback !== null ? fallback : 24 * 60;
  };
  const getEntryPunchSummary = (entry) => {
    const punches = entryPunches(entry);
    if (!punches.length) {
      const start = entry && entry.start_time ? entry.start_time : '--:--';
      const end = entry && entry.end_time ? entry.end_time : '--:--';
      return `${start} - ${end}`;
    }
    const summary = summarizePunches(punches);
    const start = summary.earliest || '--:--';
    const end = summary.openCount > 0 ? 'Open' : (summary.latest || '--:--');
    return `${start} - ${end}`;
  };
  const getEntryPunchDetail = (entry) => {
    const punches = entryPunches(entry);
    if (!punches.length) return '';
    return punches.map((punch) => `${punch.in || '--:--'} - ${punch.out || 'Open'}`).join(', ');
  };

  const sanitizeEntry = (entry) => {
    if (!entry) return entry;
    const clone = { ...entry };
    const punches = normalizePunchList(clone.punches != null ? clone.punches : clone.punches_json);
    clone.punches = clonePunches(punches);
    clone.punches_json = JSON.stringify(clone.punches);
    const summary = summarizePunches(clone.punches);
    if (clone.punches.length) {
      let worked = summary.totalMinutes;
      if (clone.duration_minutes != null && Number.isFinite(Number(clone.duration_minutes))) {
        clone.duration_minutes = Math.max(0, Math.round(Number(clone.duration_minutes)));
      } else {
        clone.duration_minutes = Math.max(0, Math.round(worked));
      }
    } else {
      clone.duration_minutes = Math.max(0, Math.round(Number(clone.duration_minutes) || 0));
    }
    clone.open_punch_count = summary.openCount || 0;
    delete clone.break;
    delete clone.description;
    const contractId = clone.contract_id || clone.contractId || clone.project || '';
    clone.contract_id = contractId ? String(contractId).trim() : '';
    delete clone.project;
    delete clone.contractId;
    // Preserve entry_type if it exists
    if (clone.entry_type) {
      clone.entry_type = String(clone.entry_type).trim();
    }
    return clone;
  };

  const sanitizeContract = (contract) => {
    if (!contract) return contract;
    const clone = { ...contract };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.start_date = clone.start_date || clone.startDate || '';
    clone.end_date = clone.end_date || clone.endDate || '';
    clone.hourly_rate = Number(clone.hourly_rate != null ? clone.hourly_rate : 0);
    if (Number.isNaN(clone.hourly_rate)) clone.hourly_rate = 0;
    clone.total_hours = Number(clone.total_hours != null ? clone.total_hours : (clone.totalHours != null ? clone.totalHours : 0));
    if (Number.isNaN(clone.total_hours) || clone.total_hours < 0) clone.total_hours = 0;
    clone.include_weekends = Boolean(
      clone.include_weekends === true ||
      clone.include_weekends === 'TRUE' ||
      String(clone.include_weekends != null ? clone.include_weekends : '').toLowerCase() === 'true'
    );
    delete clone.startDate;
    delete clone.endDate;
    delete clone.hourlyRate;
    delete clone.totalHours;
    return clone;
  };

  const sanitizeHourType = (hourType) => {
    if (!hourType) return hourType;
    const clone = { ...hourType };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.slug = clone.slug ? String(clone.slug).trim() : '';
    clone.color = clone.color ? String(clone.color).trim() : '#6b7280';
    clone.contributes_to_income = Boolean(clone.contributes_to_income === 'TRUE' || clone.contributes_to_income === true);
    clone.requires_contract = Boolean(clone.requires_contract === 'TRUE' || clone.requires_contract === true);
    clone.is_default = Boolean(clone.is_default === 'TRUE' || clone.is_default === true);
    clone.use_for_rate_calculation = Boolean(clone.use_for_rate_calculation === 'TRUE' || clone.use_for_rate_calculation === true);
    clone.auto_populate_public_holidays = Boolean(
      clone.auto_populate_public_holidays === 'TRUE' || clone.auto_populate_public_holidays === true
    );
    const autoHours = Number(clone.auto_populate_hours != null ? clone.auto_populate_hours : 0);
    clone.auto_populate_hours = Number.isFinite(autoHours) && autoHours > 0 ? autoHours : 0;
    clone.created_at = clone.created_at || '';
    return clone;
  };

  const sanitizeDeductionCategory = (category) => {
    if (!category) return category;
    const clone = { ...category };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    const color = clone.color ? String(clone.color).trim() : '#6b7280';
    clone.color = /^#([0-9a-fA-F]{6})$/.test(color) ? color.toLowerCase() : '#6b7280';
    clone.created_at = clone.created_at || '';
    clone.updated_at = clone.updated_at || '';
    return clone;
  };

  const sanitizeDeduction = (deduction) => {
    if (!deduction) return deduction;
    const clone = { ...deduction };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.category_id = clone.category_id ? String(clone.category_id).trim() : '';
    if (clone.category_id === 'company' || clone.category_id === 'personal') {
      clone.category_id = '';
    }
    clone.company_expense = Boolean(clone.company_expense === true || clone.company_expense === 'TRUE');
    clone.deduction_type = clone.deduction_type === 'extra_super' ? 'extra_super' : 'standard';
    clone.amount_type = clone.amount_type === 'percent' ? 'percent' : 'flat';
    let amountValue = Number(clone.amount_value);
    if (!Number.isFinite(amountValue) || amountValue < 0) amountValue = 0;
    if (clone.amount_type === 'percent' && amountValue > 1) {
      amountValue = amountValue / 100;
    }
    clone.amount_value = amountValue;
    clone.gst_inclusive = Boolean(clone.gst_inclusive === true || clone.gst_inclusive === 'TRUE');
    clone.gst_amount = Number(clone.gst_amount) || 0;
    clone.frequency = DEDUCTION_FREQUENCIES.includes(clone.frequency) ? clone.frequency : 'once';
    clone.start_date = clone.start_date ? String(clone.start_date) : '';
    clone.end_date = clone.end_date ? String(clone.end_date) : '';
    clone.notes = clone.notes ? String(clone.notes) : '';
    clone.active = clone.active !== false;
    clone.created_at = clone.created_at || '';
    clone.updated_at = clone.updated_at || '';
    return clone;
  };

  const sanitizeDeductionException = (exception) => {
    if (!exception) return exception;
    const clone = { ...exception };
    clone.id = clone.id ? String(clone.id) : '';
    clone.deduction_id = clone.deduction_id ? String(clone.deduction_id) : '';
    clone.original_date = clone.original_date ? String(clone.original_date) : '';
    clone.exception_type = ['skip', 'move', 'adjust_amount'].includes(clone.exception_type)
      ? clone.exception_type
      : 'skip';
    clone.new_date = clone.new_date ? String(clone.new_date) : '';
    clone.new_amount = Number(clone.new_amount) || 0;
    clone.notes = clone.notes ? String(clone.notes).trim() : '';
    clone.created_at = clone.created_at || '';
    clone.updated_at = clone.updated_at || '';
    return clone;
  };

  function nextOccurrenceDate(current, frequency) {
    if (!current) return null;
    switch (frequency) {
      case 'weekly':
        return addDays(current, 7);
      case 'fortnightly':
        return addDays(current, 14);
      case 'monthly':
        return addMonthsClamped(current, 1);
      case 'quarterly':
        return addMonthsClamped(current, 3);
      case 'yearly':
        return addMonthsClamped(current, 12);
      default:
        return null;
    }
  }

  function advanceOccurrenceTo(startDate, frequency, targetDate, endDate) {
    if (!startDate) return null;
    if (frequency === 'once') {
      return startDate;
    }
    var current = startDate;
    var safety = 0;
    while (current < targetDate && safety < 1000) {
      var next = nextOccurrenceDate(current, frequency);
      if (!next) return current;
      if (endDate && next > endDate) return next;
      if (next.getTime() === current.getTime()) return next;
      current = next;
      safety++;
    }
    return current;
  }

  function getDeductionOccurrencesBetween(deduction, rangeStart, rangeEnd, limit) {
    const occurrences = [];
    if (!deduction || !deduction.start_date) return occurrences;
    const startSource = parseIsoDate(deduction.start_date);
    if (!startSource || Number.isNaN(startSource.getTime())) return occurrences;
    let current = startOfDay(startSource);
    const endBoundary = deduction.end_date ? parseIsoDate(deduction.end_date) : null;
    const endDate = endBoundary ? startOfDay(endBoundary) : null;
    const frequency = deduction.frequency || 'once';
    const hasRangeStart = !!rangeStart;
    const hasRangeEnd = !!rangeEnd;
    const rangeStartDate = hasRangeStart ? startOfDay(rangeStart) : null;
    const rangeEndDate = hasRangeEnd ? startOfDay(rangeEnd) : null;

    if (rangeStartDate && current < rangeStartDate && frequency !== 'once') {
      current = advanceOccurrenceTo(current, frequency, rangeStartDate, endDate);
    }

    const maxIterations = 1000;
    let iterations = 0;
    while (current && iterations < maxIterations) {
      if (rangeStartDate && current < rangeStartDate) {
        // Occurrence is before range start; skip but continue advancing unless once
      } else if (!rangeEndDate || current <= rangeEndDate) {
        occurrences.push(startOfDay(current));
      } else {
        break;
      }

      if (limit && occurrences.length >= limit) break;
      if (frequency === 'once') break;

      const next = nextOccurrenceDate(current, frequency);
      if (!next) break;
      if (endDate && next > endDate) break;
      if (next.getTime() === current.getTime()) break;
      current = next;
      iterations++;
    }

    return occurrences;
  }

  function getDeductionPreviewDates(deduction, limit) {
    const occurrences = getDeductionOccurrencesBetween(
      deduction,
      parseIsoDate(deduction.start_date),
      deduction.end_date ? parseIsoDate(deduction.end_date) : null,
      limit || 5
    );
    return occurrences.map((occ) => isoDate(occ));
  }

  function getUpcomingDeductionDates(deduction, limit) {
    const today = startOfDay(new Date());
    const occurrences = getDeductionOccurrencesBetween(
      deduction,
      today,
      deduction.end_date ? parseIsoDate(deduction.end_date) : null,
      limit || 5
    );
    return occurrences.map((occ) => isoDate(occ));
  }

  function formatFrequencyLabel(frequency) {
    switch (frequency) {
      case 'weekly':
        return 'Weekly';
      case 'fortnightly':
        return 'Fortnightly';
      case 'monthly':
        return 'Monthly';
      case 'quarterly':
        return 'Quarterly';
      case 'yearly':
        return 'Yearly';
      case 'once':
      default:
        return 'One-off';
    }
  }

  /**
   * Get exceptions for a specific deduction
   */
  function getDeductionExceptions(deductionId) {
    if (!deductionId) return [];
    return state.deductionExceptions.filter(ex => ex.deduction_id === deductionId);
  }

  /**
   * Apply exceptions to occurrence dates
   * Returns array of occurrence objects with exception info
   */
  function applyExceptionsToOccurrences(occurrenceDates, deductionId, rangeStart, rangeEnd) {
    const startIso = rangeStart ? isoDate(rangeStart) : null;
    const endIso = rangeEnd ? isoDate(rangeEnd) : null;
    const exceptions = getDeductionExceptions(deductionId);

    const result = [];
    const seenKeys = new Set();

    const addOccurrence = (occ) => {
      if (!occ || !occ.date) return;
      if (startIso && occ.date < startIso) return;
      if (endIso && occ.date > endIso) return;
      const key = occ.date + '|' + (occ.originalDate || '');
      if (seenKeys.has(key)) return;
      seenKeys.add(key);
      result.push(occ);
    };

    if (Array.isArray(occurrenceDates) && occurrenceDates.length) {
      const exceptionMap = {};
      exceptions.forEach((ex) => {
        if (ex && ex.original_date) {
          exceptionMap[ex.original_date] = ex;
        }
      });

      occurrenceDates.forEach((dateObj) => {
        const dateStr = isoDate(dateObj);
        const exception = exceptionMap[dateStr];

        if (exception) {
          if (exception.exception_type === 'skip') {
            return;
          }
          if (exception.exception_type === 'move' && exception.new_date) {
            addOccurrence({
              date: exception.new_date,
              originalDate: dateStr,
              amount: null,
              hasException: true,
              exceptionType: 'move'
            });
            return;
          }
          if (exception.exception_type === 'adjust_amount') {
            addOccurrence({
              date: dateStr,
              amount: Number(exception.new_amount) || 0,
              hasException: true,
              exceptionType: 'adjust_amount'
            });
            return;
          }
        }

        addOccurrence({
          date: dateStr,
          amount: null,
          hasException: false,
          exceptionType: null
        });
      });
    }

    // Include moved occurrences whose original dates were outside the requested range
    if (Array.isArray(exceptions) && exceptions.length) {
      exceptions.forEach((ex) => {
        if (!ex || ex.exception_type !== 'move' || !ex.new_date) return;
        addOccurrence({
          date: ex.new_date,
          originalDate: ex.original_date || null,
          amount: null,
          hasException: true,
          exceptionType: 'move'
        });
      });
    }

    result.sort((a, b) => a.date.localeCompare(b.date));
    return result;
  }

  /**
   * Get deduction occurrences with exceptions applied
   * Returns array of occurrence objects
   */
  function getDeductionOccurrencesWithExceptions(deduction, rangeStart, rangeEnd, limit) {
    if (!deduction) return [];

    // Get base occurrences
    const baseOccurrences = getDeductionOccurrencesBetween(deduction, rangeStart, rangeEnd, limit);

    // Apply exceptions
    return applyExceptionsToOccurrences(baseOccurrences, deduction.id, rangeStart, rangeEnd);
  }

  function formatDeductionAmount(deduction) {
    if (deduction.amount_type === 'percent') {
      const pct = Math.round((deduction.amount_value * 100) * 100) / 100;
      return `${pct}% of gross income`;
    }
    const value = (deduction.company_expense && deduction.gst_inclusive)
      ? deduction.amount_value / (1 + GST_RATE)
      : deduction.amount_value;
    const rounded = Math.round((Number(value) || 0) * 100) / 100;
    return formatCurrency(rounded);
  }

  function computeMonthlyDeductionTotals(year, month) {
    const result = {
      standardTotal: 0,
      personalStandardTotal: 0,
      companyStandardTotal: 0,
      companyGstTotal: 0,
      extraSuperFlat: 0,
      extraSuperPercentRate: 0
    };
    if (!Array.isArray(state.deductions) || !state.deductions.length) return result;
    const monthStart = startOfDay(new Date(year, month, 1));
    const monthEnd = startOfDay(new Date(year, month + 1, 0));
    state.deductions.forEach((deduction) => {
      if (!deduction || deduction.active === false) return;
      const occurrences = getDeductionOccurrencesWithExceptions(deduction, monthStart, monthEnd);
      if (!occurrences.length) return;
      if (deduction.deduction_type === 'extra_super') {
        if (deduction.amount_type === 'percent') {
          result.extraSuperPercentRate += deduction.amount_value * occurrences.length;
        } else {
          // Sum up all occurrences, using adjusted amount if present
          occurrences.forEach(occ => {
            const amount = occ.amount !== null ? occ.amount : deduction.amount_value;
            result.extraSuperFlat += amount;
          });
        }
        return;
      }
      if (deduction.amount_type === 'percent') {
        return;
      }

      // Process each occurrence individually to handle amount adjustments
      occurrences.forEach(occ => {
        const baseAmount = occ.amount !== null ? occ.amount : deduction.amount_value;
        let netAmount = baseAmount;
        if (deduction.gst_inclusive) {
          netAmount = baseAmount / (1 + GST_RATE);
        }

        result.standardTotal += netAmount;
        if (deduction.company_expense) {
          result.companyStandardTotal += netAmount;
          if (deduction.gst_inclusive) {
            const gstComponent = baseAmount - (baseAmount / (1 + GST_RATE));
            result.companyGstTotal += gstComponent;
          }
        } else {
          result.personalStandardTotal += netAmount;
        }
      });
    });
    return result;
  }

  function collectFinancialYears() {
    const allYears = collectAllYears();
    const years = Array.isArray(allYears.financial) ? [...allYears.financial] : [];
    if (!years.length) {
      years.push(financialYearStartYear(new Date()));
    }
    return years;
  }

  function formatBasRow(label, values, fyYear, quarter, month) {
    const submittedIndicator = values.submitted ? '<span style="color:var(--success); font-weight:600;">\u2713</span>' : '';
    const rowClass = values.hasActivity ? 'bas-row-clickable' : '';
    const dataAttrs = [];
    if (fyYear) dataAttrs.push(`data-fy="${fyYear}"`);
    if (quarter) dataAttrs.push(`data-quarter="${quarter}"`);
    if (month) dataAttrs.push(`data-month="${month}"`);
    const dataAttrsStr = dataAttrs.length ? dataAttrs.join(' ') : '';

    return `
      <tr class="${rowClass}" ${dataAttrsStr} style="${rowClass ? 'cursor:pointer;' : ''}">
        <td>${label}</td>
        <td style="text-align:center;">${submittedIndicator}</td>
        <td>${formatCurrency(values.invoiceTotal)}</td>
        <td>${formatCurrency(values.invoiceGst)}</td>
        <td>${formatCurrency(values.companyIncome)}</td>
        <td>${formatCurrency(values.companyExpenses)}</td>
        <td>${formatCurrency(values.companyExpensesGst)}</td>
        <td>${formatCurrency(values.employeeGrossIncome)}</td>
        <td>${formatCurrency(values.employeeSuper)}</td>
        <td>${formatCurrency(values.employeeDeductions)}</td>
        <td>${formatCurrency(values.employeeTax)}</td>
        <td>${formatCurrency(values.employeeNetIncome)}</td>
      </tr>
    `;
  }

  function buildMonthlyBasRows(fyStartYear) {
    const months = getFinancialYearMonths(fyStartYear);
    return months.map(({ year, month }) => {
      const summary = buildIncomeSummary(year, month);
      const companyIncome = summary.companyIncome || 0;
      const invoiceTotal = summary.invoiceTotal || 0;
      const companyExpenses = summary.companyExpenses || 0;
      const companyExpensesGst = summary.companyExpensesGst || 0;
      const employeeGross = summary.grossIncome || 0;
      const employeeSuper = (summary.superGuarantee || 0) + (summary.extraSuper || 0);
      const employeeDeductions = summary.otherDeductions || 0;
      const tax = summary.tax != null ? summary.tax : 0;
      const netIncome = summary.netIncome != null ? summary.netIncome : Math.max(0, (summary.taxableIncome || 0) - tax);
      const invoiceGst = invoiceTotal - companyIncome;
      return {
        label: MONTH_YEAR_FORMATTER.format(new Date(year, month, 1)),
        year,
        month,
        invoiceTotal,
        invoiceGst,
        companyIncome,
        companyExpenses,
        companyExpensesGst,
        employeeGrossIncome: employeeGross,
        employeeSuper,
        employeeDeductions,
        employeeTax: tax,
        employeeNetIncome: netIncome,
        hasActivity: invoiceTotal > 0.01 || companyExpenses > 0.01 || employeeGross > 0.01 || employeeDeductions > 0.01 || employeeSuper > 0.01
      };
    });
  }

  function buildQuarterlyBasRows(monthRows) {
    const labels = ['Q1 (JulâSep)', 'Q2 (OctâDec)', 'Q3 (JanâMar)', 'Q4 (AprâJun)'];
    const quarters = [];
    for (let i = 0; i < 4; i += 1) {
      const slice = monthRows.slice(i * 3, i * 3 + 3);
      const totals = slice.reduce((acc, row) => {
        acc.invoiceTotal += row.invoiceTotal;
        acc.invoiceGst += row.invoiceGst;
        acc.companyIncome += row.companyIncome;
        acc.companyExpenses += row.companyExpenses;
        acc.companyExpensesGst += row.companyExpensesGst;
        acc.employeeGrossIncome += row.employeeGrossIncome;
        acc.employeeSuper += row.employeeSuper;
        acc.employeeDeductions += row.employeeDeductions;
        acc.employeeTax += row.employeeTax;
        acc.employeeNetIncome += row.employeeNetIncome;
        acc.hasActivity = acc.hasActivity || row.hasActivity;
        return acc;
      }, {
        invoiceTotal: 0,
        invoiceGst: 0,
        companyIncome: 0,
        companyExpenses: 0,
        companyExpensesGst: 0,
        employeeGrossIncome: 0,
        employeeSuper: 0,
        employeeDeductions: 0,
        employeeTax: 0,
        employeeNetIncome: 0,
        hasActivity: false
      });
      totals.label = labels[i] || `Q${i + 1}`;
      totals.quarter = i + 1; // Add quarter number for identification
      quarters.push(totals);
    }
    return quarters;
  }

  function renderBasReporting() {
    if (!pageBas) return;
    if (!state.companyTrackingEnabled) {
      if (basTableBody) basTableBody.innerHTML = '';
      if (basEmptyNote) basEmptyNote.style.display = 'none';
      if (basQuarterlyNote) basQuarterlyNote.style.display = 'none';
      if (basInvoiceSection) basInvoiceSection.style.display = 'none';
      return;
    }

    if (getFeatureFlag('enable_invoices') && !state.invoiceListLoading && !state.invoices.length) {
      loadInvoicesList();
    }

    const years = collectFinancialYears();
    if (!years.length) years.push(financialYearStartYear(new Date()));
    years.sort((a, b) => a - b);
    const latestYear = years[years.length - 1];
    if (!state.basCurrentFy || !years.includes(state.basCurrentFy)) {
      state.basCurrentFy = latestYear;
    }

    if (basFySelect) {
      basFySelect.innerHTML = years.map((year) => `<option value="${year}">${financialYearLabel(year)}</option>`).join('');
      basFySelect.value = String(state.basCurrentFy);
    }

    const monthRows = buildMonthlyBasRows(state.basCurrentFy);
    const dataset = state.companyBasQuarterly ? buildQuarterlyBasRows(monthRows) : monthRows;
    const hasActivity = dataset.some((row) => row.hasActivity);

    // Merge BAS submission data into dataset
    dataset.forEach((row) => {
      const submission = state.basSubmissions.find(s => {
        if (s.financial_year !== state.basCurrentFy) return false;
        if (state.companyBasQuarterly) {
          return s.period_type === 'quarterly' && s.quarter === row.quarter;
        } else {
          return s.period_type === 'monthly' && s.month === row.month;
        }
      });
      if (submission) {
        row.submitted = submission.submitted;
      }
    });

    if (basQuarterlyNote) basQuarterlyNote.style.display = state.companyBasQuarterly ? 'block' : 'none';
    if (basEmptyNote) basEmptyNote.style.display = hasActivity ? 'none' : 'block';

    if (basTableBody) {
      const bodyHtml = dataset
        .filter((row) => row.hasActivity || hasActivity) // keep blank rows when overall activity exists
        .map((row) => {
          const fyYear = state.basCurrentFy;
          const quarter = state.companyBasQuarterly ? row.quarter : null;
          const month = !state.companyBasQuarterly ? row.month : null;
          return formatBasRow(row.label, row, fyYear, quarter, month);
        })
        .join('');
      basTableBody.innerHTML = bodyHtml || '<tr><td colspan="12" style="text-align:center; padding:16px;">No company activity recorded.</td></tr>';

      // Add click handlers to clickable rows
      attachBasRowClickHandlers();
    }

    renderBasInvoiceTable();
  }

  function renderBasInvoiceTable() {
    if (!basInvoiceSection || !basInvoiceTableBody || !basInvoiceEmpty) return;
    if (!state.companyTrackingEnabled) {
      basInvoiceSection.style.display = 'none';
      return;
    }
    if (!getFeatureFlag('enable_invoices')) {
      basInvoiceSection.style.display = 'none';
      return;
    }
    basInvoiceSection.style.display = 'block';
    if (state.invoiceListLoading && !state.invoices.length) {
      basInvoiceEmpty.style.display = 'block';
      if (basInvoiceEmptyText) basInvoiceEmptyText.textContent = 'Loading invoices...';
      basInvoiceTableBody.innerHTML = '';
      return;
    }
    const fyYear = state.basCurrentFy;
    if (!fyYear) {
      basInvoiceEmpty.style.display = 'block';
      if (basInvoiceEmptyText) basInvoiceEmptyText.textContent = 'Select a financial year to view invoices.';
      basInvoiceTableBody.innerHTML = '';
      return;
    }
    const invoiceEntries = getInvoicesForFinancialYear(fyYear);
    if (!invoiceEntries.length) {
      basInvoiceEmpty.style.display = 'block';
      if (basInvoiceEmptyText) basInvoiceEmptyText.textContent = 'No invoices for this financial year.';
      basInvoiceTableBody.innerHTML = '';
      return;
    }
    basInvoiceEmpty.style.display = 'none';
    const rowsHtml = invoiceEntries.map(({ summary }) => {
      return [
        '<tr>',
        `<td>${summary.numberLabel}</td>`,
        `<td>${summary.dateLabel}</td>`,
        `<td>${summary.statusLabel}</td>`,
        `<td style="text-align:right;">${summary.lineCount}</td>`,
        `<td style="text-align:right;">${formatDecimalHours(summary.totalHours)}</td>`,
        `<td style="text-align:right;">${formatCurrency(summary.subtotal)}</td>`,
        `<td style="text-align:right;">${formatCurrency(summary.gstValue)}</td>`,
        `<td style="text-align:right;">${formatCurrency(summary.totalValue)}</td>`,
        '</tr>'
      ].join('');
    }).join('');
    basInvoiceTableBody.innerHTML = rowsHtml;
  }

  function getInvoicesForFinancialYear(fyYear) {
    if (!Array.isArray(state.invoices) || !fyYear) return [];
    const start = startOfFinancialYear(fyYear);
    const end = startOfFinancialYear(fyYear + 1);
    return state.invoices
      .map((invoice) => {
        const date = resolveInvoiceDate(invoice);
        if (!date || Number.isNaN(date.getTime()) || date < start || date >= end) return null;

        // Build summary inline
        const summarySource = invoice.summary || summarizeInvoiceLineItems(invoice.lineItems || []);
        const lineCount = Number(summarySource.lineCount ?? summarySource.totalLines ?? invoice.line_count ?? 0);
        const totalHours = Number(summarySource.totalHours ?? invoice.total_hours ?? 0);
        const subtotal = Number(summarySource.totalAmount != null ? summarySource.totalAmount : (invoice.total_amount || 0));
        const gstValue = Number(summarySource.gstAmount != null ? summarySource.gstAmount : Math.round(subtotal * GST_RATE * 100) / 100);
        const totalValue = Number(summarySource.totalWithGst != null ? summarySource.totalWithGst : subtotal + gstValue);
        const statusLabel = (invoice.status || 'draft').replace(/^./, (char) => char.toUpperCase());
        const dateLabel = date ? DATE_FULL_FORMATTER.format(date) : 'â';
        const baseNumber = invoice.invoice_number || (`Invoice ${invoice.sequence || ''}`).trim();
        const numberLabel = baseNumber || (invoice.id ? `Invoice ${invoice.id}` : 'Invoice');

        const summary = {
          numberLabel,
          dateLabel,
          statusLabel,
          lineCount,
          totalHours,
          subtotal,
          gstValue,
          totalValue
        };

        return { invoice, summary, date };
      })
      .filter(Boolean)
      .sort((a, b) => a.date - b.date);
  }

  function attachBasRowClickHandlers() {
    if (!basTableBody) return;
    const clickableRows = basTableBody.querySelectorAll('.bas-row-clickable');
    clickableRows.forEach(row => {
      row.addEventListener('click', () => {
        const fyYear = row.getAttribute('data-fy');
        const quarter = row.getAttribute('data-quarter');
        const month = row.getAttribute('data-month');
        if (fyYear && quarter) {
          openBasDetailModal(Number(fyYear), Number(quarter), null);
        } else if (fyYear && month) {
          openBasDetailModal(Number(fyYear), null, Number(month));
        }
      });
    });
  }

  // Annual Views
  const annualYearTypeToggle = document.getElementById('annual-year-type-toggle');
  const annualYearTypeLabel = document.getElementById('annual-year-type-label');
  const annualYearSelect = document.getElementById('annual-year-select');
  const annualContractFilterToggle = document.getElementById('annual-contract-filter-toggle');
  const annualContractFilterPanel = document.getElementById('annual-contract-filter-panel');
  const annualContractFilterList = document.getElementById('annual-contract-filter-list');
  const annualFilterSelectAll = document.getElementById('annual-filter-select-all');
  const annualEmpty = document.getElementById('annual-empty');
  const annualCategorySection = document.getElementById('annual-category-section');
  const annualCategoryFilterWrapper = document.getElementById('annual-category-filter-wrapper');
  const annualCategoryFilterList = document.getElementById('annual-category-filter-list');
  const annualCategoryFilterSelectAll = document.getElementById('annual-category-filter-select-all');
  const annualCategoryFilterClear = document.getElementById('annual-category-filter-clear');
  const annualCategoryTableHead = document.getElementById('annual-category-table-head');
  const annualCategoryTableBody = document.getElementById('annual-category-table-body');
  const annualCategoryEmpty = document.getElementById('annual-category-empty');
  const annualCategoryEmptyText = document.getElementById('annual-category-empty-text');

  function getThemeColors() {
    const computedStyle = getComputedStyle(document.body);
    return {
      text: computedStyle.getPropertyValue('--text').trim(),
      muted: computedStyle.getPropertyValue('--muted').trim(),
      border: computedStyle.getPropertyValue('--border').trim(),
      primary: computedStyle.getPropertyValue('--primary').trim(),
      danger: computedStyle.getPropertyValue('--danger').trim(),
      success: computedStyle.getPropertyValue('--success').trim(),
      warning: '#facc15'
    };
  }

  function destroyAnnualCharts() {
    if (state.annualCharts.income) {
      state.annualCharts.income.destroy();
      state.annualCharts.income = null;
    }
    if (state.annualCharts.incomePie) {
      state.annualCharts.incomePie.destroy();
      state.annualCharts.incomePie = null;
    }
    if (state.annualCharts.contractPie) {
      state.annualCharts.contractPie.destroy();
      state.annualCharts.contractPie = null;
    }
    if (state.annualCharts.hourTypesPie) {
      state.annualCharts.hourTypesPie.destroy();
      state.annualCharts.hourTypesPie = null;
    }
    if (state.annualCharts.totalHoursPie) {
      state.annualCharts.totalHoursPie.destroy();
      state.annualCharts.totalHoursPie = null;
    }
    if (state.annualCharts.totalHoursByTypePie) {
      state.annualCharts.totalHoursByTypePie.destroy();
      state.annualCharts.totalHoursByTypePie = null;
    }
  }

function ensureAnnualLoadingOverlay() {
  if (!pageAnnualViews) return null;
  let overlay = document.getElementById('annual-loading-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'annual-loading-overlay';
    overlay.innerHTML = `
      <div class="ts-loading-overlay__message">Loading annual data...</div>
      <div class="ts-loading-overlay__skeletons"></div>
    `;
    pageAnnualViews.appendChild(overlay);
  }
  return overlay;
}

function getAnnualSkeletonTargets() {
  const targets = [];
  const statIds = [
    'annual-stat-gross',
    'annual-stat-super',
    'annual-stat-tax',
    'annual-stat-net',
    'annual-stat-hours',
    'annual-stat-avg-monthly',
    'annual-stat-tax-rate',
    'annual-stat-hourly-rate'
  ];
  const seen = new Set();
  statIds.forEach((id) => {
    const el = document.getElementById(id);
    if (!el) return;
    const card = el.closest('.ts-annual-stat-card');
    const targetEl = card || el;
    if (seen.has(targetEl)) return;
    seen.add(targetEl);
    targets.push({ el: targetEl, type: 'block' });
  });
  const chartIds = [
    'annual-income-chart',
    'annual-income-pie-chart',
    'annual-contract-pie-chart',
    'annual-total-hours-pie-chart',
    'annual-total-hours-by-type-pie-chart'
  ];
  chartIds.forEach((id) => {
    const canvas = document.getElementById(id);
    if (canvas && canvas.parentElement) {
      targets.push({ el: canvas.parentElement, type: 'block' });
    }
  });
  const taxAnalysis = document.getElementById('annual-tax-analysis');
  if (taxAnalysis) targets.push({ el: taxAnalysis, type: 'block' });
  return targets;
}

function toggleAnnualSkeleton(enabled) {
  if (!pageAnnualViews) return;
  const targets = getAnnualSkeletonTargets();
  const overlay = enabled ? ensureAnnualLoadingOverlay() : document.getElementById('annual-loading-overlay');
  const skeletonLayer = overlay ? overlay.querySelector('.ts-loading-overlay__skeletons') : null;
  if (enabled) {
    if (!overlay || !skeletonLayer) return;
    overlay.classList.add('is-active');
    skeletonLayer.innerHTML = '';
    const baseRect = pageAnnualViews.getBoundingClientRect();
    targets.forEach((item) => {
      const { el, type, className } = item;
      if (!el) return;
      const rect = el.getBoundingClientRect();
      if (rect.width < 1 || rect.height < 1) return;
      if (el.dataset.prevVisibility === undefined) el.dataset.prevVisibility = el.style.visibility || '';
      el.style.visibility = 'hidden';
      const skeleton = document.createElement('div');
      skeleton.className = 'ts-skeleton';
      if (type === 'text' && className) skeleton.classList.add(className);
      skeleton.style.position = 'absolute';
      skeleton.style.top = `${rect.top - baseRect.top}px`;
      skeleton.style.left = `${rect.left - baseRect.left}px`;
      skeleton.style.width = `${rect.width}px`;
      skeleton.style.height = `${rect.height}px`;
      skeletonLayer.appendChild(skeleton);
    });
  } else {
    if (skeletonLayer) skeletonLayer.innerHTML = '';
    targets.forEach((item) => {
      const { el } = item;
      if (!el) return;
      if (el.dataset.prevVisibility !== undefined) {
        el.style.visibility = el.dataset.prevVisibility;
        delete el.dataset.prevVisibility;
      } else {
        el.style.visibility = '';
      }
    });
  }
}

function showAnnualLoadingState(useSkeleton) {
  if (!pageAnnualViews) return;
  const overlay = ensureAnnualLoadingOverlay();
  if (!overlay) return;
  const message = overlay.querySelector('.ts-loading-overlay__message');
  if (message) {
    message.textContent = useSkeleton ? 'Preparing annual insights...' : 'Loading annual data...';
  }
  overlay.classList.add('is-active');
  overlay.style.display = 'block';
  const skeletonLayer = overlay.querySelector('.ts-loading-overlay__skeletons');
  if (skeletonLayer && !useSkeleton) skeletonLayer.innerHTML = '';
  if (useSkeleton) {
    toggleAnnualSkeleton(true);
  } else {
    toggleAnnualSkeleton(false);
  }
}

function hideAnnualLoadingState() {
    const overlay = document.getElementById('annual-loading-overlay');
    if (overlay) {
      overlay.classList.remove('is-active');
      overlay.style.display = 'none';
      const skeletonLayer = overlay.querySelector('.ts-loading-overlay__skeletons');
      if (skeletonLayer) skeletonLayer.innerHTML = '';
    }
  }

function loadAnnualData() {
    const payload = {
      yearType: state.annualYearType,
      startYear: state.annualCurrentYear,
      contractIds: state.annualFilteredContracts
    };

    // Check if we have any cached annual data at all
    const hasAnyCachedData = state.annualData !== null;
    const useSkeleton = !hasAnyCachedData;

    // Always show loading state when loading data
    showAnnualLoadingState(useSkeleton);

    // Show cached data underneath if available (optimistic UI)
    if (hasAnyCachedData) {
      renderAnnualData();
      toggleAnnualSkeleton(false);
    }

    // Then fetch fresh data in background
    const statusMsg = hasAnyCachedData ? 'Updating annual data...' : 'Loading annual data...';
    setStatus(statusMsg, 'info');
    google.script.run
      .withSuccessHandler((data) => {
        state.annualData = data;
        saveCache();
        hideAnnualLoadingState();
        toggleAnnualSkeleton(false);
        renderAnnualData();
        setStatus('Ready', 'success');
      })
      .withFailureHandler((error) => {
        console.error('Failed to load annual data:', error);
        hideAnnualLoadingState();
        toggleAnnualSkeleton(false);
        setStatus('Error loading annual data', 'error');
      })
      .api_getAnnualSummary(payload);
}

  function renderAnnualViews() {
    if (!pageAnnualViews) return;

    // Get years based on current type
    const allYears = collectAllYears();
    const years = state.annualYearType === 'financial' ? allYears.financial : allYears.calendar;

    if (years.length === 0) {
      years.push(new Date().getFullYear());
    }

    if (!state.annualCurrentYear || !years.includes(state.annualCurrentYear)) {
      state.annualCurrentYear = years[0];
    }

    // Initialize year selector
    if (annualYearSelect) {
      const options = years.map(year => {
        const fy = financialYearLabel(year);
        return `<option value="${year}">${state.annualYearType === 'financial' ? fy : year}</option>`;
      }).join('');
      annualYearSelect.innerHTML = options;
      annualYearSelect.value = String(state.annualCurrentYear);
    }

    // Initialize year type toggle
    if (annualYearTypeToggle) {
      annualYearTypeToggle.checked = state.annualYearType === 'calendar';
    }
    if (annualYearTypeLabel) {
      annualYearTypeLabel.textContent = state.annualYearType === 'financial' ? 'Financial Year' : 'Calendar Year';
    }

    // Initialize contract filter
    renderAnnualContractFilter();

    // Load data
    loadAnnualData();
  }

  function renderAnnualContractFilter() {
    if (!annualContractFilterList) return;

    // Get year range based on year type
    let yearStart, yearEnd;
    if (state.annualYearType === 'financial') {
      yearStart = new Date(state.annualCurrentYear, 6, 1); // July 1st
      yearEnd = new Date(state.annualCurrentYear + 1, 5, 30, 23, 59, 59); // June 30th
    } else {
      yearStart = new Date(state.annualCurrentYear, 0, 1); // Jan 1st
      yearEnd = new Date(state.annualCurrentYear, 11, 31, 23, 59, 59); // Dec 31st
    }

    // Filter contracts that overlap with the selected year
    const relevantContracts = state.contracts.filter(c => {
      if (!c || !c.id || !c.name) return false;

      const contractStart = c.start_date ? new Date(c.start_date) : new Date(0);
      const contractEnd = c.end_date ? new Date(c.end_date) : new Date(9999, 11, 31);

      // Contract overlaps if it starts before year ends AND ends after year starts
      return contractStart <= yearEnd && contractEnd >= yearStart;
    });

    if (relevantContracts.length <= 1) {
      if (annualContractFilterToggle) annualContractFilterToggle.style.display = 'none';
      if (annualContractFilterPanel) annualContractFilterPanel.style.display = 'none';
      state.annualFilteredContracts = relevantContracts.map(c => c.id);
      return;
    }

    // Show the filter toggle button
    if (annualContractFilterToggle) annualContractFilterToggle.style.display = 'block';

    // Panel starts hidden (user can click toggle to show)
    if (!annualContractFilterPanel.dataset.initialized) {
      if (annualContractFilterPanel) annualContractFilterPanel.style.display = 'none';
      if (annualContractFilterPanel) annualContractFilterPanel.dataset.initialized = 'true';
    }

    // Initialize with all relevant contracts if not set or if filtered contracts are not relevant
    const currentFilteredAreRelevant = state.annualFilteredContracts.every(id =>
      relevantContracts.some(c => c.id === id)
    );
    if (state.annualFilteredContracts.length === 0 || !currentFilteredAreRelevant) {
      state.annualFilteredContracts = relevantContracts.map(c => c.id);
    }

    const html = relevantContracts.map(contract => {
      const isActive = state.annualFilteredContracts.includes(contract.id);
      return `
        <div class="ts-calendar-filter-item ${isActive ? 'active' : ''}" data-contract-id="${contract.id}">
          <input type="checkbox" class="ts-calendar-filter-checkbox" ${isActive ? 'checked' : ''} />
          <span class="ts-calendar-filter-name">${contract.name}</span>
        </div>
      `;
    }).join('');

    annualContractFilterList.innerHTML = html;

    // Add click handlers
    annualContractFilterList.querySelectorAll('.ts-calendar-filter-item').forEach(item => {
      item.addEventListener('click', () => {
        const contractId = item.dataset.contractId;
        const idx = state.annualFilteredContracts.indexOf(contractId);
        if (idx >= 0) {
          state.annualFilteredContracts.splice(idx, 1);
        } else {
          state.annualFilteredContracts.push(contractId);
        }
        saveCache();
        renderAnnualContractFilter();
        loadAnnualData();
      });
    });
  }

  function getAnnualCategoryKeys() {
    if (!state.annualData || !Array.isArray(state.annualData.monthlyData)) return [];
    const keys = new Set();
    state.annualData.monthlyData.forEach((month) => {
      if (!month || !month.categoryBreakdown || !Array.isArray(month.categoryBreakdown.categories)) return;
      month.categoryBreakdown.categories.forEach((entry) => {
        if (!entry) return;
        const id = entry.categoryId != null ? String(entry.categoryId) : '';
        keys.add(id);
      });
    });
    const result = Array.from(keys);
    result.sort((a, b) => {
      const metaA = getDeductionCategoryMeta(a);
      const metaB = getDeductionCategoryMeta(b);
      const isUncatA = (a || '') === '';
      const isUncatB = (b || '') === '';
      if (isUncatA && !isUncatB) return 1;
      if (isUncatB && !isUncatA) return -1;
      return metaA.name.localeCompare(metaB.name);
    });
    return result;
  }

  function ensureAnnualCategoryFilters(keys) {
    if (!keys.length) {
      state.annualCategoryFilters = [];
      state.annualCategoryExpansion = {};
      return;
    }
    const existing = Array.isArray(state.annualCategoryFilters) ? state.annualCategoryFilters.slice() : [];
    const valid = existing.filter((id) => keys.includes(id));
    const additions = keys.filter((id) => !valid.includes(id));
    state.annualCategoryFilters = valid.concat(additions);
    if (!state.annualCategoryExpansion || typeof state.annualCategoryExpansion !== 'object') {
      state.annualCategoryExpansion = {};
    }
    Object.keys(state.annualCategoryExpansion).forEach((key) => {
      if (!keys.includes(key)) {
        delete state.annualCategoryExpansion[key];
      }
    });
  }

  function renderAnnualCategorySection() {
    if (!annualCategorySection) return;
    if (!state.annualData || !getFeatureFlag('enable_deduction_categories')) {
      annualCategorySection.style.display = 'none';
      if (annualCategoryEmpty) annualCategoryEmpty.style.display = 'none';
      return;
    }
    const keys = getAnnualCategoryKeys();
    ensureAnnualCategoryFilters(keys);
    if (!keys.length) {
      annualCategorySection.style.display = 'none';
      if (annualCategoryEmpty) annualCategoryEmpty.style.display = 'none';
      return;
    }
    annualCategorySection.style.display = 'block';
    if (annualCategoryFilterWrapper) {
      annualCategoryFilterWrapper.style.display = keys.length > 0 ? 'block' : 'none';
    }
    renderAnnualCategoryFilters(keys);
    renderAnnualCategoryTable(keys);
  }

  function renderAnnualCategoryFilters(keys) {
    if (!annualCategoryFilterList) return;
    annualCategoryFilterList.innerHTML = '';
    if (!keys.length) return;

    keys.forEach((categoryId) => {
      const meta = getDeductionCategoryMeta(categoryId);
      const isActive = state.annualCategoryFilters.includes(categoryId);
      const item = document.createElement('div');
      item.className = 'ts-calendar-filter-item' + (isActive ? ' active' : '');
      item.dataset.categoryId = categoryId;
      item.style.display = 'inline-flex';
      item.style.alignItems = 'center';
      item.style.gap = '6px';

      const dot = document.createElement('span');
      dot.style.display = 'inline-block';
      dot.style.width = '10px';
      dot.style.height = '10px';
      dot.style.borderRadius = '50%';
      dot.style.backgroundColor = meta.color || '#6b7280';
      item.appendChild(dot);

      const label = document.createElement('span');
      label.className = 'ts-calendar-filter-name';
      label.textContent = meta.name;
      item.appendChild(label);

      item.addEventListener('click', () => {
        const index = state.annualCategoryFilters.indexOf(categoryId);
        if (index !== -1) {
          state.annualCategoryFilters.splice(index, 1);
        } else {
          state.annualCategoryFilters.push(categoryId);
        }
        saveCache();
        renderAnnualCategoryFilters(keys);
        renderAnnualCategoryTable(keys);
      });

      annualCategoryFilterList.appendChild(item);
    });
  }

  function getMonthlyCategoryEntry(month, categoryId) {
    if (!month || !month.categoryBreakdown || !Array.isArray(month.categoryBreakdown.categories)) return null;
    const target = categoryId != null ? String(categoryId) : '';
    const match = month.categoryBreakdown.categories.find((entry) => {
      if (!entry) return false;
      const entryId = entry.categoryId != null ? String(entry.categoryId) : '';
      return entryId === target;
    });
    return match || null;
  }

  function renderAnnualCategoryTable(keys) {
    if (!annualCategoryTableHead || !annualCategoryTableBody) return;
    annualCategoryTableHead.innerHTML = '';
    annualCategoryTableBody.innerHTML = '';

    if (!state.annualData) return;
    const visibleCategories = state.annualCategoryFilters.filter((id) => keys.includes(id));

    if (!visibleCategories.length) {
      if (annualCategoryEmpty) {
        if (annualCategoryEmptyText) annualCategoryEmptyText.textContent = 'Select at least one category to view the breakdown.';
        annualCategoryEmpty.style.display = 'block';
      }
      return;
    }

    if (annualCategoryEmpty) {
      annualCategoryEmpty.style.display = 'none';
    }

    const headRow = document.createElement('tr');
    const monthTh = document.createElement('th');
    monthTh.textContent = 'Month';
    monthTh.style.textAlign = 'left';
    monthTh.style.padding = '12px';
    headRow.appendChild(monthTh);

    visibleCategories.forEach((categoryId) => {
      const th = document.createElement('th');
      th.style.padding = '12px';
      th.style.textAlign = 'left';
      th.style.minWidth = '160px';
      const headerButton = document.createElement('button');
      headerButton.type = 'button';
      headerButton.style.display = 'flex';
      headerButton.style.alignItems = 'center';
      headerButton.style.justifyContent = 'space-between';
      headerButton.style.width = '100%';
      headerButton.style.gap = '8px';
      headerButton.style.background = 'none';
      headerButton.style.border = 'none';
      headerButton.style.padding = '0';
      headerButton.style.cursor = 'pointer';

      const left = document.createElement('span');
      left.style.display = 'inline-flex';
      left.style.alignItems = 'center';
      left.style.gap = '8px';

      const meta = getDeductionCategoryMeta(categoryId);
      const dot = document.createElement('span');
      dot.style.display = 'inline-block';
      dot.style.width = '10px';
      dot.style.height = '10px';
      dot.style.borderRadius = '50%';
      dot.style.backgroundColor = meta.color || '#6b7280';
      left.appendChild(dot);

      const nameSpan = document.createElement('span');
      nameSpan.textContent = meta.name;
      left.appendChild(nameSpan);

      headerButton.appendChild(left);

      const expanded = !!state.annualCategoryExpansion[categoryId];
      const arrow = document.createElement('span');
      arrow.textContent = expanded ? 'â¼' : 'â¶';
      headerButton.appendChild(arrow);

      headerButton.addEventListener('click', () => {
        state.annualCategoryExpansion[categoryId] = !expanded;
        saveCache();
        renderAnnualCategoryTable(keys);
      });

      th.appendChild(headerButton);
      headRow.appendChild(th);
    });

    annualCategoryTableHead.appendChild(headRow);

    const totalsByCategory = {};
    state.annualData.monthlyData.forEach((month) => {
      const row = document.createElement('tr');
      const monthCell = document.createElement('td');
      monthCell.textContent = month.label;
      monthCell.style.padding = '10px 12px';
      monthCell.style.fontWeight = '600';
      monthCell.style.whiteSpace = 'nowrap';
      row.appendChild(monthCell);

      visibleCategories.forEach((categoryId) => {
        const entry = getMonthlyCategoryEntry(month, categoryId);
        const totalValue = entry ? entry.total : 0;
        totalsByCategory[categoryId] = (totalsByCategory[categoryId] || 0) + totalValue;

        const cell = document.createElement('td');
        cell.style.padding = '10px 12px';
        const expanded = !!state.annualCategoryExpansion[categoryId];
        cell.style.textAlign = expanded ? 'left' : 'right';

        if (!entry || !entry.total) {
          cell.textContent = 'â';
          cell.style.color = 'var(--muted)';
        } else if (expanded) {
          cell.style.color = '';
          const totalEl = document.createElement('div');
          totalEl.style.fontWeight = '600';
          totalEl.style.marginBottom = '6px';
          totalEl.textContent = formatCurrency(entry.total);
          cell.appendChild(totalEl);

          const expandedItems = Array.isArray(entry.deductions) ? entry.deductions : [];
          expandedItems.forEach((deduction) => {
            const line = document.createElement('div');
            line.style.display = 'flex';
            line.style.justifyContent = 'space-between';
            line.style.gap = '12px';
            line.style.fontSize = '13px';
            const nameSpan = document.createElement('span');
            nameSpan.style.flex = '1';
            nameSpan.style.textAlign = 'left';
            nameSpan.textContent = deduction.name || 'Unnamed deduction';
            const amountSpan = document.createElement('span');
            amountSpan.textContent = formatCurrency(deduction.amount);
            amountSpan.style.textAlign = 'right';
            line.appendChild(nameSpan);
            line.appendChild(amountSpan);
            cell.appendChild(line);
          });
        } else {
          cell.style.color = '';
          cell.textContent = formatCurrency(entry.total);
        }

        row.appendChild(cell);
      });

      annualCategoryTableBody.appendChild(row);
    });

    const totalRow = document.createElement('tr');
    totalRow.style.fontWeight = '600';
    totalRow.style.borderTop = '2px solid var(--border)';
    const labelCell = document.createElement('td');
    labelCell.textContent = 'Total';
    labelCell.style.padding = '12px';
    totalRow.appendChild(labelCell);

    visibleCategories.forEach((categoryId) => {
      const totalCell = document.createElement('td');
      totalCell.style.padding = '12px';
      totalCell.style.textAlign = state.annualCategoryExpansion[categoryId] ? 'left' : 'right';
      const totalValue = Math.round((totalsByCategory[categoryId] || 0) * 100) / 100;
      if (totalValue) {
        totalCell.style.color = '';
        totalCell.textContent = formatCurrency(totalValue);
      } else {
        totalCell.textContent = 'â';
        totalCell.style.color = 'var(--muted)';
      }
      totalRow.appendChild(totalCell);
    });

    annualCategoryTableBody.appendChild(totalRow);
  }

  function collectAllYears() {
    // Get list of public holiday hour type IDs
    const publicHolidayHourTypeIds = state.hourTypes
      .filter(ht => ht.auto_populate_public_holidays === true || ht.auto_populate_public_holidays === 'TRUE')
      .map(ht => ht.id);

    // Group entries by year to check if year has non-public-holiday entries
    const calendarYearEntries = {};
    const financialYearEntries = {};

    state.entries.forEach(entry => {
      if (entry && entry.date) {
        const duration = entry.duration_minutes || 0;
        if (duration > 0) {
          const date = new Date(entry.date);
          const calendarYear = date.getFullYear();
          const fyStart = financialYearStartYear(date);
          const hourTypeId = entry.hour_type_id || '';
          const isPublicHoliday = publicHolidayHourTypeIds.includes(hourTypeId);

          // Track calendar year entries
          if (!calendarYearEntries[calendarYear]) {
            calendarYearEntries[calendarYear] = { total: 0, publicHolidays: 0 };
          }
          calendarYearEntries[calendarYear].total++;
          if (isPublicHoliday) {
            calendarYearEntries[calendarYear].publicHolidays++;
          }

          // Track financial year entries
          if (!financialYearEntries[fyStart]) {
            financialYearEntries[fyStart] = { total: 0, publicHolidays: 0 };
          }
          financialYearEntries[fyStart].total++;
          if (isPublicHoliday) {
            financialYearEntries[fyStart].publicHolidays++;
          }
        }
      }
    });

    // Only include years that have at least one non-public-holiday entry
    const calendarYears = Object.keys(calendarYearEntries)
      .filter(year => {
        const stats = calendarYearEntries[year];
        return stats.total > stats.publicHolidays; // Has at least one non-PH entry
      })
      .map(y => parseInt(y))
      .sort((a, b) => b - a);

    const financialYears = Object.keys(financialYearEntries)
      .filter(year => {
        const stats = financialYearEntries[year];
        return stats.total > stats.publicHolidays; // Has at least one non-PH entry
      })
      .map(y => parseInt(y))
      .sort((a, b) => b - a);

    return {
      calendar: calendarYears,
      financial: financialYears
    };
  }

  function getCorrespondingYear(year, fromType, toType) {
    if (fromType === toType) return year;

    if (fromType === 'financial' && toType === 'calendar') {
      // FY 2024 (Jul 2024 - Jun 2025) -> Calendar 2024
      return year;
    } else if (fromType === 'calendar' && toType === 'financial') {
      // Calendar 2024 -> FY 2024 (Jul 2024 - Jun 2025)
      return year;
    }
    return year;
  }

  function renderAnnualData() {
    if (!state.annualData) return;

    const data = state.annualData;
    const totals = data.yearTotals;

    // Update summary stats
    const grossEl = document.getElementById('annual-stat-gross');
    const superEl = document.getElementById('annual-stat-super');
    const taxEl = document.getElementById('annual-stat-tax');
    const netEl = document.getElementById('annual-stat-net');
    const hoursEl = document.getElementById('annual-stat-hours');
    const taxRateEl = document.getElementById('annual-stat-tax-rate');
    const avgMonthlyEl = document.getElementById('annual-stat-avg-monthly');
    const hourlyRateEl = document.getElementById('annual-stat-hourly-rate');

    if (grossEl) grossEl.textContent = formatCurrency(totals.grossIncome);
    if (superEl) superEl.textContent = formatCurrency(totals.superGuarantee + totals.extraSuper);
    if (taxEl) taxEl.textContent = formatCurrency(totals.tax);
    if (netEl) netEl.textContent = formatCurrency(totals.netIncome);
    if (hoursEl) hoursEl.textContent = totals.totalHours.toFixed(1) + ' hrs';

    // Calculate and display new metrics
    const effectiveTaxRate = totals.grossIncome > 0 ? (totals.tax / totals.grossIncome) * 100 : 0;
    const avgMonthlyIncome = totals.grossIncome / 12;
    // Use rateCalcHours if available and > 0, otherwise fall back to totalHours
    const hoursForRate = totals.rateCalcHours > 0 ? totals.rateCalcHours : totals.totalHours;
    const effectiveHourlyRate = hoursForRate > 0 ? totals.grossIncome / hoursForRate : 0;

    if (taxRateEl) taxRateEl.textContent = effectiveTaxRate.toFixed(1) + '%';
    if (avgMonthlyEl) avgMonthlyEl.textContent = formatCurrency(avgMonthlyIncome);
    if (hourlyRateEl) hourlyRateEl.textContent = formatCurrency(effectiveHourlyRate) + '/hr';

    // Update breakdown table
    updateAnnualBreakdownTable();

    // Render charts
    destroyAnnualCharts();
    renderAnnualIncomeChart();
    renderAnnualIncomePieChart();
    renderAnnualContractPieChart();
    renderAnnualHourTypesPieChart();
    renderAnnualTotalHoursPieChart();
    renderAnnualTotalHoursByTypePieChart();

    // Update tax analysis
    renderAnnualTaxAnalysis();
    renderAnnualCategorySection();

    // Show/hide empty state
    const hasData = data.monthlyData.some(m => m.grossIncome > 0 || m.totalHours > 0);
    if (annualEmpty) annualEmpty.style.display = hasData ? 'none' : 'block';
  }

  function updateAnnualBreakdownTable() {
    if (!state.annualData) return;
    const totals = state.annualData.yearTotals;
    const totalSuper = totals.superGuarantee + totals.extraSuper;
    const gross = totals.grossIncome;

    // Gross Income (always 100%)
    document.getElementById('annual-breakdown-gross').textContent = formatCurrency(gross);
    document.getElementById('annual-breakdown-gross-pct').textContent = '100%';
    document.getElementById('annual-breakdown-gross-bar').style.width = '100%';

    // Superannuation
    const superPct = gross > 0 ? (totalSuper / gross) * 100 : 0;
    document.getElementById('annual-breakdown-super').textContent = formatCurrency(totalSuper);
    document.getElementById('annual-breakdown-super-pct').textContent = superPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-super-bar').style.width = superPct.toFixed(1) + '%';

    // Superannuation Lost
    const superLostRow = document.getElementById('annual-breakdown-super-lost-row');
    if (totals.superLost > 0.01) {
      if (superLostRow) superLostRow.style.display = '';
      const superLostPct = gross > 0 ? (totals.superLost / gross) * 100 : 0;
      document.getElementById('annual-breakdown-super-lost').textContent = formatCurrency(totals.superLost);
      document.getElementById('annual-breakdown-super-lost-pct').textContent = superLostPct.toFixed(1) + '%';
      document.getElementById('annual-breakdown-super-lost-bar').style.width = superLostPct.toFixed(1) + '%';
    } else {
      if (superLostRow) superLostRow.style.display = 'none';
    }

    // Deductions
    const deductionsPct = gross > 0 ? (totals.otherDeductions / gross) * 100 : 0;
    document.getElementById('annual-breakdown-deductions').textContent = formatCurrency(totals.otherDeductions);
    document.getElementById('annual-breakdown-deductions-pct').textContent = deductionsPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-deductions-bar').style.width = deductionsPct.toFixed(1) + '%';

    // Tax
    const taxPct = gross > 0 ? (totals.tax / gross) * 100 : 0;
    document.getElementById('annual-breakdown-tax').textContent = formatCurrency(totals.tax);
    document.getElementById('annual-breakdown-tax-pct').textContent = taxPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-tax-bar').style.width = taxPct.toFixed(1) + '%';

    // Net Income
    const netPct = gross > 0 ? (totals.netIncome / gross) * 100 : 0;
    document.getElementById('annual-breakdown-net').textContent = formatCurrency(totals.netIncome);
    document.getElementById('annual-breakdown-net-pct').textContent = netPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-net-bar').style.width = netPct.toFixed(1) + '%';

    // Update table striping based on visible rows
    restripeTable('annual-income-breakdown-table');
  }

  // Chart.js plugin for center text in donut charts
  const centerTextPlugin = {
    id: 'centerText',
    beforeDraw: (chart) => {
      if (!chart.config.options.plugins.centerText) return;

      const { ctx, chartArea: { left, top, right, bottom, width, height } } = chart;
      const centerX = left + width / 2;
      const centerY = top + height / 2;

      ctx.save();

      const text = chart.config.options.plugins.centerText.text || '';
      const color = chart.config.options.plugins.centerText.color || '#ffffff';

      // Main text (large, centered)
      ctx.font = 'bold 26px Inter, system-ui, sans-serif';
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, centerX, centerY);

      ctx.restore();
    }
  };

  function renderAnnualIncomeChart() {
    const canvas = document.getElementById('annual-income-chart');
    if (!canvas || !state.annualData) return;

    const monthlyData = state.annualData.monthlyData;
    const labels = monthlyData.map(m => m.label);
    const colors = getThemeColors();

    // Create border arrays - show border for actual income months
    const borderWidths = monthlyData.map(m => m.hasActualIncome ? 2 : 0);
    const borderColors = monthlyData.map(m => m.hasActualIncome ? colors.text : 'transparent');

    const ctx = canvas.getContext('2d');
    state.annualCharts.income = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Tax',
            data: monthlyData.map(m => m.tax),
            backgroundColor: colors.danger,
            borderWidth: borderWidths,
            borderColor: borderColors
          },
          {
            label: 'Deductions',
            data: monthlyData.map(m => m.otherDeductions),
            backgroundColor: colors.warning,
            borderWidth: borderWidths,
            borderColor: borderColors
          },
          {
            label: 'Superannuation',
            data: monthlyData.map(m => m.superGuarantee + m.extraSuper),
            backgroundColor: colors.success,
            borderWidth: borderWidths,
            borderColor: borderColors
          },
          {
            label: 'Net Income',
            data: monthlyData.map(m => m.netIncome),
            backgroundColor: colors.primary,
            borderWidth: borderWidths,
            borderColor: borderColors
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'dataset',
          intersect: true
        },
        plugins: {
          datalabels: {
            color: '#fff',
            font: { size: 10, weight: '600' },
            formatter: (value) => {
              if (value < 500) return ''; // Hide labels for small segments
              return '$' + (value / 1000).toFixed(1) + 'k';
            },
            anchor: 'center',
            align: 'center'
          },
          legend: {
            position: 'top',
            align: 'start',
            labels: {
              color: colors.text,
              font: { size: 12, weight: '500' },
              padding: 16,
              usePointStyle: true,
              pointStyle: 'roundedRect'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            bodySpacing: 6,
            cornerRadius: 8,
            mode: 'index',
            intersect: false,
            callbacks: {
              label: (context) => {
                return '  ' + context.dataset.label + ': ' + formatCurrency(context.parsed.y);
              },
              footer: (items) => {
                const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                const monthIndex = items[0].dataIndex;
                const hasActual = monthlyData[monthIndex].hasActualIncome;
                const dataType = hasActual ? ' (Actual)' : ' (Estimated)';
                return '\n  Gross Total: ' + formatCurrency(total) + dataType;
              }
            }
          }
        },
        scales: {
          x: {
            stacked: true,
            grid: {
              display: false
            },
            ticks: {
              color: colors.muted,
              font: { size: 11 },
              padding: 8
            },
            border: {
              display: false
            }
          },
          y: {
            stacked: true,
            grid: {
              color: colors.border,
              drawBorder: false,
              lineWidth: 1
            },
            ticks: {
              color: colors.muted,
              font: { size: 11 },
              padding: 8,
              callback: (value) => '$' + (value / 1000).toFixed(0) + 'k'
            },
            border: {
              display: false
            }
          }
        },
        layout: {
          padding: {
            top: 10,
            right: 10,
            bottom: 0,
            left: 0
          }
        }
      }
    });
  }

  function renderAnnualIncomePieChart() {
    const canvas = document.getElementById('annual-income-pie-chart');
    if (!canvas || !state.annualData) return;

    const totals = state.annualData.yearTotals;
    const colors = getThemeColors();

    const grossIncome = totals.grossIncome;

    const ctx = canvas.getContext('2d');
    state.annualCharts.incomePie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: ['Net Income', 'Tax', 'Deductions', 'Superannuation'],
        datasets: [{
          data: [
            totals.netIncome,
            totals.tax,
            totals.otherDeductions,
            totals.superGuarantee + totals.extraSuper
          ],
          backgroundColor: [colors.primary, colors.danger, colors.warning, colors.success],
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: formatCurrency(grossIncome),
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'roundedRect'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const value = formatCurrency(context.parsed);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + value + ' (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function renderAnnualContractPieChart() {
    const container = document.getElementById('annual-contract-pie-container');
    const canvas = document.getElementById('annual-contract-pie-chart');
    if (!canvas || !state.annualData || !container) return;

    const contractBreakdown = state.annualData.contractBreakdown;
    if (contractBreakdown.length <= 1) {
      container.style.display = 'none';
      return;
    }

    container.style.display = 'block';
    const colors = getThemeColors();
    const chartColors = [colors.primary, colors.success, colors.warning, colors.danger, '#8b5cf6', '#ec4899', '#14b8a6', '#f59e0b'];

    const totalIncome = contractBreakdown.reduce((sum, c) => sum + c.grossIncome, 0);

    const ctx = canvas.getContext('2d');
    state.annualCharts.contractPie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: contractBreakdown.map(c => c.contractName),
        datasets: [{
          data: contractBreakdown.map(c => c.grossIncome),
          backgroundColor: chartColors.slice(0, contractBreakdown.length),
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: formatCurrency(totalIncome),
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'roundedRect'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const value = formatCurrency(context.parsed);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + value + ' (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function renderAnnualHourTypesPieChart() {
    const container = document.getElementById('annual-hour-types-pie-container');
    const canvas = document.getElementById('annual-hour-types-pie-chart');
    if (!canvas || !state.annualData || !container) return;

    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
    if (!hourTypesEnabled) {
      container.style.display = 'none';
      return;
    }

    const hourTypeBreakdown = state.annualData.hourTypeBreakdown;
    if (hourTypeBreakdown.length === 0) {
      container.style.display = 'none';
      return;
    }

    container.style.display = 'block';
    const colors = getThemeColors();

    const ctx = canvas.getContext('2d');
    state.annualCharts.hourTypesPie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: hourTypeBreakdown.map(ht => ht.hourTypeName),
        datasets: [{
          data: hourTypeBreakdown.map(ht => ht.hours),
          backgroundColor: hourTypeBreakdown.map(ht => ht.hourTypeColor || colors.muted),
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '45%',
        plugins: {
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'roundedRect'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const hours = context.parsed.toFixed(1);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + hours + ' hrs (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      }
    });
  }

  function renderAnnualTotalHoursPieChart() {
    const canvas = document.getElementById('annual-total-hours-pie-chart');
    if (!canvas || !state.annualData) return;

    const monthlyData = state.annualData.monthlyData;
    const labels = monthlyData.map(m => m.label);
    const hours = monthlyData.map(m => m.totalHours);
    const colors = getThemeColors();

    const totalHours = hours.reduce((sum, h) => sum + h, 0);

    // Use rainbow gradient for 12 months (ordered visually)
    const monthColors = hours.map((_, index) => {
      const hue = (index * 30) % 360; // 0, 30, 60, 90, 120... (full spectrum)
      return `hsl(${hue}, 70%, 60%)`;
    });

    const ctx = canvas.getContext('2d');
    state.annualCharts.totalHoursPie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: labels,
        datasets: [{
          data: hours,
          backgroundColor: monthColors,
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: totalHours.toFixed(1) + ' hrs',
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'roundedRect'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const hoursVal = context.parsed.toFixed(1);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + hoursVal + ' hrs (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function renderAnnualTotalHoursByTypePieChart() {
    const canvas = document.getElementById('annual-total-hours-by-type-pie-chart');
    if (!canvas || !state.annualData) return;

    const hourTypeBreakdown = state.annualData.hourTypeBreakdown;
    if (!hourTypeBreakdown || hourTypeBreakdown.length === 0) {
      return;
    }

    const labels = hourTypeBreakdown.map(ht => ht.hourTypeName);
    const hours = hourTypeBreakdown.map(ht => ht.hours);
    const hourColors = hourTypeBreakdown.map(ht => ht.hourTypeColor);
    const colors = getThemeColors();

    const totalHours = hours.reduce((sum, h) => sum + h, 0);

    const ctx = canvas.getContext('2d');
    state.annualCharts.totalHoursByTypePie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: labels,
        datasets: [{
          data: hours,
          backgroundColor: hourColors,
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: totalHours.toFixed(1) + ' hrs',
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const hoursVal = context.parsed.toFixed(1);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + hoursVal + ' hrs (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function calculateAustralianTax(annualTaxableIncome) {
    // Australian tax brackets 2024/2025
    let tax = 0;

    if (annualTaxableIncome <= 18200) {
      tax = 0;
    } else if (annualTaxableIncome <= 45000) {
      tax = (annualTaxableIncome - 18200) * 0.16;
    } else if (annualTaxableIncome <= 135000) {
      tax = 4288 + (annualTaxableIncome - 45000) * 0.30;
    } else if (annualTaxableIncome <= 190000) {
      tax = 31288 + (annualTaxableIncome - 135000) * 0.37;
    } else {
      tax = 51638 + (annualTaxableIncome - 190000) * 0.45;
    }

    // Add Medicare levy (2%)
    const medicareLevy = annualTaxableIncome * 0.02;

    return tax + medicareLevy;
  }

  function renderAnnualTaxAnalysis() {
    if (!state.annualData) return;

    const monthlyData = state.annualData.monthlyData;
    const totals = state.annualData.yearTotals;
    const paidTax = totals.tax;

    // Calculate annual taxable income by summing monthly taxable incomes
    const annualTaxableIncome = monthlyData.reduce((sum, m) => sum + m.taxableIncome, 0);

    // Calculate expected ATO tax with Medicare levy
    const expectedTax = calculateAustralianTax(annualTaxableIncome);
    const difference = paidTax - expectedTax;

    document.getElementById('annual-tax-paid').textContent = formatCurrency(paidTax);
    document.getElementById('annual-tax-expected').textContent = formatCurrency(expectedTax);

    const diffEl = document.getElementById('annual-tax-difference');
    if (diffEl) {
      diffEl.textContent = formatCurrency(Math.abs(difference));
      diffEl.style.color = difference > 0 ? 'var(--danger)' : 'var(--success)';
    }
  }

  // Event listeners for annual views
  if (annualYearTypeToggle) {
    annualYearTypeToggle.addEventListener('change', () => {
      const oldType = state.annualYearType;
      state.annualYearType = annualYearTypeToggle.checked ? 'calendar' : 'financial';

      if (annualYearTypeLabel) {
        annualYearTypeLabel.textContent = state.annualYearType === 'financial' ? 'Financial Year' : 'Calendar Year';
      }

      // Get corresponding year for new type
      const correspondingYear = getCorrespondingYear(state.annualCurrentYear, oldType, state.annualYearType);

      // Update year selector with new type's years
      const allYears = collectAllYears();
      const years = state.annualYearType === 'financial' ? allYears.financial : allYears.calendar;

      if (years.length === 0) {
        years.push(new Date().getFullYear());
      }

      // Set year to corresponding year if it exists, otherwise use first available
      if (years.includes(correspondingYear)) {
        state.annualCurrentYear = correspondingYear;
      } else {
        state.annualCurrentYear = years[0];
      }

      if (annualYearSelect) {
        const options = years.map(year => {
          const fy = financialYearLabel(year);
          return `<option value="${year}">${state.annualYearType === 'financial' ? fy : year}</option>`;
        }).join('');
        annualYearSelect.innerHTML = options;
        annualYearSelect.value = String(state.annualCurrentYear);
      }

      saveCache();
      renderAnnualContractFilter();
      loadAnnualData();
    });
  }

  if (annualYearSelect) {
    annualYearSelect.addEventListener('change', () => {
      state.annualCurrentYear = Number(annualYearSelect.value);
      saveCache();
      loadAnnualData();
    });
  }

  if (annualContractFilterToggle) {
    annualContractFilterToggle.addEventListener('click', () => {
      if (annualContractFilterPanel) {
        const isHidden = annualContractFilterPanel.style.display === 'none';
        annualContractFilterPanel.style.display = isHidden ? 'block' : 'none';
      }
    });
  }

  if (annualFilterSelectAll) {
    annualFilterSelectAll.addEventListener('click', () => {
      // Get year range based on year type
      let yearStart, yearEnd;
      if (state.annualYearType === 'financial') {
        yearStart = new Date(state.annualCurrentYear, 6, 1);
        yearEnd = new Date(state.annualCurrentYear + 1, 5, 30, 23, 59, 59);
      } else {
        yearStart = new Date(state.annualCurrentYear, 0, 1);
        yearEnd = new Date(state.annualCurrentYear, 11, 31, 23, 59, 59);
      }

      // Select only relevant contracts for this year
      const relevantContracts = state.contracts.filter(c => {
        if (!c || !c.id) return false;
        const contractStart = c.start_date ? new Date(c.start_date) : new Date(0);
        const contractEnd = c.end_date ? new Date(c.end_date) : new Date(9999, 11, 31);
        return contractStart <= yearEnd && contractEnd >= yearStart;
      });

      state.annualFilteredContracts = relevantContracts.map(c => c.id);
      saveCache();
      renderAnnualContractFilter();
      loadAnnualData();
    });
  }

  if (annualCategoryFilterSelectAll) {
    annualCategoryFilterSelectAll.addEventListener('click', (event) => {
      event.preventDefault();
      const keys = getAnnualCategoryKeys();
      state.annualCategoryFilters = keys.slice();
      saveCache();
      renderAnnualCategoryFilters(keys);
      renderAnnualCategoryTable(keys);
    });
  }

  if (annualCategoryFilterClear) {
    annualCategoryFilterClear.addEventListener('click', (event) => {
      event.preventDefault();
      state.annualCategoryFilters = [];
      saveCache();
      const keys = getAnnualCategoryKeys();
      renderAnnualCategoryFilters(keys);
      renderAnnualCategoryTable(keys);
    });
  }
function renderDeductionsList() {
    if (!deductionsListEl) return;
    const list = Array.isArray(state.deductions) ? [...state.deductions] : [];
    list.sort((a, b) => {
      if (a.active !== b.active) return a.active ? -1 : 1;
      return a.name.localeCompare(b.name);
    });
    const hasItems = list.length > 0;
    if (deductionsEmptyEl) {
      deductionsEmptyEl.style.display = hasItems ? 'none' : 'block';
    }

    const showReadonlyNote = !state.companyTrackingEnabled && list.some((item) => item.company_expense);
    if (deductionCompanyDisabledNote) {
      deductionCompanyDisabledNote.style.display = showReadonlyNote ? 'inline-flex' : 'none';
    }

    deductionsListEl.innerHTML = '';

    const categoriesEnabled = isDeductionCategoriesEnabled();
    const hasCustomCategories = categoriesEnabled && state.deductionCategories.length > 0;

    if (hasCustomCategories) {
      ensureDeductionCategoryCollapseState();

      const groups = {};
      list.forEach((deduction) => {
        const key = deduction.category_id && state.deductionCategoryMap[deduction.category_id]
          ? deduction.category_id
          : '__uncategorised__';
        if (!groups[key]) groups[key] = [];
        groups[key].push(deduction);
      });

      const groupEntries = Object.keys(groups).map((key) => {
        const items = groups[key].slice().sort((a, b) => {
          if (a.active !== b.active) return a.active ? -1 : 1;
          return a.name.localeCompare(b.name);
        });
        const meta = key === '__uncategorised__'
          ? { id: '__uncategorised__', name: 'Uncategorised', color: '#6b7280' }
          : getDeductionCategoryMeta(key);
        return { id: key, meta, items };
      });

      groupEntries.sort((a, b) => {
        if (a.id === '__uncategorised__') return 1;
        if (b.id === '__uncategorised__') return -1;
        return a.meta.name.localeCompare(b.meta.name);
      });

      groupEntries.forEach((group) => {
        const container = document.createElement('div');
        container.className = 'ts-deduction-category-group';

        const header = document.createElement('div');
        header.className = 'ts-item';
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.justifyContent = 'space-between';
        header.style.cursor = 'pointer';

        const left = document.createElement('div');
        left.style.display = 'flex';
        left.style.alignItems = 'center';
        left.style.gap = '8px';

        const dot = document.createElement('span');
        dot.style.display = 'inline-block';
        dot.style.width = '10px';
        dot.style.height = '10px';
        dot.style.borderRadius = '50%';
        dot.style.backgroundColor = group.meta.color || '#6b7280';
        left.appendChild(dot);

        const title = document.createElement('span');
        title.style.fontWeight = '600';
        title.textContent = group.meta.name;
        left.appendChild(title);

        const count = document.createElement('span');
        count.className = 'ts-note';
        count.textContent = `${group.items.length} item${group.items.length === 1 ? '' : 's'}`;
        left.appendChild(count);

        header.appendChild(left);

        const arrow = document.createElement('span');
        const collapsed = !!state.deductionCategoryCollapse[group.id];
        arrow.textContent = collapsed ? 'â¶' : 'â¼';
        header.appendChild(arrow);

        header.addEventListener('click', () => {
          const current = !!state.deductionCategoryCollapse[group.id];
          state.deductionCategoryCollapse[group.id] = !current;
          saveCache();
          renderDeductionsList();
        });

        container.appendChild(header);

        const body = document.createElement('div');
        body.style.marginTop = '8px';
        body.style.display = collapsed ? 'none' : 'block';

        group.items.forEach((deduction) => {
          const card = createDeductionCard(deduction, { hideCategoryBadge: true });
          body.appendChild(card);
        });

        container.appendChild(body);
        deductionsListEl.appendChild(container);
      });
    } else {
      list.forEach((deduction) => {
        const card = createDeductionCard(deduction, { hideCategoryBadge: false });
        deductionsListEl.appendChild(card);
      });
    }

    if (deductionCategoryCollapseControls) {
      deductionCategoryCollapseControls.style.display = (hasCustomCategories && hasItems) ? 'flex' : 'none';
    }

    renderAnnualCategorySection();
  }

function createDeductionCard(deduction, options = {}) {
    const hideCategoryBadge = !!options.hideCategoryBadge;
    const wrapper = document.createElement('div');
    wrapper.className = 'ts-item';
    if (!deduction.active || (deduction.company_expense && !state.companyTrackingEnabled)) {
      wrapper.classList.add('ts-deduction-readonly');
    }

    const details = document.createElement('div');
    details.className = 'ts-deduction-details';

    const header = document.createElement('div');
    header.className = 'ts-deduction-header';

    const title = document.createElement('div');
    title.style.fontWeight = '600';
    title.textContent = deduction.name || 'Untitled deduction';
    header.appendChild(title);

    if (!hideCategoryBadge && isDeductionCategoriesEnabled()) {
      const categoryMeta = getDeductionCategoryMeta(deduction.category_id);
      const categoryBadge = document.createElement('span');
      categoryBadge.className = 'ts-badge';
      categoryBadge.textContent = categoryMeta.name;
      categoryBadge.style.borderLeft = `4px solid ${categoryMeta.color || '#6b7280'}`;
      header.appendChild(categoryBadge);
    }

    const expenseBadge = document.createElement('span');
    expenseBadge.className = 'ts-badge';
    const isUnusedCompanyExpense = deduction.company_expense && !state.companyTrackingEnabled;
    expenseBadge.textContent = deduction.company_expense ? 'Company expense' : 'Salary sacrifice';
    header.appendChild(expenseBadge);

    // Add prominent warning indicator for unused company expenses
    if (isUnusedCompanyExpense) {
      const warningBadge = document.createElement('span');
      warningBadge.className = 'ts-badge';
      warningBadge.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align:middle;"><path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/></svg> Not used in calculations';
      warningBadge.style.cssText = 'background:var(--warning)20; color:var(--warning); border:1px solid var(--warning); font-weight:600;';
      warningBadge.title = 'Company expense tracking is disabled. This deduction is not included in any income calculations while the "Enable company income tracking" feature flag is disabled.';
      header.appendChild(warningBadge);
    }

    if (deduction.deduction_type === 'extra_super') {
      const typeBadge = document.createElement('span');
      typeBadge.className = 'ts-badge';
      typeBadge.textContent = 'Extra super';
      header.appendChild(typeBadge);
    }

    details.appendChild(header);

    const meta = document.createElement('div');
    meta.className = 'ts-deduction-meta';
    const amountSpan = document.createElement('span');
    amountSpan.textContent = formatDeductionAmount(deduction);
    if (deduction.company_expense && deduction.gst_inclusive && deduction.amount_type !== 'percent') {
      amountSpan.textContent += ' (GST excl.)';
      amountSpan.title = `Entered ${formatCurrency(deduction.amount_value)} incl. GST`;
    }
    meta.appendChild(amountSpan);

    const freqSpan = document.createElement('span');
    freqSpan.textContent = formatFrequencyLabel(deduction.frequency);
    meta.appendChild(freqSpan);

    const startSpan = document.createElement('span');
    startSpan.textContent = `Starts ${deduction.start_date ? DATE_FULL_FORMATTER.format(parseIsoDate(deduction.start_date)) : 'â'}`;
    meta.appendChild(startSpan);

    if (deduction.end_date) {
      const endSpan = document.createElement('span');
      endSpan.textContent = `Ends ${DATE_FULL_FORMATTER.format(parseIsoDate(deduction.end_date))}`;
      meta.appendChild(endSpan);
    }
    details.appendChild(meta);

    const upcomingDates = getUpcomingDeductionDates(deduction, 5);
    if (deduction.frequency !== 'once') {
      const occurrenceEl = document.createElement('span');
      occurrenceEl.className = 'ts-deduction-occurrences';
      if (upcomingDates.length) {
        occurrenceEl.textContent = `Next deduction on ${DATE_FULL_FORMATTER.format(parseIsoDate(upcomingDates[0]))}`;
      } else {
        occurrenceEl.textContent = 'No upcoming deductions scheduled.';
      }
      meta.appendChild(occurrenceEl);
    }

    if (deduction.notes) {
      const noteEl = document.createElement('div');
      noteEl.className = 'ts-deduction-note';
      noteEl.textContent = deduction.notes;
      details.appendChild(noteEl);
    }

    const actions = document.createElement('div');
    actions.className = 'ts-deduction-actions';

    const editBtn = document.createElement('button');
    editBtn.className = 'ghost small';
    editBtn.textContent = 'Edit';
    editBtn.addEventListener('click', () => openDeductionForm('edit', deduction));

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'ghost small danger';
    deleteBtn.textContent = 'Delete';
    deleteBtn.addEventListener('click', () => handleDeleteDeduction(deduction));

    const readOnly = (!deduction.active) || (deduction.company_expense && !state.companyTrackingEnabled);
    if (readOnly) {
      editBtn.disabled = true;
      deleteBtn.disabled = true;
      editBtn.title = 'Company tracking is disabled; this deduction is read-only.';
      deleteBtn.title = editBtn.title;
    }

    actions.appendChild(editBtn);
    actions.appendChild(deleteBtn);

    wrapper.appendChild(details);
    wrapper.appendChild(actions);
    return wrapper;
  }

  function resetDeductionForm() {
    if (!deductionNameInput) return;
    deductionFormState.mode = 'create';
    deductionFormState.editingId = null;
    deductionFormState.original = null;
    deductionNameInput.value = '';
    renderDeductionCategoryOptions('');
    if (deductionTypeSelect) deductionTypeSelect.value = 'standard';
    if (deductionAmountInput) deductionAmountInput.value = '';
    if (deductionPercentInput) deductionPercentInput.value = '';
    if (deductionAmountModeSelect) deductionAmountModeSelect.value = 'flat';
    if (deductionGstToggle) deductionGstToggle.checked = false;
    if (deductionCompanyToggle) deductionCompanyToggle.checked = false;
    if (deductionFrequencySelect) deductionFrequencySelect.value = 'once';
    if (deductionStartDateInput) deductionStartDateInput.value = todayIso();
    if (deductionEndDateInput) deductionEndDateInput.value = '';
    if (deductionNotesInput) deductionNotesInput.value = '';
    if (deductionOccurrencePreview) deductionOccurrencePreview.textContent = '';
    updateDeductionFormVisibility();
  }

  function closeDeductionForm() {
    deductionFormState.mode = 'create';
    deductionFormState.editingId = null;
    deductionFormState.original = null;
    hideModal(deductionFormModal);
  }

  function openDeductionForm(mode, deduction) {
    if (!deductionFormModal) return;
    if (mode === 'edit' && deduction && deduction.company_expense && !state.companyTrackingEnabled) {
      setStatus('Enable company tracking features to edit company deductions.', 'warn');
      return;
    }
    resetDeductionForm();
    deductionFormState.mode = mode;
    deductionFormState.editingId = deduction ? deduction.id : null;
    deductionFormState.original = deduction || null;
    if (deductionFormTitle) {
      deductionFormTitle.textContent = mode === 'edit' ? 'Edit deduction' : 'Add deduction';
    }
    if (mode === 'edit' && deduction) {
      if (deductionNameInput) deductionNameInput.value = deduction.name || '';
      renderDeductionCategoryOptions(deduction.category_id || '');
      if (deductionTypeSelect) deductionTypeSelect.value = deduction.deduction_type === 'extra_super' ? 'extra_super' : 'standard';
      if (deductionCompanyToggle) {
        deductionCompanyToggle.checked = !!(deduction.company_expense && state.companyTrackingEnabled && deduction.deduction_type !== 'extra_super');
      }
      const amountMode = deduction.amount_type === 'percent' ? 'percent' : 'flat';
      if (deductionAmountModeSelect) deductionAmountModeSelect.value = amountMode;
      if (amountMode === 'percent') {
        if (deductionPercentInput) {
          deductionPercentInput.value = Math.round((Number(deduction.amount_value) || 0) * 10000) / 100;
        }
      } else if (deductionAmountInput) {
        deductionAmountInput.value = Number(deduction.amount_value || 0).toFixed(2);
      }
      if (deductionGstToggle) deductionGstToggle.checked = !!deduction.gst_inclusive;
      if (deductionFrequencySelect) deductionFrequencySelect.value = deduction.frequency || 'once';
      if (deductionStartDateInput) deductionStartDateInput.value = deduction.start_date || '';
      if (deductionEndDateInput) deductionEndDateInput.value = deduction.end_date || '';
      if (deductionNotesInput) deductionNotesInput.value = deduction.notes || '';
    } else {
      renderDeductionCategoryOptions('');
    }
    updateDeductionFormVisibility();
    updateDeductionOccurrencePreview();
    showModal(deductionFormModal);
    if (deductionNameInput) deductionNameInput.focus();
  }

function updateDeductionFormVisibility() {
    if (!deductionTypeSelect) return;
    const type = deductionTypeSelect.value === 'extra_super' ? 'extra_super' : 'standard';
    const amountMode = type === 'extra_super' && deductionAmountModeSelect ? deductionAmountModeSelect.value : 'flat';
    const companyAllowed = state.companyTrackingEnabled;
    const companyExpense = companyAllowed && deductionCompanyToggle ? deductionCompanyToggle.checked : false;

    if (deductionCompanyWrapper) {
      deductionCompanyWrapper.style.display = companyAllowed ? 'flex' : 'none';
    }
    if (deductionCompanyToggle) {
      if (!companyAllowed) {
        deductionCompanyToggle.checked = false;
      }
      const shouldDisableCompanyToggle = !companyAllowed || type === 'extra_super';
      deductionCompanyToggle.disabled = shouldDisableCompanyToggle;
      if (shouldDisableCompanyToggle && deductionCompanyToggle.checked) {
        deductionCompanyToggle.checked = false;
      }
    }

    if (deductionAmountModeWrapper) {
      deductionAmountModeWrapper.style.display = type === 'extra_super' ? 'block' : 'none';
    }
    if (deductionPercentWrapper) {
      deductionPercentWrapper.style.display = type === 'extra_super' && amountMode === 'percent' ? 'block' : 'none';
    }
    if (deductionAmountWrapper) {
      deductionAmountWrapper.style.display = !(type === 'extra_super' && amountMode === 'percent') ? 'block' : 'none';
    }

    const showGstToggle = type === 'standard';
    if (deductionGstWrapper) {
      deductionGstWrapper.style.display = 'flex';
    }
    if (deductionGstToggle) {
      if (!showGstToggle) {
        deductionGstToggle.checked = false;
      }
      deductionGstToggle.disabled = !showGstToggle;
    }
    if (deductionCompanyGstNote) {
      if (companyExpense && showGstToggle) {
        deductionCompanyGstNote.style.display = 'block';
        deductionCompanyGstNote.textContent = 'GST component is tracked automatically when the amount includes GST.';
      } else {
        deductionCompanyGstNote.style.display = 'none';
      }
    }

    const restrictToMonthly = type === 'extra_super' && amountMode === 'percent';
    if (deductionFrequencySelect) {
      Array.from(deductionFrequencySelect.options).forEach((option) => {
        if (restrictToMonthly && option.value !== 'monthly') {
          option.disabled = true;
        } else {
          option.disabled = false;
        }
      });
      if (restrictToMonthly) {
        deductionFrequencySelect.value = 'monthly';
      }
    }

    if (deductionFrequencySelect && deductionFrequencySelect.value === 'once') {
      if (deductionEndDateWrapper) deductionEndDateWrapper.style.display = 'none';
      if (deductionEndDateInput) deductionEndDateInput.value = '';
    } else if (deductionEndDateWrapper) {
      deductionEndDateWrapper.style.display = 'block';
    }

    updateDeductionOccurrencePreview();
  }

  function updateDeductionOccurrencePreview() {
    if (!deductionOccurrencePreview || !deductionStartDateInput) return;
    const startDateValue = deductionStartDateInput.value;
    const frequency = deductionFrequencySelect ? deductionFrequencySelect.value : 'once';
    const endDateValue = deductionEndDateInput ? deductionEndDateInput.value : '';
    if (!startDateValue) {
      deductionOccurrencePreview.textContent = 'Select a start date to preview the schedule.';
      return;
    }
    const preview = {
      start_date: startDateValue,
      end_date: frequency === 'once' ? '' : endDateValue,
      frequency: frequency
    };
    const previewDates = getDeductionPreviewDates(preview, 5);
    if (!previewDates.length) {
      if (frequency === 'once') {
      deductionOccurrencePreview.textContent = `Occurs on ${DATE_FULL_FORMATTER.format(parseIsoDate(startDateValue))}.`;
      } else {
        deductionOccurrencePreview.textContent = 'No future occurrences within the configured range.';
      }
      return;
    }
    const labels = previewDates.map((iso) => DATE_FULL_FORMATTER.format(parseIsoDate(iso)));
    deductionOccurrencePreview.textContent = `Next ${labels.length > 1 ? labels.length : 1} deduction${labels.length > 1 ? 's' : ''}: ${labels.join(', ')}`;
  }

  function collectDeductionPayload() {
    if (!deductionNameInput) return null;
    const name = deductionNameInput.value.trim();
    if (!name) {
      setStatus('Deduction name is required.', 'warn');
      return null;
    }
    const type = deductionTypeSelect ? deductionTypeSelect.value : 'standard';
    const categoryId = (isDeductionCategoriesEnabled() && deductionCategorySelect) ? deductionCategorySelect.value : '';
    let companyExpense = state.companyTrackingEnabled && deductionCompanyToggle ? deductionCompanyToggle.checked : false;
    if (type === 'extra_super') {
      companyExpense = false;
    }
    const amountMode = type === 'extra_super' && deductionAmountModeSelect ? deductionAmountModeSelect.value : 'flat';
    let amountValue;
    if (amountMode === 'percent') {
      amountValue = Number(deductionPercentInput ? deductionPercentInput.value : '');
      if (!Number.isFinite(amountValue) || amountValue <= 0) {
        setStatus('Enter a valid percentage for the deduction.', 'warn');
        return null;
      }
      if (amountValue > 50) {
        setStatus('Percentage deductions must be 50% or less.', 'warn');
        return null;
      }
    } else {
      amountValue = Number(deductionAmountInput ? deductionAmountInput.value : '');
      if (!Number.isFinite(amountValue) || amountValue < 0) {
        setStatus('Enter a valid amount for the deduction.', 'warn');
        return null;
      }
    }
    const frequency = deductionFrequencySelect ? deductionFrequencySelect.value : 'once';
    const startDateValue = deductionStartDateInput ? deductionStartDateInput.value : '';
    if (!startDateValue) {
      setStatus('Select a start date for the deduction.', 'warn');
      return null;
    }
    let endDateValue = deductionEndDateInput ? deductionEndDateInput.value : '';
    if (frequency === 'once') {
      endDateValue = '';
    } else if (endDateValue && endDateValue < startDateValue) {
      setStatus('End date must be on or after the start date.', 'warn');
      return null;
    }
    const payload = {
      id: deductionFormState.mode === 'edit' ? deductionFormState.editingId : undefined,
      name,
      category_id: categoryId,
      company_expense: companyExpense,
      deduction_type: type,
      amount_type: amountMode,
      amount_value: amountValue,
      gst_inclusive: (type === 'standard' && companyExpense) ? (deductionGstToggle ? deductionGstToggle.checked : false) : false,
      frequency,
      start_date: startDateValue,
      end_date: endDateValue,
      notes: deductionNotesInput ? deductionNotesInput.value.trim() : '',
      active: true
    };
    if (payload.deduction_type === 'extra_super') {
      payload.company_expense = false;
      payload.gst_inclusive = false;
    }
    if (type === 'extra_super' && amountMode === 'percent') {
      payload.frequency = 'monthly';
    }
    return payload;
  }

  function buildOptimisticDeduction(payload, existing) {
    const nowIso = new Date().toISOString();
    const id = payload.id || `temp_${Date.now()}`;
    const amountDecimal = payload.amount_type === 'percent'
      ? (Number(payload.amount_value) / 100)
      : Number(payload.amount_value);
    const base = {
      id,
      name: payload.name,
      category_id: payload.category_id || '',
      company_expense: !!payload.company_expense,
      deduction_type: payload.deduction_type,
      amount_type: payload.amount_type,
      amount_value: payload.amount_type === 'percent' ? amountDecimal : amountDecimal,
      gst_inclusive: !!payload.gst_inclusive,
      gst_amount: payload.company_expense && payload.deduction_type === 'standard' && payload.gst_inclusive
        ? Math.round((Number(payload.amount_value) - (Number(payload.amount_value) / (1 + GST_RATE))) * 100) / 100
        : 0,
      frequency: payload.frequency,
      start_date: payload.start_date,
      end_date: payload.frequency === 'once' ? '' : payload.end_date,
      notes: payload.notes || '',
      active: true,
      created_at: existing && existing.created_at ? existing.created_at : nowIso,
      updated_at: nowIso
    };
    return sanitizeDeduction(base);
  }

  function deductionHasPastOccurrences(deduction) {
    if (!deduction || !deduction.start_date) return false;
    const today = startOfDay(new Date());
    const startDate = parseIsoDate(deduction.start_date);
    return startDate < today;
  }

  function findLastPastOccurrence(deduction) {
    if (!deduction || !deduction.start_date) return null;
    const today = startOfDay(new Date());
    const startDate = parseIsoDate(deduction.start_date);
    const endDate = deduction.end_date ? parseIsoDate(deduction.end_date) : null;

    if (startDate >= today) return null;

    const upperBound = endDate && endDate < today ? endDate : new Date(today.getTime() - 24 * 60 * 60 * 1000); // Yesterday

    if (deduction.frequency === 'once') {
      return startDate <= upperBound ? isoDate(startDate) : null;
    }

    let current = startOfDay(startDate);
    let lastPast = null;

    while (current && current <= upperBound) {
      lastPast = isoDate(current);
      current = nextOccurrenceDate(current, deduction.frequency);
      if (!current) break;
      if (endDate && current > endDate) break;
    }

    return lastPast;
  }

  function findNextFutureOccurrence(deduction) {
    if (!deduction || !deduction.start_date) return null;
    const today = startOfDay(new Date());
    const startDate = parseIsoDate(deduction.start_date);
    const endDate = deduction.end_date ? parseIsoDate(deduction.end_date) : null;

    if (startDate >= today) return isoDate(startDate);

    if (deduction.frequency === 'once') {
      return null; // One-time deduction in the past has no future occurrence
    }

    let current = startOfDay(startDate);

    while (current && current < today) {
      current = nextOccurrenceDate(current, deduction.frequency);
      if (!current) return null;
      if (endDate && current > endDate) return null;
    }

    return current ? isoDate(current) : null;
  }

  function performSplitDeduction(originalDeduction, newPayload) {
    const lastPastDate = findLastPastOccurrence(originalDeduction);
    const nextFutureDate = findNextFutureOccurrence(originalDeduction);

    if (!lastPastDate || !nextFutureDate) {
      // No split needed, just save normally
      saveDeductionDirectly(newPayload, originalDeduction);
      return;
    }

    // Step 1: Update original deduction with end date = last past occurrence
    const updatedOriginal = {
      ...originalDeduction,
      end_date: lastPastDate
    };

    // Step 2: Create new deduction with new settings starting from next future occurrence
    const newDeduction = {
      ...newPayload,
      id: undefined, // New UUID will be generated
      start_date: nextFutureDate
    };

    // Save both deductions
    setStatus('Splitting deduction...', 'warn');

    const previousList = state.deductions.slice();
    const revertOptimisticSplit = () => {
      state.deductions = previousList.slice();
      state.deductions = dedupeById(state.deductions);
      saveCache();
      renderDeductionsList();
      renderIncomeSummary();
      renderAnnualCategorySection();
    };

    const optimisticOriginal = sanitizeDeduction({ ...updatedOriginal });
    const optimisticNewId = `temp_split_${Date.now()}`;
    const optimisticNew = sanitizeDeduction({
      ...newDeduction,
      id: optimisticNewId
    });

    const originalIndex = state.deductions.findIndex((item) => item.id === originalDeduction.id);
    if (originalIndex !== -1) {
      state.deductions.splice(originalIndex, 1, optimisticOriginal);
    } else {
      state.deductions.push(optimisticOriginal);
    }
    state.deductions.push(optimisticNew);
    state.deductions = dedupeById(state.deductions);
    saveCache();
    renderDeductionsList();
    renderIncomeSummary();
    renderAnnualCategorySection();

    // First, update the original
    google.script.run
      .withSuccessHandler((res1) => {
        if (res1 && res1.success) {
          // Then create the new one
          google.script.run
            .withSuccessHandler((res2) => {
              if (res2 && res2.success) {
                // Reload deductions
                google.script.run
                  .withSuccessHandler((deductions) => {
                    state.deductions = dedupeById((deductions || []).map(sanitizeDeduction));
                    saveCache();
                    renderDeductionsList();
                    renderIncomeSummary();
                    renderAnnualCategorySection();
                    if (state.annualData) {
                      loadAnnualData();
                    }
                    setStatus('Deduction split successfully', 'success');
                  })
                  .withFailureHandler(() => {
                    revertOptimisticSplit();
                    setStatus('Failed to reload deductions', 'error');
                  })
                  .api_getDeductions();
              } else {
                revertOptimisticSplit();
                setStatus('Failed to create future deduction', 'error');
              }
            })
            .withFailureHandler(() => {
              revertOptimisticSplit();
              setStatus('Failed to create future deduction', 'error');
            })
            .api_upsertDeduction(newDeduction);
        } else {
          revertOptimisticSplit();
          setStatus('Failed to update past deduction', 'error');
        }
      })
      .withFailureHandler(() => {
        revertOptimisticSplit();
        setStatus('Failed to update past deduction', 'error');
      })
      .api_upsertDeduction(updatedOriginal);
  }

  function performOverrideDeduction(payload, originalDeduction) {
    // Delete all exceptions for this deduction
    if (originalDeduction && originalDeduction.id) {
      google.script.run
        .withSuccessHandler(() => {
          // Remove exceptions from local state
          state.deductionExceptions = state.deductionExceptions.filter(
            ex => ex.deduction_id !== originalDeduction.id
          );
          saveCache();

          // Now save the deduction normally
          saveDeductionDirectly(payload, originalDeduction);
        })
        .withFailureHandler(() => {
          setStatus('Failed to delete exceptions', 'error');
        })
        .api_deleteExceptionsByDeductionId(originalDeduction.id);
    } else {
      saveDeductionDirectly(payload, originalDeduction);
    }
  }

  function saveDeductionDirectly(payload, existing) {
    const isEdit = !!existing;
    const previousList = state.deductions.slice();
    const existingIndex = isEdit ? state.deductions.findIndex((item) => item.id === payload.id) : -1;
    const optimisticId = isEdit ? payload.id : `temp_${Date.now()}`;
    const optimisticDeduction = buildOptimisticDeduction({ ...payload, id: optimisticId }, existing);

    if (isEdit && existingIndex !== -1) {
      state.deductions.splice(existingIndex, 1, optimisticDeduction);
    } else {
      state.deductions.push(optimisticDeduction);
    }

    state.deductions = dedupeById(state.deductions);
    saveCache();
    renderDeductionsList();
    renderIncomeSummary();
    renderAnnualCategorySection();
    setStatus('Saving deduction...', 'warn');

    const serverPayload = { ...payload };

    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success && res.deduction) {
          const updated = sanitizeDeduction(res.deduction);
          const matchIndex = state.deductions.findIndex((item) => item.id === optimisticId);
          if (matchIndex !== -1) {
            state.deductions.splice(matchIndex, 1, updated);
          } else if (isEdit) {
            const editIndex = state.deductions.findIndex((item) => item.id === payload.id);
            if (editIndex !== -1) state.deductions.splice(editIndex, 1, updated);
          } else {
            state.deductions.push(updated);
          }
          state.deductions = dedupeById(state.deductions);
          saveCache();
          renderDeductionsList();
          renderIncomeSummary();
          renderAnnualCategorySection();
          if (state.annualData) {
            loadAnnualData();
          }
          setStatus('Deduction saved', 'success');
        } else {
          state.deductions = previousList;
          state.deductions = dedupeById(state.deductions);
          saveCache();
          renderDeductionsList();
          renderIncomeSummary();
          renderAnnualCategorySection();
          setStatus('Deduction save failed', 'error');
        }
      })
      .withFailureHandler(() => {
        state.deductions = previousList;
        state.deductions = dedupeById(state.deductions);
        saveCache();
        renderDeductionsList();
        renderIncomeSummary();
        renderAnnualCategorySection();
        setStatus('Deduction save failed', 'error');
      })
      .api_upsertDeduction(serverPayload);
  }

  function handleSaveDeduction() {
    const payload = collectDeductionPayload();
    if (!payload) return;
    const isEdit = deductionFormState.mode === 'edit' && deductionFormState.editingId;
    if (isEdit) {
      payload.id = deductionFormState.editingId;
    }
    const previousList = state.deductions.slice();
    const existingIndex = isEdit ? state.deductions.findIndex((item) => item.id === payload.id) : -1;
    const existing = existingIndex !== -1 ? state.deductions[existingIndex] : null;

    // Check if we need to show the split dialog
    if (isEdit && existing && deductionHasPastOccurrences(existing)) {
      // Store the payload and original for later
      pendingDeductionPayload = payload;
      originalDeductionForSplit = existing;

      // Close deduction form
      closeDeductionForm();

      // Show split decision modal
      showModal(modalSplitDeduction);
      return;
    }

    // No split needed, save normally
    closeDeductionForm();
    saveDeductionDirectly(payload, existing);
  }

  async function handleDeleteDeduction(deduction) {
    if (!deduction || !deduction.id) return;
    const confirmed = await customConfirm('Delete this deduction?', { danger: true });
    if (!confirmed) return;
    if (deduction.company_expense && !state.companyTrackingEnabled) {
      setStatus('Enable company tracking to modify company deductions.', 'warn');
      return;
    }
    const previousList = state.deductions.slice();
    state.deductions = state.deductions.filter((item) => item.id !== deduction.id);
    state.deductions = dedupeById(state.deductions);
    saveCache();
    renderDeductionsList();
    renderIncomeSummary();
    renderAnnualCategorySection();
    setStatus('Deleting deduction...', 'warn');
    google.script.run
      .withSuccessHandler(() => {
        if (state.annualData) {
          loadAnnualData();
        }
        setStatus('Deduction deleted', 'success');
      })
      .withFailureHandler(() => {
        state.deductions = previousList;
        state.deductions = dedupeById(state.deductions);
        saveCache();
        renderDeductionsList();
        renderIncomeSummary();
        renderAnnualCategorySection();
        setStatus('Failed to delete deduction', 'error');
      })
      .api_deleteDeduction(deduction.id);
  }

  function renderDeductionCategoryList() {
    if (!deductionCategoryList) return;
    const categories = [...state.deductionCategories].sort((a, b) => a.name.localeCompare(b.name));
    deductionCategoryList.innerHTML = '';
    if (!categories.length) {
      deductionCategoryDeleteId = null;
      if (deductionCategoryEmptyState) deductionCategoryEmptyState.style.display = 'block';
      return;
    }
    if (deductionCategoryEmptyState) deductionCategoryEmptyState.style.display = 'none';

    categories.forEach((category) => {
      const item = document.createElement('div');
      item.className = 'ts-item';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.justifyContent = 'space-between';

      const info = document.createElement('div');
      info.style.display = 'flex';
      info.style.alignItems = 'center';
      info.style.gap = '12px';

      const swatch = document.createElement('span');
      swatch.style.display = 'inline-block';
      swatch.style.width = '14px';
      swatch.style.height = '14px';
      swatch.style.borderRadius = '3px';
      swatch.style.backgroundColor = category.color || '#6b7280';
      info.appendChild(swatch);

      const name = document.createElement('span');
      name.textContent = category.name || 'Untitled category';
      info.appendChild(name);

      item.appendChild(info);

      const actions = document.createElement('div');
      actions.style.display = 'flex';
      actions.style.gap = '8px';

      if (deductionCategoryDeleteId === category.id) {
        const confirmText = document.createElement('span');
        confirmText.className = 'ts-note';
        confirmText.textContent = 'Delete this category?';
        actions.appendChild(confirmText);

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'ghost small';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.addEventListener('click', () => {
          deductionCategoryDeleteId = null;
          renderDeductionCategoryList();
        });

        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'ghost small danger';
        confirmBtn.textContent = 'Delete';
        confirmBtn.addEventListener('click', () => confirmDeleteDeductionCategory(category));

        actions.appendChild(cancelBtn);
        actions.appendChild(confirmBtn);
      } else {
        const editBtn = document.createElement('button');
        editBtn.className = 'ghost small';
        editBtn.textContent = 'Edit';
        editBtn.addEventListener('click', () => {
          showDeductionCategoryForm('edit', category);
        });

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'ghost small danger';
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', () => {
          deductionCategoryDeleteId = category.id;
          renderDeductionCategoryList();
        });

        actions.appendChild(editBtn);
        actions.appendChild(deleteBtn);
      }

      item.appendChild(actions);

      deductionCategoryList.appendChild(item);
    });
  }

  function openDeductionCategoryModal() {
    if (!modalDeductionCategories) return;
    deductionCategoryFormState.mode = 'list';
    deductionCategoryFormState.editingId = null;
    if (deductionCategoryFormWrapper) deductionCategoryFormWrapper.style.display = 'none';
    if (deductionCategoryListWrapper) deductionCategoryListWrapper.style.display = 'block';
    if (deductionCategoryListFooter) deductionCategoryListFooter.style.display = 'flex';
    if (deductionCategoryFormFooter) deductionCategoryFormFooter.style.display = 'none';
    if (btnAddDeductionCategory) btnAddDeductionCategory.style.display = 'inline-flex';
    renderDeductionCategoryList();
    showModal(modalDeductionCategories);
  }

  function closeDeductionCategoryModal() {
    if (modalDeductionCategories) hideModal(modalDeductionCategories);
    hideDeductionCategoryForm();
    deductionCategoryDeleteId = null;
    renderDeductionCategoryList();
    renderAnnualCategorySection();
  }

  function showDeductionCategoryForm(mode, category) {
    deductionCategoryFormState.mode = mode;
    deductionCategoryFormState.editingId = category ? category.id : null;
    deductionCategoryDeleteId = null;
    if (deductionCategoryNameInput) deductionCategoryNameInput.value = category ? category.name : '';
    if (deductionCategoryColorInput) deductionCategoryColorInput.value = category ? category.color : '#6b7280';
    if (deductionCategoryFormWrapper) deductionCategoryFormWrapper.style.display = 'block';
    if (deductionCategoryListWrapper) deductionCategoryListWrapper.style.display = 'none';
    if (deductionCategoryListFooter) deductionCategoryListFooter.style.display = 'none';
    if (deductionCategoryFormFooter) deductionCategoryFormFooter.style.display = 'flex';
    if (btnAddDeductionCategory) btnAddDeductionCategory.style.display = 'none';
    if (deductionCategoryNameInput) deductionCategoryNameInput.focus();
  }

  function hideDeductionCategoryForm() {
    deductionCategoryFormState.mode = 'list';
    deductionCategoryFormState.editingId = null;
    if (deductionCategoryNameInput) deductionCategoryNameInput.value = '';
    if (deductionCategoryColorInput) deductionCategoryColorInput.value = '#6b7280';
    if (deductionCategoryFormWrapper) deductionCategoryFormWrapper.style.display = 'none';
    if (deductionCategoryListWrapper) deductionCategoryListWrapper.style.display = 'block';
    if (deductionCategoryListFooter) deductionCategoryListFooter.style.display = 'flex';
    if (deductionCategoryFormFooter) deductionCategoryFormFooter.style.display = 'none';
    if (btnAddDeductionCategory) btnAddDeductionCategory.style.display = 'inline-flex';
    deductionCategorySavePending = false;
    if (btnSaveDeductionCategory) {
      btnSaveDeductionCategory.disabled = false;
      btnSaveDeductionCategory.textContent = 'Save category';
    }
  }

  function handleSaveDeductionCategory(event) {
    if (event) event.preventDefault();
    if (!deductionCategoryNameInput || !deductionCategoryColorInput) return;
    const name = deductionCategoryNameInput.value.trim();
    if (!name) {
      setStatus('Category name is required.', 'warn');
      return;
    }
    const color = deductionCategoryColorInput.value || '#6b7280';
    const payload = {
      id: deductionCategoryFormState.mode === 'edit' ? deductionCategoryFormState.editingId : undefined,
      name,
      color
    };
    if (deductionCategorySavePending) return;
    deductionCategorySavePending = true;
    if (btnSaveDeductionCategory) {
      btnSaveDeductionCategory.disabled = true;
      btnSaveDeductionCategory.textContent = 'Saving...';
    }

    const nowIso = new Date().toISOString();
    const isEdit = deductionCategoryFormState.mode === 'edit' && deductionCategoryFormState.editingId;
    const previousCategories = state.deductionCategories.slice();
    const previousMap = { ...state.deductionCategoryMap };
    const previousFilters = state.annualCategoryFilters.slice();
    const previousExpansion = { ...state.annualCategoryExpansion };

    const tempId = isEdit ? payload.id : `temp_category_${Date.now()}`;
    const optimisticCategory = sanitizeDeductionCategory({
      id: tempId,
      name,
      color,
      created_at: nowIso,
      updated_at: nowIso
    });

    if (isEdit) {
      const index = state.deductionCategories.findIndex((item) => item.id === payload.id);
      if (index !== -1) {
        state.deductionCategories.splice(index, 1, optimisticCategory);
      } else {
        state.deductionCategories.push(optimisticCategory);
      }
    } else {
      state.deductionCategories.push(optimisticCategory);
    }

    state.deductionCategories = dedupeById(state.deductionCategories);
    updateDeductionCategoryMap();
    ensureDeductionCategoryCollapseState();
    renderDeductionCategoryOptions(optimisticCategory.id);
    renderDeductionCategoryList();
    renderDeductionsList();
    renderAnnualCategorySection();
    saveCache();
    setStatus('Saving category...', 'warn');

    google.script.run
      .withSuccessHandler((res) => {
        deductionCategorySavePending = false;
        if (btnSaveDeductionCategory) {
          btnSaveDeductionCategory.disabled = false;
          btnSaveDeductionCategory.textContent = 'Save category';
        }
        if (res && res.success && res.category) {
          const updated = sanitizeDeductionCategory(res.category);
          const tempIndex = state.deductionCategories.findIndex((item) => item.id === optimisticCategory.id);
          if (tempIndex !== -1) {
            state.deductionCategories.splice(tempIndex, 1, updated);
          } else {
            const existingIndex = state.deductionCategories.findIndex((item) => item.id === updated.id);
            if (existingIndex !== -1) {
              state.deductionCategories.splice(existingIndex, 1, updated);
            } else {
              state.deductionCategories.push(updated);
            }
          }
          state.deductionCategories = dedupeById(state.deductionCategories);
          updateDeductionCategoryMap();
          ensureDeductionCategoryCollapseState();
          renderDeductionCategoryOptions(updated.id);
          renderDeductionCategoryList();
          renderDeductionsList();
          renderAnnualCategorySection();
          saveCache();
          setStatus('Category saved', 'success');
          hideDeductionCategoryForm();
          deductionCategoryDeleteId = null;
        } else {
          state.deductionCategories = previousCategories;
          state.deductionCategoryMap = previousMap;
          state.annualCategoryFilters = previousFilters;
          state.annualCategoryExpansion = previousExpansion;
          ensureDeductionCategoryCollapseState();
          renderDeductionCategoryOptions(payload.id || '');
          renderDeductionCategoryList();
          renderDeductionsList();
          renderAnnualCategorySection();
          saveCache();
          setStatus('Failed to save category', 'error');
        }
      })
      .withFailureHandler(() => {
        deductionCategorySavePending = false;
        if (btnSaveDeductionCategory) {
          btnSaveDeductionCategory.disabled = false;
          btnSaveDeductionCategory.textContent = 'Save category';
        }
        state.deductionCategories = previousCategories;
        state.deductionCategoryMap = previousMap;
        state.annualCategoryFilters = previousFilters;
        state.annualCategoryExpansion = previousExpansion;
        ensureDeductionCategoryCollapseState();
        renderDeductionCategoryOptions(payload.id || '');
        renderDeductionCategoryList();
        renderDeductionsList();
        renderAnnualCategorySection();
        saveCache();
        setStatus('Failed to save category', 'error');
      })
      .api_upsertDeductionCategory(payload);
  }

  function confirmDeleteDeductionCategory(category) {
    if (!category || !category.id) return;
    deductionCategoryDeleteId = null;
    const previousCategories = state.deductionCategories.slice();
    const previousMap = { ...state.deductionCategoryMap };
    const previousFilters = state.annualCategoryFilters.slice();
    const previousExpansion = { ...state.annualCategoryExpansion };
    const previousDeductions = state.deductions.map((item) => ({ ...item }));

    state.deductionCategories = state.deductionCategories.filter((item) => item.id !== category.id);
    state.deductions.forEach((deduction) => {
      if (deduction.category_id === category.id) {
        deduction.category_id = '';
      }
    });
    state.deductions = dedupeById(state.deductions);
    state.annualCategoryFilters = state.annualCategoryFilters.filter((id) => id !== category.id);
    delete state.annualCategoryExpansion[category.id];

    updateDeductionCategoryMap();
    ensureDeductionCategoryCollapseState();
    renderDeductionCategoryOptions('');
    renderDeductionCategoryList();
    renderDeductionsList();
    renderAnnualCategorySection();
    renderIncomeSummary();
    saveCache();
    setStatus('Deleting category...', 'warn');

    google.script.run
      .withSuccessHandler(() => {
        setStatus('Category deleted', 'success');
        renderAnnualCategorySection();
      })
      .withFailureHandler(() => {
        state.deductionCategories = previousCategories;
        state.deductionCategoryMap = previousMap;
        state.annualCategoryFilters = previousFilters;
        state.annualCategoryExpansion = previousExpansion;
        state.deductions = dedupeById(previousDeductions.map((item) => ({ ...item })));
        updateDeductionCategoryMap();
        ensureDeductionCategoryCollapseState();
        renderDeductionCategoryOptions('');
        renderDeductionCategoryList();
        renderDeductionsList();
        renderAnnualCategorySection();
        renderIncomeSummary();
        saveCache();
        setStatus('Failed to delete category', 'error');
      })
      .api_deleteDeductionCategory(category.id);
  }

  function loadDeductionCategories() {
    if (!isDeductionCategoriesEnabled()) {
      state.deductionCategories = [];
      state.annualCategoryFilters = [];
      state.annualCategoryExpansion = {};
      deductionCategoryDeleteId = null;
      updateDeductionCategoryMap();
      ensureDeductionCategoryCollapseState();
      renderDeductionCategoryOptions('');
      renderDeductionCategoryList();
      renderDeductionsList();
      renderAnnualCategorySection();
      saveCache();
      return;
    }
    renderDeductionCategoryOptions(deductionCategorySelect ? deductionCategorySelect.value : '');
    if (loadingDeductionCategories) return;
    loadingDeductionCategories = true;
    google.script.run
      .withSuccessHandler((categories) => {
        loadingDeductionCategories = false;
        deductionCategoryDeleteId = null;
        state.deductionCategories = Array.isArray(categories) ? categories.map(sanitizeDeductionCategory) : [];
        updateDeductionCategoryMap();
        ensureDeductionCategoryCollapseState();
        const currentSelection = deductionCategorySelect ? deductionCategorySelect.value : '';
        renderDeductionCategoryOptions(currentSelection);
        renderDeductionCategoryList();
        renderDeductionsList();
        renderAnnualCategorySection();
        saveCache();
      })
      .withFailureHandler(() => {
        loadingDeductionCategories = false;
        setStatus('Failed to load categories', 'error');
      })
      .api_getDeductionCategories();
  }

  const FEATURE_FLAG_GROUPS = [
    { id: 'income', title: 'Income', order: 100 },
    { id: 'time_entries', title: 'Time Entries', order: 200 },
    { id: 'company', title: 'Company', order: 300 },
    { id: 'utilities', title: 'Utilities', order: 400 },
    { id: 'accessibility', title: 'Accessibility', order: 500 }
  ];

  const FEATURE_FLAG_GROUP_MAP = FEATURE_FLAG_GROUPS.reduce((acc, group) => {
    acc[group.id] = group;
    return acc;
  }, {});

  const DEFAULT_FEATURE_FLAGS = {
    enable_deduction_categories: {
      name: 'Enable deduction tracking',
      description: 'Adds category management for deductions and groups them on the deductions page and annual reports.',
      order: 110,
      group: 'income'
    },
    enable_actual_income: {
      name: 'Enable actual income tracking',
      description: 'Allows recording actual income so you can compare estimated versus received amounts with variance indicators.',
      order: 120,
      group: 'income'
    },
    expected_monthly_hours: {
      name: 'Enable expected monthly hours insights',
      description: 'Adds a calendar badge that projects contract hours for the month and shows whether you are ahead or behind.',
      order: 130,
      group: 'income'
    },
    contract_rate_preview: {
      name: 'Enable contract rate preview page',
      description: 'Unlocks the rate preview view to model hourly rate changes and see their impact across a contract.',
      order: 140,
      group: 'income'
    },
    no_lost_super_to_deductions: {
      name: 'Reclaim lost super to deductions',
      description: 'Recovers super guarantee lost to pre-tax deductions. Configure the recovery method on the Settings tab.',
      order: 150,
      group: 'income'
    },
    default_inputs: {
      name: 'Enable default hours for time entries',
      description: 'Allows saving reusable entry templates that can be applied when adding new time entries.',
      order: 210,
      group: 'time_entries'
    },
    hour_types: {
      name: 'Enable multiple hour types',
      description: 'Lets you categorise hours (work, annual, sick, training, etc.) and visualise their impact on income.',
      order: 220,
      group: 'time_entries'
    },
    suggest_end_time: {
      name: 'Suggest exact end time',
      description: 'Uses your rounding rule and preferred finish time to recommend when to clock off for tidy totals.',
      order: 230,
      group: 'time_entries'
    },
    enable_public_holidays: {
      name: 'Enable automatic public holiday display',
      description: 'Automatically overlays Australian public holidays on the calendar view and keeps them in sync.',
      order: 240,
      group: 'time_entries'
    },
    xero_payroll_helper: {
      name: 'Enable Xero payroll helper',
      description: 'Adds a modal that slices the active month into Xero-aligned weekly ranges with cumulative hour totals.',
      order: 250,
      group: 'time_entries'
    },
    myob_payroll_helper: {
      name: 'Enable MYOB payroll helper',
      description: 'Adds a modal that groups the active month into MYOB-ready weekly totals with a monthly cross-check.',
      order: 260,
      group: 'time_entries'
    },
    enable_monthly_print_view: {
      name: 'Enable monthly hours print view',
      description: 'Adds a printable calendar showing hour breakdowns by type that fits on one A4 page for timesheets or records.',
      order: 270,
      group: 'time_entries'
    },
    enable_company_tracking_features: {
      name: 'Enable company income tracking',
      description: 'Unlocks company-focused features including company deductions, BAS reporting, and invoice tooling.',
      order: 310,
      group: 'company'
    },
    enable_company_quarterly_bas: {
      name: 'Switch from monthly to quarterly BAS reporting',
      description: 'Shows BAS reporting in quarterly totals instead of monthly when company income tracking is enabled.',
      order: 320,
      group: 'company'
    },
    enable_invoices: {
      name: 'Enable invoices page',
      description: 'Enables invoice management, default line items, and Google Docs generation using your template.',
      order: 330,
      group: 'company'
    },
    is_sole_trader: {
      name: 'Enable sole trader mode',
      description: 'Indicates the business operates as a sole trader and adjusts PAYG income calculations accordingly.',
      order: 340,
      group: 'company'
    },
    remember_last_page: {
      name: 'Remember last page on refresh',
      description: 'When enabled, the app reopens on the most recently viewed page after a reload.',
      order: 410,
      group: 'utilities'
    },
    show_zero_hours: {
      name: 'Show zero hours on days with no time entered',
      description: 'Displays a 0 for days without logged time instead of leaving them blank on the calendar.',
      order: 420,
      group: 'utilities'
    },
    show_clear_cache: {
      name: 'Show clear cache button',
      description: 'Adds a button to wipe cached entries, settings, and remembered preferences from this browser.',
      order: 430,
      group: 'utilities'
    },
    custom_theme: {
      name: 'Enable custom theme',
      description: 'Adds a Custom theme option with configurable colours.',
      order: 510,
      group: 'accessibility'
    },
    enable_colorblind_themes: {
      name: 'Enable colour blind themes',
      description: 'Adds colour-blind friendly theme presets and warns about difficult hour type colour combinations.',
      order: 520,
      group: 'accessibility'
    }
  };

  const DEDUCTION_FREQUENCIES = ['once', 'weekly', 'fortnightly', 'monthly', 'quarterly', 'yearly'];

  const THEME_KEYS = ['dark', 'light', 'og', 'rose', 'sierra117', 'protanopia', 'deuteranopia', 'tritanopia', 'monochrome', 'custom'];

  const CUSTOM_THEME_DEFAULTS = {
    bg: '#0b1220',
    panel: '#111d33',
    text: '#e8edf7',
    muted: '#a4b5d6',
    primary: '#3b82f6',
    success: '#22c55e',
    warning: '#fbbf24',
    danger: '#ef4444'
  };

  function getCustomThemeFlag() {
    const fromState = state && state.featureFlags ? state.featureFlags.custom_theme : null;
    const fromDefaults = DEFAULT_FEATURE_FLAGS ? DEFAULT_FEATURE_FLAGS.custom_theme : null;
    return fromState || fromDefaults || { enabled: false };
  }

  function isCustomThemeEnabled() {
    const flag = getCustomThemeFlag();
    return !!(flag && flag.enabled);
  }

  function getLastNonCustomTheme() {
    if (state && state.settings && state.settings.last_non_custom_theme && state.settings.last_non_custom_theme !== 'custom') {
      return state.settings.last_non_custom_theme;
    }
    return 'dark';
  }

  function updateCustomThemeControls(activeTheme) {
    const themeSelectEl = document.getElementById('set-theme');
    const customThemeOption = document.querySelector('.ts-custom-theme');
    const configureButton = document.getElementById('btn-configure-theme');
    const customEnabled = isCustomThemeEnabled();
    const currentTheme = activeTheme || (themeSelectEl ? themeSelectEl.value : (state.settings && state.settings.theme) || 'dark');

    if (!customEnabled && currentTheme === 'custom') {
      const fallback = getLastNonCustomTheme();
      if (themeSelectEl) themeSelectEl.value = fallback;
      applyTheme(fallback);
      if (typeof checkSettingsDirty === 'function') {
        checkSettingsDirty();
      }
      return;
    }

    if (customThemeOption) {
      customThemeOption.style.display = customEnabled ? 'block' : 'none';
    }

    if (configureButton) {
      const effectiveTheme = themeSelectEl ? themeSelectEl.value : currentTheme;
      configureButton.style.display = customEnabled && effectiveTheme === 'custom'
        ? 'inline-block'
        : 'none';
    }
  }

  function applyTheme(theme) {
    const normalizedTheme = (typeof theme === 'string' ? theme.trim().toLowerCase() : '');
    const normalized = THEME_KEYS.includes(normalizedTheme) ? normalizedTheme : 'dark';
    const body = document.body;
    THEME_KEYS.forEach((key) => body.classList.remove('ts-theme-' + key));
    body.classList.add('ts-theme-' + normalized);
    state.settings = { ...state.settings, theme: normalized };
    if (normalized !== 'custom') {
      state.settings.last_non_custom_theme = normalized;
    }
    if (themeSelect) themeSelect.value = normalized;

    // Apply custom theme if selected
    if (normalized === 'custom') {
      applyCustomTheme();
    }

    if (state.annualData) {
      renderAnnualData();
    }

    if (contractBurndownEl && state.selectedContractId) {
      const activeContract = getContractById(state.selectedContractId);
      if (activeContract) {
        const usage = computeContractUsage(activeContract);
        renderContractBurndown(activeContract, usage);
      }
    }

    updateCustomThemeControls(normalized);
  }

  function normalizeCustomThemeConfig(raw) {
    var base = { ...CUSTOM_THEME_DEFAULTS };
    if (raw && typeof raw === 'object') {
      Object.keys(raw).forEach(function(key) {
        if (raw[key]) {
          base[key] = raw[key];
        }
      });
    }

    if (!base.panel) {
      base.panel = isColorLight(base.bg) ? darken(base.bg, 0.12) : lighten(base.bg, 0.12);
    }
    if (!base.muted) {
      base.muted = mixColors(base.text, base.bg, 0.65);
    }
    if (!base.success) {
      base.success = CUSTOM_THEME_DEFAULTS.success;
    }
    if (!base.warning) {
      base.warning = adjustHue(base.primary, 35);
    }
    if (!base.danger) {
      base.danger = adjustHue(base.primary, -25);
    }

    return base;
  }

  // Color manipulation helpers
  function hexToRgb(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  function lighten(hex, amount) {
    var rgb = hexToRgb(hex);
    if (!rgb) return hex;
    var r = Math.min(255, Math.floor(rgb.r + (255 - rgb.r) * amount));
    var g = Math.min(255, Math.floor(rgb.g + (255 - rgb.g) * amount));
    var b = Math.min(255, Math.floor(rgb.b + (255 - rgb.b) * amount));
    return rgbToHex(r, g, b);
  }

  function darken(hex, amount) {
    var rgb = hexToRgb(hex);
    if (!rgb) return hex;
    var r = Math.floor(rgb.r * (1 - amount));
    var g = Math.floor(rgb.g * (1 - amount));
    var b = Math.floor(rgb.b * (1 - amount));
    return rgbToHex(r, g, b);
  }

  function adjustHue(hex, degrees) {
    var rgb = hexToRgb(hex);
    if (!rgb) return hex;

    // Convert to HSL
    var r = rgb.r / 255;
    var g = rgb.g / 255;
    var b = rgb.b / 255;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      if (max === r) h = (g - b) / d + (g < b ? 6 : 0);
      else if (max === g) h = (b - r) / d + 2;
      else h = (r - g) / d + 4;
      h /= 6;
    }

    // Adjust hue
    h = (h * 360 + degrees) % 360;
    if (h < 0) h += 360;
    h = h / 360;

    // Convert back to RGB
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);

    return rgbToHex(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255));
  }

  function withAlpha(hex, alpha) {
    var rgb = hexToRgb(hex);
    if (!rgb) return `rgba(15, 23, 42, ${alpha})`;
    return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
  }

  function clamp01(value) {
    if (value < 0) return 0;
    if (value > 1) return 1;
    return value;
  }

  function mixColors(hexA, hexB, weight) {
    var rgbA = hexToRgb(hexA);
    var rgbB = hexToRgb(hexB);
    var w = clamp01(typeof weight === 'number' ? weight : 0.5);

    if (!rgbA && !rgbB) return '#000000';
    if (!rgbA) return rgbToHex(rgbB.r, rgbB.g, rgbB.b);
    if (!rgbB) return rgbToHex(rgbA.r, rgbA.g, rgbA.b);

    var r = Math.round(rgbA.r * (1 - w) + rgbB.r * w);
    var g = Math.round(rgbA.g * (1 - w) + rgbB.g * w);
    var b = Math.round(rgbA.b * (1 - w) + rgbB.b * w);
    return rgbToHex(r, g, b);
  }

  function getLuminance(hex) {
    var rgb = hexToRgb(hex);
    if (!rgb) return 0;
    var channel = [rgb.r, rgb.g, rgb.b].map(function(component) {
      var c = component / 255;
      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    });
    return 0.2126 * channel[0] + 0.7152 * channel[1] + 0.0722 * channel[2];
  }

  function getContrastRatio(hexA, hexB) {
    var lumA = getLuminance(hexA);
    var lumB = getLuminance(hexB);
    var lighter = Math.max(lumA, lumB);
    var darker = Math.min(lumA, lumB);
    if (!lighter && !darker) return 1;
    return (lighter + 0.05) / (darker + 0.05);
  }

  function formatContrast(value) {
    if (!value || !isFinite(value)) return '0.00';
    return (Math.round(value * 100) / 100).toFixed(2);
  }

  function isColorLight(hex) {
    return getLuminance(hex) > 0.6;
  }

  function generateCustomTheme(config) {
    var normalized = normalizeCustomThemeConfig(config);
    var bg = normalized.bg;
    var panel = normalized.panel;
    var text = normalized.text;
    var muted = normalized.muted;
    var primary = normalized.primary;
    var success = normalized.success;
    var warning = normalized.warning;
    var danger = normalized.danger;

    var bgIsLight = isColorLight(bg);
    var panelIsLight = isColorLight(panel);

    var border = mixColors(panel, bg, 0.35);
    var surfaceSubtle = bgIsLight ? darken(bg, 0.04) : lighten(bg, 0.04);
    var focusRing = withAlpha(primary, 0.55);
    var primaryDark = darken(primary, 0.16);

    var primarySoftBg = withAlpha(primary, 0.18);
    var primarySoftBorder = withAlpha(primary, 0.65);
    var primarySoftText = panelIsLight ? darken(primary, 0.25) : lighten(primary, 0.25);
    var primaryGlow = withAlpha(primary, 0.3);
    var primaryHintBg = withAlpha(primary, 0.16);
    var primaryHintBorder = withAlpha(primary, 0.55);
    var hoverBg = withAlpha(primary, 0.12);

    var successText = isColorLight(success) ? darken(success, 0.3) : lighten(success, 0.3);
    var warningText = isColorLight(warning) ? darken(warning, 0.35) : lighten(warning, 0.35);
    var dangerText = isColorLight(danger) ? darken(danger, 0.35) : lighten(danger, 0.35);

    var badgeSuccessBg = withAlpha(success, 0.18);
    var badgeSuccessBorder = withAlpha(success, 0.55);
    var badgeWarnBg = withAlpha(warning, 0.18);
    var badgeWarnBorder = withAlpha(warning, 0.55);
    var badgeErrorBg = withAlpha(danger, 0.2);
    var badgeErrorBorder = withAlpha(danger, 0.6);

    var holidayBg = withAlpha(success, 0.18);
    var holidayBorder = withAlpha(success, 0.5);
    var holidayHover = withAlpha(success, 0.75);

    var calendarGlow = withAlpha(primary, 0.36);
    var calendarBg = withAlpha(primary, 0.22);

    return {
      '--bg': bg,
      '--panel': panel,
      '--muted': muted,
      '--text': text,
      '--primary': primary,
      '--primary-600': primaryDark,
      '--danger': danger,
      '--warning': warning,
      '--success': success,
      '--border': border,
      '--badge-bg': panel,
      '--badge-border': border,
      '--badge-text': text,
      '--badge-success-bg': badgeSuccessBg,
      '--badge-success-border': badgeSuccessBorder,
      '--badge-success-text': successText,
      '--badge-warn-bg': badgeWarnBg,
      '--badge-warn-border': badgeWarnBorder,
      '--badge-warn-text': warningText,
      '--badge-error-bg': badgeErrorBg,
      '--badge-error-border': badgeErrorBorder,
      '--badge-error-text': dangerText,
      '--primary-soft-bg': primarySoftBg,
      '--primary-soft-border': primarySoftBorder,
      '--primary-soft-text': primarySoftText,
      '--primary-glow': primaryGlow,
      '--primary-hint-bg': primaryHintBg,
      '--primary-hint-border': primaryHintBorder,
      '--hover-bg': hoverBg,
      '--border-color': border,
      '--text-secondary': muted,
      '--surface-subtle': surfaceSubtle,
      '--focus-ring': focusRing,
      '--holiday-bg': holidayBg,
      '--holiday-border': holidayBorder,
      '--holiday-hover': holidayHover,
      '--calendar-selected-border': primary,
      '--calendar-selected-glow': calendarGlow,
      '--calendar-selected-bg': calendarBg
    };
  }

  function applyCustomTheme() {
    var customThemeConfig = normalizeCustomThemeConfig(state.settings.custom_theme_config);
    state.settings.custom_theme_config = customThemeConfig;

    var themeVars = generateCustomTheme(customThemeConfig);

    // Find or create style element for custom theme
    var styleId = 'custom-theme-style';
    var styleEl = document.getElementById(styleId);
    if (!styleEl) {
      styleEl = document.createElement('style');
      styleEl.id = styleId;
      document.head.appendChild(styleEl);
    }

    var css = '.ts-theme-custom {';
    Object.keys(themeVars).forEach(function(key) {
      css += key + ': ' + themeVars[key] + ';';
    });
    css += '}';
    styleEl.textContent = css;
  }

  const normalizeFeatureFlags = (raw) => {
    const out = {};
    const defaults = DEFAULT_FEATURE_FLAGS || {};
    const rawKeys = raw && typeof raw === 'object' ? Object.keys(raw) : [];
    const combinedKeys = Array.from(new Set([...Object.keys(defaults), ...rawKeys]));
    combinedKeys.forEach((key) => {
      const rawValue = raw && raw[key];
      const enabled = rawValue && typeof rawValue === 'object'
        ? !!rawValue.enabled
        : !!rawValue;
      const fallback = defaults[key] || { name: key, description: '' };
      out[key] = {
        enabled,
        name: fallback.name || key,
        description: fallback.description || ''
      };
    });
    return out;
  };

  function updateContractMap() {
    state.contractMap = state.contracts.reduce((map, contract) => {
      map[contract.id] = contract;
      return map;
    }, {});
  }

  function updateHourTypeMap() {
    state.hourTypeMap = state.hourTypes.reduce((map, hourType) => {
      map[hourType.id] = hourType;
      return map;
    }, {});
  }

  function updateDeductionCategoryMap() {
    const map = {};
    state.deductionCategories.forEach((category) => {
      if (!category || !category.id) return;
      map[category.id] = category;
    });
    state.deductionCategoryMap = map;
  }

  function getDeductionCategoryMeta(categoryId) {
    if (!categoryId) {
      return { id: '', name: 'Uncategorised', color: '#6b7280' };
    }
    return state.deductionCategoryMap[categoryId] || {
      id: categoryId,
      name: 'Unknown category',
      color: '#6b7280'
    };
  }

  function renderDeductionCategoryOptions(selectedId) {
    if (!deductionCategorySelect) return;
    const enabled = isDeductionCategoriesEnabled();
    const priorValue = selectedId !== undefined ? selectedId : deductionCategorySelect.value;

    deductionCategorySelect.innerHTML = '';
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = 'Uncategorised';
    deductionCategorySelect.appendChild(defaultOption);

    if (enabled) {
      const sorted = [...state.deductionCategories].sort((a, b) => a.name.localeCompare(b.name));
      sorted.forEach((category) => {
        if (!category.id) return;
        const option = document.createElement('option');
        option.value = category.id;
        option.textContent = category.name || 'Untitled category';
        deductionCategorySelect.appendChild(option);
      });
    }

    if (priorValue && (priorValue === '' || state.deductionCategoryMap[priorValue])) {
      deductionCategorySelect.value = priorValue;
    } else {
      deductionCategorySelect.value = '';
    }

    deductionCategorySelect.disabled = !enabled;

    if (deductionCategoryEmptyNote) {
      deductionCategoryEmptyNote.style.display = enabled && state.deductionCategories.length === 0 ? 'block' : 'none';
    }
    if (deductionCategoryColumn) {
      deductionCategoryColumn.style.display = enabled ? 'block' : 'none';
    }

    const nameCol = deductionNameInput ? deductionNameInput.closest('.ts-col') : null;
    const typeCol = deductionTypeSelect ? deductionTypeSelect.closest('.ts-col') : null;
    if (nameCol && typeCol) {
      if (enabled) {
        nameCol.style.flex = '';
        nameCol.style.maxWidth = '';
        typeCol.style.flex = '';
        typeCol.style.maxWidth = '220px';
      } else {
        nameCol.style.flex = '1';
        nameCol.style.maxWidth = '';
        typeCol.style.flex = '1';
        typeCol.style.maxWidth = '';
      }
    }
  }

  function ensureDeductionCategoryCollapseState() {
    if (!state.deductionCategoryCollapse) state.deductionCategoryCollapse = {};
    const collapse = state.deductionCategoryCollapse;
    const validIds = state.deductionCategories.map((category) => category.id);
    validIds.forEach((id) => {
      if (!collapse.hasOwnProperty(id)) {
        collapse[id] = true;
      }
    });
    if (!collapse.hasOwnProperty('__uncategorised__')) {
      collapse.__uncategorised__ = true;
    }
    Object.keys(collapse).forEach((key) => {
      if (key === '__uncategorised__') return;
      if (!validIds.includes(key)) {
        delete collapse[key];
      }
    });
  }

  function setAllDeductionCategoryCollapse(collapsed) {
    ensureDeductionCategoryCollapseState();
    Object.keys(state.deductionCategoryCollapse).forEach((key) => {
      state.deductionCategoryCollapse[key] = collapsed;
    });
    saveCache();
    renderDeductionsList();
  }

  function setAllFeatureFlagCollapse(collapsed) {
    if (!state.featureFlagCollapse || typeof state.featureFlagCollapse !== 'object') {
      state.featureFlagCollapse = {};
    }
    const groupIds = new Set();
    FEATURE_FLAG_GROUPS.forEach((group) => {
      if (group && group.id) groupIds.add(group.id);
    });
    Object.keys(DEFAULT_FEATURE_FLAGS).forEach((key) => {
      const cfg = DEFAULT_FEATURE_FLAGS[key];
      const groupId = (cfg && cfg.group) ? cfg.group : 'other';
      groupIds.add(groupId);
    });
    const rawFlags = state.featureFlags && typeof state.featureFlags === 'object' ? state.featureFlags : {};
    Object.keys(rawFlags).forEach((key) => {
      const cfg = DEFAULT_FEATURE_FLAGS[key];
      const groupId = cfg && cfg.group ? cfg.group : 'other';
      groupIds.add(groupId);
    });
    groupIds.add('other');
    groupIds.forEach((groupId) => {
      if (groupId) {
        state.featureFlagCollapse[groupId] = collapsed;
      }
    });
    saveCache();
    renderFeatureFlags();
  }

  const contractIsValid = (contract, dateIso) => {
    if (!contract || !dateIso) return false;
    if (contract.start_date && contract.start_date > dateIso) return false;
    if (contract.end_date && contract.end_date !== '' && contract.end_date < dateIso) return false;
    return true;
  };

  function validContractsForDate(dateIso) {
    if (!dateIso) return [];
    return state.contracts.filter((contract) => contractIsValid(contract, dateIso));
  }

  function getContractName(id) {
    if (!id) return '';
    const match = state.contractMap[id];
    if (match) return match.name;
    return '';
  }

  const contractBadge = (entry) => {
    const name = getContractName(entry.contract_id);
    if (name) return `<span class="ts-badge">${name}</span>`;
    if (entry.contract_id) return `<span class="ts-badge warn">Unknown contract</span>`;
    return `<span class="ts-badge warn">No contract</span>`;
  };

  function dedupeById(list) {
    if (!Array.isArray(list)) return [];
    const seen = new Set();
    const result = [];
    list.forEach((item) => {
      if (!item || !item.id) return;
      if (seen.has(item.id)) return;
      seen.add(item.id);
      result.push(item);
    });
    return result;
  }

  function loadCache() {
    try {
      const raw = localStorage.getItem(state.cacheKey);
      if (!raw) return;
      const obj = JSON.parse(raw);
      state.entries = Array.isArray(obj.entries) ? obj.entries.map(sanitizeEntry) : [];
      state.settings = obj.settings || {};
      state.contracts = Array.isArray(obj.contracts) ? obj.contracts.map(sanitizeContract) : [];
      state.hourTypes = Array.isArray(obj.hourTypes) ? obj.hourTypes.map(sanitizeHourType) : [];
      state.deductions = Array.isArray(obj.deductions) ? dedupeById(obj.deductions.map(sanitizeDeduction)) : [];
      state.deductionCategories = Array.isArray(obj.deductionCategories) ? obj.deductionCategories.map(sanitizeDeductionCategory) : [];
      state.deductionCategoryCollapse = obj.deductionCategoryCollapse && typeof obj.deductionCategoryCollapse === 'object'
        ? { ...obj.deductionCategoryCollapse }
        : {};
      state.featureFlagCollapse = obj.featureFlagCollapse && typeof obj.featureFlagCollapse === 'object'
        ? { ...obj.featureFlagCollapse }
        : {};
      state.deductionExceptions = Array.isArray(obj.deductionExceptions) ? obj.deductionExceptions.map(sanitizeDeductionException) : [];
      if (obj.basCurrentFy != null) state.basCurrentFy = Number(obj.basCurrentFy);
      state.featureFlags = normalizeFeatureFlags(obj.featureFlags);
      state.publicHolidays = Array.isArray(obj.publicHolidays) ? obj.publicHolidays : [];
      state.actualIncome = Array.isArray(obj.actualIncome) ? obj.actualIncome : [];
      state.annualCategoryFilters = Array.isArray(obj.annualCategoryFilters) ? obj.annualCategoryFilters.slice() : [];
      state.annualCategoryExpansion = obj.annualCategoryExpansion && typeof obj.annualCategoryExpansion === 'object'
        ? { ...obj.annualCategoryExpansion }
        : {};
      state.invoices = Array.isArray(obj.invoices) ? obj.invoices.map((invoice) => ({ ...invoice })) : [];
      updateInvoiceMaps();
      state.invoiceDefaults = Array.isArray(obj.invoiceDefaults) ? obj.invoiceDefaults.map((item) => ({ ...item })) : [];
      state.invoiceDefaultMap = state.invoiceDefaults.reduce((acc, item) => {
        if (item && item.id) acc[item.id] = item;
        return acc;
      }, {});
      if (obj.invoiceFilters && typeof obj.invoiceFilters === 'object') {
        state.invoiceFilters = {
          year: obj.invoiceFilters.year != null ? String(obj.invoiceFilters.year) : '',
          month: obj.invoiceFilters.month != null ? String(obj.invoiceFilters.month) : ''
        };
      } else {
        state.invoiceFilters = { year: '', month: '' };
      }
      state.invoiceSelectedId = obj.invoiceSelectedId || '';
      if (obj.invoiceDetail && obj.invoiceDetail.invoice) {
        const detailLineItems = Array.isArray(obj.invoiceDetail.lineItems) ? obj.invoiceDetail.lineItems.map((item) => ({ ...item })) : [];
        const detailSummary = obj.invoiceDetail.summary || summarizeInvoiceLineItems(detailLineItems);
        state.invoiceDetail = {
          invoice: { ...obj.invoiceDetail.invoice },
          lineItems: detailLineItems,
          summary: detailSummary
        };
      } else {
        state.invoiceDetail = null;
      }
      state.invoiceDetailLoading = false;
      state.invoiceListLoading = false;
      state.invoicesInitialized = Array.isArray(state.invoices) && state.invoices.length > 0;
      updatePublicHolidayMap();
      refreshActualIncomeMap();
      updateDeductionCategoryMap();
      ensureDeductionCategoryCollapseState();
      ensureInvoiceFormOptions();

      // Set initial tab based on today's entry type
      const today = todayIso();
      const todayEntry = state.entries.find(entry => entry.date === today);
      if (resolveEntryType(todayEntry) === 'advanced') {
        activateTab('punch');
        if (punchDate) punchDate.value = today;
        ensurePunchDraft(todayEntry.contract_id);
      }
      updateTabStates();
      updateContractMap();
      updateHourTypeMap();
      applyTheme((state.settings && state.settings.theme) || 'dark');
    } catch (e) {}
  }
  function saveCache() {
    try {
      const invoicesForCache = Array.isArray(state.invoices) ? state.invoices.map((invoice) => ({ ...invoice })) : [];
      const invoiceDefaultsForCache = Array.isArray(state.invoiceDefaults) ? state.invoiceDefaults.map((item) => ({ ...item })) : [];
      const invoiceDetailForCache = (state.invoiceDetail && state.invoiceDetail.invoice)
        ? {
            invoice: { ...state.invoiceDetail.invoice },
            lineItems: Array.isArray(state.invoiceDetail.lineItems) ? state.invoiceDetail.lineItems.map((item) => ({ ...item })) : [],
            summary: state.invoiceDetail.summary ? { ...state.invoiceDetail.summary } : null
          }
        : null;
      const invoiceFiltersForCache = {
        year: state.invoiceFilters && state.invoiceFilters.year != null ? String(state.invoiceFilters.year) : '',
        month: state.invoiceFilters && state.invoiceFilters.month != null ? String(state.invoiceFilters.month) : ''
      };
      const payload = {
        entries: state.entries.map(sanitizeEntry),
        settings: state.settings,
        contracts: state.contracts.map(sanitizeContract),
        hourTypes: state.hourTypes.map(sanitizeHourType),
        deductions: state.deductions.map(sanitizeDeduction),
        deductionCategories: state.deductionCategories.map(sanitizeDeductionCategory),
        deductionCategoryCollapse: state.deductionCategoryCollapse,
        featureFlagCollapse: state.featureFlagCollapse,
        deductionExceptions: state.deductionExceptions.map(sanitizeDeductionException),
        annualCategoryFilters: state.annualCategoryFilters,
        annualCategoryExpansion: state.annualCategoryExpansion,
        featureFlags: normalizeFeatureFlags(state.featureFlags),
        basCurrentFy: state.basCurrentFy,
        publicHolidays: state.publicHolidays,
        actualIncome: state.actualIncome,
        invoices: invoicesForCache,
        invoiceDefaults: invoiceDefaultsForCache,
        invoiceFilters: invoiceFiltersForCache,
        invoiceSelectedId: state.invoiceSelectedId,
        invoiceDetail: invoiceDetailForCache
      };
      localStorage.setItem(state.cacheKey, JSON.stringify(payload));
    } catch (e) {}
  }

  // Tabs
  function activateTab(id) {
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;

    // With hour types enabled, allow switching between tabs to create entries for different hour types
    if (!hourTypesEnabled) {
      // Original validation logic when hour types are disabled
      const isEditingEntry = state.editingEntryId && state.currentTab !== id;
      const isEditingPunch = state.punchDraft && state.punchDraft.dirty && state.currentTab !== id;

      const isWrongEntryType = state.editingEntryId && (
        (state.editingEntryType === 'basic' && id === 'punch') ||
        (state.editingEntryType === 'advanced' && id === 'manual')
      );

      const hasConflictingData = (() => {
        if (!state.selectedCalendarDate) return false;
        const existingEntry = state.entries.find(entry => entry.date === state.selectedCalendarDate);
        if (!existingEntry) return false;

        const entryType = resolveEntryType(existingEntry);
        if (id === 'manual' && entryType === 'advanced') return true;
        if (id === 'punch' && entryType === 'basic') return true;

        return false;
      })();

      if (isEditingEntry || isEditingPunch || isWrongEntryType || hasConflictingData) {
        return;
      }
    } else {
      // With hour types enabled, only prevent switching if the current entry has unsaved changes
      const hasUnsavedChanges = state.punchDraft && state.punchDraft.dirty && state.currentTab !== id;
      if (hasUnsavedChanges) {
        return;
      }
    }
    
    // Update tab visual states
    $$('.ts-tab').forEach((tab) => {
      const target = tab.getAttribute('data-tab');
      tab.classList.toggle('active', target === id);
    });
    updateTabStates();
    ['manual', 'punch'].forEach((pane) => {
      const el = document.getElementById('tab-' + pane);
      if (el) el.style.display = pane === id ? 'block' : 'none';
    });

    const previousTab = state.currentTab;
    const switchingTabs = previousTab && previousTab !== id;

    // When switching tabs with hour types enabled, preserve hour type and date
    if (hourTypesEnabled && switchingTabs) {
      let currentDate = null;
      let currentHourType = null;

      // Get current values from the previous tab
      if (previousTab === 'manual' && manualDate && manualHourType) {
        currentDate = manualDate.value;
        currentHourType = manualHourType.value;
      } else if (previousTab === 'punch' && punchDate && punchHourType) {
        currentDate = punchDate.value;
        currentHourType = punchHourType.value;
      }

      // Apply to the new tab
      if (id === 'punch' && currentDate && currentHourType) {
        if (punchDate) punchDate.value = currentDate;
        if (punchHourType) punchHourType.value = currentHourType;

        // Check if there's ANY entry (basic or advanced) for this date + hour type
        const anyEntry = state.entries.find(e =>
          e.date === currentDate &&
          (e.hour_type_id || getDefaultHourTypeId()) === currentHourType
        );
        const anyEntryType = anyEntry ? resolveEntryType(anyEntry) : null;

        if (anyEntryType === 'basic') {
          // Hour type exists as basic entry - prevent switching to advanced
          // Switch back to the original tab
          state.currentTab = previousTab;
          $$('.ts-tab').forEach((tab) => {
            const target = tab.getAttribute('data-tab');
            tab.classList.toggle('active', target === previousTab);
          });
          ['manual', 'punch'].forEach((pane) => {
            const el = document.getElementById('tab-' + pane);
            if (el) el.style.display = pane === previousTab ? 'block' : 'none';
          });
          customAlert('This hour type already has a basic entry for this date. Please use the hour type dropdown to switch between different hour types.');
          return;
        }

        if (anyEntryType === 'advanced') {
          const existingEntry = anyEntry;
          // Load existing entry
          state.editingEntryId = existingEntry.id;
          state.editingEntryType = anyEntryType;
          updatePunchContractOptions(existingEntry.contract_id);
          if (punchContract) punchContract.value = existingEntry.contract_id || '';
          state.punchDraft = {
            entryId: existingEntry.id,
            contractId: existingEntry.contract_id || '',
            date: existingEntry.date,
            punches: clonePunches(existingEntry.punches || []),
            dirty: false
          };
          renderPunchDraft();
          updatePunchSummary();
        } else {
          // Create new entry
          state.editingEntryId = null;
          state.editingEntryType = null;
          updatePunchContractOptions();
          state.punchDraft = {
            entryId: null,
            contractId: punchContract ? punchContract.value : '',
            date: currentDate,
            punches: [{ in: '', out: '' }],
            dirty: false
          };
          renderPunchDraft();
          updatePunchSummary();
        }
        updatePunchContractVisibility();
      } else if (id === 'manual' && currentDate && currentHourType) {
        if (manualDate) manualDate.value = currentDate;
        if (manualHourType) manualHourType.value = currentHourType;

        // Check if there's ANY entry (basic or advanced) for this date + hour type
        const anyEntry = state.entries.find(e =>
          e.date === currentDate &&
          (e.hour_type_id || getDefaultHourTypeId()) === currentHourType
        );
        const anyEntryType = anyEntry ? resolveEntryType(anyEntry) : null;

        if (anyEntryType === 'advanced') {
          // Hour type exists as advanced entry - prevent switching to basic
          // Switch back to the original tab
          state.currentTab = previousTab;
          $$('.ts-tab').forEach((tab) => {
            const target = tab.getAttribute('data-tab');
            tab.classList.toggle('active', target === previousTab);
          });
          ['manual', 'punch'].forEach((pane) => {
            const el = document.getElementById('tab-' + pane);
            if (el) el.style.display = pane === previousTab ? 'block' : 'none';
          });
          customAlert('This hour type already has an advanced entry for this date. Please use the hour type dropdown to switch between different hour types.');
          return;
        }

        if (anyEntryType === 'basic') {
          // Load existing entry
          populateManualForm(anyEntry, true);
        } else {
          // Create new entry
          clearManualEditing();
          if (manualDate) manualDate.value = currentDate;
          if (manualHourType) manualHourType.value = currentHourType;
          updateManualContractVisibility();
        }
      }
    } else if (id === 'punch' && state.selectedCalendarDate && punchDate) {
      // Original behavior when hour types disabled
      punchDate.value = state.selectedCalendarDate;
      state.punchDraft = null;
      ensurePunchDraft();
    }

    state.currentTab = id;
  }
  $$('.ts-tab').forEach((tab) => {
    tab.addEventListener('click', () => activateTab(tab.getAttribute('data-tab')));
  });

  // Function to update tab disabled states
  function updateTabStates() {
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;

    $$('.ts-tab').forEach((tab) => {
      const target = tab.getAttribute('data-tab');

      // Check if this tab should be disabled
      let isDisabled = false;
      let disabledReason = '';

      if (hourTypesEnabled && state.selectedCalendarDate) {
        // With hour types enabled, check if the CURRENT hour type has an entry in the opposite format
        const currentHourType = state.currentTab === 'manual'
          ? (manualHourType ? manualHourType.value : getDefaultHourTypeId())
          : (punchHourType ? punchHourType.value : getDefaultHourTypeId());

        const existingEntry = state.entries.find(entry =>
          entry.date === state.selectedCalendarDate &&
          (entry.hour_type_id || getDefaultHourTypeId()) === currentHourType
        );

        if (existingEntry) {
          const entryType = resolveEntryType(existingEntry);
          // Disable basic tab if current hour type has advanced entry
          if (target === 'manual' && entryType === 'advanced') {
            isDisabled = true;
            disabledReason = 'This hour type has an advanced entry for this date';
          }
          // Disable advanced tab if current hour type has basic entry
          if (target === 'punch' && entryType === 'basic') {
            isDisabled = true;
            disabledReason = 'This hour type has a basic entry for this date';
          }
        }
      } else if (!hourTypesEnabled && state.selectedCalendarDate) {
        // Original behavior when hour types disabled
        const existingEntry = state.entries.find(entry => entry.date === state.selectedCalendarDate);
        if (existingEntry) {
          const entryType = resolveEntryType(existingEntry);
          // Disable basic tab if date has advanced entry
          if (target === 'manual' && entryType === 'advanced') {
            isDisabled = true;
            disabledReason = 'This date already has an advanced entry';
          }
          // Disable advanced tab if date has basic entry
          if (target === 'punch' && entryType === 'basic') {
            isDisabled = true;
            disabledReason = 'This date already has a basic entry';
          }
        }
      }

      tab.style.opacity = isDisabled ? '0.4' : '1';
      tab.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
      tab.title = disabledReason;
    });
  }

  // Default to manual tab initially (will be updated after cache loads)
  activateTab('manual');

  // Punch controls
  const punchDate = document.getElementById('punch-date');
  const punchHourType = document.getElementById('punch-hour-type');
  const punchHourTypeCol = document.getElementById('punch-hour-type-col');
  const punchContract = document.getElementById('punch-contract');
  const punchContractWarning = document.getElementById('punch-contract-warning');
  const punchToggleBtn = document.getElementById('btn-punch-toggle');
  const punchSaveBtn = document.getElementById('btn-punch-save');
  const punchCancelBtn = document.getElementById('btn-punch-cancel');
  const punchDeleteBtn = document.getElementById('btn-delete-punch');
  const punchList = document.getElementById('punch-range-list');
  const punchOpenWarning = document.getElementById('punch-open-warning');
  const punchSummary = document.getElementById('punch-summary');
  const punchSuggestion = document.getElementById('punch-suggestion');

  function currentPunchDate() {
    return punchDate && punchDate.value ? punchDate.value : todayIso();
  }

  function updatePunchContractOptions(preferredContractId) {
    if (!punchContract) return '';
    const dateIso = currentPunchDate();
    const valid = validContractsForDate(dateIso);
    const currentValue = preferredContractId != null ? preferredContractId : punchContract.value;
    const options = [...valid];
    if (currentValue && !options.some((contract) => contract.id === currentValue)) {
      const fallback = state.contractMap[currentValue];
      if (fallback) options.push(fallback);
    }
    options.sort((a, b) => a.name.localeCompare(b.name));
    punchContract.innerHTML = '';
    if (!options.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts';
      punchContract.appendChild(placeholder);
      punchContract.value = '';
      punchContract.disabled = true;
      if (punchContractWarning) punchContractWarning.style.display = 'block';
      return '';
    }
    if (options.length > 1) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select contract';
      punchContract.appendChild(placeholder);
    }
    options.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      punchContract.appendChild(opt);
    });
    let selected = currentValue && options.some((contract) => contract.id === currentValue) ? currentValue : '';
    if (!selected && valid.length === 1) {
      selected = valid[0].id;
    }
    punchContract.value = selected;
    punchContract.disabled = valid.length === 1 && options.length === valid.length;
    if (punchContractWarning) punchContractWarning.style.display = selected ? 'none' : 'block';
    return punchContract.value;
  }

  function setPunchDate(dateIso, preferredContractId) {
    if (!punchDate) return;
    punchDate.value = dateIso || todayIso();
    updatePunchContractOptions(preferredContractId != null ? preferredContractId : (punchContract ? punchContract.value : ''));
  }

  function ensurePunchDraft(preferredContractId) {
    const selected = updatePunchContractOptions(preferredContractId);
    const contractId = selected || '';
    const dateIso = currentPunchDate();
    
    // If we're switching dates and there's no contract selected, start fresh
    if (!contractId) {
      state.punchDraft = {
        entryId: null,
        contractId: '',
        date: dateIso,
        punches: [{ in: '', out: '' }],
        dirty: false
      };
      renderPunchDraft();
      return;
    }
    
    // Look for existing entry for this specific date and contract
    const entry = state.entries.find((e) => e.date === dateIso && e.contract_id === contractId) || null;
    state.punchDraft = {
      entryId: entry ? entry.id : null,
      contractId,
      date: dateIso,
      punches: entry ? clonePunches(entry.punches || []) : [{ in: '', out: '' }],
      dirty: false
    };

    // Set hour type if editing existing entry
    if (punchHourType && entry && entry.hour_type_id) {
      punchHourType.value = entry.hour_type_id;
      updatePunchContractVisibility();
    }

    renderPunchDraft();
  }

  function setPunchDraftDirty() {
    if (!state.punchDraft) return;
    state.punchDraft.dirty = true;
  }

  function renderPunchDraft() {
    if (!punchList) return;
    punchList.innerHTML = '';
    const draft = state.punchDraft || { punches: [], contractId: '' };
    const punches = draft.punches || [];
    if (!draft.contractId) {
      const note = document.createElement('div');
      note.className = 'ts-note';
      note.textContent = 'Select a contract to view today\'s punches.';
      punchList.appendChild(note);
    } else if (!punches.length || (punches.length === 1 && !punches[0].in)) {
      // Show an empty range for new entries
      const emptyRange = document.createElement('div');
      emptyRange.className = 'ts-punch-row';
      const startInput = document.createElement('input');
      startInput.type = 'time';
      startInput.value = punches.length > 0 ? (punches[0].in || '') : '';
      startInput.className = 'ts-punch-input';
      startInput.onchange = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches[0].in = startInput.value;
        setPunchDraftDirty();
        updatePunchSummary();
      };
      const endInput = document.createElement('input');
      endInput.type = 'time';
      endInput.value = punches.length > 0 ? (punches[0].out || '') : '';
      endInput.className = 'ts-punch-input';
      endInput.onchange = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches[0].out = endInput.value;
        setPunchDraftDirty();
        updatePunchSummary();
      };
      const addBtn = document.createElement('button');
      addBtn.type = 'button';
      addBtn.className = 'ghost';
      addBtn.textContent = 'Add';
      addBtn.onclick = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches.push({ in: '', out: '' });
        setPunchDraftDirty();
        renderPunchDraft();
        // Focus on the new row's start input
        setTimeout(() => {
          const newRow = punchList.children[punchList.children.length - 1];
          const newStartInput = newRow.querySelector('input[type="time"]');
          if (newStartInput) newStartInput.focus();
        }, 0);
      };
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'ghost';
      removeBtn.textContent = 'Remove';
      removeBtn.onclick = () => {
        if (draft.punches.length) draft.punches.splice(0, 1);
        setPunchDraftDirty();
        renderPunchDraft();
      };
      emptyRange.appendChild(startInput);
      emptyRange.appendChild(document.createTextNode(' to '));
      emptyRange.appendChild(endInput);
      emptyRange.appendChild(addBtn);
      emptyRange.appendChild(removeBtn);
      punchList.appendChild(emptyRange);
    } else {
      punches.forEach((punch, index) => {
        const row = document.createElement('div');
        row.className = 'ts-punch-row';
        const startInput = document.createElement('input');
        startInput.type = 'time';
        startInput.value = punch.in || '';
        startInput.className = 'ts-punch-input';
        startInput.onchange = () => {
          draft.punches[index].in = startInput.value;
          setPunchDraftDirty();
          updatePunchSummary();
        };
        const endInput = document.createElement('input');
        endInput.type = 'time';
        endInput.value = punch.out || '';
        endInput.className = 'ts-punch-input';
        endInput.onchange = () => {
          draft.punches[index].out = endInput.value;
          setPunchDraftDirty();
          updatePunchSummary();
        };
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'ghost';
        addBtn.textContent = 'Add';
        addBtn.onclick = () => {
          // Insert new punch after current index
          draft.punches.splice(index + 1, 0, { in: '', out: '' });
          setPunchDraftDirty();
          renderPunchDraft();
          // Focus on the new row's start input
          setTimeout(() => {
            const allRows = punchList.children;
            const newRowIndex = index + 1;
            if (allRows[newRowIndex]) {
              const newStartInput = allRows[newRowIndex].querySelector('input[type="time"]');
              if (newStartInput) newStartInput.focus();
            }
          }, 0);
        };
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'ghost';
        removeBtn.textContent = 'Remove';
        removeBtn.onclick = () => {
          draft.punches.splice(index, 1);
          setPunchDraftDirty();
          renderPunchDraft();
        };
        row.appendChild(startInput);
        row.appendChild(document.createTextNode(' to '));
        row.appendChild(endInput);
        row.appendChild(addBtn);
        row.appendChild(removeBtn);
        punchList.appendChild(row);
      });
    }
    updatePunchSummary();
    const hasContract = !!draft.contractId;
    const hasPunches = punches.length > 0;
    const openCount = summarizePunches(punches).openCount;
    if (punchToggleBtn) {
      punchToggleBtn.textContent = openCount > 0 ? 'Punch Out' : 'Punch In';
      punchToggleBtn.disabled = !hasContract;
    }
    if (punchSaveBtn) {
      punchSaveBtn.disabled = !hasContract || !hasPunches;
      punchSaveBtn.textContent = draft.entryId ? 'Update Entry' : 'Add Entry';
    }
    if (punchCancelBtn) {
      punchCancelBtn.disabled = !hasContract || !draft.dirty;
      punchCancelBtn.style.display = draft.dirty ? 'inline-flex' : 'none';
    }
    if (punchDeleteBtn) {
      punchDeleteBtn.style.display = draft.entryId ? 'inline-flex' : 'none';
    }
  }

  function calculateEndTimeSuggestion(punches, openPunch, roundingMinutes, minimumEndTime) {
    // Calculate total minutes from closed punches
    var closedMinutes = 0;
    for (var i = 0; i < punches.length; i++) {
      if (punches[i].in && punches[i].out) {
        var inParts = punches[i].in.split(':');
        var outParts = punches[i].out.split(':');
        var inMinutes = parseInt(inParts[0], 10) * 60 + parseInt(inParts[1], 10);
        var outMinutes = parseInt(outParts[0], 10) * 60 + parseInt(outParts[1], 10);
        closedMinutes += (outMinutes - inMinutes);
      }
    }

    // Calculate minutes from open punch to current time
    var inParts = openPunch.in.split(':');
    var inMinutes = parseInt(inParts[0], 10) * 60 + parseInt(inParts[1], 10);

    // Parse minimum end time
    var minEndParts = minimumEndTime.split(':');
    var minEndMinutes = parseInt(minEndParts[0], 10) * 60 + parseInt(minEndParts[1], 10);

    // Calculate current total if we were to clock out at minimum end time
    var currentTotal = closedMinutes + (minEndMinutes - inMinutes);

    // If the open punch hasn't reached minimum end time yet, no suggestion
    if (minEndMinutes < inMinutes) {
      return null;
    }

    // Calculate what the rounded total should be
    var roundedTotal = Math.ceil(currentTotal / roundingMinutes) * roundingMinutes;

    // Calculate suggested clock-out time
    var suggestedMinutes = inMinutes + (roundedTotal - closedMinutes);

    // Make sure it's within the valid range
    var maxEndMinutes = minEndMinutes + roundingMinutes;
    if (suggestedMinutes < minEndMinutes || suggestedMinutes > maxEndMinutes) {
      return null;
    }

    // Format the suggested time
    var suggestedHours = Math.floor(suggestedMinutes / 60);
    var suggestedMins = suggestedMinutes % 60;
    var suggestedTime = String(suggestedHours).padStart(2, '0') + ':' + String(suggestedMins).padStart(2, '0');

    // Format the total hours
    var totalHours = roundedTotal / 60;
    var formattedTotal = formatHours(roundedTotal);

    // Determine AM/PM
    var period = suggestedHours >= 12 ? 'pm' : 'am';
    var displayHours = suggestedHours > 12 ? suggestedHours - 12 : (suggestedHours === 0 ? 12 : suggestedHours);
    var displayTime = displayHours + ':' + String(suggestedMins).padStart(2, '0') + ' ' + period;

    return {
      time: suggestedTime,
      total: formattedTotal,
      message: 'Clock out at ' + displayTime + ' to round out your hours nicely to ' + formattedTotal
    };
  }

  function updatePunchSummary() {
    if (!punchSummary || !punchOpenWarning || !punchSuggestion) return;
    const draft = state.punchDraft || { punches: [] };
    const punches = normalizePunchList(draft.punches || []);
    const summary = summarizePunches(punches);
    if (punches.length) {
      const rounded = summary.totalMinutes > 0 ? roundDuration(summary.totalMinutes) : 0;
      punchSummary.textContent = `Recorded: ${formatHours(rounded)} hours`;
    } else {
      punchSummary.textContent = '';
    }
    if (summary.openCount > 0) {
      const lastOpen = punches.find((p) => !p.out);
      punchOpenWarning.textContent = lastOpen && lastOpen.in ? `Open punch since ${lastOpen.in}. Remember to punch out.` : 'Open punch detected. Please punch out when you finish.';
      punchOpenWarning.style.display = 'block';
    } else {
      punchOpenWarning.style.display = 'none';
    }

    // Calculate and display end time suggestion
    const suggestEndTimeEnabled = getFeatureFlag('suggest_end_time');
    if (suggestEndTimeEnabled && punches.length > 1 && summary.openCount > 0) {
      const lastOpen = punches.find((p) => !p.out);
      if (lastOpen && lastOpen.in) {
        const roundingMinutes = parseInt(state.settings.round_to_nearest, 10) || 0;
        const minimumEndTime = state.settings.minimum_end_time || '17:00';

        if (roundingMinutes > 0) {
          const suggestion = calculateEndTimeSuggestion(punches, lastOpen, roundingMinutes, minimumEndTime);
          if (suggestion) {
            punchSuggestion.textContent = suggestion.message;
            punchSuggestion.style.display = 'block';
          } else {
            punchSuggestion.style.display = 'none';
          }
        } else {
          punchSuggestion.style.display = 'none';
        }
      } else {
        punchSuggestion.style.display = 'none';
      }
    } else {
      punchSuggestion.style.display = 'none';
    }
  }

  function addPunchRow() {
    if (!state.punchDraft) return;
    state.punchDraft.punches.push({ in: '', out: '' });
    setPunchDraftDirty();
    renderPunchDraft();
  }

  function persistPunchDraft(options = {}) {
    const { requireClosed = false } = options;
    const draft = state.punchDraft;

    // Get hour type
    const hourTypeId = punchHourType ? punchHourType.value : getDefaultHourTypeId();
    const selectedHourType = state.hourTypeMap[hourTypeId];

    // Check for duplicate hour type on the same date (when not editing)
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
    if (hourTypesEnabled && draft && !draft.entryId) {
      const duplicateEntry = state.entries.find(e =>
        e.date === draft.date &&
        (e.hour_type_id || getDefaultHourTypeId()) === hourTypeId &&
        e.id !== draft.entryId
      );
      if (duplicateEntry) {
        const hourTypeName = selectedHourType?.name || 'Work';
        customAlert(`An entry with hour type "${hourTypeName}" already exists for ${draft.date}. Please switch to that hour type to edit it.`);
        return;
      }
    }

    // Validate contract based on hour type
    if (selectedHourType && selectedHourType.requires_contract) {
      if (!draft || !draft.contractId) {
        customAlert('Select a contract before saving punches.');
        return;
      }
    }

    const punches = normalizePunchList(draft.punches || []);
    const validationError = validatePunches(punches, { allowOpen: !requireClosed, requireClosed });
    if (validationError) {
      customAlert(validationError);
      return;
    }
    const summary = summarizePunches(punches);
    const roundedMinutes = summary.totalMinutes > 0 ? roundDuration(summary.totalMinutes) : 0;
    const payload = {
      date: draft.date,
      contract_id: draft.contractId || '',
      hour_type_id: hourTypeId,
      punches,
      duration_minutes: roundedMinutes,
      round_interval: getRoundInterval(),
      entry_type: 'advanced'
    };
    if (draft.entryId) payload.id = draft.entryId;

    // Optimistic update: Add entry to UI immediately for new entries
    let optimisticEntry = null;
    if (!draft.entryId) {
      optimisticEntry = {
        id: 'temp_' + Date.now(),
        ...payload,
        created_at: isoDateTime(new Date())
      };
      state.entries.unshift(sanitizeEntry(optimisticEntry));
      saveCache();
      renderEntries();
    }

    setStatus('Saving punches...', 'warn');
    renderPunchDraft();

    const onSuccess = (res) => {
      if (res && res.success && res.entry) {
        const sanitized = sanitizeEntry(res.entry);
        if (optimisticEntry) {
          // Replace optimistic entry with real one
          const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
          if (idx > -1) {
            state.entries[idx] = sanitized;
          }
        } else {
          // Update existing entry
          const idx = state.entries.findIndex((e) => e.id === sanitized.id);
          if (idx > -1) {
            state.entries[idx] = sanitized;
          } else {
            state.entries.push(sanitized);
          }
        }
        state.punchDraft = {
          entryId: sanitized.id,
          contractId: sanitized.contract_id,
          date: sanitized.date,
          punches: clonePunches(sanitized.punches || []),
          dirty: false
        };
        saveCache();
        renderEntries();
        setStatus('Punches saved', 'success');
      } else {
        // Remove optimistic entry on failure
        if (optimisticEntry) {
          const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
          if (idx > -1) {
            state.entries.splice(idx, 1);
            saveCache();
            renderEntries();
          }
        }
        setStatus('Punch save failed', 'error');
      }
      renderPunchDraft();
    };

    const onFailure = () => {
      // Remove optimistic entry on failure
      if (optimisticEntry) {
        const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
        if (idx > -1) {
          state.entries.splice(idx, 1);
          saveCache();
          renderEntries();
        }
      }
      setStatus('Punch save failed', 'error');
      renderPunchDraft();
    };

    if (draft.entryId) {
      google.script.run
        .withSuccessHandler(onSuccess)
        .withFailureHandler(onFailure)
        .api_updateEntry(payload);
    } else {
      google.script.run
        .withSuccessHandler(onSuccess)
        .withFailureHandler(onFailure)
        .api_addEntry(payload);
    }
  }

  function handlePunchToggle() {
    const draft = state.punchDraft;
    if (!draft || !draft.contractId) {
      customAlert('Select a contract before punching in.');
      return;
    }
    const now = new Date();
    const currentTime = now.toTimeString().slice(0, 5);
    const punches = draft.punches || [];
    
    // Look for an open punch (has in but no out)
    const openIndex = punches.findIndex((punch) => punch && punch.in && !punch.out);
    if (openIndex !== -1) {
      // Punch out - close the open punch
      draft.punches[openIndex].out = currentTime;
    } else {
      // Punch in - add a new punch or populate the first empty range
      if (punches.length === 0) {
        draft.punches.push({ in: currentTime, out: '' });
      } else {
        // Find the first empty range (no in time) and populate it
        const firstEmpty = punches.findIndex(punch => !punch.in);
        if (firstEmpty !== -1) {
          draft.punches[firstEmpty].in = currentTime;
        } else {
          draft.punches.push({ in: currentTime, out: '' });
        }
      }
    }
    setPunchDraftDirty();
    renderPunchDraft();
    persistPunchDraft({ requireClosed: false });
  }

  function handlePunchSave() {
    persistPunchDraft({ requireClosed: false });
  }

  function handlePunchDiscard() {
    if (!state.punchDraft) return;
    ensurePunchDraft(state.punchDraft.contractId);
  }

  async function handlePunchDelete() {
    if (!state.punchDraft || !state.punchDraft.entryId) return;

    const confirmed = await customConfirm(
      'Are you sure you want to delete this entry? This action cannot be undone.',
      { danger: true }
    );
    if (!confirmed) return;

    const entryId = state.punchDraft.entryId;
    const currentDate = state.punchDraft.date;

    // Optimistic delete: Remove from local state immediately
    const idx = state.entries.findIndex(e => e.id === entryId);
    if (idx === -1) return;

    const backup = state.entries[idx];
    state.entries.splice(idx, 1);

    // Clear punch draft and start fresh
    state.punchDraft = null;
    if (punchDate) punchDate.value = currentDate;
    ensurePunchDraft();

    saveCache();
    renderEntries();
    updateTabStates();
    setStatus('Deleting entry...', 'warn');

    google.script.run
      .withSuccessHandler(() => {
        setStatus('Entry deleted', 'success');
      })
      .withFailureHandler(() => {
        // Rollback: restore the entry
        state.entries.splice(idx, 0, backup);
        saveCache();
        renderEntries();
        updateTabStates();
        setStatus('Delete failed', 'error');
      })
      .api_deleteEntry(entryId);
  }

  if (punchToggleBtn) punchToggleBtn.onclick = handlePunchToggle;
  if (punchSaveBtn) punchSaveBtn.onclick = handlePunchSave;
  if (punchCancelBtn) punchCancelBtn.onclick = handlePunchDiscard;
  if (punchDeleteBtn) punchDeleteBtn.onclick = handlePunchDelete;
  if (punchDate) {
    punchDate.addEventListener('change', () => {
      state.selectedCalendarDate = punchDate.value;
      // Clear any existing draft when date changes
      state.punchDraft = null;
      updatePunchContractOptions();
      ensurePunchDraft();
    });
  }
  if (punchContract) {
    punchContract.addEventListener('change', () => {
      ensurePunchDraft(punchContract.value);
    });
  }

  // Manual form helpers
  const manualDate = document.getElementById('manual-date');
  const manualHourType = document.getElementById('manual-hour-type');
  const manualHourTypeCol = document.getElementById('manual-hour-type-col');
  const manualContract = document.getElementById('manual-contract');
  const manualContractWarning = document.getElementById('manual-contract-warning');
  const manualHoursInput = document.getElementById('manual-hours');
  const manualSaveBtn = document.getElementById('btn-add-manual');
  const manualCancelBtn = document.getElementById('btn-cancel-edit');
  const manualDeleteBtn = document.getElementById('btn-delete-manual');

  function updateBasicSaveEnabled() {
    if (!manualSaveBtn) return;

    const hours = Number(manualHoursInput ? manualHoursInput.value : '');
    const validHours = Number.isFinite(hours) && hours > 0;

    // Check if contract is required based on hour type
    let contractValid = true;
    if (manualHourType && manualHourType.value) {
      const selectedHourType = state.hourTypeMap[manualHourType.value];
      if (selectedHourType && selectedHourType.requires_contract) {
        contractValid = !!(manualContract && manualContract.value);
      }
    } else {
      // Default behavior when no hour type selected or feature disabled
      contractValid = !!(manualContract && manualContract.value);
    }

    manualSaveBtn.disabled = !(contractValid && validHours);
  }

  function updateManualContractOptions(preferredContractId) {
    if (!manualContract) return '';
    const dateIso = manualDate && manualDate.value ? manualDate.value : todayIso();
    const valid = validContractsForDate(dateIso);
    const currentValue = preferredContractId != null ? preferredContractId : manualContract.value;
    const options = [...valid];
    if (currentValue && !options.some((contract) => contract.id === currentValue)) {
      const fallback = state.contractMap[currentValue];
      if (fallback) options.push(fallback);
    }
    options.sort((a, b) => a.name.localeCompare(b.name));
    manualContract.innerHTML = '';
    if (!options.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts';
      manualContract.appendChild(placeholder);
      manualContract.value = '';
      manualContract.disabled = true;
      if (manualContractWarning) manualContractWarning.style.display = 'block';
      updateBasicSaveEnabled();
      return '';
    }
    if (options.length > 1) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select contract';
      manualContract.appendChild(placeholder);
    }
    options.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      manualContract.appendChild(opt);
    });
    let selected = currentValue && options.some((contract) => contract.id === currentValue) ? currentValue : '';
    if (!selected && valid.length === 1) {
      selected = valid[0].id;
    }
    manualContract.value = selected;
    manualContract.disabled = valid.length === 1 && options.length === valid.length;
    if (manualContractWarning) manualContractWarning.style.display = manualContract.value ? 'none' : 'block';
    updateBasicSaveEnabled();
    return manualContract.value;
  }

  function refreshContractBindings(preferredManualContractId, preferredPunchContractId) {
    updateContractMap();
    const manualDateIso = manualDate && manualDate.value ? manualDate.value : todayIso();
    const manualPreferred = preferredManualContractId && contractIsValid(state.contractMap[preferredManualContractId], manualDateIso)
      ? preferredManualContractId
      : undefined;
    const punchPreferred = preferredPunchContractId && contractIsValid(state.contractMap[preferredPunchContractId], currentPunchDate())
      ? preferredPunchContractId
      : undefined;
    updateManualContractOptions(manualPreferred);
    ensurePunchDraft(punchPreferred);
    renderContractsUI();
  }

  function setManualDate(dateIso, preferredContractId) {
    if (!manualDate) return;
    manualDate.value = dateIso || todayIso();
    updateManualContractOptions(preferredContractId != null ? preferredContractId : (manualContract ? manualContract.value : ''));
  }

  function setManualMode(isEdit) {
    if (manualSaveBtn) manualSaveBtn.textContent = isEdit ? 'Update Entry' : 'Add Entry';
    if (manualCancelBtn) manualCancelBtn.style.display = isEdit ? 'inline-flex' : 'none';
    if (manualDeleteBtn) manualDeleteBtn.style.display = isEdit ? 'inline-flex' : 'none';
  }

  function populateManualForm(entry, isEdit) {
    showPage('time');
    state.currentTab = 'manual';
    activateTab('manual');
    const preferredDate = entry.date || todayIso();
    const preferredContractId = entry.contract_id || '';
    setManualDate(preferredDate, preferredContractId);
    const punches = entryPunches(entry);
    let totalMinutes = punches.reduce((acc, punch) => {
      const start = timeToMinutes(punch.in);
      const end = timeToMinutes(punch.out);
      if (start === null || end === null || end <= start) return acc;
      return acc + (end - start);
    }, 0);
    if (!totalMinutes && entry.duration_minutes != null) {
      totalMinutes = Number(entry.duration_minutes);
    }
    if (manualHoursInput) {
      const hoursValue = totalMinutes > 0 ? formatDecimalHours(totalMinutes / 60) : '';
      manualHoursInput.value = hoursValue ? hoursValue : '';
    }
    // Set hour type
    if (manualHourType && entry.hour_type_id) {
      manualHourType.value = entry.hour_type_id;
      updateManualContractVisibility();
    }

    state.editingEntryId = isEdit ? entry.id : null;
    state.editingEntryType = isEdit ? (entry.entry_type || 'basic') : null;
    setManualMode(!!isEdit);
    if (isEdit && manualHoursInput) manualHoursInput.focus();
    updateBasicSaveEnabled();
  }

  function clearManualEditing() {
    state.editingEntryId = null;
    state.editingEntryType = null;
    state.currentTab = 'manual';
    setManualMode(false);
    if (manualHoursInput) manualHoursInput.value = '';
    updateManualContractOptions();
    updateBasicSaveEnabled();
  }

  function getManualPayload() {
    const date = manualDate.value || todayIso();
    if (!date) {
      customAlert('Date is required.');
      return null;
    }
    const hoursRaw = manualHoursInput ? manualHoursInput.value.trim() : '';
    const totalHours = Number(hoursRaw);
    if (!Number.isFinite(totalHours) || totalHours <= 0) {
      customAlert('Enter the total number of hours worked.');
      return null;
    }
    const totalMinutes = Math.round(totalHours * 60);
    if (totalMinutes > 24 * 60) {
      customAlert('Total hours must be within a single day (24 hours or less).');
      return null;
    }
    if (totalMinutes <= 0) {
      customAlert('Total hours must be greater than zero.');
      return null;
    }
    // Get hour type
    const hourTypeId = manualHourType ? manualHourType.value : getDefaultHourTypeId();
    const selectedHourType = state.hourTypeMap[hourTypeId];

    // Check for duplicate hour type on the same date (when not editing)
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
    if (hourTypesEnabled && !state.editingEntryId) {
      const duplicateEntry = state.entries.find(e =>
        e.date === date &&
        (e.hour_type_id || getDefaultHourTypeId()) === hourTypeId &&
        e.id !== state.editingEntryId
      );
      if (duplicateEntry) {
        const hourTypeName = selectedHourType?.name || 'Work';
        customAlert(`An entry with hour type "${hourTypeName}" already exists for ${date}. Please switch to that hour type to edit it.`);
        return null;
      }
    }

    // Validate contract based on hour type
    const contractId = manualContract ? manualContract.value : '';
    if (selectedHourType && selectedHourType.requires_contract) {
      if (!contractId) {
        customAlert('Select a contract for this date.');
        return null;
      }
      const contract = state.contractMap[contractId];
      if (!contract) {
        customAlert('Selected contract is no longer available.');
        return null;
      }
      if (!contractIsValid(contract, date) && !state.editingEntryId) {
        customAlert('Selected contract is not valid for this date.');
        return null;
      }
    }

    const punches = [{ in: '00:00', out: minutesToTime(totalMinutes) }];
    const roundedMinutes = roundDuration(totalMinutes);
    return {
      date,
      punches,
      duration_minutes: roundedMinutes,
      contract_id: contractId,
      hour_type_id: hourTypeId,
      round_interval: getRoundInterval(),
      entry_type: 'basic'
    };
  }

  manualSaveBtn.onclick = function () {
    const payload = getManualPayload();
    if (!payload) return;
    if (state.editingEntryId) {
      const idx = state.entries.findIndex((e) => e.id === state.editingEntryId);
      if (idx === -1) return;
      const backup = { ...state.entries[idx] };
      const update = { id: state.editingEntryId, ...payload };
      state.entries[idx] = sanitizeEntry({ ...backup, ...update });
      saveCache();
      renderEntries();
      setStatus('Saving...', 'warn');
      google.script.run
        .withSuccessHandler((res) => {
          if (res && res.success) {
            state.entries[idx] = sanitizeEntry(res.entry);
            clearManualEditing();
            saveCache();
            renderEntries();
            ensurePunchDraft(payload.contract_id);
            setStatus('Saved', 'success');
          } else {
            state.entries[idx] = backup;
            saveCache();
            renderEntries();
            setStatus('Save failed', 'error');
          }
        })
        .withFailureHandler(() => {
          state.entries[idx] = backup;
          saveCache();
          renderEntries();
          setStatus('Save failed', 'error');
        })
        .api_updateEntry(update);
    } else {
      const now = new Date();
      const entry = {
        id: 'temp_' + Date.now(),
        ...payload,
        created_at: isoDateTime(now)
      };
      state.entries.unshift(sanitizeEntry(entry));
      saveCache();
      renderEntries();
      clearManualEditing();
      setStatus('Saving...', 'warn');
      google.script.run
        .withSuccessHandler((res) => {
          if (res && res.success) {
            const idx = state.entries.findIndex((e) => e.id === entry.id);
            if (idx > -1) state.entries[idx] = sanitizeEntry(res.entry);
            saveCache();
            renderEntries();
            ensurePunchDraft(payload.contract_id);
            setStatus('Saved', 'success');
          } else {
            setStatus('Save failed', 'error');
          }
        })
        .withFailureHandler(() => setStatus('Save failed (offline?)', 'error'))
        .api_addEntry(entry);
    }
    state.selectedCalendarDate = payload.date;
    setManualDate(state.selectedCalendarDate, payload.contract_id);
    renderCalendar();
  };
  manualCancelBtn.onclick = function () {
    clearManualEditing();
    activateTab('manual');
  };

  if (manualDeleteBtn) {
    manualDeleteBtn.onclick = async function () {
      if (!state.editingEntryId) return;

      const confirmed = await customConfirm(
        'Are you sure you want to delete this entry? This action cannot be undone.',
        { danger: true }
      );
      if (!confirmed) return;

      const entryId = state.editingEntryId;
      const currentDate = manualDate ? manualDate.value : todayIso();

      // Optimistic delete: Remove from local state immediately
      const idx = state.entries.findIndex(e => e.id === entryId);
      if (idx === -1) return;

      const backup = state.entries[idx];
      state.entries.splice(idx, 1);

      // Clear editing state and reset form
      clearManualEditing();
      setManualDate(currentDate);

      saveCache();
      renderEntries();
      updateTabStates();
      setStatus('Deleting entry...', 'warn');

      google.script.run
        .withSuccessHandler(() => {
          setStatus('Entry deleted', 'success');
        })
        .withFailureHandler(() => {
          // Rollback: restore the entry
          state.entries.splice(idx, 0, backup);
          saveCache();
          renderEntries();
          updateTabStates();
          setStatus('Delete failed', 'error');
        })
        .api_deleteEntry(entryId);
    };
  }

  if (manualDate) {
    manualDate.addEventListener('change', () => {
      const newDate = manualDate.value;
      const oldDate = state.selectedCalendarDate;
      
      // If we're editing an entry and the date changed, assume changes were discarded
      if (state.editingEntryId && newDate !== oldDate) {
        clearManualEditing();
        state.selectedCalendarDate = newDate;
        setManualDate(newDate);
        updateManualContractOptions();
        renderCalendar();
        return;
      }
      
      state.selectedCalendarDate = newDate;
      updateManualContractOptions();
      renderCalendar();
    });
  }

  if (manualContract) {
    manualContract.addEventListener('change', updateBasicSaveEnabled);
  }

  if (manualHoursInput) manualHoursInput.addEventListener('input', updateBasicSaveEnabled);

  if (manualHourType) {
    manualHourType.addEventListener('change', updateBasicSaveEnabled);
  }

  if (manualHoursInput) manualHoursInput.value = '';
  updateBasicSaveEnabled();
  setManualDate(todayIso());

  const incomeNetBadge = document.getElementById('calendar-net-income');
  const incomeToggleBtn = incomeNetBadge;
  const incomeBreakdownEl = document.getElementById('income-breakdown');
  const incomeInvoiceTotalRow = document.getElementById('income-invoice-total-row');
  const incomeInvoiceTotalEl = document.getElementById('income-invoice-total');
  const incomeCompanyIncomeRow = document.getElementById('income-company-income-row');
  const incomeCompanyIncomeEl = document.getElementById('income-company-income');
  const incomeCompanyExpensesRow = document.getElementById('income-company-expenses-row');
  const incomeCompanyExpensesEl = document.getElementById('income-company-expenses');
  const incomeGrossEl = document.getElementById('income-gross');
  const incomeSuperGuaranteeEl = document.getElementById('income-super-guarantee');
  const incomeSuperLostRow = document.getElementById('income-super-lost-row');
  const incomeSuperLostEl = document.getElementById('income-super-lost');
  const incomeExtraSuperEl = document.getElementById('income-extra-super');
  const incomeSuperTotalEl = document.getElementById('income-super-total');
  const incomeOtherDeductionsEl = document.getElementById('income-other-deductions');
  const incomeTaxableEl = document.getElementById('income-taxable');
  const incomeTaxEl = document.getElementById('income-tax');
  const incomeNetDetailEl = document.getElementById('income-net');
  const incomeActualGrossValueEl = document.getElementById('income-actual-gross-value');
  const incomeActualSuperValueEl = document.getElementById('income-actual-super-value');
  const incomeActualTaxValueEl = document.getElementById('income-actual-tax-value');
  const incomeActualNetValueEl = document.getElementById('income-actual-net-value');
  const btnCompanyExpensesDetails = document.getElementById('btn-company-expenses-details');
  const btnDeductionsDetails = document.getElementById('btn-deductions-details');
  const modalMonthlyDeductions = document.getElementById('modal-monthly-deductions');
  const monthlyDeductionsTitle = document.getElementById('monthly-deductions-title');
  const monthlyDeductionsContent = document.getElementById('monthly-deductions-content');
  const btnCloseMonthlyDeductions = document.getElementById('btn-close-monthly-deductions');
  const modalAdjustOccurrence = document.getElementById('modal-adjust-occurrence');
  const adjustDeductionName = document.getElementById('adjust-deduction-name');
  const adjustOriginalDate = document.getElementById('adjust-original-date');
  const adjustOriginalAmount = document.getElementById('adjust-original-amount');
  const adjustNewDate = document.getElementById('adjust-new-date');
  const adjustNewAmount = document.getElementById('adjust-new-amount');
  const adjustNotes = document.getElementById('adjust-notes');
  const btnCancelAdjust = document.getElementById('btn-cancel-adjust');
  const btnSaveException = document.getElementById('btn-save-exception');
  const btnDeleteException = document.getElementById('btn-delete-exception');
  let adjustingDeduction = null;
  let adjustingOriginalDate = null;
  let adjustingType = null;
  let incomeBreakdownExpanded = false;
  if (incomeToggleBtn) {
    incomeToggleBtn.addEventListener('click', () => {
      incomeBreakdownExpanded = !incomeBreakdownExpanded;
      applyIncomeBreakdownVisibility();
    });
  }
  applyIncomeBreakdownVisibility();

  // Hour types breakdown toggle
  const hourTypesToggleBtn = document.getElementById('calendar-month-total');
  const hourTypesBreakdownEl = document.getElementById('hour-types-breakdown');
  const hourTypesBreakdownListEl = document.getElementById('hour-types-breakdown-list');
  let hourTypesBreakdownExpanded = false;

  function applyHourTypesBreakdownVisibility() {
    if (!hourTypesBreakdownEl || !hourTypesToggleBtn) return;

    if (hourTypesBreakdownExpanded) {
      hourTypesBreakdownEl.hidden = false;
      hourTypesToggleBtn.setAttribute('data-expanded', 'true');
      hourTypesToggleBtn.setAttribute('aria-expanded', 'true');
    } else {
      hourTypesBreakdownEl.hidden = true;
      hourTypesToggleBtn.setAttribute('data-expanded', 'false');
      hourTypesToggleBtn.setAttribute('aria-expanded', 'false');
    }
  }

  if (hourTypesToggleBtn) {
    hourTypesToggleBtn.addEventListener('click', () => {
      hourTypesBreakdownExpanded = !hourTypesBreakdownExpanded;
      applyHourTypesBreakdownVisibility();
    });
  }
  applyHourTypesBreakdownVisibility();

  const expectedHoursBadge = document.getElementById('calendar-expected-hours');
  const expectedHoursBreakdownEl = document.getElementById('expected-hours-breakdown');
  const expectedHoursContentEl = document.getElementById('expected-hours-content');
  let expectedHoursExpanded = false;

  function applyExpectedHoursVisibility() {
    if (!expectedHoursBadge || !expectedHoursBreakdownEl) return;
    expectedHoursBadge.setAttribute('data-expanded', expectedHoursExpanded ? 'true' : 'false');
    expectedHoursBadge.setAttribute('aria-expanded', expectedHoursExpanded ? 'true' : 'false');
    expectedHoursBreakdownEl.hidden = !expectedHoursExpanded;
  }

  if (expectedHoursBadge) {
    expectedHoursBadge.addEventListener('click', () => {
      expectedHoursExpanded = !expectedHoursExpanded;
      renderExpectedHoursSummary();
    });
  }
  applyExpectedHoursVisibility();

  const featureFlagCollapseControls = document.getElementById('feature-flag-collapse-controls');
  const btnExpandAllFeatureFlags = document.getElementById('btn-expand-all-feature-flags');
  const btnCollapseAllFeatureFlags = document.getElementById('btn-collapse-all-feature-flags');
  const featureFlagsListEl = document.getElementById('feature-flags-list');
  const roundInput = document.getElementById('set-round');
  const themeSelect = document.getElementById('set-theme');
  const statusNotificationSelect = document.getElementById('set-status-notifications');
  const paygRateInput = document.getElementById('set-payg-rate');
  const paygRateCol = document.getElementById('payg-rate-col');
  const publicHolidayStateSelect = document.getElementById('set-public-holiday-state');
  const publicHolidayStateCol = document.getElementById('public-holiday-state-col');
  const minimumEndTimeInput = document.getElementById('set-minimum-end-time');
  const minimumEndTimeCol = document.getElementById('minimum-end-time-col');
  const lostSuperRecoveryModeSelect = document.getElementById('set-lost-super-recovery-mode');
  const lostSuperRecoveryCol = document.getElementById('lost-super-recovery-col');
  const saveSettingsBtn = document.getElementById('btn-save-settings');
  const discardSettingsBtn = document.getElementById('btn-discard-settings');
  if (btnExpandAllFeatureFlags) {
    btnExpandAllFeatureFlags.addEventListener('click', () => setAllFeatureFlagCollapse(false));
  }
  if (btnCollapseAllFeatureFlags) {
    btnCollapseAllFeatureFlags.addEventListener('click', () => setAllFeatureFlagCollapse(true));
  }
  if (statusNotificationSelect) {
    statusNotificationSelect.addEventListener('change', applyStatusDisplay);
  }

  const contractNameInput = document.getElementById('contract-name');
  const contractStartInput = document.getElementById('contract-start');
  const contractEndInput = document.getElementById('contract-end');
  const contractRateInput = document.getElementById('contract-rate');
  const contractTotalHoursInput = document.getElementById('contract-total-hours');
  const contractIncludeWeekendsRow = document.getElementById('contract-weekends-row');
  const contractIncludeWeekendsInput = document.getElementById('contract-include-weekends');
  const contractSaveBtn = document.getElementById('contract-save');
  const contractCancelBtn = document.getElementById('contract-cancel');
  const contractAddToggle = document.getElementById('contract-toggle-add');
  const contractFormContainer = document.getElementById('contract-form-container');
  const contractSelector = document.getElementById('contract-selector');
  const contractDetailEl = document.getElementById('contract-detail');
  const contractBurndownEl = document.getElementById('contract-burndown');
  const contractUnlimitedNote = document.getElementById('contract-unlimited-note');
  const contractFormDefaultParent = contractFormContainer ? contractFormContainer.parentElement : null;
  const contractFormPlaceholder = contractFormContainer && contractFormDefaultParent
    ? (function () {
        const placeholder = document.createComment('contract-form-home');
        contractFormDefaultParent.insertBefore(placeholder, contractFormContainer.nextSibling);
        return placeholder;
      })()
    : null;
  const clearCacheWrapper = document.getElementById('clear-cache-wrapper');
  const clearCacheBtn = document.getElementById('btn-clear-cache');
  const payrollXeroBtn = document.getElementById('calendar-xero-helper');
  const payrollMyobBtn = document.getElementById('calendar-myob-helper');
  const xeroHelperModal = document.getElementById('modal-xero-helper');
  const myobHelperModal = document.getElementById('modal-myob-helper');
  const xeroHelperContent = document.getElementById('xero-helper-content');
  const myobHelperContent = document.getElementById('myob-helper-content');
  const actualIncomeBtn = document.getElementById('calendar-actual-income-btn');
  const actualIncomeModal = document.getElementById('modal-actual-income');
  const actualIncomeTitle = document.getElementById('actual-income-title');
  const actualIncomeMonthInput = document.getElementById('actual-income-month');
  const actualIncomeMonthDisplay = document.getElementById('actual-income-month-display');
  const actualIncomeGrossInput = document.getElementById('actual-income-gross');
  const actualIncomeSuperInput = document.getElementById('actual-income-super');
  const actualIncomeTaxInput = document.getElementById('actual-income-tax');
  const actualIncomeNetInput = document.getElementById('actual-income-net');
  const btnSaveActualIncome = document.getElementById('btn-save-actual-income');
  const btnCancelActualIncome = document.getElementById('btn-cancel-actual-income');
  const btnDeleteActualIncome = document.getElementById('btn-delete-actual-income');
  const printMonthlyBtn = document.getElementById('calendar-print-monthly-btn');
  const printViewConfigModal = document.getElementById('modal-print-view-config');
  const printViewIncomeList = document.getElementById('print-view-income-list');
  const printViewOtherList = document.getElementById('print-view-other-list');
  const printViewWarning = document.getElementById('print-view-warning');
  const printViewWarningText = document.getElementById('print-view-warning-text');
  const btnCancelPrintView = document.getElementById('btn-cancel-print-view');
  const btnGeneratePrintView = document.getElementById('btn-generate-print-view');
  const btnUnselectAllOther = document.getElementById('btn-unselect-all-other');

  const DECIMAL_HOURS_FORMATTER = new Intl.NumberFormat(undefined, {
    minimumFractionDigits: 0,
    maximumFractionDigits: 2
  });
  const MONTH_DAY_FORMATTER = new Intl.DateTimeFormat(undefined, {
    month: 'short',
    day: 'numeric'
  });
  const DATE_FULL_FORMATTER = new Intl.DateTimeFormat(undefined, {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
  const MONTH_YEAR_FORMATTER = new Intl.DateTimeFormat(undefined, {
    month: 'short',
    year: 'numeric'
  });
  const FINANCIAL_YEAR_START_MONTH = 6; // July (0-indexed)

  function financialYearLabel(startYear) {
    const endYear = startYear + 1;
    return `FY ${startYear}-${String(endYear).slice(-2)}`;
  }

  function financialYearStartYear(date) {
    if (!(date instanceof Date) || Number.isNaN(date.getTime())) return new Date().getFullYear();
    return date.getMonth() >= FINANCIAL_YEAR_START_MONTH ? date.getFullYear() : date.getFullYear() - 1;
  }

  function getFinancialYearMonths(startYear) {
    const months = [];
    for (let i = 0; i < 12; i += 1) {
      const monthIndex = (FINANCIAL_YEAR_START_MONTH + i) % 12;
      const yearOffset = Math.floor((FINANCIAL_YEAR_START_MONTH + i) / 12);
      months.push({ year: startYear + yearOffset, month: monthIndex });
    }
    return months;
  }

  function startOfFinancialYear(startYear) {
    return startOfDay(new Date(startYear, FINANCIAL_YEAR_START_MONTH, 1));
  }
  const WEEKDAY_FORMATTER = new Intl.DateTimeFormat(undefined, {
    weekday: 'short'
  });

  function formatDecimalHours(value) {
    return DECIMAL_HOURS_FORMATTER.format(Math.max(0, Math.round((Number(value) || 0) * 100) / 100));
  }

  function formatSignedHours(value) {
    const num = Math.round((Number(value) || 0) * 100) / 100;
    if (num === 0) return '0';
    const prefix = num > 0 ? '+' : '-';
    return prefix + DECIMAL_HOURS_FORMATTER.format(Math.abs(num));
  }

  function resetContractFormFields() {
    if (contractNameInput) contractNameInput.value = '';
    if (contractStartInput) contractStartInput.value = '';
    if (contractEndInput) contractEndInput.value = '';
    if (contractRateInput) contractRateInput.value = '';
    if (contractTotalHoursInput) contractTotalHoursInput.value = '';
    if (contractIncludeWeekendsInput) contractIncludeWeekendsInput.checked = false;
  }

  function placeContractFormAtDefault() {
    if (!contractFormContainer || !contractFormPlaceholder || !contractFormPlaceholder.parentNode) return;
    if (contractFormContainer.parentElement !== contractFormPlaceholder.parentNode) {
      contractFormPlaceholder.parentNode.insertBefore(contractFormContainer, contractFormPlaceholder);
    }
  }

  function placeContractFormInDetail() {
    if (!contractFormContainer || !contractDetailEl) return;
    if (contractFormContainer.parentElement !== contractDetailEl) {
      contractDetailEl.appendChild(contractFormContainer);
    }
  }

  function setContractFormMode(mode) {
    state.contractFormMode = mode;
    const visible = mode === 'create' || mode === 'edit';
    if (contractFormContainer) contractFormContainer.style.display = visible ? 'block' : 'none';
    if (contractSaveBtn) contractSaveBtn.textContent = mode === 'edit' ? 'Save Changes' : 'Save';
    if (contractCancelBtn) contractCancelBtn.style.display = visible ? 'inline-flex' : 'none';
  }

  function showContractForm(mode) {
    if (mode === 'create') {
      state.editingContractId = null;
      resetContractFormFields();
      placeContractFormInDetail();
      if (contractAddToggle) contractAddToggle.textContent = 'Close';
    }
    setContractFormMode(mode);
    if (mode === 'create' && contractNameInput) contractNameInput.focus();
    renderContractDetail();
  }

  function hideContractForm() {
    resetContractFormFields();
    state.editingContractId = null;
    setContractFormMode('hidden');
    placeContractFormAtDefault();
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
  }

  function getContractFormPayload() {
    const name = contractNameInput ? contractNameInput.value.trim() : '';
    const startDate = contractStartInput ? contractStartInput.value : '';
    const endDate = contractEndInput ? contractEndInput.value : '';
    const hourlyRateRaw = contractRateInput ? contractRateInput.value : '';
    const hourlyRate = Number(hourlyRateRaw || 0);
    const totalHoursRaw = contractTotalHoursInput ? contractTotalHoursInput.value : '';
    const totalHoursValue = totalHoursRaw === '' ? 0 : Number(totalHoursRaw);
    if (!name) {
      customAlert('Contract name is required.');
      return null;
    }
    if (!startDate) {
      customAlert('Contract start date is required.');
      return null;
    }
    if (endDate && endDate < startDate) {
      customAlert('End date must be on or after the start date.');
      return null;
    }
    if (hourlyRate < 0) {
      customAlert('Hourly rate must be zero or greater.');
      return null;
    }
    if (Number.isNaN(totalHoursValue) || totalHoursValue < 0) {
      customAlert('Total hours must be zero or greater.');
      return null;
    }
    const totalHours = Math.round(Number(totalHoursValue || 0) * 100) / 100;
    const includeWeekends = contractIncludeWeekendsInput ? contractIncludeWeekendsInput.checked : false;
    return {
      name,
      start_date: startDate,
      end_date: endDate,
      hourly_rate: Math.round(hourlyRate * 100) / 100,
      total_hours: totalHours,
      include_weekends: includeWeekends
    };
  }

  function populateContractForm(contract) {
    state.editingContractId = contract.id;
    if (contractNameInput) contractNameInput.value = contract.name || '';
    if (contractStartInput) contractStartInput.value = contract.start_date || '';
    if (contractEndInput) contractEndInput.value = contract.end_date || '';
    if (contractRateInput) contractRateInput.value = contract.hourly_rate != null ? Number(contract.hourly_rate).toFixed(2) : '';
    if (contractTotalHoursInput) {
      const totalHours = Number(contract.total_hours || 0);
      contractTotalHoursInput.value = totalHours > 0 ? String(totalHours) : '';
    }
    if (contractIncludeWeekendsInput) contractIncludeWeekendsInput.checked = !!contract.include_weekends;
    placeContractFormInDetail();
    setContractFormMode('edit');
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
    if (contractNameInput) contractNameInput.focus();
    renderContractDetail();
  }

  function getContractById(id) {
    return id ? state.contractMap[id] : undefined;
  }

  function contractEndSortValue(contract) {
    return contract.end_date && contract.end_date !== '' ? contract.end_date : '9999-12-31';
  }

  function renderContractSelectorOptions() {
    if (!contractSelector) return;
    const previousSelection = state.selectedContractId;
    contractSelector.innerHTML = '';
    if (!state.contracts.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts yet';
      contractSelector.appendChild(placeholder);
      contractSelector.disabled = true;
      state.selectedContractId = '';
      return;
    }
    contractSelector.disabled = false;
    const sorted = [...state.contracts].sort((a, b) => {
      const endA = contractEndSortValue(a);
      const endB = contractEndSortValue(b);
      if (endA !== endB) return endB.localeCompare(endA);
      const startA = a.start_date || '';
      const startB = b.start_date || '';
      if (startA !== startB) return startB.localeCompare(startA);
      return a.name.localeCompare(b.name);
    });
    const todayContracts = validContractsForDate(todayIso());
    const soleCurrentContractId = (!state.editingContractId && todayContracts.length === 1)
      ? todayContracts[0].id
      : '';
    if (!state.selectedContractId || !getContractById(state.selectedContractId)) {
      state.selectedContractId = soleCurrentContractId
        || (previousSelection && getContractById(previousSelection) ? previousSelection : '')
        || (sorted.length ? sorted[0].id : '');
    }
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select a contract...';
    contractSelector.appendChild(placeholder);
    sorted.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name || 'Untitled contract';
      contractSelector.appendChild(opt);
    });
    contractSelector.value = state.selectedContractId || '';
  }

  function computeContractUsage(contract) {
    const monthlyHours = {};
    let total = 0;
    if (contract) {
      state.entries.forEach((entry) => {
        if (entry.contract_id !== contract.id || !entry.date) return;
        const monthKey = entry.date.slice(0, 7);
        const hours = (Number(entry.duration_minutes) || 0) / 60;
        total += hours;
        monthlyHours[monthKey] = (monthlyHours[monthKey] || 0) + hours;
      });
    }
    return { totalHours: total, monthlyHours };
  }

  function contractMonthRange(contract) {
    if (!contract) return [];
    const startDate = contract.start_date ? parseIsoDate(contract.start_date) : parseIsoDate(todayIso());
    if (!startDate || Number.isNaN(startDate.getTime())) return [];
    const start = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
    const today = new Date();
    const endSource = contract.end_date ? parseIsoDate(contract.end_date) : today;
    const effectiveEndDate = (!endSource || Number.isNaN(endSource.getTime())) ? today : endSource;
    const end = new Date(effectiveEndDate.getFullYear(), effectiveEndDate.getMonth(), 1);
    const months = [];
    const cursor = new Date(start.getFullYear(), start.getMonth(), 1);
    if (cursor > end) {
      months.push(new Date(cursor));
      return months;
    }
    while (cursor <= end) {
      months.push(new Date(cursor));
      cursor.setMonth(cursor.getMonth() + 1);
    }
    if (!months.length) months.push(new Date(start));
    return months;
  }

  function renderContractDetail() {
    if (!contractDetailEl) return;
    contractDetailEl.innerHTML = '';
    if (state.contractFormMode === 'create') {
      if (contractSelector) contractSelector.value = '';
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (contractAddToggle) contractAddToggle.textContent = 'Close';
      const heading = document.createElement('div');
      heading.className = 'ts-note';
      heading.textContent = 'Creating new contract';
      contractDetailEl.appendChild(heading);
      placeContractFormInDetail();
      return;
    }
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
    if (contractSelector) contractSelector.value = state.selectedContractId || '';
    if (!state.selectedContractId) {
      const note = document.createElement('div');
      note.className = 'ts-note';
      note.textContent = state.contracts.length ? 'Select a contract to see its detail and burndown.' : 'Add a contract to get started.';
      contractDetailEl.appendChild(note);
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (!state.editingContractId) placeContractFormAtDefault();
      return;
    }
    const contract = getContractById(state.selectedContractId);
    if (!contract) {
      state.selectedContractId = '';
      if (contractSelector) contractSelector.value = '';
      renderContractDetail();
      return;
    }
    const isEditing = state.editingContractId === contract.id;
    if (!isEditing) {
      placeContractFormAtDefault();
      if (contractFormContainer && contractFormContainer.style.display === 'block' && !state.editingContractId) {
        // create mode already visible in default location
      }
    }
    const usage = computeContractUsage(contract);
    if (isEditing) {
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      placeContractFormInDetail();
      setContractFormMode('edit');
      const heading = document.createElement('div');
      heading.className = 'ts-note';
      heading.textContent = 'Editing contract';
      contractDetailEl.appendChild(heading);
      contractDetailEl.appendChild(contractFormContainer);
      renderContractBurndown(contract, usage);
      return;
    }

    const grid = document.createElement('div');
    grid.className = 'contract-detail-grid';

    const addDetail = (label, value) => {
      const item = document.createElement('div');
      item.className = 'contract-detail-item';
      const labelEl = document.createElement('div');
      labelEl.className = 'contract-detail-label';
      labelEl.textContent = label;
      const valueEl = document.createElement('div');
      valueEl.className = 'contract-detail-value';
      valueEl.textContent = value || 'â';
      item.append(labelEl, valueEl);
      grid.appendChild(item);
    };

    const rangeLabel = contract.end_date
      ? `${contract.start_date || 'â'} â ${contract.end_date}`
      : `${contract.start_date || 'â'} â Present`;
    const totalHoursValue = Number(contract.total_hours || 0);
    addDetail('Contract name', contract.name || 'Untitled contract');
    addDetail('Date range', rangeLabel);
    addDetail('Hourly rate', `${Number(contract.hourly_rate || 0).toFixed(2)} / hr`);
    addDetail('Total hours', totalHoursValue > 0 ? `${formatDecimalHours(totalHoursValue)} hrs` : 'Unlimited');
    addDetail('Weekends counted', contract.include_weekends ? 'Yes (all days)' : 'No (Mon-Fri)');
    addDetail('Hours logged', `${formatDecimalHours(usage.totalHours)} hrs`);

    contractDetailEl.appendChild(grid);

    const actions = document.createElement('div');
    actions.className = 'contract-detail-actions';
    const editBtn = document.createElement('button');
    editBtn.textContent = 'Edit';
    editBtn.className = 'ghost';
    editBtn.onclick = () => handleContractEdit(contract.id);
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    deleteBtn.className = 'danger';
    deleteBtn.onclick = () => handleContractDelete(contract.id);
    actions.append(editBtn, deleteBtn);
    contractDetailEl.appendChild(actions);

    renderContractBurndown(contract, usage);
  }

  function renderContractBurndown(contract, usage) {
    if (!contractBurndownEl) return;
    contractBurndownEl.innerHTML = '';
    if (state.contractCharts && state.contractCharts.monthlyHours) {
      state.contractCharts.monthlyHours.destroy();
      state.contractCharts.monthlyHours = null;
    }
    const totalHours = Number(contract.total_hours || 0);
    if (!usage) usage = computeContractUsage(contract);
    if (totalHours <= 0) {
      if (contractUnlimitedNote) {
        contractUnlimitedNote.style.display = 'block';
        contractUnlimitedNote.textContent = `This contract is unlimited. Hours logged so far: ${formatDecimalHours(usage.totalHours)} hrs. Burndown charts require a total hour cap.`;
      }
      const monthsEntries = Object.keys(usage.monthlyHours).sort();
      if (usage.totalHours > 0 && monthsEntries.length) {
        const heading = document.createElement('div');
        heading.className = 'ts-note';
        heading.textContent = 'Monthly hours logged';
        contractBurndownEl.appendChild(heading);
        const table = document.createElement('table');
        table.className = 'contract-burndown-table';
        table.innerHTML = '<thead><tr><th>Month</th><th>Hours logged</th></tr></thead>';
        const tbody = document.createElement('tbody');
        monthsEntries.forEach((monthKey) => {
          const tr = document.createElement('tr');
          const monthCell = document.createElement('td');
          const parts = monthKey.split('-');
          const dateObj = new Date(Number(parts[0]), Number(parts[1]) - 1, 1);
          monthCell.textContent = formatMonthShortYear(dateObj);
          const valueCell = document.createElement('td');
          valueCell.textContent = `${formatDecimalHours(usage.monthlyHours[monthKey])} hrs`;
          tr.append(monthCell, valueCell);
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        contractBurndownEl.appendChild(table);
      } else {
        const empty = document.createElement('div');
        empty.className = 'contract-burndown-empty';
        empty.textContent = 'No time has been logged for this contract yet.';
        contractBurndownEl.appendChild(empty);
      }
      return;
    }
    if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';

    const months = contractMonthRange(contract);
    if (!months.length) {
      const empty = document.createElement('div');
      empty.className = 'contract-burndown-empty';
      empty.textContent = 'Not enough data to build a burndown chart.';
      contractBurndownEl.appendChild(empty);
      return;
    }

    const avgBurn = totalHours / months.length;
    const expectedPoints = [{ label: 'Start', value: totalHours }];
    const actualPathPoints = [{ label: 'Start', value: totalHours }];
    const tableRows = [];
    const today = new Date();
    const todayIsoString = todayIso();
    const contractStarted = !contract.start_date || contract.start_date <= todayIsoString;
    const contractActive = contractStarted && (!contract.end_date || contract.end_date >= todayIsoString);
    const currentMonthKey = monthKeyFor(today.getFullYear(), today.getMonth());
    const currentIdx = months.findIndex((monthDate) => monthKeyFor(monthDate.getFullYear(), monthDate.getMonth()) === currentMonthKey);
    let latestDataIdx = -1;
    months.forEach((monthDate, idx) => {
      const key = monthKeyFor(monthDate.getFullYear(), monthDate.getMonth());
      if ((usage.monthlyHours[key] || 0) > 0) latestDataIdx = idx;
    });
    let actualEndIndex = months.length - 1;
    if (contractActive && currentIdx !== -1) {
      actualEndIndex = Math.max(latestDataIdx, currentIdx);
      if (actualEndIndex < 0) actualEndIndex = currentIdx;
      actualEndIndex = Math.min(actualEndIndex, months.length - 1);
    }
    if (actualEndIndex < 0) actualEndIndex = months.length - 1;

    const monthContributions = months.map((monthDate, idx) => {
      if (idx === currentIdx && contractActive && latestDataIdx <= currentIdx) {
        const daysInMonth = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0).getDate();
        const daysElapsed = Math.min(daysInMonth, Math.max(1, today.getDate()));
        return Math.min(1, daysElapsed / daysInMonth);
      }
      return 1;
    });

    let actualConsumedForAverage = 0;
    let monthsContributionUsed = 0;
    let cumulativeConsumed = 0;
    months.forEach((monthDate, idx) => {
      const key = monthKeyFor(monthDate.getFullYear(), monthDate.getMonth());
      const expectedRemaining = Math.max(0, totalHours - avgBurn * (idx + 1));
      const hoursThisMonth = usage.monthlyHours[key] || 0;
      cumulativeConsumed += hoursThisMonth;
      const actualRemaining = Math.max(0, totalHours - cumulativeConsumed);
      expectedPoints.push({ label: monthDate, value: expectedRemaining });
      if (idx <= actualEndIndex) {
        actualPathPoints.push({ label: monthDate, value: actualRemaining });
        actualConsumedForAverage += hoursThisMonth;
        monthsContributionUsed += monthContributions[idx];
      }
      tableRows.push({
        monthLabel: formatMonthShortYear(monthDate),
        hoursLogged: hoursThisMonth,
        expectedRemaining,
        actualRemaining
      });
    });

    const avgActualMonthlyBurn = monthsContributionUsed > 0 ? actualConsumedForAverage / monthsContributionUsed : 0;
    const totalContribution = monthContributions.reduce((sum, value) => sum + value, 0);
    const actualAveragePoints = [{ label: 'Start', value: totalHours }];
    if (avgActualMonthlyBurn > 0) {
      let cumulativeContribution = 0;
      months.forEach((monthDate, idx) => {
        cumulativeContribution += monthContributions[idx];
        const projectedRemaining = Math.max(0, totalHours - avgActualMonthlyBurn * cumulativeContribution);
        actualAveragePoints.push({ label: monthDate, value: projectedRemaining });
      });
    }

    const pointGroups = [expectedPoints, actualPathPoints];
    if (actualAveragePoints.length > 1) pointGroups.push(actualAveragePoints);
    const maxValue = Math.max(totalHours, ...pointGroups.flat().map((p) => p.value));
    const containerRect = contractBurndownEl.getBoundingClientRect();
    const detailRect = contractDetailEl ? contractDetailEl.getBoundingClientRect() : null;
    const measuredWidth = containerRect.width || (detailRect && detailRect.width) || 720;
    const width = Math.max(480, Math.floor(measuredWidth));
    const height = 320;
    const margin = { top: 20, right: 28, bottom: 44, left: 56 };
    const plotWidth = width - margin.left - margin.right;
    const plotHeight = height - margin.top - margin.bottom;
    const stepX = expectedPoints.length > 1 ? plotWidth / (expectedPoints.length - 1) : 0;
    const scaleX = (index) => margin.left + stepX * index;
    const scaleY = (value) => {
      if (maxValue === 0) return margin.top + plotHeight;
      return margin.top + plotHeight - (value / maxValue) * plotHeight;
    };
    const buildPath = (points) => points.map((point, idx) => {
      const x = scaleX(idx).toFixed(2);
      const y = scaleY(point.value).toFixed(2);
      return `${idx === 0 ? 'M' : 'L'}${x},${y}`;
    }).join(' ');

    const styles = getComputedStyle(document.body);
    const borderColor = (styles.getPropertyValue('--border') || '#1e293b').trim();
    const mutedColor = (styles.getPropertyValue('--muted') || '#94a3b8').trim();
    const primaryColor = (styles.getPropertyValue('--primary') || '#3b82f6').trim();
    const successColor = (styles.getPropertyValue('--success') || '#10b981').trim();
    const textColor = mutedColor || '#94a3b8';

    const expectedPath = buildPath(expectedPoints);
    const actualPath = buildPath(actualPathPoints);
    const actualAveragePath = actualAveragePoints.length > 1 ? buildPath(actualAveragePoints) : '';
    const xAxisY = margin.top + plotHeight;
    const svgParts = [];
    svgParts.push(`<path d="M${margin.left},${xAxisY} L${margin.left + plotWidth},${xAxisY}" stroke="${borderColor}" stroke-width="1" fill="none" />`);
    svgParts.push(`<path d="M${margin.left},${margin.top} L${margin.left},${xAxisY}" stroke="${borderColor}" stroke-width="1" fill="none" />`);
    svgParts.push(`<path d="${expectedPath}" stroke="${mutedColor}" stroke-width="2" fill="none" />`);
    svgParts.push(`<path d="${actualPath}" stroke="${primaryColor}" stroke-width="2" fill="none" />`);
    if (actualAveragePath) svgParts.push(`<path d="${actualAveragePath}" stroke="${successColor}" stroke-width="2" fill="none" stroke-dasharray="6 4" />`);

    expectedPoints.forEach((point, idx) => {
      const x = scaleX(idx);
      const y = scaleY(point.value);
      svgParts.push(`<circle cx="${x}" cy="${y}" r="3" fill="${mutedColor}" />`);
    });
    actualPathPoints.forEach((point, idx) => {
      const x = scaleX(idx);
      const y = scaleY(point.value);
      svgParts.push(`<circle cx="${x}" cy="${y}" r="3" fill="${primaryColor}" />`);
    });
    if (actualAveragePath) {
      actualAveragePoints.forEach((point, idx) => {
        const x = scaleX(idx);
        const y = scaleY(point.value);
        svgParts.push(`<circle cx="${x}" cy="${y}" r="3" fill="${successColor}" />`);
      });
    }

    const labelGroup = months.map((monthDate, idx) => {
      const x = scaleX(idx + 1);
      const label = formatMonthShortYear(monthDate);
      return `<text x="${x}" y="${xAxisY + 18}" text-anchor="middle" font-size="11" fill="${textColor}">${label}</text>`;
    }).join('');

    const svg = `<svg viewBox="0 0 ${width} ${height}" role="img" aria-label="Contract burndown chart"><g>${svgParts.join('')} ${labelGroup}</g></svg>`;

    const avgSummary = document.createElement('div');
    avgSummary.className = 'ts-note contract-burndown-summary';
    const summaryParts = [`Average burn required: ${formatDecimalHours(avgBurn)} hrs/month.`];
    if (avgActualMonthlyBurn > 0) {
      summaryParts.push(`Actual average to date: ${formatDecimalHours(avgActualMonthlyBurn)} hrs/month (${monthsContributionUsed.toFixed(2)} months measured).`);
    }
    avgSummary.textContent = summaryParts.join(' ');
    contractBurndownEl.appendChild(avgSummary);

    if (contractActive && avgActualMonthlyBurn > avgBurn + 0.01 && monthsContributionUsed > 0) {
      const projectedTotalUsage = avgActualMonthlyBurn * totalContribution;
      const overageHours = projectedTotalUsage - totalHours;
      if (overageHours > 0.5) {
        const warning = document.createElement('div');
        warning.className = 'ts-warning contract-burndown-warning';
        warning.textContent = `At the current pace you're on track to exceed this contract by approximately ${formatDecimalHours(overageHours)} hrs.`;
        contractBurndownEl.appendChild(warning);
      }
    }

    const plotWrapper = document.createElement('div');
    plotWrapper.className = 'contract-burndown-plot';
    plotWrapper.innerHTML = svg;
    contractBurndownEl.appendChild(plotWrapper);

    const legend = document.createElement('div');
    legend.className = 'contract-burndown-legend';
    legend.innerHTML = `<span><span class="line" style="background:${mutedColor};"></span>Expected remaining</span><span><span class="line" style="background:${primaryColor};"></span>Actual remaining</span>${actualAveragePath ? `<span><span class="line" style="background:transparent; border-bottom:2px dashed ${successColor}; height:0;"></span>Actual average (projection)</span>` : ''}`;
    contractBurndownEl.appendChild(legend);

    const chartLabels = months.map((monthDate) => formatMonthShortYear(monthDate));
    const monthlyHoursData = months.map((monthDate) => {
      const key = monthKeyFor(monthDate.getFullYear(), monthDate.getMonth());
      return Number(usage.monthlyHours[key] || 0);
    });

    if (chartLabels.length) {
      const chartWrapper = document.createElement('div');
      chartWrapper.className = 'contract-monthly-chart';
      const chartCanvas = document.createElement('canvas');
      chartWrapper.appendChild(chartCanvas);
      contractBurndownEl.appendChild(chartWrapper);

      const colors = getThemeColors();
      const datasets = [
        {
          type: 'bar',
          label: 'Hours logged',
          data: monthlyHoursData,
          backgroundColor: colors.primary || '#3b82f6',
          borderColor: colors.primary || '#3b82f6',
          borderWidth: 0,
          borderRadius: 6,
          maxBarThickness: 42,
          order: 2
        }
      ];

      if (avgBurn > 0) {
        datasets.push({
          type: 'line',
          label: 'Expected monthly average',
          data: chartLabels.map(() => avgBurn),
          borderColor: colors.warning || '#facc15',
          backgroundColor: 'transparent',
          borderWidth: 2,
          borderDash: [6, 4],
          pointRadius: 0,
          pointHoverRadius: 4,
          tension: 0,
          order: 0
        });
      }

      if (avgActualMonthlyBurn > 0) {
        datasets.push({
          type: 'line',
          label: 'Actual average to date',
          data: chartLabels.map(() => avgActualMonthlyBurn),
          borderColor: colors.success || '#10b981',
          backgroundColor: 'transparent',
          borderWidth: 2,
          pointRadius: 0,
          pointHoverRadius: 4,
          tension: 0,
          order: 1
        });
      }

      const ctx = chartCanvas.getContext('2d');
      const textColor = colors.text || '#f5f9ff';
      const mutedColor = colors.muted || '#94a3b8';
      const gridColor = colors.border || 'rgba(148,163,184,0.35)';

      if (state.contractCharts.monthlyHours) {
        state.contractCharts.monthlyHours.destroy();
      }

      state.contractCharts.monthlyHours = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: chartLabels,
          datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: {
              position: 'top',
            labels: {
              color: textColor,
              usePointStyle: true,
              pointStyle: 'roundedRect',
              padding: 12
            }
            },
            tooltip: {
              callbacks: {
                label(context) {
                  const value = typeof context.parsed === 'number' ? context.parsed : context.parsed.y;
                  return `${context.dataset.label}: ${formatDecimalHours(value || 0)} hrs`;
                }
              }
            }
          },
          scales: {
            x: {
              grid: { display: false },
              ticks: {
                color: mutedColor
              }
            },
            y: {
              beginAtZero: true,
              grid: { color: gridColor },
              ticks: {
                color: mutedColor,
                callback(value) {
                  return `${formatDecimalHours(Number(value) || 0)} hrs`;
                }
              }
            }
          }
        }
      });
    }

    const table = document.createElement('table');
    table.className = 'contract-burndown-table';
    table.innerHTML = '<thead><tr><th>Month</th><th>Hours logged</th><th>Expected remaining</th><th>Actual remaining</th></tr></thead>';
    const tbody = document.createElement('tbody');
    tableRows.forEach((row) => {
      const tr = document.createElement('tr');
      const monthCell = document.createElement('td');
      monthCell.textContent = row.monthLabel;
      const loggedCell = document.createElement('td');
      loggedCell.textContent = `${formatDecimalHours(row.hoursLogged)} hrs`;
      const expectedCell = document.createElement('td');
      expectedCell.textContent = `${formatDecimalHours(row.expectedRemaining)} hrs`;
      const actualCell = document.createElement('td');
      actualCell.textContent = `${formatDecimalHours(row.actualRemaining)} hrs`;
      tr.append(monthCell, loggedCell, expectedCell, actualCell);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    contractBurndownEl.appendChild(table);
  }

  function isRatePreviewEnabled() {
    const flag = state.featureFlags.contract_rate_preview || DEFAULT_FEATURE_FLAGS.contract_rate_preview || { enabled: false };
    return !!flag.enabled;
  }

  function normalizeRateValue(value) {
    const num = Number(value);
    if (!Number.isFinite(num) || num < 0) return 0;
    return Math.round(num * 100) / 100;
  }

  function normalizePercentValue(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return null;
    return Math.round(num * 100) / 100;
  }

  function formatPercentInputValue(value) {
    const normalized = normalizePercentValue(value);
    if (normalized === null) return '';
    const abs = Math.abs(normalized).toFixed(2).replace(/\.00$/, '').replace(/(\.\d*?)0+$/, '$1');
    return normalized < 0 ? `-${abs}` : abs;
  }

  function resetRatePreviewState() {
    state.ratePreview.selectedContractId = '';
    state.ratePreview.data = null;
    state.ratePreview.loading = false;
    state.ratePreview.requestToken = 0;
    state.ratePreview.inputs = { percentChange: null, newRate: null };
    if (ratePreviewContractSelect) ratePreviewContractSelect.value = '';
    if (ratePreviewPercentInput) {
      ratePreviewPercentInput.value = '';
      ratePreviewPercentInput.disabled = false;
      ratePreviewPercentInput.placeholder = 'e.g. 5';
    }
    if (ratePreviewRateInput) ratePreviewRateInput.value = '';
    hideRatePreviewLoading();
    clearRatePreviewContent();
    updateRatePreviewEmptyState();
  }

  function clearRatePreviewContent() {
    if (ratePreviewAdjustedRateEl) ratePreviewAdjustedRateEl.textContent = '--';
    if (ratePreviewCurrentRateEl) ratePreviewCurrentRateEl.textContent = '--';
    if (ratePreviewRateDeltaEl) {
      ratePreviewRateDeltaEl.textContent = '--';
      applyRatePreviewVariance(ratePreviewRateDeltaEl, null);
    }
    if (ratePreviewTotalHoursEl) ratePreviewTotalHoursEl.textContent = '--';
    if (ratePreviewTotalEarnScenarioEl) ratePreviewTotalEarnScenarioEl.textContent = '--';
    if (ratePreviewTotalEarnCurrentEl) ratePreviewTotalEarnCurrentEl.textContent = '--';
    if (ratePreviewTotalEarnVarianceEl) {
      ratePreviewTotalEarnVarianceEl.textContent = '--';
      applyRatePreviewVariance(ratePreviewTotalEarnVarianceEl, null);
    }
    setRatePreviewMetric(ratePreviewTotalSuperScenarioEl, ratePreviewTotalSuperCurrentEl, ratePreviewTotalSuperVarianceEl, null, null, null, null);
    setRatePreviewMetric(ratePreviewTotalTaxScenarioEl, ratePreviewTotalTaxCurrentEl, ratePreviewTotalTaxVarianceEl, null, null, null, null, true);
    setRatePreviewMetric(ratePreviewTotalNetScenarioEl, ratePreviewTotalNetCurrentEl, ratePreviewTotalNetVarianceEl, null, null, null, null);
    if (ratePreviewRemainingScenarioEl) ratePreviewRemainingScenarioEl.textContent = '--';
    if (ratePreviewRemainingCurrentEl) ratePreviewRemainingCurrentEl.textContent = '--';
    if (ratePreviewContractHoursEl) ratePreviewContractHoursEl.textContent = '--';
    if (ratePreviewRemainingVarianceEl) {
      ratePreviewRemainingVarianceEl.textContent = '--';
      applyRatePreviewVariance(ratePreviewRemainingVarianceEl, null);
    }
    setRatePreviewMetric(ratePreviewRemainingSuperScenarioEl, ratePreviewRemainingSuperCurrentEl, ratePreviewRemainingSuperVarianceEl, null, null, null, null);
    setRatePreviewMetric(ratePreviewRemainingTaxScenarioEl, ratePreviewRemainingTaxCurrentEl, ratePreviewRemainingTaxVarianceEl, null, null, null, null, true);
    setRatePreviewMetric(ratePreviewRemainingNetScenarioEl, ratePreviewRemainingNetCurrentEl, ratePreviewRemainingNetVarianceEl, null, null, null, null);
    if (ratePreviewRemainingCard) ratePreviewRemainingCard.style.display = 'none';
    if (ratePreviewSummaryFootnote) ratePreviewSummaryFootnote.textContent = '--';
    if (ratePreviewNoEntriesNote) ratePreviewNoEntriesNote.style.display = 'none';
    if (ratePreviewMonthlyBody) ratePreviewMonthlyBody.innerHTML = '';
    if (ratePreviewContent) ratePreviewContent.style.display = 'none';
  }

  function updateRatePreviewEmptyState() {
    if (!ratePreviewEmpty || !ratePreviewContent) return;
    const contractId = state.ratePreview.selectedContractId;
    const hasSelection = contractId && state.contractMap[contractId];
    if (!hasSelection) {
      ratePreviewEmpty.style.display = 'block';
      ratePreviewContent.style.display = 'none';
      return;
    }
    ratePreviewEmpty.style.display = 'none';
    if (state.ratePreview.data) {
      ratePreviewContent.style.display = 'block';
    }
  }

  function renderRatePreviewContractOptions() {
    if (!ratePreviewContractSelect) return;
    const selectedId = state.ratePreview.selectedContractId;
    ratePreviewContractSelect.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select a contract...';
    ratePreviewContractSelect.appendChild(placeholder);
    state.contracts.forEach((contract) => {
      if (!contract) return;
      const option = document.createElement('option');
      option.value = contract.id;
      option.textContent = contract.name || 'Untitled contract';
      ratePreviewContractSelect.appendChild(option);
    });
    if (selectedId && state.contractMap[selectedId]) {
      ratePreviewContractSelect.value = selectedId;
    } else {
      ratePreviewContractSelect.value = '';
      if (selectedId) {
        state.ratePreview.selectedContractId = '';
        state.ratePreview.data = null;
        clearRatePreviewContent();
      }
    }
  }

  function applyRatePreviewVariance(element, value) {
    if (!element) return;
    element.classList.remove('rate-preview-metric-positive', 'rate-preview-metric-negative');
    const num = Number(value);
    if (!Number.isFinite(num) || num === 0) return;
    element.classList.add(num > 0 ? 'rate-preview-metric-positive' : 'rate-preview-metric-negative');
  }

  function setRatePreviewMetric(scenarioEl, currentEl, varianceEl, scenarioValue, currentValue, varianceValue, variancePercent, invertTrend) {
    if (scenarioEl) {
      if (scenarioValue === null || scenarioValue === undefined) {
        scenarioEl.textContent = '--';
      } else {
        scenarioEl.textContent = formatCurrency(scenarioValue);
      }
    }
    if (currentEl) {
      if (currentValue === null || currentValue === undefined) {
        currentEl.textContent = '--';
      } else {
        currentEl.textContent = formatCurrency(currentValue);
      }
    }
    if (varianceEl) {
      if (varianceValue === null || varianceValue === undefined) {
        varianceEl.textContent = '--';
        applyRatePreviewVariance(varianceEl, null);
      } else {
        const varianceText = formatSignedCurrency(varianceValue);
        const percentText = Number.isFinite(Number(variancePercent)) ? ` (${formatPercentValue(variancePercent)})` : '';
        varianceEl.textContent = varianceText + percentText;
        const varianceForColor = invertTrend ? -varianceValue : varianceValue;
        applyRatePreviewVariance(varianceEl, varianceForColor);
      }
    }
  }

  function showRatePreviewLoading(message) {
    if (!ratePreviewLoadingOverlay || !pageRatePreview) return;
    pageRatePreview.style.position = pageRatePreview.style.position || 'relative';
    ratePreviewLoadingOverlay.textContent = message || 'Calculating scenario...';
    ratePreviewLoadingOverlay.style.display = 'flex';
  }

  function hideRatePreviewLoading() {
    if (ratePreviewLoadingOverlay) {
      ratePreviewLoadingOverlay.style.display = 'none';
    }
  }

  function scheduleRatePreviewFetch(immediate) {
    if (!isRatePreviewEnabled()) return;
    if (!state.ratePreview.selectedContractId) return;
    if (ratePreviewDebounceTimer) {
      clearTimeout(ratePreviewDebounceTimer);
      ratePreviewDebounceTimer = null;
    }
    if (immediate) {
      fetchRatePreviewData();
      return;
    }
    ratePreviewDebounceTimer = setTimeout(() => {
      fetchRatePreviewData();
    }, RATE_PREVIEW_DEBOUNCE_MS);
  }

  function fetchRatePreviewData() {
    if (!isRatePreviewEnabled()) return;
    const contractId = state.ratePreview.selectedContractId;
    if (!contractId || !state.contractMap[contractId]) {
      updateRatePreviewEmptyState();
      return;
    }
    const percent = normalizePercentValue(state.ratePreview.inputs.percentChange);
    const rate = state.ratePreview.inputs.newRate != null ? normalizeRateValue(state.ratePreview.inputs.newRate) : null;
    const payload = {
      contractId,
      percentChange: percent != null ? percent : null,
      newRate: rate != null ? rate : null
    };
    state.ratePreview.loading = true;
    const requestId = state.ratePreview.requestToken + 1;
    state.ratePreview.requestToken = requestId;
    showRatePreviewLoading('Calculating scenario...');
    setStatus('Calculating rate preview...', 'info');
    google.script.run
      .withSuccessHandler((data) => {
        if (state.ratePreview.requestToken !== requestId) return;
        state.ratePreview.loading = false;
        hideRatePreviewLoading();
        if (data && data.contract && data.contract.id === state.ratePreview.selectedContractId) {
          state.ratePreview.data = data;
          applyRatePreviewData(data);
          setStatus('Ready', 'success');
        } else {
          setStatus('Rate preview updated', 'success');
        }
      })
      .withFailureHandler((error) => {
        if (state.ratePreview.requestToken !== requestId) return;
        state.ratePreview.loading = false;
        hideRatePreviewLoading();
        console.error('Failed to calculate rate preview', error);
        setStatus('Failed to calculate rate preview', 'error');
      })
      .api_getContractRatePreview(payload);
  }

  function applyRatePreviewData(data) {
    if (!data) return;
    const contractId = state.ratePreview.selectedContractId;
    if (!contractId || !state.contractMap[contractId]) return;
    const baseRate = normalizeRateValue(data.current && data.current.hourlyRate);
    if (ratePreviewPercentInput) {
      if (baseRate === 0) {
        ratePreviewPercentInput.disabled = true;
        ratePreviewPercentInput.placeholder = 'Unavailable for $0 rates';
      } else {
        ratePreviewPercentInput.disabled = false;
        ratePreviewPercentInput.placeholder = 'e.g. 5';
      }
    }
    if (ratePreviewAdjustedRateEl) ratePreviewAdjustedRateEl.textContent = `${formatCurrency(normalizeRateValue(data.scenario && data.scenario.hourlyRate))} / hr`;
    if (ratePreviewCurrentRateEl) ratePreviewCurrentRateEl.textContent = `${formatCurrency(baseRate)} / hr`;
    if (ratePreviewRateDeltaEl) {
      const delta = Number(data.variance && data.variance.hourlyRateDelta) || 0;
      ratePreviewRateDeltaEl.textContent = `${formatSignedCurrency(delta)} / hr`;
      applyRatePreviewVariance(ratePreviewRateDeltaEl, delta);
    }
    if (ratePreviewTotalHoursEl) ratePreviewTotalHoursEl.textContent = `${formatDecimalHours(data.current && data.current.totalHours)} hrs`;
    if (ratePreviewTotalEarnScenarioEl) ratePreviewTotalEarnScenarioEl.textContent = formatCurrency(data.scenario && data.scenario.totalEarnings);
    if (ratePreviewTotalEarnCurrentEl) ratePreviewTotalEarnCurrentEl.textContent = formatCurrency(data.current && data.current.totalEarnings);
    if (ratePreviewTotalEarnVarianceEl) {
      const totalVariance = Number(data.variance && data.variance.totalEarnings) || 0;
      const totalVarianceText = formatSignedCurrency(totalVariance);
      const totalVariancePercent = Number.isFinite(Number(data.variance && data.variance.totalEarningsPercent))
        ? ` (${formatPercentValue(data.variance.totalEarningsPercent)})`
        : '';
      ratePreviewTotalEarnVarianceEl.textContent = totalVarianceText + totalVariancePercent;
      applyRatePreviewVariance(ratePreviewTotalEarnVarianceEl, totalVariance);
    }
    setRatePreviewMetric(
      ratePreviewTotalSuperScenarioEl,
      ratePreviewTotalSuperCurrentEl,
      ratePreviewTotalSuperVarianceEl,
      data.scenario && data.scenario.super,
      data.current && data.current.super,
      data.variance && data.variance.super,
      data.variance && data.variance.superPercent
    );
    setRatePreviewMetric(
      ratePreviewTotalTaxScenarioEl,
      ratePreviewTotalTaxCurrentEl,
      ratePreviewTotalTaxVarianceEl,
      data.scenario && data.scenario.tax,
      data.current && data.current.tax,
      data.variance && data.variance.tax,
      data.variance && data.variance.taxPercent,
      true
    );
    setRatePreviewMetric(
      ratePreviewTotalNetScenarioEl,
      ratePreviewTotalNetCurrentEl,
      ratePreviewTotalNetVarianceEl,
      data.scenario && data.scenario.net,
      data.current && data.current.net,
      data.variance && data.variance.net,
      data.variance && data.variance.netPercent
    );
    const hasContractCap = Number(data.current && data.current.remainingHours) > 0;
    if (ratePreviewRemainingCard) {
      ratePreviewRemainingCard.style.display = hasContractCap ? 'flex' : 'none';
    }
    if (hasContractCap) {
      if (ratePreviewRemainingScenarioEl) ratePreviewRemainingScenarioEl.textContent = formatCurrency(data.scenario && data.scenario.remainingEarnings);
      if (ratePreviewRemainingCurrentEl) ratePreviewRemainingCurrentEl.textContent = formatCurrency(data.current && data.current.remainingEarnings);
      if (ratePreviewContractHoursEl) {
        const hoursValue = Number(data.current && data.current.remainingHours) || 0;
        ratePreviewContractHoursEl.textContent = `${formatDecimalHours(hoursValue)} hrs`;
      }
      if (ratePreviewRemainingVarianceEl) {
        const remainingVariance = Number(data.variance && data.variance.remainingEarnings) || 0;
        const remainingVarianceText = formatSignedCurrency(remainingVariance);
        const remainingVariancePercent = Number.isFinite(Number(data.variance && data.variance.remainingEarningsPercent))
          ? ` (${formatPercentValue(data.variance.remainingEarningsPercent)})`
          : '';
        ratePreviewRemainingVarianceEl.textContent = remainingVarianceText + remainingVariancePercent;
        applyRatePreviewVariance(ratePreviewRemainingVarianceEl, remainingVariance);
      }
      setRatePreviewMetric(
        ratePreviewRemainingSuperScenarioEl,
        ratePreviewRemainingSuperCurrentEl,
        ratePreviewRemainingSuperVarianceEl,
        data.scenario && data.scenario.remainingSuper,
        data.current && data.current.remainingSuper,
        data.variance && data.variance.remainingSuper,
        data.variance && data.variance.remainingSuperPercent
      );
      setRatePreviewMetric(
        ratePreviewRemainingTaxScenarioEl,
        ratePreviewRemainingTaxCurrentEl,
        ratePreviewRemainingTaxVarianceEl,
        data.scenario && data.scenario.remainingTax,
        data.current && data.current.remainingTax,
        data.variance && data.variance.remainingTax,
        data.variance && data.variance.remainingTaxPercent,
        true
      );
      setRatePreviewMetric(
        ratePreviewRemainingNetScenarioEl,
        ratePreviewRemainingNetCurrentEl,
        ratePreviewRemainingNetVarianceEl,
        data.scenario && data.scenario.remainingNet,
        data.current && data.current.remainingNet,
        data.variance && data.variance.remainingNet,
        data.variance && data.variance.remainingNetPercent
      );
    }
    if (!hasContractCap) {
      if (ratePreviewRemainingScenarioEl) ratePreviewRemainingScenarioEl.textContent = formatCurrency(data.scenario && data.scenario.remainingEarnings);
      if (ratePreviewRemainingCurrentEl) ratePreviewRemainingCurrentEl.textContent = formatCurrency(data.current && data.current.remainingEarnings);
      if (ratePreviewContractHoursEl) ratePreviewContractHoursEl.textContent = '--';
      if (ratePreviewRemainingVarianceEl) {
        ratePreviewRemainingVarianceEl.textContent = '--';
        applyRatePreviewVariance(ratePreviewRemainingVarianceEl, null);
      }
      setRatePreviewMetric(ratePreviewRemainingSuperScenarioEl, ratePreviewRemainingSuperCurrentEl, ratePreviewRemainingSuperVarianceEl, null, null, null, null);
      setRatePreviewMetric(ratePreviewRemainingTaxScenarioEl, ratePreviewRemainingTaxCurrentEl, ratePreviewRemainingTaxVarianceEl, null, null, null, null, true);
      setRatePreviewMetric(ratePreviewRemainingNetScenarioEl, ratePreviewRemainingNetCurrentEl, ratePreviewRemainingNetVarianceEl, null, null, null, null);
    }
    if (ratePreviewSummaryFootnote) {
      const entryCount = Number(data.metadata && data.metadata.entryCount) || 0;
      const monthCount = Number(data.metadata && data.metadata.monthCount) || 0;
      if (entryCount === 0) {
        ratePreviewSummaryFootnote.textContent = 'No entries logged yetâfuture time entries will update this preview automatically.';
      } else {
        const entryLabel = entryCount === 1 ? '1 entry' : `${entryCount} entries`;
        const monthLabel = monthCount === 1 ? '1 month' : `${monthCount} months`;
        ratePreviewSummaryFootnote.textContent = `Based on ${entryLabel} across ${monthLabel}.`;
      }
    }
    if (ratePreviewNoEntriesNote) {
      const entryCount = Number(data.metadata && data.metadata.entryCount) || 0;
      ratePreviewNoEntriesNote.style.display = entryCount === 0 ? 'block' : 'none';
    }
    renderRatePreviewMonthlyRows(Array.isArray(data.monthly) ? data.monthly : []);
    if (ratePreviewContent) ratePreviewContent.style.display = 'block';
    updateRatePreviewEmptyState();
    ratePreviewInputSyncing = true;
    const scenarioRate = normalizeRateValue(data.scenario && data.scenario.hourlyRate);
    if (ratePreviewRateInput) ratePreviewRateInput.value = scenarioRate.toFixed(2);
    if (ratePreviewPercentInput) {
      if (Number.isFinite(Number(data.scenario && data.scenario.percentChange))) {
        ratePreviewPercentInput.value = formatPercentInputValue(data.scenario.percentChange);
      } else {
        ratePreviewPercentInput.value = '';
      }
    }
    ratePreviewInputSyncing = false;
    state.ratePreview.inputs.newRate = scenarioRate;
    state.ratePreview.inputs.percentChange = Number.isFinite(Number(data.scenario && data.scenario.percentChange))
      ? normalizePercentValue(data.scenario.percentChange)
      : null;
  }

  function appendRatePreviewMetricCell(rowEl, scenarioValue, currentValue, varianceValue, variancePercent, invertTrend) {
    const cell = document.createElement('td');
    cell.className = 'rate-preview-metric-cell';
    const scenarioDiv = document.createElement('div');
    scenarioDiv.className = 'rate-preview-metric-cell-main';
    if (scenarioValue === null || scenarioValue === undefined) {
      scenarioDiv.textContent = '--';
    } else {
      scenarioDiv.textContent = formatCurrency(scenarioValue);
    }
    const varianceDiv = document.createElement('div');
    varianceDiv.className = 'rate-preview-metric-cell-variance';
    applyRatePreviewVariance(varianceDiv, null);
    if (varianceValue === null || varianceValue === undefined) {
      varianceDiv.textContent = '--';
    } else {
      varianceDiv.textContent = formatSignedCurrency(varianceValue);
      const varianceForColor = invertTrend ? -varianceValue : varianceValue;
      applyRatePreviewVariance(varianceDiv, varianceForColor);
      if (Number.isFinite(Number(variancePercent))) {
        const percentSpan = document.createElement('span');
        percentSpan.className = 'rate-preview-metric-cell-percent';
        percentSpan.textContent = `(${formatPercentValue(variancePercent)})`;
        varianceDiv.appendChild(percentSpan);
      }
    }
    const currentDiv = document.createElement('div');
    currentDiv.className = 'rate-preview-metric-cell-sub';
    if (currentValue === null || currentValue === undefined) {
      currentDiv.textContent = 'Current: --';
    } else {
      currentDiv.textContent = `Current: ${formatCurrency(currentValue)}`;
    }
    cell.append(scenarioDiv, varianceDiv, currentDiv);
    rowEl.appendChild(cell);
  }

  function renderRatePreviewMonthlyRows(rows) {
    if (!ratePreviewMonthlyBody) return;
    ratePreviewMonthlyBody.innerHTML = '';
    if (!rows.length) {
      const emptyRow = document.createElement('tr');
      const cell = document.createElement('td');
      cell.colSpan = 5;
      cell.style.textAlign = 'center';
      cell.textContent = 'No months to display yet.';
      emptyRow.appendChild(cell);
      ratePreviewMonthlyBody.appendChild(emptyRow);
      return;
    }
    rows.forEach((row) => {
      const tr = document.createElement('tr');
      const monthTd = document.createElement('td');
      monthTd.textContent = row.label || row.month || '--';
      const hoursTd = document.createElement('td');
      hoursTd.textContent = `${formatDecimalHours(row.hours || 0)} hrs`;
      tr.append(monthTd, hoursTd);
      appendRatePreviewMetricCell(tr, row.scenarioEarnings, row.currentEarnings, row.variance, row.variancePercent);
      appendRatePreviewMetricCell(tr, row.scenarioSuper, row.currentSuper, row.superVariance, row.superVariancePercent);
      appendRatePreviewMetricCell(tr, row.scenarioTax, row.currentTax, row.taxVariance, row.taxVariancePercent, true);
      appendRatePreviewMetricCell(tr, row.scenarioNet, row.currentNet, row.netVariance, row.netVariancePercent);
      ratePreviewMonthlyBody.appendChild(tr);
    });
  }

  function handleRatePreviewContractChange() {
    const contractId = ratePreviewContractSelect ? ratePreviewContractSelect.value : '';
    state.ratePreview.selectedContractId = contractId || '';
    state.ratePreview.data = null;
    state.ratePreview.loading = false;
    state.ratePreview.inputs = { percentChange: null, newRate: null };
    state.ratePreview.requestToken += 1;
    hideRatePreviewLoading();
    clearRatePreviewContent();
    if (!contractId || !state.contractMap[contractId]) {
      updateRatePreviewEmptyState();
      return;
    }
    const contract = state.contractMap[contractId];
    const baseRate = normalizeRateValue(contract.hourly_rate);
    ratePreviewInputSyncing = true;
    if (ratePreviewPercentInput) {
      ratePreviewPercentInput.value = '';
      ratePreviewPercentInput.disabled = baseRate === 0;
      ratePreviewPercentInput.placeholder = baseRate === 0 ? 'Unavailable for $0 rates' : 'e.g. 5';
    }
    if (ratePreviewRateInput) ratePreviewRateInput.value = baseRate.toFixed(2);
    ratePreviewInputSyncing = false;
    state.ratePreview.inputs.newRate = baseRate;
    state.ratePreview.inputs.percentChange = null;
    updateRatePreviewEmptyState();
    scheduleRatePreviewFetch(true);
  }

  function resetRatePreviewInputs() {
    const contractId = state.ratePreview.selectedContractId;
    if (!contractId || !state.contractMap[contractId]) return;
    const baseRate = normalizeRateValue(state.contractMap[contractId].hourly_rate);
    state.ratePreview.inputs = { percentChange: null, newRate: baseRate };
    ratePreviewInputSyncing = true;
    if (ratePreviewPercentInput) ratePreviewPercentInput.value = '';
    if (ratePreviewRateInput) ratePreviewRateInput.value = baseRate.toFixed(2);
    ratePreviewInputSyncing = false;
    scheduleRatePreviewFetch(true);
  }

  function handleRatePreviewPercentInput() {
    if (ratePreviewInputSyncing) return;
    const contractId = state.ratePreview.selectedContractId;
    if (!contractId || !state.contractMap[contractId]) return;
    const contract = state.contractMap[contractId];
    const baseRate = normalizeRateValue(contract.hourly_rate);
    if (!ratePreviewPercentInput) return;
    if (baseRate === 0) {
      ratePreviewPercentInput.value = '';
      return;
    }
    const raw = ratePreviewPercentInput.value.trim();
    if (raw === '') {
      state.ratePreview.inputs.percentChange = null;
      state.ratePreview.inputs.newRate = baseRate;
      ratePreviewInputSyncing = true;
      if (ratePreviewRateInput) ratePreviewRateInput.value = baseRate.toFixed(2);
      ratePreviewInputSyncing = false;
      scheduleRatePreviewFetch();
      return;
    }
    const parsed = Number(raw);
    if (!Number.isFinite(parsed)) return;
    const percent = normalizePercentValue(parsed);
    const calculatedRate = Math.max(0, baseRate * (1 + percent / 100));
    const normalizedRate = normalizeRateValue(calculatedRate);
    state.ratePreview.inputs.percentChange = percent;
    state.ratePreview.inputs.newRate = normalizedRate;
    ratePreviewInputSyncing = true;
    if (ratePreviewRateInput) ratePreviewRateInput.value = normalizedRate.toFixed(2);
    ratePreviewInputSyncing = false;
    scheduleRatePreviewFetch();
  }

  function handleRatePreviewPercentBlur() {
    if (!ratePreviewPercentInput) return;
    const raw = ratePreviewPercentInput.value.trim();
    if (raw === '') return;
    const parsed = Number(raw);
    if (!Number.isFinite(parsed)) {
      ratePreviewPercentInput.value = '';
      return;
    }
    ratePreviewPercentInput.value = formatPercentInputValue(parsed);
  }

  function handleRatePreviewRateInput() {
    if (ratePreviewInputSyncing) return;
    const contractId = state.ratePreview.selectedContractId;
    if (!contractId || !state.contractMap[contractId]) return;
    if (!ratePreviewRateInput) return;
    const raw = ratePreviewRateInput.value.trim();
    if (raw === '') {
      state.ratePreview.inputs.newRate = null;
      return;
    }
    const parsed = Number(raw);
    if (!Number.isFinite(parsed)) return;
    const normalizedRate = normalizeRateValue(parsed);
    state.ratePreview.inputs.newRate = normalizedRate;
    const contract = state.contractMap[contractId];
    const baseRate = normalizeRateValue(contract.hourly_rate);
    ratePreviewInputSyncing = true;
    if (ratePreviewPercentInput) {
      if (baseRate === 0) {
        ratePreviewPercentInput.value = '';
        state.ratePreview.inputs.percentChange = null;
      } else {
        const percent = normalizePercentValue(((normalizedRate - baseRate) / baseRate) * 100);
        state.ratePreview.inputs.percentChange = percent;
        ratePreviewPercentInput.value = percent != null ? formatPercentInputValue(percent) : '';
      }
    }
    ratePreviewInputSyncing = false;
    scheduleRatePreviewFetch();
  }

  function handleRatePreviewRateBlur() {
    if (!ratePreviewRateInput) return;
    const raw = ratePreviewRateInput.value.trim();
    if (raw === '') return;
    const parsed = Number(raw);
    if (!Number.isFinite(parsed)) {
      ratePreviewRateInput.value = state.ratePreview.inputs.newRate != null
        ? normalizeRateValue(state.ratePreview.inputs.newRate).toFixed(2)
        : '';
      return;
    }
    ratePreviewRateInput.value = normalizeRateValue(parsed).toFixed(2);
  }

  function renderRatePreviewPage(forceRefresh) {
    if (!isRatePreviewEnabled()) {
      updateRatePreviewEmptyState();
      return;
    }
    renderRatePreviewContractOptions();
    if (state.ratePreview.selectedContractId && !state.contractMap[state.ratePreview.selectedContractId]) {
      state.ratePreview.selectedContractId = '';
    }
    if (ratePreviewContractSelect) {
      ratePreviewContractSelect.value = state.ratePreview.selectedContractId || '';
    }
    updateRatePreviewEmptyState();
    if (forceRefresh && state.ratePreview.selectedContractId) {
      scheduleRatePreviewFetch(true);
      return;
    }
    if (state.ratePreview.data) {
      applyRatePreviewData(state.ratePreview.data);
    }
  }

  function renderContractsUI() {
    renderContractSelectorOptions();
    renderContractDetail();
    renderRatePreviewContractOptions();
    if (isRatePreviewEnabled()) {
      updateRatePreviewEmptyState();
    }
  }

  function handleContractSave() {
    if (!contractSaveBtn) return;
    const payload = getContractFormPayload();
    if (!payload) return;
    contractSaveBtn.disabled = true;
    const isEdit = !!state.editingContractId;
    setStatus(isEdit ? 'Updating contract...' : 'Saving contract...', 'warn');
    const handler = (res) => {
      contractSaveBtn.disabled = false;
      if (res && res.success && res.contract) {
        const normalized = sanitizeContract(res.contract);
        state.contracts = [...state.contracts.filter((c) => c.id !== normalized.id), normalized];
        state.selectedContractId = normalized.id;
        refreshContractBindings(normalized.id, normalized.id);
        saveCache();
        hideContractForm();
        renderContractDetail();
        setStatus(isEdit ? 'Contract updated' : 'Contract saved', 'success');
      } else {
        setStatus('Contract save failed', 'error');
      }
    };
    const failure = () => {
      contractSaveBtn.disabled = false;
      setStatus('Contract save failed', 'error');
    };
    if (isEdit) {
      google.script.run
        .withSuccessHandler(handler)
        .withFailureHandler(failure)
        .api_updateContract({ id: state.editingContractId, ...payload });
    } else {
      google.script.run
        .withSuccessHandler(handler)
        .withFailureHandler(failure)
        .api_addContract(payload);
    }
  }

  function handleContractEdit(id) {
    const contract = state.contracts.find((c) => c.id === id);
    if (!contract) return;
    populateContractForm(contract);
    showPage('contracts');
  }

  async function handleContractDelete(id) {
    if (!id) return;
    const hasEntries = state.entries.some((entry) => entry.contract_id === id);
    if (hasEntries) {
      customAlert('This contract already has time entries and cannot be deleted.');
      return;
    }
    const confirmed = await customConfirm('Delete this contract?', { danger: true });
    if (!confirmed) return;
    setStatus('Deleting contract...', 'warn');
    google.script.run
      .withSuccessHandler(() => {
        state.contracts = state.contracts.filter((contract) => contract.id !== id);
        if (state.editingContractId === id) {
          hideContractForm();
        }
        if (state.selectedContractId === id) {
          state.selectedContractId = '';
        }
        refreshContractBindings();
        saveCache();
        setStatus('Contract deleted', 'success');
      })
      .withFailureHandler(() => setStatus('Contract delete failed', 'error'))
      .api_deleteContract(id);
  }

  function renderFeatureFlags() {
    if (!featureFlagsListEl) return;
    featureFlagsListEl.innerHTML = '';
    if (featureFlagCollapseControls) {
      featureFlagCollapseControls.style.display = 'none';
    }

    const formatGroupTitle = (value) => {
      if (!value) return 'Other';
      return value.split('_').map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join(' ');
    };

    if (!state.featureFlagCollapse || typeof state.featureFlagCollapse !== 'object') {
      state.featureFlagCollapse = {};
    }

    const groups = {};
    const ensureGroup = (groupId) => {
      if (!groupId) groupId = 'other';
      if (!groups[groupId]) {
        const config = FEATURE_FLAG_GROUP_MAP[groupId] || { id: groupId, title: formatGroupTitle(groupId), order: 900 };
        groups[groupId] = {
          id: groupId,
          title: config.title || formatGroupTitle(groupId),
          order: config.order != null ? config.order : 900,
          items: []
        };
        if (state.featureFlagCollapse[groupId] === undefined) {
          state.featureFlagCollapse[groupId] = true;
        }
      }
      return groups[groupId];
    };
    const processed = new Set();
    const rawFlags = state.featureFlags && typeof state.featureFlags === 'object' ? state.featureFlags : {};

    const addFlagToGroup = (key, config, stateMeta) => {
      const shouldHideCompanyDependent = (key === 'enable_company_quarterly_bas' || key === 'is_sole_trader')
        && !state.companyTrackingEnabled;
      if (shouldHideCompanyDependent) return;

      const groupId = config.group || 'other';
      const group = ensureGroup(groupId);
      const item = {
        key,
        enabled: !!(stateMeta && stateMeta.enabled),
        name: config.name || (stateMeta && stateMeta.name) || key,
        description: config.description || (stateMeta && stateMeta.description) || '',
        order: config.order != null ? config.order : 0
      };
      group.items.push(item);
    };

    Object.keys(DEFAULT_FEATURE_FLAGS).forEach((key) => {
      const config = DEFAULT_FEATURE_FLAGS[key];
      const stateMeta = rawFlags[key];
      addFlagToGroup(key, config, stateMeta);
      processed.add(key);
    });

    Object.keys(rawFlags).forEach((key) => {
      if (processed.has(key)) return;
      const stateMeta = rawFlags[key] || {};
      const fallbackConfig = {
        name: (stateMeta && stateMeta.name) || key,
        description: (stateMeta && stateMeta.description) || '',
        order: 1000,
        group: 'other'
      };
      addFlagToGroup(key, fallbackConfig, stateMeta);
    });

    const groupList = Object.values(groups).filter((group) => group.items.length > 0);
    groupList.sort((a, b) => {
      if (a.order !== b.order) return a.order - b.order;
      return a.title.localeCompare(b.title);
    });

    if (featureFlagCollapseControls) {
      featureFlagCollapseControls.style.display = groupList.length ? 'flex' : 'none';
    }

    if (!groupList.length) {
      const empty = document.createElement('div');
      empty.className = 'ts-note';
      empty.textContent = 'No feature flags configured.';
      featureFlagsListEl.appendChild(empty);
      return;
    }

    const toggleGroup = (groupId) => {
      const current = !!state.featureFlagCollapse[groupId];
      state.featureFlagCollapse[groupId] = !current;
      saveCache();
      renderFeatureFlags();
    };

    groupList.forEach((group) => {
      group.items.sort((a, b) => {
        if (a.order !== b.order) return a.order - b.order;
        return a.name.localeCompare(b.name);
      });

      const container = document.createElement('div');
      container.className = 'ts-flag-group';

      const header = document.createElement('div');
      header.className = 'ts-flag-group-header';
      header.setAttribute('role', 'button');
      header.setAttribute('tabindex', '0');

      const collapsed = !!state.featureFlagCollapse[group.id];
      header.setAttribute('aria-expanded', collapsed ? 'false' : 'true');

      const titleWrapper = document.createElement('div');
      titleWrapper.className = 'ts-flag-group-header-title';
      const title = document.createElement('span');
      title.textContent = group.title;
      titleWrapper.appendChild(title);

      const count = document.createElement('span');
      count.className = 'ts-flag-group-count';
      count.textContent = `${group.items.length} item${group.items.length === 1 ? '' : 's'}`;
      titleWrapper.appendChild(count);

      const toggle = document.createElement('span');
      toggle.className = 'ts-flag-group-toggle';
      toggle.textContent = collapsed ? 'â¶' : 'â¼';

      header.appendChild(titleWrapper);
      header.appendChild(toggle);
      header.addEventListener('click', () => toggleGroup(group.id));
      header.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          toggleGroup(group.id);
        }
      });

      container.appendChild(header);

      const bodyId = `feature-flag-group-${group.id}`;
      header.setAttribute('aria-controls', bodyId);

      const body = document.createElement('div');
      body.className = 'ts-flag-group-body';
      body.id = bodyId;
      body.style.display = collapsed ? 'none' : 'block';

      group.items.forEach((flag) => {
        const row = document.createElement('div');
        row.className = 'ts-flag-row';

        const meta = document.createElement('div');
        meta.className = 'ts-flag-meta';
        meta.innerHTML = `<div class="ts-flag-title">${flag.name}</div>` + (flag.description ? `<div class="ts-flag-desc">${flag.description}</div>` : '');

        const toggleLabel = document.createElement('label');
        toggleLabel.className = 'ts-toggle';
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = flag.enabled;
        input.dataset.flag = flag.key;
        input.setAttribute('aria-label', flag.name);
        const track = document.createElement('span');
        track.className = 'ts-toggle-track';
        const thumb = document.createElement('span');
        thumb.className = 'ts-toggle-thumb';
        track.appendChild(thumb);
        toggleLabel.appendChild(input);
        toggleLabel.appendChild(track);

        input.addEventListener('change', () => {
          if (!!state.featureFlags[flag.key]?.enabled === input.checked) return;
          updateFeatureFlag(flag.key, input.checked);
        });

        row.append(meta, toggleLabel);
        body.appendChild(row);
      });

      container.appendChild(body);
      featureFlagsListEl.appendChild(container);
    });
  }

  function updateFeatureFlag(featureKey, enabled) {
    const toggleInput = featureFlagsListEl ? featureFlagsListEl.querySelector(`input[data-flag="${featureKey}"]`) : null;
    if (toggleInput) toggleInput.disabled = true;
    const defaultMeta = DEFAULT_FEATURE_FLAGS[featureKey];
    const currentMeta = state.featureFlags[featureKey] || {
      name: defaultMeta ? defaultMeta.name : featureKey,
      description: defaultMeta ? defaultMeta.description : '',
      enabled: false
    };
    setStatus('Updating feature flags...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (toggleInput) toggleInput.disabled = false;
        if (res && res.success && res.flags) {
          state.featureFlags = normalizeFeatureFlags(res.flags);
          saveCache();
          renderFeatureFlags();
          applyFeatureFlags();

          // If no_lost_super_to_deductions was just enabled and the setting doesn't exist, save default
          if (featureKey === 'no_lost_super_to_deductions' && enabled && !state.settings.lost_super_recovery_mode) {
            const defaultMode = 'extra_contribution';
            state.settings.lost_super_recovery_mode = defaultMode;
            saveCache();
            google.script.run
              .withSuccessHandler(() => {
                if (lostSuperRecoveryModeSelect) lostSuperRecoveryModeSelect.value = defaultMode;
                captureSettingsState();
                renderIncomeSummary();
              })
              .withFailureHandler(() => {})
              .api_updateSettings({ lost_super_recovery_mode: defaultMode });
          } else if (featureKey === 'no_lost_super_to_deductions') {
            // Recalculate income summary when this flag changes (and we didn't already queue it above)
            renderIncomeSummary();
          }

          setStatus('Feature flags updated', 'success');
        } else {
          if (toggleInput) toggleInput.checked = !!currentMeta.enabled;
          setStatus('Feature flag update failed', 'error');
        }
      })
      .withFailureHandler(() => {
        if (toggleInput) {
          toggleInput.disabled = false;
          toggleInput.checked = !!currentMeta.enabled;
        }
        setStatus('Feature flag update failed', 'error');
      })
      .api_setFeatureFlag({
        feature: featureKey,
        enabled: enabled
      });
  }

  function applyFeatureFlags() {
    const rememberFlag = state.featureFlags.remember_last_page || DEFAULT_FEATURE_FLAGS.remember_last_page || { enabled: false };
    if (rememberFlag.enabled) {
      let stored = null;
      try {
        stored = localStorage.getItem(LAST_PAGE_KEY);
      } catch (e) {}
      if (!stored) {
        persistLastPage(state.currentPage);
      } else if (stored && PAGE_KEYS.includes(stored) && stored !== state.currentPage) {
        showPage(stored);
      }
    } else {
      try {
        localStorage.removeItem(LAST_PAGE_KEY);
      } catch (e) {}
    }
    const zeroFlag = state.featureFlags.show_zero_hours || DEFAULT_FEATURE_FLAGS.show_zero_hours || { enabled: false };
    state.showZeroHours = !!zeroFlag.enabled;
    renderCalendar();
    updateClearCacheVisibility();

    const expectedMonthlyFlag = state.featureFlags.expected_monthly_hours || DEFAULT_FEATURE_FLAGS.expected_monthly_hours || { enabled: false };
    if (contractIncludeWeekendsRow) {
      contractIncludeWeekendsRow.style.display = expectedMonthlyFlag.enabled ? 'flex' : 'none';
    }

    const companyFlag = state.featureFlags.enable_company_tracking_features || DEFAULT_FEATURE_FLAGS.enable_company_tracking_features || { enabled: false };
    state.companyTrackingEnabled = !!companyFlag.enabled;
    updateDeductionFormVisibility();

    const categoryFlag = state.featureFlags.enable_deduction_categories || DEFAULT_FEATURE_FLAGS.enable_deduction_categories || { enabled: false };
    if (btnManageDeductionCategories) {
      btnManageDeductionCategories.style.display = categoryFlag.enabled ? 'inline-flex' : 'none';
    }
    if (categoryFlag.enabled) {
      loadDeductionCategories();
    } else {
      state.deductionCategories = [];
      state.deductionCategoryCollapse = { __uncategorised__: true };
      updateDeductionCategoryMap();
      renderDeductionCategoryOptions('');
      renderDeductionCategoryList();
      saveCache();
    }

    renderDeductionsList();
    renderIncomeSummary();

    const quarterlyFlag = state.featureFlags.enable_company_quarterly_bas || DEFAULT_FEATURE_FLAGS.enable_company_quarterly_bas || { enabled: false };
    state.companyBasQuarterly = state.companyTrackingEnabled && !!quarterlyFlag.enabled;
    if (navBasBtn) {
      navBasBtn.style.display = state.companyTrackingEnabled ? 'block' : 'none';
    }
    if (!state.companyTrackingEnabled && state.currentPage === 'bas') {
      showPage('time');
    }
    renderBasReporting();

    updatePayrollHelperButtons();

    // Show/hide hour types navigation
    const hourTypesFlag = state.featureFlags.hour_types || DEFAULT_FEATURE_FLAGS.hour_types || { enabled: false };
    if (navHourTypesBtn) {
      navHourTypesBtn.style.display = hourTypesFlag.enabled ? 'block' : 'none';
    }
    if (hourTypesFlag.enabled) {
      loadHourTypes();
    }
    updateHourTypeFormVisibility();

    const ratePreviewFlag = state.featureFlags.contract_rate_preview || DEFAULT_FEATURE_FLAGS.contract_rate_preview || { enabled: false };
    if (navRatePreviewBtn) {
      navRatePreviewBtn.style.display = ratePreviewFlag.enabled ? 'block' : 'none';
    }
    if (ratePreviewFlag.enabled) {
      renderRatePreviewContractOptions();
      updateRatePreviewEmptyState();
    } else {
      if (state.currentPage === 'rate-preview') {
        showPage('contracts');
      }
      resetRatePreviewState();
    }

    const invoicesFlag = state.featureFlags.enable_invoices || DEFAULT_FEATURE_FLAGS.enable_invoices || { enabled: false };
    if (navInvoicesBtn) {
      navInvoicesBtn.style.display = invoicesFlag.enabled ? 'block' : 'none';
    }
    if (invoiceTemplateCol) invoiceTemplateCol.classList.toggle('ts-hidden', !invoicesFlag.enabled);
    if (invoiceOutputFolderCol) invoiceOutputFolderCol.classList.toggle('ts-hidden', !invoicesFlag.enabled);
    if (invoiceLineLimitCol) invoiceLineLimitCol.classList.toggle('ts-hidden', !invoicesFlag.enabled);
    if (!invoicesFlag.enabled && state.currentPage === 'invoices') {
      showPage('time');
    }
    if (invoicesFlag.enabled) {
      initializeInvoicesFeature();
    } else {
      resetInvoicesState();
    }

    // Show/hide public holidays state setting
    const publicHolidaysFlag = state.featureFlags.enable_public_holidays || DEFAULT_FEATURE_FLAGS.enable_public_holidays || { enabled: false };
    if (publicHolidayStateCol) {
      publicHolidayStateCol.classList.toggle('ts-hidden', !publicHolidaysFlag.enabled);
    }
    if (publicHolidaysFlag.enabled) {
      loadPublicHolidays();
    }

    // Show/hide PAYG rate setting (only for sole traders)
    const soleTraderFlag = state.featureFlags.is_sole_trader || DEFAULT_FEATURE_FLAGS.is_sole_trader || { enabled: false };
    if (paygRateCol) {
      paygRateCol.classList.toggle('ts-hidden', !soleTraderFlag.enabled);
    }

    // Show/hide minimum end time setting
    const suggestEndTimeFlag = state.featureFlags.suggest_end_time || DEFAULT_FEATURE_FLAGS.suggest_end_time || { enabled: false };
    if (minimumEndTimeCol) {
      minimumEndTimeCol.classList.toggle('ts-hidden', !suggestEndTimeFlag.enabled);
    }

    // Show/hide lost super recovery mode setting
    const noLostSuperFlag = state.featureFlags.no_lost_super_to_deductions || DEFAULT_FEATURE_FLAGS.no_lost_super_to_deductions || { enabled: false };
    if (lostSuperRecoveryCol) {
      lostSuperRecoveryCol.classList.toggle('ts-hidden', !noLostSuperFlag.enabled);
    }

    // Show/hide colorblind theme options
    const colorblindThemesFlag = state.featureFlags.enable_colorblind_themes || DEFAULT_FEATURE_FLAGS.enable_colorblind_themes || { enabled: false };
    const colorblindThemeOptions = document.querySelectorAll('.ts-colorblind-theme');
    colorblindThemeOptions.forEach(function(option) {
      option.style.display = colorblindThemesFlag.enabled ? 'block' : 'none';
    });

    // Update custom theme availability and controls
    updateCustomThemeControls();
  }

  if (contractSaveBtn) {
    contractSaveBtn.onclick = handleContractSave;
  }
  if (contractCancelBtn) {
    contractCancelBtn.onclick = () => {
      hideContractForm();
      renderContractDetail();
    };
  }
  if (contractAddToggle) {
    contractAddToggle.addEventListener('click', () => {
      showPage('contracts');
      if (state.contractFormMode === 'create') {
        hideContractForm();
        renderContractDetail();
        return;
      }
      if (state.contractFormMode === 'edit') {
        hideContractForm();
      }
      showContractForm('create');
    });
  }
  if (contractSelector) {
    contractSelector.addEventListener('change', () => {
      const nextId = contractSelector.value || '';
      if (state.contractFormMode === 'create' || (state.contractFormMode === 'edit' && state.editingContractId && state.editingContractId !== nextId)) {
        hideContractForm();
      }
      state.selectedContractId = nextId;
      renderContractDetail();
    });
  }
  setContractFormMode('hidden');

  function updateClearCacheVisibility() {
    if (!clearCacheWrapper) return;
    const enabled = !!(state.featureFlags.show_clear_cache && state.featureFlags.show_clear_cache.enabled);
    clearCacheWrapper.style.display = enabled ? 'block' : 'none';
  }

  if (clearCacheBtn) {
    clearCacheBtn.addEventListener('click', async () => {
      const confirmed = await customConfirm('Clear cached entries and settings from this browser?', {
        title: 'Clear Cache',
        danger: true
      });
      if (!confirmed) return;
      try {
        localStorage.removeItem(state.cacheKey);
        localStorage.removeItem(LAST_PAGE_KEY);
      } catch (e) {}
      setStatus('Local cache cleared. Data will be reloaded from the server on next sync.', 'success');
    });
  }

  if (payrollXeroBtn) {
    payrollXeroBtn.addEventListener('click', () => {
      renderXeroPayrollHelper();
      showModal(xeroHelperModal);
    });
  }

  if (payrollMyobBtn) {
    payrollMyobBtn.addEventListener('click', () => {
      renderMyobPayrollHelper();
      showModal(myobHelperModal);
    });
  }

  // Actual Income Modal Event Listeners
  if (actualIncomeBtn) {
    actualIncomeBtn.addEventListener('click', openActualIncomeModal);
  }
  if (btnSaveActualIncome) {
    btnSaveActualIncome.addEventListener('click', saveActualIncome);
  }
  if (btnCancelActualIncome) {
    btnCancelActualIncome.addEventListener('click', closeActualIncomeModal);
  }
  if (btnDeleteActualIncome) {
    btnDeleteActualIncome.addEventListener('click', deleteActualIncome);
  }

  // Monthly Print View Event Listeners
  if (printMonthlyBtn) {
    printMonthlyBtn.addEventListener('click', openPrintViewConfigModal);
  }
  if (btnCancelPrintView) {
    btnCancelPrintView.addEventListener('click', closePrintViewConfigModal);
  }
  if (btnGeneratePrintView) {
    btnGeneratePrintView.addEventListener('click', generatePrintView);
  }
  if (btnUnselectAllOther) {
    btnUnselectAllOther.addEventListener('click', unselectAllOtherHourTypes);
  }

  // Entries & KPIs
  function minutesForDate(date) {
    return state.entries
      .filter((e) => e.date === date)
      .reduce((acc, entry) => acc + (Number(entry.duration_minutes) || 0), 0);
  }
  const monthKeyFor = (year, month) => `${year}-${String(month + 1).padStart(2, '0')}`;
  function entriesForMonth(year, month) {
    const prefix = monthKeyFor(year, month);
    return state.entries.filter((entry) => entry.date && entry.date.startsWith(prefix));
  }
  function payrollEligibleEntries(year, month) {
    return entriesForMonth(year, month).filter((entry) => entry && entry.date && entryContributesToIncome(entry));
  }
  function formatRangeLabel(startDate, endDate) {
    const startLabel = MONTH_DAY_FORMATTER.format(startDate);
    const endLabel = MONTH_DAY_FORMATTER.format(endDate);
    return startLabel === endLabel ? startLabel : `${startLabel} - ${endLabel}`;
  }
  function buildXeroPayrollReport(year, month) {
    const eligibleEntries = payrollEligibleEntries(year, month);
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const minutesByDay = Array.from({ length: daysInMonth + 1 }, () => 0);
    eligibleEntries.forEach((entry) => {
      const dayString = entry.date ? entry.date.slice(-2) : '';
      const day = Number(dayString);
      if (!Number.isFinite(day)) return;
      minutesByDay[day] += Number(entry.duration_minutes) || 0;
    });
    const weeks = [];
    let cumulativeMinutes = 0;
    for (let start = 1; start <= daysInMonth; start += 7) {
      const end = Math.min(start + 6, daysInMonth);
      let weekMinutes = 0;
      const days = [];
      for (let offset = 0; offset < 7; offset += 1) {
        const day = start + offset;
        const existsInMonth = day <= daysInMonth;
        const dateObj = new Date(year, month, day);
        const minutes = existsInMonth ? (minutesByDay[day] || 0) : 0;
        if (existsInMonth) weekMinutes += minutes;
        days.push({
          date: dateObj,
          minutes,
          inMonth: existsInMonth
        });
      }
      cumulativeMinutes += weekMinutes;
      weeks.push({
        startDay: start,
        endDay: end,
        days,
        weekMinutes,
        cumulativeMinutes
      });
    }
    return {
      weeks,
      totalMinutes: cumulativeMinutes,
      hasEntries: eligibleEntries.length > 0
    };
  }
  function buildMyobPayrollReport(year, month) {
    const eligibleEntries = payrollEligibleEntries(year, month);
    const minutesByDate = eligibleEntries.reduce((map, entry) => {
      if (!entry.date) return map;
      map[entry.date] = (map[entry.date] || 0) + (Number(entry.duration_minutes) || 0);
      return map;
    }, {});
    const monthStart = startOfDay(new Date(year, month, 1));
    const monthEnd = startOfDay(new Date(year, month + 1, 0));
    const firstWeekStart = (() => {
      const first = new Date(monthStart);
      const offset = (first.getDay() + 6) % 7; // shift Sunday to 6, Monday to 0
      first.setDate(first.getDate() - offset);
      return startOfDay(first);
    })();
    const weeks = [];
    for (let cursor = new Date(firstWeekStart); cursor <= monthEnd; cursor.setDate(cursor.getDate() + 7)) {
      const weekStart = startOfDay(new Date(cursor));
      const weekEnd = startOfDay(new Date(cursor));
      weekEnd.setDate(weekEnd.getDate() + 6);
      const days = [];
      let weekMinutes = 0;
      for (let i = 0; i < 7; i += 1) {
        const dayDate = new Date(weekStart);
        dayDate.setDate(dayDate.getDate() + i);
        const key = isoDate(dayDate);
        const inMonth = dayDate >= monthStart && dayDate <= monthEnd;
        const minutes = inMonth ? (minutesByDate[key] || 0) : 0;
        if (inMonth) weekMinutes += minutes;
        days.push({
          date: dayDate,
          minutes,
          inMonth
        });
      }
      weeks.push({
        weekStart,
        weekEnd,
        days,
        weekMinutes
      });
      if (weekEnd >= monthEnd) break;
    }
    const totalMinutes = weeks.reduce((acc, week) => acc + week.weekMinutes, 0);
    return {
      weeks,
      totalMinutes,
      hasEntries: eligibleEntries.length > 0
    };
  }
  function entryContributesToIncome(entry) {
    if (!entry) return false;
    const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
    const hourType = hourTypeId ? state.hourTypeMap[hourTypeId] : null;
    if (hourType && Object.prototype.hasOwnProperty.call(hourType, 'contributes_to_income')) {
      return !!hourType.contributes_to_income;
    }
    return true;
  }
  function renderXeroPayrollHelper() {
    if (!xeroHelperContent) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const report = buildXeroPayrollReport(year, month);
    xeroHelperContent.innerHTML = '';

    report.weeks.forEach((week) => {
      const section = document.createElement('section');
      section.className = 'ts-payroll-week ts-payroll-xero';
      const rangeStart = new Date(year, month, week.startDay);
      const rangeEnd = new Date(year, month, week.endDay);

      const heading = document.createElement('div');
      heading.className = 'ts-payroll-week-header';
      const title = document.createElement('h4');
      title.textContent = `Week ending ${MONTH_DAY_FORMATTER.format(rangeEnd)}`;
      heading.appendChild(title);
      section.appendChild(heading);

      const table = document.createElement('table');
      table.className = 'ts-payroll-table ts-payroll-table-grid';
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      week.days.forEach((day) => {
        const th = document.createElement('th');
        const label = `${WEEKDAY_FORMATTER.format(day.date)} ${MONTH_DAY_FORMATTER.format(day.date)}`;
        th.textContent = label;
        if (!day.inMonth) th.classList.add('ts-payroll-outside');
        headRow.appendChild(th);
      });
      const totalHead = document.createElement('th');
      totalHead.textContent = 'Month-to-date total';
      headRow.appendChild(totalHead);
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      const row = document.createElement('tr');
      week.days.forEach((day) => {
        const td = document.createElement('td');
        if (!day.inMonth) {
          td.classList.add('ts-payroll-outside');
          td.textContent = 'â';
        } else {
          const rounded = roundDuration(day.minutes || 0);
          td.textContent = formatDecimalHours(rounded / 60);
        }
        row.appendChild(td);
      });
      const totalCell = document.createElement('td');
      const roundedTotal = roundDuration(week.cumulativeMinutes || 0);
      totalCell.textContent = formatDecimalHours(roundedTotal / 60);
      row.appendChild(totalCell);
      tbody.appendChild(row);
      table.appendChild(tbody);

      section.appendChild(table);
      xeroHelperContent.appendChild(section);
    });

    const total = document.createElement('div');
    total.className = 'ts-payroll-total';
    const roundedMonthlyTotal = roundDuration(report.totalMinutes || 0);
    total.textContent = `Monthly total across all weeks: ${formatDecimalHours(roundedMonthlyTotal / 60)} hrs`;
    xeroHelperContent.appendChild(total);

    if (!report.hasEntries) {
      const empty = document.createElement('p');
      empty.className = 'ts-note';
      empty.textContent = 'No income-contributing hours logged for this month yet. Week ranges are shown with zero values so you can prepare entries ahead of time.';
      xeroHelperContent.appendChild(empty);
    }
  }
  function renderMyobPayrollHelper() {
    if (!myobHelperContent) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const report = buildMyobPayrollReport(year, month);
    myobHelperContent.innerHTML = '';

    report.weeks.forEach((week) => {
      const section = document.createElement('section');
      section.className = 'ts-payroll-week ts-payroll-myob';

      const heading = document.createElement('div');
      heading.className = 'ts-payroll-week-header';
      const title = document.createElement('h4');
      title.textContent = `Week of ${MONTH_DAY_FORMATTER.format(week.weekStart)}`;
      heading.appendChild(title);
      section.appendChild(heading);

      const table = document.createElement('table');
      table.className = 'ts-payroll-table ts-myob-table';
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      week.days.forEach((day) => {
        const th = document.createElement('th');
        th.textContent = `${WEEKDAY_FORMATTER.format(day.date)} ${MONTH_DAY_FORMATTER.format(day.date)}`;
        if (!day.inMonth) th.classList.add('ts-payroll-outside');
        headRow.appendChild(th);
      });
      const totalHead = document.createElement('th');
      totalHead.textContent = 'Week total';
      headRow.appendChild(totalHead);
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      const row = document.createElement('tr');
      week.days.forEach((day) => {
        const td = document.createElement('td');
        if (!day.inMonth) {
          td.classList.add('ts-payroll-outside');
          td.textContent = 'â';
        } else {
          const rounded = roundDuration(day.minutes || 0);
          td.textContent = formatDecimalHours(rounded / 60);
        }
        row.appendChild(td);
      });
      const totalCell = document.createElement('td');
      const roundedTotal = roundDuration(week.weekMinutes || 0);
      totalCell.textContent = formatDecimalHours(roundedTotal / 60);
      row.appendChild(totalCell);
      tbody.appendChild(row);
      table.appendChild(tbody);
      section.appendChild(table);
      myobHelperContent.appendChild(section);
    });

    const total = document.createElement('div');
    total.className = 'ts-payroll-total';
    const roundedMonthlyTotal = roundDuration(report.totalMinutes || 0);
    total.textContent = `Monthly total across all weeks: ${formatDecimalHours(roundedMonthlyTotal / 60)} hrs`;
    myobHelperContent.appendChild(total);

    if (!report.hasEntries) {
      const empty = document.createElement('p');
      empty.className = 'ts-note';
      empty.textContent = 'No income-contributing hours logged for this month yet. Weekly ranges include out-of-month days for context; in-month days show 0 hrs.';
      myobHelperContent.appendChild(empty);
    }
  }
  function updatePayrollHelperButtons() {
    if (!payrollXeroBtn && !payrollMyobBtn) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const hasEligibleEntries = payrollEligibleEntries(year, month).length > 0;
    if (payrollXeroBtn) {
      const visible = getFeatureFlag('xero_payroll_helper');
      payrollXeroBtn.style.display = visible ? 'inline-flex' : 'none';
      payrollXeroBtn.setAttribute('aria-disabled', visible && !hasEligibleEntries ? 'true' : 'false');
      payrollXeroBtn.title = visible && !hasEligibleEntries
        ? 'No income-contributing hours logged yet in this month'
        : 'Open the Xero payroll helper';
    }
    if (payrollMyobBtn) {
      const visible = getFeatureFlag('myob_payroll_helper');
      payrollMyobBtn.style.display = visible ? 'inline-flex' : 'none';
      payrollMyobBtn.setAttribute('aria-disabled', visible && !hasEligibleEntries ? 'true' : 'false');
      payrollMyobBtn.title = visible && !hasEligibleEntries
        ? 'No income-contributing hours logged yet in this month'
        : 'Open the MYOB payroll helper';
    }
    // Update actual income button visibility
    if (actualIncomeBtn) {
      const visible = getFeatureFlag('enable_actual_income');
      actualIncomeBtn.style.display = visible ? 'inline-flex' : 'none';
      actualIncomeBtn.title = 'Add or view actual income for the current month';
    }
    // Update print monthly button visibility
    if (printMonthlyBtn) {
      const visible = getFeatureFlag('enable_monthly_print_view');
      printMonthlyBtn.style.display = visible ? 'inline-flex' : 'none';
      printMonthlyBtn.title = 'Generate printable monthly hours view';
    }
  }

  // Actual Income Functions
  function openActualIncomeModal() {
    if (!actualIncomeModal) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const monthStr = `${year}-${String(month + 1).padStart(2, '0')}`;

    // Format month display text to match calendar (e.g., "October 2025")
    const monthDate = new Date(year, month, 1);
    const monthDisplayText = monthDate.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    if (actualIncomeMonthDisplay) actualIncomeMonthDisplay.textContent = monthDisplayText;

    // Check if there's existing data for this month
    const existing = state.actualIncome.find(item => item.month === monthStr);

    if (existing) {
      state.editingActualIncomeId = existing.id;
      if (actualIncomeTitle) actualIncomeTitle.textContent = 'Edit Actual Income';
      if (actualIncomeMonthInput) actualIncomeMonthInput.value = existing.month;
      if (actualIncomeGrossInput) actualIncomeGrossInput.value = existing.gross_income;
      if (actualIncomeSuperInput) actualIncomeSuperInput.value = existing.superannuation;
      if (actualIncomeTaxInput) actualIncomeTaxInput.value = existing.tax;
      if (actualIncomeNetInput) actualIncomeNetInput.value = existing.net_income;
      if (btnDeleteActualIncome) btnDeleteActualIncome.style.display = 'inline-flex';
    } else {
      state.editingActualIncomeId = null;
      if (actualIncomeTitle) actualIncomeTitle.textContent = 'Add Actual Income';
      if (actualIncomeMonthInput) actualIncomeMonthInput.value = monthStr;
      if (actualIncomeGrossInput) actualIncomeGrossInput.value = '';
      if (actualIncomeSuperInput) actualIncomeSuperInput.value = '';
      if (actualIncomeTaxInput) actualIncomeTaxInput.value = '';
      if (actualIncomeNetInput) actualIncomeNetInput.value = '';
      if (btnDeleteActualIncome) btnDeleteActualIncome.style.display = 'none';
    }

    showModal(actualIncomeModal);
  }

  function closeActualIncomeModal() {
    if (!actualIncomeModal) return;
    hideModal(actualIncomeModal);
    state.editingActualIncomeId = null;
  }

  async function saveActualIncome() {
    if (!actualIncomeMonthInput || !actualIncomeGrossInput || !actualIncomeSuperInput ||
        !actualIncomeTaxInput || !actualIncomeNetInput) return;

    const payload = {
      id: state.editingActualIncomeId || undefined,
      month: actualIncomeMonthInput.value,
      gross_income: Number(actualIncomeGrossInput.value) || 0,
      superannuation: Number(actualIncomeSuperInput.value) || 0,
      tax: Number(actualIncomeTaxInput.value) || 0,
      net_income: Number(actualIncomeNetInput.value) || 0
    };

    // Optimistic update
    const previousList = state.actualIncome.slice();
    if (state.editingActualIncomeId) {
      const index = state.actualIncome.findIndex(item => item.id === state.editingActualIncomeId);
      if (index !== -1) {
        state.actualIncome[index] = { ...state.actualIncome[index], ...payload };
      }
    } else {
      const tempId = 'temp_' + Date.now();
      state.actualIncome.push({ ...payload, id: tempId, created_at: '', updated_at: '' });
    }
    refreshActualIncomeMap();
    saveCache();
    renderIncomeSummary();
    closeActualIncomeModal();
    setStatus('Saving actual income...', 'warn');

    google.script.run
      .withSuccessHandler((response) => {
        if (response && response.success && response.actualIncome) {
          const updated = response.actualIncome;
          const index = state.actualIncome.findIndex(item =>
            item.id === state.editingActualIncomeId || item.id === updated.id || item.id.startsWith('temp_')
          );
          if (index !== -1) {
            state.actualIncome[index] = updated;
          } else {
            state.actualIncome.push(updated);
          }
          refreshActualIncomeMap();
          saveCache();
          renderIncomeSummary();
          setStatus('Actual income saved', 'success');
        } else {
          state.actualIncome = previousList;
          refreshActualIncomeMap();
          saveCache();
          renderIncomeSummary();
          setStatus('Actual income save failed', 'error');
        }
      })
      .withFailureHandler(() => {
        state.actualIncome = previousList;
        refreshActualIncomeMap();
        saveCache();
        renderIncomeSummary();
        setStatus('Actual income save failed', 'error');
      })
      .api_upsertActualIncome(payload);
  }

  async function deleteActualIncome() {
    if (!state.editingActualIncomeId) return;
    const confirmed = await customConfirm('Delete this actual income entry?', { danger: true });
    if (!confirmed) return;

    const previousList = state.actualIncome.slice();
    state.actualIncome = state.actualIncome.filter(item => item.id !== state.editingActualIncomeId);
    refreshActualIncomeMap();
    saveCache();
    renderIncomeSummary();
    closeActualIncomeModal();
    setStatus('Deleting actual income...', 'warn');

    google.script.run
      .withSuccessHandler(() => {
        setStatus('Actual income deleted', 'success');
      })
      .withFailureHandler(() => {
        state.actualIncome = previousList;
        refreshActualIncomeMap();
        saveCache();
        renderIncomeSummary();
        setStatus('Failed to delete actual income', 'error');
      })
      .api_deleteActualIncome(state.editingActualIncomeId);
  }

  function refreshActualIncomeMap() {
    state.actualIncomeMap = {};
    state.actualIncome.forEach(item => {
      state.actualIncomeMap[item.month] = item;
    });
  }

  // Monthly Print View Functions
  let printViewSelectedHourTypes = new Set();

  function openPrintViewConfigModal() {
    if (!printViewConfigModal) return;
    ensureCalendarState();
    const { year, month } = state.calendar;

    // Get all entries for the current month
    const monthEntries = entriesForMonth(year, month);

    if (monthEntries.length === 0) {
      customAlert('No time entries for this month', 'No entries to print');
      return;
    }

    // Get unique hour type IDs from the entries
    const hourTypeIds = new Set();
    monthEntries.forEach(entry => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      hourTypeIds.add(hourTypeId);
    });

    // Separate into income and non-income hour types
    const incomeTypes = [];
    const otherTypes = [];

    hourTypeIds.forEach(id => {
      const hourType = state.hourTypeMap[id];
      if (hourType) {
        if (hourType.contributes_to_income) {
          incomeTypes.push(hourType);
        } else {
          otherTypes.push(hourType);
        }
      }
    });

    // Initialize all selected by default
    printViewSelectedHourTypes.clear();
    incomeTypes.forEach(ht => printViewSelectedHourTypes.add(ht.id));
    otherTypes.forEach(ht => printViewSelectedHourTypes.add(ht.id));

    // Helper to create hour type row
    function createHourTypeRow(hourType, isIncome) {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px';
      row.style.borderRadius = '6px';
      row.style.transition = 'background 0.15s ease';

      const leftSide = document.createElement('div');
      leftSide.style.display = 'flex';
      leftSide.style.alignItems = 'center';
      leftSide.style.gap = '8px';

      const colorDot = document.createElement('span');
      colorDot.style.width = '12px';
      colorDot.style.height = '12px';
      colorDot.style.borderRadius = '50%';
      colorDot.style.backgroundColor = hourType.color || '#6b7280';
      colorDot.style.flexShrink = '0';

      const name = document.createElement('span');
      name.textContent = hourType.name;

      leftSide.appendChild(colorDot);
      leftSide.appendChild(name);

      const toggleLabel = document.createElement('label');
      toggleLabel.className = 'ts-toggle';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = true;
      checkbox.dataset.hourTypeId = hourType.id;
      checkbox.dataset.isIncome = isIncome ? 'true' : 'false';
      checkbox.addEventListener('change', updatePrintViewSelection);

      const track = document.createElement('span');
      track.className = 'ts-toggle-track';
      const thumb = document.createElement('span');
      thumb.className = 'ts-toggle-thumb';
      track.appendChild(thumb);

      toggleLabel.appendChild(checkbox);
      toggleLabel.appendChild(track);

      row.appendChild(leftSide);
      row.appendChild(toggleLabel);

      return row;
    }

    // Render income hour types
    if (printViewIncomeList) {
      printViewIncomeList.innerHTML = '';
      if (incomeTypes.length === 0) {
        const note = document.createElement('div');
        note.className = 'ts-note';
        note.textContent = 'No income-generating hour types in this month';
        printViewIncomeList.appendChild(note);
      } else {
        incomeTypes.forEach(hourType => {
          printViewIncomeList.appendChild(createHourTypeRow(hourType, true));
        });
      }
    }

    // Render other hour types
    if (printViewOtherList) {
      printViewOtherList.innerHTML = '';
      if (otherTypes.length === 0) {
        const note = document.createElement('div');
        note.className = 'ts-note';
        note.textContent = 'No non-income hour types in this month';
        printViewOtherList.appendChild(note);
      } else {
        otherTypes.forEach(hourType => {
          printViewOtherList.appendChild(createHourTypeRow(hourType, false));
        });
      }
    }

    // Validate initial selection - require exactly 1 income type and max 2 non-income types
    const selectedIncome = incomeTypes.length; // All are selected by default
    const selectedNonIncome = otherTypes.length; // All are selected by default
    const invalidIncome = selectedIncome !== 1;
    const invalidNonIncome = selectedNonIncome > 2;
    const isInvalid = invalidIncome || invalidNonIncome;

    if (printViewWarning) {
      printViewWarning.style.display = isInvalid ? 'block' : 'none';
      if (printViewWarningText) {
        if (invalidIncome && invalidNonIncome) {
          printViewWarningText.textContent = 'Exactly 1 income hour type and maximum 2 non-income hour types allowed.';
        } else if (invalidIncome) {
          printViewWarningText.textContent = 'Exactly 1 income hour type must be selected.';
        } else if (invalidNonIncome) {
          printViewWarningText.textContent = 'Maximum 2 non-income hour types allowed.';
        }
      }
    }
    if (btnGeneratePrintView) {
      btnGeneratePrintView.disabled = isInvalid || printViewSelectedHourTypes.size === 0;
    }

    showModal(printViewConfigModal);
  }

  function updatePrintViewSelection(event) {
    const checkbox = event.target;
    const hourTypeId = checkbox.dataset.hourTypeId;
    const isIncome = checkbox.dataset.isIncome === 'true';

    if (checkbox.checked) {
      printViewSelectedHourTypes.add(hourTypeId);
    } else {
      printViewSelectedHourTypes.delete(hourTypeId);
    }

    // Validate: exactly 1 income type and max 2 non-income types
    const selectedIncome = Array.from(printViewSelectedHourTypes).filter(id => {
      const hourType = state.hourTypeMap[id];
      return hourType && hourType.contributes_to_income;
    });

    const selectedNonIncome = Array.from(printViewSelectedHourTypes).filter(id => {
      const hourType = state.hourTypeMap[id];
      return hourType && !hourType.contributes_to_income;
    });

    const invalidIncome = selectedIncome.length !== 1;
    const invalidNonIncome = selectedNonIncome.length > 2;
    const isInvalid = invalidIncome || invalidNonIncome;

    if (printViewWarning) {
      printViewWarning.style.display = isInvalid ? 'block' : 'none';
      if (printViewWarningText) {
        if (invalidIncome && invalidNonIncome) {
          printViewWarningText.textContent = 'Exactly 1 income hour type and maximum 2 non-income hour types allowed.';
        } else if (invalidIncome) {
          printViewWarningText.textContent = 'Exactly 1 income hour type must be selected.';
        } else if (invalidNonIncome) {
          printViewWarningText.textContent = 'Maximum 2 non-income hour types allowed.';
        }
      }
    }
    if (btnGeneratePrintView) {
      btnGeneratePrintView.disabled = isInvalid || printViewSelectedHourTypes.size === 0;
    }
  }

  function closePrintViewConfigModal() {
    if (!printViewConfigModal) return;
    hideModal(printViewConfigModal);
    printViewSelectedHourTypes.clear();
  }

  function unselectAllOtherHourTypes() {
    if (!printViewOtherList) return;

    // Find all checkboxes in the other hour types list and uncheck them
    const checkboxes = printViewOtherList.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
      if (checkbox.checked) {
        checkbox.checked = false;
        const hourTypeId = checkbox.dataset.hourTypeId;
        printViewSelectedHourTypes.delete(hourTypeId);
      }
    });

    // Update validation state - check if exactly 1 income type is selected
    const selectedIncome = Array.from(printViewSelectedHourTypes).filter(id => {
      const hourType = state.hourTypeMap[id];
      return hourType && hourType.contributes_to_income;
    });

    const invalidIncome = selectedIncome.length !== 1;
    const isInvalid = invalidIncome;

    if (printViewWarning) {
      printViewWarning.style.display = isInvalid ? 'block' : 'none';
      if (printViewWarningText && invalidIncome) {
        printViewWarningText.textContent = 'Exactly 1 income hour type must be selected.';
      }
    }
    if (btnGeneratePrintView) {
      btnGeneratePrintView.disabled = isInvalid || printViewSelectedHourTypes.size === 0;
    }
  }

  function generatePrintView() {
    ensureCalendarState();
    const { year, month } = state.calendar;

    if (printViewSelectedHourTypes.size === 0) {
      return;
    }

    // Get rounding interval
    const roundInterval = getRoundInterval();

    // Helper to format hours with rounding
    function formatHours(minutes) {
      let displayMinutes = minutes;
      if (roundInterval > 1 && minutes > 0) {
        displayMinutes = Math.max(roundInterval, Math.round(minutes / roundInterval) * roundInterval);
      }
      return (displayMinutes / 60).toFixed(2);
    }

    // Get selected hour types
    const selectedTypes = Array.from(printViewSelectedHourTypes)
      .map(id => state.hourTypeMap[id])
      .filter(Boolean)
      .sort((a, b) => {
        // Sort income types first
        if (a.contributes_to_income && !b.contributes_to_income) return -1;
        if (!a.contributes_to_income && b.contributes_to_income) return 1;
        return a.name.localeCompare(b.name);
      });

    // Get all entries for the month
    const monthEntries = entriesForMonth(year, month);

    // Build daily summaries
    const dailySummaries = {};
    monthEntries.forEach(entry => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      if (!printViewSelectedHourTypes.has(hourTypeId)) return;

      if (!dailySummaries[entry.date]) {
        dailySummaries[entry.date] = {};
      }
      if (!dailySummaries[entry.date][hourTypeId]) {
        dailySummaries[entry.date][hourTypeId] = 0;
      }
      dailySummaries[entry.date][hourTypeId] += entry.duration_minutes || 0;
    });

    // Calculate monthly totals by category
    let workTotal = 0;
    let otherTotal = 0;
    const otherBreakdown = {};

    Object.values(dailySummaries).forEach(daySummary => {
      Object.keys(daySummary).forEach(hourTypeId => {
        const hourType = state.hourTypeMap[hourTypeId];
        if (hourType) {
          if (hourType.contributes_to_income) {
            workTotal += daySummary[hourTypeId];
          } else {
            otherTotal += daySummary[hourTypeId];
            if (!otherBreakdown[hourTypeId]) {
              otherBreakdown[hourTypeId] = 0;
            }
            otherBreakdown[hourTypeId] += daySummary[hourTypeId];
          }
        }
      });
    });

    // Generate HTML
    const monthDate = new Date(year, month, 1);
    const monthName = monthDate.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });

    // Build calendar grid
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    const firstDayOfWeek = firstDay.getDay(); // 0 = Sunday
    const startOffset = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1; // Convert to Monday = 0

    let calendarHtml = '<div style="display:grid; grid-template-columns:repeat(7, 1fr); gap:1px; margin-bottom:24px; border:2px solid #333; border-radius:8px; overflow:hidden; box-shadow:0 2px 8px rgba(0,0,0,0.1);">';

    // Add day headers
    ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].forEach(day => {
      calendarHtml += `<div style="font-weight:700; font-size:10px; padding:8px 4px; text-align:center; background:#333; color:#fff; letter-spacing:0.5px;">${day.toUpperCase()}</div>`;
    });

    // Add empty cells for offset
    for (let i = 0; i < startOffset; i++) {
      calendarHtml += '<div style="background:#f8f9fa; border-right:1px solid #dee2e6;"></div>';
    }

    // Add days
    for (let day = 1; day <= daysInMonth; day++) {
      const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
      const daySummary = dailySummaries[dateStr] || {};

      calendarHtml += '<div style="background:#fff; padding:6px; min-height:70px; font-size:10px; display:flex; flex-direction:column; border-right:1px solid #dee2e6; border-bottom:1px solid #dee2e6; position:relative;">';
      calendarHtml += `<div style="font-weight:600; font-size:11px; margin-bottom:6px; color:#6c757d;">${day}</div>`;

      // Collect income and other hours separately
      const incomeHoursHtml = [];
      const otherHoursHtml = [];

      selectedTypes.forEach(hourType => {
        const minutes = daySummary[hourType.id] || 0;
        if (minutes > 0) {
          const hours = formatHours(minutes);
          const isIncome = hourType.contributes_to_income;
          if (isIncome) {
            // Income hours: bold, no label, larger with better styling
            const style = `font-weight:700; font-size:18px; color:#000; background:${hourType.color}25; padding:4px 8px; margin:2px 0; border-radius:4px; text-align:center;`;
            incomeHoursHtml.push(`<div style="${style}">${hours}</div>`);
          } else {
            // Other hours: regular weight, with label, smaller with subtle styling
            const style = 'font-size:9px; color:#6c757d; margin:2px 0; padding:2px 4px; background:#f8f9fa; border-radius:3px;';
            otherHoursHtml.push(`<div style="${style}">${hours} ${hourType.name}</div>`);
          }
        }
      });

      // Add other hours first (between date and income)
      otherHoursHtml.forEach(html => {
        calendarHtml += html;
      });

      // Add income hours at bottom - wrap in div with margin-top:auto to always push to bottom
      if (incomeHoursHtml.length > 0) {
        calendarHtml += '<div style="margin-top:auto;">';
        incomeHoursHtml.forEach(html => {
          calendarHtml += html;
        });
        calendarHtml += '</div>';
      }

      calendarHtml += '</div>';
    }

    calendarHtml += '</div>';

    // Build separate tables for Work and Other
    let totalsHtml = '';

    // Work table
    if (workTotal > 0) {
      const workHours = formatHours(workTotal);
      totalsHtml += '<table style="width:100%; border-collapse:collapse; margin-top:24px; border:2px solid #333; border-radius:8px; overflow:hidden; box-shadow:0 2px 8px rgba(0,0,0,0.1);">';
      totalsHtml += '<thead><tr style="background:#333; color:#fff;"><th style="text-align:left; padding:12px; font-size:14px; font-weight:700; letter-spacing:0.5px;">WORK</th><th style="text-align:right; padding:12px; font-size:14px; font-weight:700;">TOTAL HOURS</th></tr></thead>';
      totalsHtml += '<tbody style="background:#fff;">';
      totalsHtml += `<tr><td style="padding:12px; font-weight:600; font-size:15px;">Total</td><td style="text-align:right; padding:12px; font-weight:700; font-size:16px; color:#000;">${workHours}</td></tr>`;
      totalsHtml += '</tbody></table>';
    }

    // Other table with breakdown
    if (otherTotal > 0) {
      const otherHours = formatHours(otherTotal);
      totalsHtml += '<table style="width:100%; border-collapse:collapse; margin-top:16px; border:2px solid #6c757d; border-radius:8px; overflow:hidden; box-shadow:0 2px 8px rgba(0,0,0,0.1);">';
      totalsHtml += '<thead><tr style="background:#6c757d; color:#fff;"><th style="text-align:left; padding:12px; font-size:14px; font-weight:700; letter-spacing:0.5px;">OTHER</th><th style="text-align:right; padding:12px; font-size:14px; font-weight:700;">TOTAL HOURS</th></tr></thead>';
      totalsHtml += '<tbody style="background:#fff;">';

      // Individual hour type breakdowns
      Object.keys(otherBreakdown).forEach(hourTypeId => {
        const hourType = state.hourTypeMap[hourTypeId];
        const hours = formatHours(otherBreakdown[hourTypeId]);
        totalsHtml += `<tr style="border-bottom:1px solid #dee2e6;"><td style="padding:10px 12px; color:#495057;">${hourType.name}</td><td style="text-align:right; padding:10px 12px; color:#495057; font-variant-numeric:tabular-nums;">${hours}</td></tr>`;
      });

      // Other total
      totalsHtml += `<tr style="background:#f8f9fa;"><td style="padding:12px; font-weight:600; font-size:15px;">Total</td><td style="text-align:right; padding:12px; font-weight:700; font-size:16px; color:#495057;">${otherHours}</td></tr>`;
      totalsHtml += '</tbody></table>';
    }

    // Complete HTML document
    const printHtml = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Monthly Hours - ${monthName}</title>
  <style>
    @page {
      size: A4 portrait;
      margin: 10mm 15mm;
    }
    @media print {
      html, body {
        margin: 0;
        padding: 0;
        width: 210mm;
        height: 297mm;
      }
      body {
        margin: 0 !important;
        padding: 10mm 15mm !important;
      }
      .no-print {
        display: none;
      }
      /* Try to hide browser headers/footers - browser dependent */
      @page {
        margin: 0;
      }
      body {
        padding-top: 10mm;
        padding-bottom: 10mm;
      }
    }
    @media screen {
      body {
        max-width: 210mm;
        margin: 0 auto;
        padding: 10mm 15mm;
      }
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      font-size: 12px;
      line-height: 1.5;
      color: #212529;
      background: #fff;
    }
    h1 {
      margin: 0 0 24px 0;
      font-size: 28px;
      font-weight: 700;
      text-align: center;
      color: #212529;
      letter-spacing: -0.5px;
      padding-bottom: 16px;
      border-bottom: 3px solid #333;
    }
    * {
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <h1>Monthly Hours<br><span style="font-size:20px; font-weight:500; color:#6c757d;">${monthName}</span></h1>
  ${calendarHtml}
  ${totalsHtml}
  <script>
    window.onload = function() {
      window.print();
    };
  <\/script>
</body>
</html>`;

    // Open in new window
    const printWindow = window.open('', '_blank');
    if (printWindow) {
      printWindow.document.write(printHtml);
      printWindow.document.close();
    }

    closePrintViewConfigModal();
  }

  function buildIncomeSummary(year, month) {
    const allEntries = entriesForMonth(year, month);
    // Filter to only include entries from hour types that contribute to income
    const entries = allEntries.filter(entry => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      const hourType = state.hourTypeMap[hourTypeId];
      return hourType ? hourType.contributes_to_income : true; // Default to true for backwards compatibility
    });
    const periodStart = new Date(year, month, 1);
    const periodStartStr = periodStart.toISOString().substring(0, 10);
    const superRate = getSuperGuaranteeRateForDate(periodStartStr);
    let totalMinutes = 0;
    let totalHours = 0;
    let totalPackage = 0;
    if (entries.length) {
      totalMinutes = entries.reduce((acc, entry) => acc + (Number(entry.duration_minutes) || 0), 0);
      totalHours = totalMinutes / 60;
    }
    const validContractsUsed = entries.reduce((set, entry) => {
      const contract = state.contractMap[entry.contract_id];
      if (contract && contractIsValid(contract, entry.date)) set.add(contract.id);
      return set;
    }, new Set());
    const validContractsAcrossDates = entries.reduce((set, entry) => {
      const valids = validContractsForDate(entry.date);
      valids.forEach((contract) => set.add(contract.id));
      return set;
    }, new Set());
    if (validContractsUsed.size === 1) {
      const onlyId = Array.from(validContractsUsed)[0];
      const contract = state.contractMap[onlyId];
      const rate = contract ? Number(contract.hourly_rate || 0) : 0;
      totalPackage = totalHours * rate;
    } else if (!validContractsUsed.size && validContractsAcrossDates.size === 1) {
      const fallbackId = Array.from(validContractsAcrossDates)[0];
      const contract = state.contractMap[fallbackId];
      const rate = contract ? Number(contract.hourly_rate || 0) : 0;
      totalPackage = totalHours * rate;
    } else {
      totalPackage = entries.reduce((acc, entry) => {
        const minutes = Number(entry.duration_minutes) || 0;
        let rate = 0;
        const contract = state.contractMap[entry.contract_id];
        if (contract && contractIsValid(contract, entry.date)) {
          rate = Number(contract.hourly_rate || 0);
        } else {
          const valids = validContractsForDate(entry.date);
          if (valids.length === 1) rate = Number(valids[0].hourly_rate || 0);
        }
        return acc + (minutes / 60) * rate;
      }, 0);
    }
    // Calculate hours for the hour type marked for rate calculation
    let rateCalcHours = 0;
    let rateCalcHourType = null;

    // Find the hour type marked for rate calculation (works regardless of hour types feature flag)
    rateCalcHourType = Object.values(state.hourTypeMap).find(ht => ht && ht.use_for_rate_calculation);
    if (rateCalcHourType) {
      const matchingEntries = allEntries.filter(entry => {
        const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
        return hourTypeId === rateCalcHourType.id;
      });

      const rateCalcMinutes = matchingEntries.reduce((acc, entry) => acc + (Number(entry.duration_minutes) || 0), 0);
      rateCalcHours = rateCalcMinutes / 60;
    }

    const deductionTotals = computeMonthlyDeductionTotals(year, month);
    const salarySacrifice = deductionTotals.personalStandardTotal;
    const companyExpenses = state.companyTrackingEnabled ? deductionTotals.companyStandardTotal : 0;
    const companyExpensesGst = state.companyTrackingEnabled ? deductionTotals.companyGstTotal : 0;

    const companyIncome = state.companyTrackingEnabled ? totalPackage : 0;
    const invoiceTotal = state.companyTrackingEnabled ? companyIncome * (1 + GST_RATE) : 0;
    const employeePackage = state.companyTrackingEnabled
      ? Math.max(0, companyIncome - companyExpenses)
      : totalPackage;
    const grossIncome = deriveGrossFromPackage(employeePackage, superRate);

    const extraSuperPercent = Math.max(0, deductionTotals.extraSuperPercentRate) * Math.max(0, grossIncome);
    const extraSuper = deductionTotals.extraSuperFlat + extraSuperPercent;

    // Calculate super base and lost super
    let superBase = Math.max(0, grossIncome - salarySacrifice);
    const idealSuper = Math.max(0, grossIncome * superRate);
    let superGuarantee = Math.max(0, superBase * superRate);
    let superLostDueToDeductions = Math.max(0, idealSuper - superGuarantee);

    // Check if "no lost super to deductions" feature is enabled
    const noLostSuperFlag = state.featureFlags.no_lost_super_to_deductions || DEFAULT_FEATURE_FLAGS.no_lost_super_to_deductions || { enabled: false };
    const recoveryMode = state.settings.lost_super_recovery_mode || 'extra_contribution';
    let recoveredSuper = 0;
    let recoveredToSuperBase = 0;

    if (noLostSuperFlag.enabled && superLostDueToDeductions > 0) {
      if (recoveryMode === 'extra_contribution') {
        // Add lost super as extra contribution
        recoveredSuper = superLostDueToDeductions;
        superLostDueToDeductions = 0;
      } else if (recoveryMode === 'add_to_taxable') {
        // Add lost super back to super base and taxable income
        recoveredToSuperBase = superLostDueToDeductions;
        superBase = Math.max(0, superBase + recoveredToSuperBase);
        superGuarantee = Math.max(0, superBase * superRate);
        superLostDueToDeductions = 0;
      }
    }

    const taxableIncome = Math.max(0, grossIncome - extraSuper - salarySacrifice + recoveredToSuperBase);
    const requestKey = `${monthKeyFor(year, month)}:${Math.round(taxableIncome * 100)}`;
    return {
      monthKey: monthKeyFor(year, month),
      periodStart,
      hasEntries: entries.length > 0,
      totalMinutes,
      totalHours,
      totalPackage,
      companyIncome,
      invoiceTotal,
      invoiceGst: invoiceTotal - companyIncome,
      companyExpenses,
      companyExpensesGst,
      grossIncome,
      superRate,
      superGuarantee,
      extraSuper: extraSuper + recoveredSuper,
      otherDeductions: salarySacrifice,
      totalSuper: superGuarantee + extraSuper + recoveredSuper,
      taxableIncome,
      superLostDueToDeductions,
      taxStatus: taxableIncome > 0 ? 'pending' : 'resolved',
      tax: taxableIncome > 0 ? null : 0,
      netIncome: taxableIncome > 0 ? null : taxableIncome,
      requestKey,
      rateCalcHours,
      rateCalcHourType
    };
  }
  function applyIncomeBreakdownVisibility() {
    if (!incomeBreakdownEl) return;
    incomeBreakdownEl.hidden = !incomeBreakdownExpanded;
    if (incomeToggleBtn) {
      incomeToggleBtn.dataset.expanded = incomeBreakdownExpanded ? 'true' : 'false';
      incomeToggleBtn.setAttribute('aria-expanded', incomeBreakdownExpanded ? 'true' : 'false');
    }
  }
  function updateIncomeSummaryUI(summary) {
    if (!incomeNetBadge && !incomeBreakdownEl) return;
    const hourlyRateDivider = document.getElementById('hourly-rate-divider');
    const hourlyRateGrossRow = document.getElementById('hourly-rate-gross-row');
    const hourlyRateNetRow = document.getElementById('hourly-rate-net-row');
    const hourlyRateGrossEl = document.getElementById('income-hourly-rate-gross');
    const hourlyRateNetEl = document.getElementById('income-hourly-rate-net');
    const hourlyRateGrossLabel = document.getElementById('hourly-rate-gross-label');
    const hourlyRateNetLabel = document.getElementById('hourly-rate-net-label');

    if (!summary) {
      if (incomeNetBadge) incomeNetBadge.textContent = 'Net income: --';
      if (incomeNetDetailEl) incomeNetDetailEl.textContent = '--';
      if (incomeInvoiceTotalEl) incomeInvoiceTotalEl.textContent = '--';
      if (incomeCompanyIncomeEl) incomeCompanyIncomeEl.textContent = '--';
      if (incomeInvoiceTotalRow) incomeInvoiceTotalRow.style.display = 'none';
      if (incomeCompanyIncomeRow) incomeCompanyIncomeRow.style.display = 'none';
      if (incomeCompanyExpensesEl) incomeCompanyExpensesEl.textContent = '--';
      if (incomeCompanyExpensesRow) incomeCompanyExpensesRow.style.display = 'none';
      if (incomeGrossEl) incomeGrossEl.textContent = '--';
      if (incomeSuperGuaranteeEl) incomeSuperGuaranteeEl.textContent = '--';
      if (incomeSuperLostEl) incomeSuperLostEl.textContent = '--';
      if (incomeSuperLostRow) incomeSuperLostRow.style.display = 'none';
      if (incomeExtraSuperEl) incomeExtraSuperEl.textContent = '--';
      if (incomeOtherDeductionsEl) incomeOtherDeductionsEl.textContent = '--';
      if (incomeTaxableEl) incomeTaxableEl.textContent = '--';
      if (incomeTaxEl) incomeTaxEl.textContent = '--';
      if (incomeActualGrossValueEl) incomeActualGrossValueEl.textContent = '';
      if (incomeActualSuperValueEl) incomeActualSuperValueEl.textContent = '';
      if (incomeActualTaxValueEl) incomeActualTaxValueEl.textContent = '';
      if (incomeActualNetValueEl) incomeActualNetValueEl.textContent = '';
      if (btnCompanyExpensesDetails) btnCompanyExpensesDetails.style.display = 'none';
      if (btnDeductionsDetails) btnDeductionsDetails.style.display = 'none';
      if (hourlyRateDivider) {
        hourlyRateDivider.hidden = true;
        hourlyRateDivider.style.display = 'none';
      }
      if (hourlyRateGrossRow) {
        hourlyRateGrossRow.hidden = true;
        hourlyRateGrossRow.style.display = 'none';
      }
      if (hourlyRateNetRow) {
        hourlyRateNetRow.hidden = true;
        hourlyRateNetRow.style.display = 'none';
      }
      if (hourlyRateGrossEl) hourlyRateGrossEl.textContent = '--';
      if (hourlyRateNetEl) hourlyRateNetEl.textContent = '--';
      if (hourlyRateGrossLabel) hourlyRateGrossLabel.textContent = '--';
      if (hourlyRateNetLabel) hourlyRateNetLabel.textContent = '--';
      return;
    }
    const netValue = summary.netIncome != null ? summary.netIncome : summary.taxableIncome;
    const netDisplay = (() => {
      if (summary.taxStatus === 'pending') return 'Calculating...';
      if (summary.taxStatus === 'error') return 'Tax unavailable';
      return formatCurrency(netValue);
    })();
    const taxText = (() => {
      if (summary.taxStatus === 'pending') return 'Calculating...';
      if (summary.taxStatus === 'error') return 'Tax unavailable';
      return formatCurrency(summary.tax || 0);
    })();

    // Check for actual income data - show actual if available, otherwise show estimate
    if (incomeNetBadge) {
      let displayValue = netDisplay;

      if (getFeatureFlag('enable_actual_income')) {
        const monthStr = `${state.calendar.year}-${String(state.calendar.month + 1).padStart(2, '0')}`;
        const actualData = state.actualIncomeMap[monthStr];

        // If we have actual data, show it immediately regardless of tax calculation status
        if (actualData) {
          displayValue = formatCurrency(actualData.net_income);
        }
      }

      incomeNetBadge.textContent = `Net income: ${displayValue}`;
    }
    if (incomeNetDetailEl) incomeNetDetailEl.textContent = netDisplay;
    if (incomeInvoiceTotalEl) incomeInvoiceTotalEl.textContent = formatCurrency(summary.invoiceTotal || 0);
    if (incomeCompanyIncomeEl) incomeCompanyIncomeEl.textContent = formatCurrency(summary.companyIncome || 0);
    if (incomeCompanyExpensesEl) incomeCompanyExpensesEl.textContent = formatCurrency(summary.companyExpenses || 0);
    if (incomeInvoiceTotalRow) {
      incomeInvoiceTotalRow.hidden = !state.companyTrackingEnabled;
      incomeInvoiceTotalRow.style.display = state.companyTrackingEnabled ? '' : 'none';
    }
    if (incomeCompanyIncomeRow) {
      incomeCompanyIncomeRow.hidden = !state.companyTrackingEnabled;
      incomeCompanyIncomeRow.style.display = state.companyTrackingEnabled ? '' : 'none';
    }
    if (incomeCompanyExpensesRow) {
      incomeCompanyExpensesRow.hidden = !state.companyTrackingEnabled;
      incomeCompanyExpensesRow.style.display = state.companyTrackingEnabled ? '' : 'none';
    }
    if (incomeGrossEl) incomeGrossEl.textContent = formatCurrency(summary.grossIncome);
    if (incomeSuperGuaranteeEl) incomeSuperGuaranteeEl.textContent = formatCurrency(summary.superGuarantee);
    if (incomeSuperLostEl) incomeSuperLostEl.textContent = formatCurrency(summary.superLostDueToDeductions || 0);
    if (incomeSuperLostRow) {
      const noLostSuperEnabled = state.featureFlags.no_lost_super_to_deductions?.enabled || false;
      const shouldShowSuperLost = !noLostSuperEnabled && summary.superLostDueToDeductions && summary.superLostDueToDeductions > 0.009;
      incomeSuperLostRow.style.display = shouldShowSuperLost ? '' : 'none';
    }
    if (incomeExtraSuperEl) incomeExtraSuperEl.textContent = formatCurrency(summary.extraSuper);
    if (incomeSuperTotalEl) {
      const estimatedSuperTotal = (summary.superGuarantee || 0) + (summary.extraSuper || 0);
      incomeSuperTotalEl.textContent = formatCurrency(estimatedSuperTotal);
    }
    if (incomeOtherDeductionsEl) incomeOtherDeductionsEl.textContent = formatCurrency(summary.otherDeductions);
    if (incomeTaxableEl) incomeTaxableEl.textContent = formatCurrency(summary.taxableIncome);
    if (incomeTaxEl) incomeTaxEl.textContent = taxText;

    // Show/hide detail buttons based on whether there are expenses
    if (btnCompanyExpensesDetails) {
      btnCompanyExpensesDetails.style.display = (summary.companyExpenses > 0.01) ? 'inline-block' : 'none';
    }
    if (btnDeductionsDetails) {
      btnDeductionsDetails.style.display = (summary.otherDeductions > 0.01) ? 'inline-block' : 'none';
    }

    // Show/hide and populate hourly rate section
    if (hourlyRateDivider && hourlyRateGrossRow && hourlyRateNetRow) {
      const rateCalcType = summary.rateCalcHourType;
      const shouldShowHourlyRate = rateCalcType &&
                                   rateCalcType.use_for_rate_calculation &&
                                   !rateCalcType.contributes_to_income &&
                                   summary.rateCalcHours > 0;

      if (shouldShowHourlyRate) {
        if (hourlyRateDivider) {
          hourlyRateDivider.hidden = false;
          hourlyRateDivider.style.display = '';
        }
        if (hourlyRateGrossRow) {
          hourlyRateGrossRow.hidden = false;
          hourlyRateGrossRow.style.display = '';
        }
        if (hourlyRateNetRow) {
          hourlyRateNetRow.hidden = false;
          hourlyRateNetRow.style.display = '';
        }

        const grossHourlyRate = summary.rateCalcHours > 0 ? summary.grossIncome / summary.rateCalcHours : 0;
        const netHourlyRateBase = summary.netIncome != null ? summary.netIncome : summary.taxableIncome;
        const netHourlyRate = summary.rateCalcHours > 0 ? netHourlyRateBase / summary.rateCalcHours : 0;
        const hourlyRateName = rateCalcType ? rateCalcType.name : '--';

        if (hourlyRateGrossEl) hourlyRateGrossEl.textContent = formatCurrency(grossHourlyRate) + '/hr';
        if (hourlyRateNetEl) hourlyRateNetEl.textContent = formatCurrency(netHourlyRate) + '/hr';
        if (hourlyRateGrossLabel) hourlyRateGrossLabel.textContent = hourlyRateName;
        if (hourlyRateNetLabel) hourlyRateNetLabel.textContent = hourlyRateName;
      } else {
        if (hourlyRateDivider) {
          hourlyRateDivider.hidden = true;
          hourlyRateDivider.style.display = 'none';
        }
        if (hourlyRateGrossRow) {
          hourlyRateGrossRow.hidden = true;
          hourlyRateGrossRow.style.display = 'none';
        }
        if (hourlyRateNetRow) {
          hourlyRateNetRow.hidden = true;
          hourlyRateNetRow.style.display = 'none';
        }
        if (hourlyRateGrossEl) hourlyRateGrossEl.textContent = '--';
        if (hourlyRateNetEl) hourlyRateNetEl.textContent = '--';
        if (hourlyRateGrossLabel) hourlyRateGrossLabel.textContent = '--';
        if (hourlyRateNetLabel) hourlyRateNetLabel.textContent = '--';
      }
    }

    // Handle actual income inline comparisons
    if (getFeatureFlag('enable_actual_income')) {
      const monthStr = `${state.calendar.year}-${String(state.calendar.month + 1).padStart(2, '0')}`;
      const actualData = state.actualIncomeMap[monthStr];

      if (actualData) {
        // Helper function to calculate and format variance display
        const formatActualWithVariance = (actual, estimated) => {
          const variance = actual - estimated;
          const absVariance = Math.abs(variance);
          if (absVariance < 0.01) {
            return `Act: ${formatCurrency(actual)}`;
          }
          const arrow = variance > 0 ? 'â' : 'â';
          const color = variance > 0 ? 'var(--success)' : 'var(--danger)';
          return `Act: ${formatCurrency(actual)} <span style="color:${color}">${arrow} ${formatCurrency(absVariance)}</span>`;
        };

        // Calculate estimated superannuation (super guarantee + extra super)
        const estimatedSuper = (summary.superGuarantee || 0) + (summary.extraSuper || 0);

        // For net income, if tax is still calculating, compare against taxable income instead
        const effectiveNetEstimate = (summary.taxStatus === 'pending' || summary.taxStatus === 'error')
          ? summary.taxableIncome
          : netValue;

        // Populate actual gross income
        if (incomeActualGrossValueEl) {
          incomeActualGrossValueEl.innerHTML = formatActualWithVariance(actualData.gross_income, summary.grossIncome);
        }

        // Populate actual superannuation
        if (incomeActualSuperValueEl) {
          incomeActualSuperValueEl.innerHTML = formatActualWithVariance(actualData.superannuation, estimatedSuper);
        }

        // Populate actual tax (only if we have a valid estimated tax)
        if (incomeActualTaxValueEl) {
          if (summary.taxStatus === 'pending') {
            incomeActualTaxValueEl.innerHTML = `Act: ${formatCurrency(actualData.tax)} <span style="color:var(--muted)">(Est pending)</span>`;
          } else if (summary.taxStatus === 'error') {
            incomeActualTaxValueEl.innerHTML = `Act: ${formatCurrency(actualData.tax)} <span style="color:var(--muted)">(Est unavailable)</span>`;
          } else {
            incomeActualTaxValueEl.innerHTML = formatActualWithVariance(actualData.tax, summary.tax || 0);
          }
        }

        // Populate actual net income
        if (incomeActualNetValueEl) {
          if (summary.taxStatus === 'pending') {
            incomeActualNetValueEl.innerHTML = `Act: ${formatCurrency(actualData.net_income)} <span style="color:var(--muted)">(Est pending)</span>`;
          } else if (summary.taxStatus === 'error') {
            incomeActualNetValueEl.innerHTML = `Act: ${formatCurrency(actualData.net_income)} <span style="color:var(--muted)">(Est unavailable)</span>`;
          } else {
            incomeActualNetValueEl.innerHTML = formatActualWithVariance(actualData.net_income, effectiveNetEstimate);
          }
        }
      } else {
        // Clear actual values if no data
        if (incomeActualGrossValueEl) incomeActualGrossValueEl.textContent = '';
        if (incomeActualSuperValueEl) incomeActualSuperValueEl.textContent = '';
        if (incomeActualTaxValueEl) incomeActualTaxValueEl.textContent = '';
        if (incomeActualNetValueEl) incomeActualNetValueEl.textContent = '';
      }
    } else {
      // Clear actual values if feature flag is disabled
      if (incomeActualGrossValueEl) incomeActualGrossValueEl.textContent = '';
      if (incomeActualSuperValueEl) incomeActualSuperValueEl.textContent = '';
      if (incomeActualTaxValueEl) incomeActualTaxValueEl.textContent = '';
      if (incomeActualNetValueEl) incomeActualNetValueEl.textContent = '';
    }
  }
  function handleTaxSuccess(requestId, taxValue) {
    if (!state.pendingTaxRequest || state.pendingTaxRequest.id !== requestId) return;
    const summary = state.incomeSummary;
    if (!summary || summary.monthKey !== state.pendingTaxRequest.monthKey) {
      state.pendingTaxRequest = null;
      return;
    }
    const computedTax = Math.max(0, Number(taxValue) || 0);
    summary.tax = computedTax;
    summary.taxStatus = 'resolved';
    summary.netIncome = summary.taxableIncome - computedTax;
    state.pendingTaxRequest = null;
    updateIncomeSummaryUI(summary);
  }
  function handleTaxFailure(requestId) {
    if (!state.pendingTaxRequest || state.pendingTaxRequest.id !== requestId) return;
    const summary = state.incomeSummary;
    if (!summary || summary.monthKey !== state.pendingTaxRequest.monthKey) {
      state.pendingTaxRequest = null;
      return;
    }
    summary.tax = 0;
    summary.taxStatus = 'error';
    summary.netIncome = summary.taxableIncome;
    state.pendingTaxRequest = null;
    updateIncomeSummaryUI(summary);
  }
  function requestTaxEstimate(summary) {
    if (!summary || summary.taxStatus !== 'pending') return;
    if (!summary.taxableIncome || summary.taxableIncome <= 0) {
      summary.taxStatus = 'resolved';
      summary.tax = 0;
      summary.netIncome = summary.taxableIncome;
      updateIncomeSummaryUI(summary);
      return;
    }
    if (state.pendingTaxRequest && state.pendingTaxRequest.key === summary.requestKey) return;
    if (typeof google === 'undefined' || !google.script || !google.script.run) {
      summary.taxStatus = 'error';
      summary.tax = 0;
      summary.netIncome = summary.taxableIncome;
      updateIncomeSummaryUI(summary);
      state.pendingTaxRequest = null;
      return;
    }
    const requestId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    state.pendingTaxRequest = {
      id: requestId,
      key: summary.requestKey,
      monthKey: summary.monthKey
    };
    google.script.run
      .withSuccessHandler((value) => handleTaxSuccess(requestId, value))
      .withFailureHandler(() => handleTaxFailure(requestId))
      .estimateTax(Number(summary.taxableIncome) || 0, summary.periodStart.toISOString());
  }
  function renderIncomeSummary() {
    if (!incomeNetBadge && !incomeBreakdownEl) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const summary = buildIncomeSummary(year, month);
    state.incomeSummary = summary;
    updateIncomeSummaryUI(summary);
    applyIncomeBreakdownVisibility();
    if (summary.taxStatus === 'pending') {
      requestTaxEstimate(summary);
    } else {
      state.pendingTaxRequest = null;
    }
    renderBasReporting();
  }

  function buildExpectedHoursSummary(year, month) {
    if (!getFeatureFlag('expected_monthly_hours')) return null;
    const monthEntries = entriesForMonth(year, month);
    const filteredEntries = monthEntries.filter((entry) => {
      if (!entry || !entry.contract_id || !entry.date) return false;
      if (!entryContributesToIncome(entry)) return false;
      const contract = state.contractMap[entry.contract_id];
      if (!contract) return false;
      if (!contractIsValid(contract, entry.date)) return false;
      return true;
    });
    if (!filteredEntries.length) return null;

    const contractBuckets = new Map();
    filteredEntries.forEach((entry) => {
      const contract = state.contractMap[entry.contract_id];
      if (!contract) return;
      if (!contractBuckets.has(contract.id)) {
        contractBuckets.set(contract.id, { contract, entries: [] });
      }
      contractBuckets.get(contract.id).entries.push(entry);
    });
    if (!contractBuckets.size) return null;

    const monthStartDate = startOfDay(new Date(year, month, 1));
    const monthEndDate = startOfDay(new Date(year, month + 1, 0));

    const aggregatedEvaluatedDays = new Set();
    const aggregatedMonthDays = new Set();
    let aggregatedHoursToDate = 0;
    let aggregatedExpectedMonthlyHours = 0;
    let aggregatedExpectedHoursToDate = 0;
    let aggregatedProjectedHours = 0;
    let baselineContracts = 0;

    const contractSummaries = [];

    contractBuckets.forEach(({ contract, entries }) => {
      const sortedEntries = [...entries].sort((a, b) => a.date.localeCompare(b.date));
      const contractStartRaw = contract.start_date ? parseIsoDate(contract.start_date) : null;
      if (!contractStartRaw || Number.isNaN(contractStartRaw.getTime())) return;
      const contractStart = startOfDay(contractStartRaw);
      const contractEndRaw = contract.end_date ? parseIsoDate(contract.end_date) : null;
      const includeWeekends = !!contract.include_weekends;

      const periodStart = contractStart > monthStartDate ? contractStart : monthStartDate;
      const boundedContractEnd = (contractEndRaw && !Number.isNaN(contractEndRaw.getTime())) ? startOfDay(contractEndRaw) : null;
      const periodEnd = boundedContractEnd && boundedContractEnd < monthEndDate ? boundedContractEnd : monthEndDate;
      if (periodEnd < periodStart) return;

      const periodStartIso = isoDate(periodStart);
      const periodEndIso = isoDate(periodEnd);

      const monthBusinessDaysList = collectBusinessDays(periodStart, periodEnd, includeWeekends);
      monthBusinessDaysList.forEach((day) => aggregatedMonthDays.add(day));
      const monthBusinessDays = monthBusinessDaysList.length;

      const recordedBusinessDaysSet = new Set();
      const totalMinutes = sortedEntries.reduce((acc, entry) => {
        if (!entry || !entry.date) return acc;
        if (entry.date < periodStartIso || entry.date > periodEndIso) return acc;
        const entryDateObj = parseIsoDate(entry.date);
        if (!entryDateObj || Number.isNaN(entryDateObj.getTime())) return acc;
        const minutes = Number(entry.duration_minutes) || 0;
        if (!includeWeekends && isWeekendDate(entryDateObj)) {
          return acc + minutes;
        }
        recordedBusinessDaysSet.add(isoDate(startOfDay(entryDateObj)));
        return acc + minutes;
      }, 0);

      const totalHours = totalMinutes / 60;
      const recordedBusinessDays = recordedBusinessDaysSet.size;
      if (recordedBusinessDays === 0) return;

      recordedBusinessDaysSet.forEach((day) => aggregatedEvaluatedDays.add(day));
      aggregatedHoursToDate += totalHours;

      const averageDailyHours = totalHours / recordedBusinessDays;

      const hasBaseline = Number(contract.total_hours || 0) > 0 && contract.end_date;
      let expectedDailyHours = null;
      let expectedMonthlyHours = null;
      let expectedHoursToDate = null;
      let expectedHoursRemaining = null;
      let projectedTotalHours = monthBusinessDays > 0 ? averageDailyHours * monthBusinessDays : totalHours;
      let projectedVariance = null;
      let varianceToDate = null;

      if (hasBaseline && monthBusinessDays > 0) {
        const contractBusinessDaysList = collectBusinessDays(contractStart, boundedContractEnd || periodEnd, includeWeekends);
        const contractBusinessDays = contractBusinessDaysList.length;
        if (contractBusinessDays > 0) {
          expectedDailyHours = Number(contract.total_hours || 0) / contractBusinessDays;
          expectedMonthlyHours = expectedDailyHours * monthBusinessDays;
          expectedHoursToDate = expectedDailyHours * Math.min(recordedBusinessDays, monthBusinessDays);
          expectedHoursRemaining = Math.max(0, expectedMonthlyHours - (expectedHoursToDate || 0));
          varianceToDate = totalHours - (expectedHoursToDate || 0);
        }
      }

      if (expectedMonthlyHours != null) {
        projectedVariance = projectedTotalHours - expectedMonthlyHours;
      }

      const businessDaysRemaining = Math.max(0, monthBusinessDays - Math.min(recordedBusinessDays, monthBusinessDays));

      let status = 'ontrack';
      let statusText = 'Projected on target';
      if (projectedVariance != null) {
        const roundedVariance = Math.round(projectedVariance * 100) / 100;
        const varianceMagnitude = Math.abs(roundedVariance);
        if (roundedVariance > 0.01) {
          status = 'behind';
          statusText = `Projected over by ${formatDecimalHours(varianceMagnitude)} hrs`;
        } else if (roundedVariance < -0.01) {
          status = 'ahead';
          statusText = `Projected under by ${formatDecimalHours(varianceMagnitude)} hrs`;
        }
      }
      if (expectedMonthlyHours == null) {
        status = 'ontrack';
        statusText = 'No expected hours configured';
      }

      const summary = {
        contractId: contract.id,
        contractName: contract.name || 'Untitled contract',
        includeWeekends,
        monthBusinessDays,
        recordedBusinessDays,
        businessDaysRemaining,
        totalHours,
        hoursToDate: totalHours,
        averageDailyHours,
        calculationDays: recordedBusinessDays,
        calculationLabel: 'Recorded work days',
        expectedDailyHours,
        expectedMonthlyHours,
        expectedHoursToDate,
        expectedHoursRemaining,
        varianceToDate,
        projectedTotalHours,
        projectedVariance,
        status,
        statusText
      };

      contractSummaries.push(summary);

      if (hasBaseline && expectedMonthlyHours != null) {
        baselineContracts += 1;
        aggregatedExpectedMonthlyHours += expectedMonthlyHours;
        aggregatedExpectedHoursToDate += expectedHoursToDate || 0;
        aggregatedProjectedHours += projectedTotalHours || 0;
      }
    });

    if (!contractSummaries.length) return null;

    const uniqueRecordedDays = aggregatedEvaluatedDays.size;
    if (uniqueRecordedDays <= 2) return null;

    const totalBusinessDays = aggregatedMonthDays.size || contractSummaries.reduce((max, summary) => Math.max(max, summary.monthBusinessDays), 0);
    const averageHours = aggregatedHoursToDate / uniqueRecordedDays;
    const overallProjectedVariance = baselineContracts > 0 ? (aggregatedProjectedHours - aggregatedExpectedMonthlyHours) : null;

    contractSummaries.sort((a, b) => a.contractName.localeCompare(b.contractName));

    return {
      monthKey: monthKeyFor(year, month),
      contracts: contractSummaries,
      contractCount: contractSummaries.length,
      averageHours,
      totalHoursToDate: aggregatedHoursToDate,
      daysEvaluated: uniqueRecordedDays,
      totalBusinessDays,
      totalExpectedMonthlyHours: aggregatedExpectedMonthlyHours,
      totalExpectedHoursToDate: aggregatedExpectedHoursToDate,
      totalProjectedHours: aggregatedProjectedHours,
      baselineContractCount: baselineContracts,
      overallProjectedVariance
    };

  }

  function renderExpectedHoursBreakdown(summary) {
    if (!expectedHoursContentEl) return;
    expectedHoursContentEl.innerHTML = '';
    if (!summary || !summary.contracts || !summary.contracts.length) return;

    const makeLine = (label, value) => {
      const row = document.createElement('div');
      row.className = 'ts-expected-line';
      const labelEl = document.createElement('span');
      labelEl.textContent = label;
      const valueEl = document.createElement('span');
      valueEl.textContent = value;
      row.append(labelEl, valueEl);
      return row;
    };

    const buildVarianceStatus = (variance, prefix) => {
      if (variance === null || variance === undefined) return null;
      const rounded = Math.round(variance * 100) / 100;
      const magnitude = Math.abs(rounded);
      const statusEl = document.createElement('div');
      if (rounded > 0.01) {
        statusEl.className = 'ts-expected-status behind';
        statusEl.textContent = prefix
          ? `${prefix} projected over by ${formatDecimalHours(magnitude)} hrs`
          : `Projected over by ${formatDecimalHours(magnitude)} hrs`;
      } else if (rounded < -0.01) {
        statusEl.className = 'ts-expected-status ahead';
        statusEl.textContent = prefix
          ? `${prefix} projected under by ${formatDecimalHours(magnitude)} hrs`
          : `Projected under by ${formatDecimalHours(magnitude)} hrs`;
      } else {
        statusEl.className = 'ts-expected-status ontrack';
        statusEl.textContent = prefix
          ? `${prefix} projected on target`
          : 'Projected on target';
      }
      return statusEl;
    };

    const aggregate = document.createElement('div');
    aggregate.className = 'ts-expected-aggregate';
    aggregate.appendChild(makeLine('Average daily hours to date', `${formatDecimalHours(summary.averageHours)} hrs`));
    const daysLabel = summary.totalBusinessDays > 0
      ? `${summary.daysEvaluated} of ${summary.totalBusinessDays}`
      : String(summary.daysEvaluated);
    aggregate.appendChild(makeLine('Business days evaluated', daysLabel));
    aggregate.appendChild(makeLine('Total hours logged this month', `${formatDecimalHours(summary.totalHoursToDate)} hrs`));

    const hasExpectedTotals = summary.baselineContractCount > 0 && summary.totalExpectedMonthlyHours > 0;
    let overallStatus = null;
    if (summary.contractCount > 1 && hasExpectedTotals) {
      aggregate.appendChild(makeLine('Total expected hours this month', `${formatDecimalHours(summary.totalExpectedMonthlyHours)} hrs`));
      if (summary.totalExpectedHoursToDate > 0) {
        aggregate.appendChild(makeLine('Expected hours to date', `${formatDecimalHours(summary.totalExpectedHoursToDate)} hrs`));
      }
      if (summary.overallProjectedVariance !== null) {
        aggregate.appendChild(makeLine('Projected month variance', `${formatSignedHours(summary.overallProjectedVariance)} hrs`));
        overallStatus = buildVarianceStatus(summary.overallProjectedVariance, 'Overall');
      }
    }

    if (summary.contractCount === 1) {
      const contract = summary.contracts[0];
      const hasExpected = contract.expectedMonthlyHours != null;
      const expectedMonthlyValue = hasExpected
        ? `${formatDecimalHours(contract.expectedMonthlyHours)} hrs`
        : 'Not available for unlimited contracts';
      aggregate.appendChild(makeLine('Total expected hours this month', expectedMonthlyValue));

      const expectedToDateValue = hasExpected
        ? `${formatDecimalHours(contract.expectedHoursToDate || 0)} hrs`
        : 'Not available for unlimited contracts';
      aggregate.appendChild(makeLine('Expected hours to date', expectedToDateValue));

      const projectedVarianceValue = contract.projectedVariance != null
        ? `${formatSignedHours(contract.projectedVariance)} hrs`
        : 'Not available';
      aggregate.appendChild(makeLine('Projected month variance', projectedVarianceValue));

      const varianceStatus = buildVarianceStatus(contract.projectedVariance);
      if (varianceStatus) {
        aggregate.appendChild(varianceStatus);
      } else {
        const varianceUnavailable = document.createElement('div');
        varianceUnavailable.className = 'ts-expected-status ontrack';
        varianceUnavailable.textContent = hasExpected
          ? 'Projected variance not available'
          : 'Projected variance not available for unlimited contracts';
        aggregate.appendChild(varianceUnavailable);
      }
    } else if (overallStatus) {
      aggregate.appendChild(overallStatus);
    }

    expectedHoursContentEl.appendChild(aggregate);

    if (summary.contractCount > 1) {
      summary.contracts.forEach((contract) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'ts-expected-contract';

        const header = document.createElement('div');
        header.className = 'ts-expected-contract-header';
        const nameEl = document.createElement('span');
        nameEl.textContent = contract.contractName;
        const hoursEl = document.createElement('span');
        hoursEl.textContent = `${formatDecimalHours(contract.hoursToDate)} hrs logged`;
        header.append(nameEl, hoursEl);
        wrapper.appendChild(header);

        const meta = document.createElement('div');
        meta.className = 'ts-expected-meta';
        meta.textContent = contract.includeWeekends
          ? 'Including weekends in averages'
          : 'Weekdays only (Mon-Fri)';
        wrapper.appendChild(meta);

        const lines = document.createElement('div');
        lines.className = 'ts-expected-lines';
        lines.appendChild(makeLine('Average daily hours', `${formatDecimalHours(contract.averageDailyHours)} hrs`));
        lines.appendChild(makeLine('Days in calculation', `${contract.calculationDays} (${contract.calculationLabel})`));
        if (contract.expectedMonthlyHours != null) {
          const expectedToDate = contract.expectedHoursToDate != null ? formatDecimalHours(contract.expectedHoursToDate) : '0';
          lines.appendChild(makeLine('Hours logged vs expected to date', `${formatDecimalHours(contract.hoursToDate)} / ${expectedToDate} hrs`));
          lines.appendChild(makeLine('Expected hours remaining', `${formatDecimalHours(contract.expectedHoursRemaining || 0)} hrs`));
        } else {
          lines.appendChild(makeLine('Expected hours remaining', 'Not available for unlimited contracts'));
        }
        lines.appendChild(makeLine('Projected month total', `${formatDecimalHours(contract.projectedTotalHours)} hrs`));
        if (contract.projectedVariance != null) {
          lines.appendChild(makeLine('Projected variance', `${formatSignedHours(contract.projectedVariance)} hrs`));
        }
        lines.appendChild(makeLine('Business days remaining', String(contract.businessDaysRemaining)));
        wrapper.appendChild(lines);

        const statusEl = document.createElement('div');
        statusEl.className = `ts-expected-status ${contract.status}`;
        statusEl.textContent = contract.statusText;
        wrapper.appendChild(statusEl);

        expectedHoursContentEl.appendChild(wrapper);
      });
    }
  }

  function resetExpectedHoursBadge(text) {
    if (!expectedHoursBadge) return;
    expectedHoursBadge.className = 'ts-badge ts-expected-badge';
    expectedHoursBadge.textContent = text || 'Projected variance: --';
  }

  function applyExpectedHoursBadge(summary) {
    if (!expectedHoursBadge) return;
    resetExpectedHoursBadge();
    if (!summary) return;

    let varianceValue = summary.overallProjectedVariance;
    if ((varianceValue === null || varianceValue === undefined) && summary.contractCount === 1 && summary.contracts[0]) {
      varianceValue = summary.contracts[0].projectedVariance;
    }

    const suffix = summary.contractCount > 1 ? ` (${summary.contractCount})` : '';
    if (varianceValue === null || varianceValue === undefined) {
      expectedHoursBadge.textContent = `Projected variance: --${suffix}`;
      return;
    }

    const rounded = Math.round(varianceValue * 100) / 100;
    expectedHoursBadge.textContent = `Projected variance: ${formatSignedHours(varianceValue)} hrs${suffix}`;
    if (rounded > 0.01) {
      expectedHoursBadge.classList.add('error');
    } else if (rounded < -0.01) {
      expectedHoursBadge.classList.add('success');
    }
  }

  function renderExpectedHoursSummary() {
    if (!expectedHoursBadge || !expectedHoursBreakdownEl) return;
    if (!getFeatureFlag('expected_monthly_hours')) {
      expectedHoursBadge.style.display = 'none';
      resetExpectedHoursBadge();
      state.expectedHoursSummary = null;
      expectedHoursExpanded = false;
      applyExpectedHoursVisibility();
      if (expectedHoursContentEl) expectedHoursContentEl.innerHTML = '';
      return;
    }

    ensureCalendarState();
    const { year, month } = state.calendar;
    const summary = buildExpectedHoursSummary(year, month);
    state.expectedHoursSummary = summary;

    if (!summary) {
      expectedHoursBadge.style.display = 'none';
      resetExpectedHoursBadge();
      expectedHoursExpanded = false;
      applyExpectedHoursVisibility();
      if (expectedHoursContentEl) expectedHoursContentEl.innerHTML = '';
      return;
    }

    expectedHoursBadge.style.display = 'inline-flex';
    applyExpectedHoursBadge(summary);

    applyExpectedHoursVisibility();
    if (expectedHoursExpanded) {
      renderExpectedHoursBreakdown(summary);
    } else if (expectedHoursContentEl) {
      expectedHoursContentEl.innerHTML = '';
    }
  }
  function renderEntries() {
    renderCalendar();
    renderContractsUI();
  }
  function deleteEntry(id) {
    const idx = state.entries.findIndex((e) => e.id === id);
    if (idx === -1) return;
    const backup = state.entries[idx];
    state.entries.splice(idx, 1);
    saveCache();
    renderEntries();
    setStatus('Deleting...', 'warn');
    google.script.run
      .withSuccessHandler(() => setStatus('Deleted', 'success'))
      .withFailureHandler(() => {
        state.entries.splice(idx, 0, backup);
        saveCache();
        renderEntries();
        setStatus('Delete failed', 'error');
      })
      .api_deleteEntry(id);
  }
  function editEntry(id) {
    const entry = state.entries.find((e) => e.id === id);
    if (!entry) return;
    state.selectedCalendarDate = entry.date;
    populateManualForm(entry, true);
    renderCalendar();
  }

  // Calendar rendering
  function ensureCalendarState() {
    if (!state.calendar) {
      const today = new Date();
      state.calendar = { year: today.getFullYear(), month: today.getMonth() };
    }
    if (!state.selectedCalendarDate) {
      state.selectedCalendarDate = todayIso();
      if (!state.editingEntryId) setManualDate(state.selectedCalendarDate);
    }
  }
  function calendarStartDate(year, month) {
    const first = new Date(year, month, 1);
    const offset = (first.getDay() + 6) % 7; // shift so Monday=0
    return new Date(year, month, 1 - offset);
  }
  function minutesByDate() {
    return state.entries.reduce((map, entry) => {
      if (!entry.date) return map;
      const key = entry.date;
      map[key] = (map[key] || 0) + (Number(entry.duration_minutes) || 0);
      return map;
    }, {});
  }

  function minutesByDateAndHourType() {
    return state.entries.reduce((map, entry) => {
      if (!entry.date) return map;
      const date = entry.date;
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();

      if (!map[date]) map[date] = {};
      if (!map[date][hourTypeId]) map[date][hourTypeId] = 0;

      map[date][hourTypeId] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});
  }

  function getDefaultHourType() {
    if (!state.hourTypes.length) return null;
    return state.hourTypes.find(ht => ht.is_default) || state.hourTypes[0];
  }

  function getFeatureFlag(flagKey) {
  const flag = state.featureFlags[flagKey] || DEFAULT_FEATURE_FLAGS[flagKey];
  return flag ? flag.enabled : false;
}

  function isDeductionCategoriesEnabled() {
  return !!getFeatureFlag('enable_deduction_categories');
}
  function renderCalendar() {
    ensureCalendarState();

    // Get filtered hour type IDs
    const activeHourTypeIds = state.calendarFilteredHourTypes || state.hourTypes.map(ht => ht.id);

    // Filter entries by active hour types
    const filteredEntries = state.entries.filter(entry => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      return activeHourTypeIds.includes(hourTypeId);
    });

    // Calculate totals based on filtered entries
    const totals = filteredEntries.reduce((map, entry) => {
      if (!entry.date) return map;
      if (!map[entry.date]) map[entry.date] = 0;
      map[entry.date] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});

    const hourTypeTotals = filteredEntries.reduce((map, entry) => {
      if (!entry.date) return map;
      const date = entry.date;
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      if (!map[date]) map[date] = {};
      if (!map[date][hourTypeId]) map[date][hourTypeId] = 0;
      map[date][hourTypeId] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});

    const defaultHourType = getDefaultHourType();
    const defaultHourTypeId = defaultHourType?.id || getDefaultHourTypeId();
    const grid = document.getElementById('calendar-grid');
    const label = document.getElementById('calendar-label');
    const monthTotalEl = document.getElementById('calendar-month-total');
    const activeMonth = new Date(state.calendar.year, state.calendar.month, 1);
    label.textContent = activeMonth.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    const monthKey = `${activeMonth.getFullYear()}-${String(activeMonth.getMonth() + 1).padStart(2, '0')}`;
    const monthTotalMinutes = Object.keys(totals).reduce((acc, key) => {
      if (key.startsWith(monthKey)) {
        acc += totals[key];
      }
      return acc;
    }, 0);

    // If hour types are enabled, also calculate income-contributing hours
    let monthIncomeMinutes = 0;
    if (getFeatureFlag('hour_types') && state.hourTypes.length > 0) {
      const monthEntries = filteredEntries.filter(entry =>
        entry.date && entry.date.startsWith(monthKey)
      );
      monthIncomeMinutes = monthEntries.reduce((acc, entry) => {
        const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
        const hourType = state.hourTypeMap[hourTypeId];
        const contributesToIncome = hourType ? hourType.contributes_to_income : true;
        if (contributesToIncome) {
          acc += Number(entry.duration_minutes) || 0;
        }
        return acc;
      }, 0);
    }

    const roundedMonthTotal = roundDuration(monthTotalMinutes);
    if (getFeatureFlag('hour_types') && state.hourTypes.length > 0 && monthIncomeMinutes !== monthTotalMinutes) {
      const roundedIncomeTotal = roundDuration(monthIncomeMinutes);
      monthTotalEl.textContent = `Total hours: ${formatHours(roundedMonthTotal)} (${formatHours(roundedIncomeTotal)} billable)`;
    } else {
      monthTotalEl.textContent = `Total hours: ${formatHours(roundedMonthTotal)}`;
    }

    // Render hour types breakdown
    renderHourTypesBreakdown(filteredEntries, monthKey);

    grid.innerHTML = '';
    const start = calendarStartDate(state.calendar.year, state.calendar.month);
    for (let i = 0; i < 42; i++) {
      const current = new Date(start.getFullYear(), start.getMonth(), start.getDate() + i);
      const iso = isoDate(current);
      const cell = document.createElement('div');
      cell.className = 'ts-calendar-cell';
      if (current.getMonth() !== state.calendar.month) cell.classList.add('inactive');
      if (iso === todayIso()) cell.classList.add('today');
      const totalMinutes = totals[iso] || 0;
      if (totalMinutes > 0) cell.classList.add('has-entries');
      if (iso === state.selectedCalendarDate) cell.classList.add('selected');
      const dayEl = document.createElement('div');
      dayEl.className = 'ts-calendar-day';

      // Check for public holiday
      const holiday = state.publicHolidayMap[iso];
      if (holiday && getFeatureFlag('enable_public_holidays')) {
        const holidayName = holiday.localName || holiday.name || '';
        const truncatedName = holidayName.length > 12 ? holidayName.substring(0, 12) + 'â¦' : holidayName;
        dayEl.innerHTML = `${current.getDate()} <span class="ts-calendar-holiday-label">${truncatedName}</span>`;
        cell.classList.add('ts-calendar-holiday');
      } else {
        dayEl.textContent = current.getDate();
      }

      // Check if hour types feature is enabled and we have multiple hour types
      const showHourTypes = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
      const dayHourTypes = hourTypeTotals[iso] || {};

      if (showHourTypes && Object.keys(dayHourTypes).length > 0) {
        const defaultMinutes = dayHourTypes[defaultHourTypeId] || 0;
        const hasDefault = defaultMinutes > 0;
        const hasMultiple = Object.keys(dayHourTypes).length > 1 || (Object.keys(dayHourTypes).length === 1 && !hasDefault);

        // When there are multiple hour types with default present: show non-default on top, default on bottom
        // When only non-default hours exist: show them on bottom
        if (hasMultiple && hasDefault) {
          // Show other hour types as small colored indicators at top
          const otherTypesEl = document.createElement('div');
          otherTypesEl.className = 'ts-calendar-hour-types';
          Object.keys(dayHourTypes).forEach(hourTypeId => {
            if (hourTypeId !== defaultHourTypeId && dayHourTypes[hourTypeId] > 0) {
              const hourType = state.hourTypeMap[hourTypeId];
              if (hourType) {
                const minutes = dayHourTypes[hourTypeId];
                const roundedMinutes = roundDuration(minutes);
                const indicator = document.createElement('span');
                indicator.className = 'ts-calendar-hour-type-indicator';
                indicator.style.color = hourType.color;
                indicator.textContent = formatHours(roundedMinutes);
                indicator.title = `${hourType.name}: ${formatHours(roundedMinutes)}`;
                otherTypesEl.appendChild(indicator);
              }
            }
          });

          // Show default hour type as main total at bottom
          const totalEl = document.createElement('div');
          totalEl.className = 'ts-calendar-total';
          const roundedMinutes = roundDuration(defaultMinutes);
          totalEl.textContent = formatHours(roundedMinutes);

          cell.append(dayEl, otherTypesEl, totalEl);
        } else if (!hasDefault) {
          // Only non-default hours exist - show them at bottom
          const otherTypesEl = document.createElement('div');
          otherTypesEl.className = 'ts-calendar-hour-types';
          Object.keys(dayHourTypes).forEach(hourTypeId => {
            if (dayHourTypes[hourTypeId] > 0) {
              const hourType = state.hourTypeMap[hourTypeId];
              if (hourType) {
                const minutes = dayHourTypes[hourTypeId];
                const roundedMinutes = roundDuration(minutes);
                const indicator = document.createElement('span');
                indicator.className = 'ts-calendar-hour-type-indicator';
                indicator.style.color = hourType.color;
                indicator.textContent = formatHours(roundedMinutes);
                indicator.title = `${hourType.name}: ${formatHours(roundedMinutes)}`;
                otherTypesEl.appendChild(indicator);
              }
            }
          });

          cell.append(dayEl, otherTypesEl);
        } else {
          // Only default hour type exists
          const totalEl = document.createElement('div');
          totalEl.className = 'ts-calendar-total';
          if (defaultMinutes === 0) totalEl.classList.add('empty');
          if (defaultMinutes === 0) {
            totalEl.textContent = state.showZeroHours ? '0' : '';
          } else {
            const roundedMinutes = roundDuration(defaultMinutes);
            totalEl.textContent = formatHours(roundedMinutes);
          }

          cell.append(dayEl, totalEl);
        }
      } else {
        // Original behavior - show total hours
        const totalEl = document.createElement('div');
        totalEl.className = 'ts-calendar-total';
        if (totalMinutes === 0) totalEl.classList.add('empty');
        if (totalMinutes === 0) {
          totalEl.textContent = state.showZeroHours ? '0' : '';
        } else {
          const roundedMinutes = roundDuration(totalMinutes);
          totalEl.textContent = formatHours(roundedMinutes);
        }
        cell.append(dayEl, totalEl);
      }

      cell.onclick = () => handleCalendarClick(iso);
    grid.appendChild(cell);
  }
  renderIncomeSummary();
  renderExpectedHoursSummary();
  updatePayrollHelperButtons();
}

  function renderHourTypesBreakdown(entries, monthKey) {
    if (!hourTypesBreakdownListEl) return;

    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
    if (!hourTypesEnabled) {
      hourTypesBreakdownListEl.innerHTML = '';
      return;
    }

    // Calculate totals for each hour type in the month
    const monthEntries = entries.filter(entry => entry.date && entry.date.startsWith(monthKey));
    const hourTypeTotals = monthEntries.reduce((map, entry) => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      if (!map[hourTypeId]) map[hourTypeId] = 0;
      map[hourTypeId] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});

    // Sort hour types by total (descending)
    const sortedHourTypes = Object.keys(hourTypeTotals)
      .map(id => ({
        id,
        hourType: state.hourTypeMap[id],
        minutes: hourTypeTotals[id]
      }))
      .filter(item => item.hourType && item.minutes > 0)
      .sort((a, b) => b.minutes - a.minutes);

    if (sortedHourTypes.length === 0) {
      hourTypesBreakdownListEl.innerHTML = '<div class="ts-note">No hours tracked this month</div>';
      return;
    }

    const html = sortedHourTypes.map(item => {
      const roundedMinutes = roundDuration(item.minutes);
      return `
        <div class="ts-hour-type-breakdown-row">
          <div class="ts-hour-type-breakdown-color" style="background-color: ${item.hourType.color}"></div>
          <div class="ts-hour-type-breakdown-name">${item.hourType.name}</div>
          <div class="ts-hour-type-breakdown-value">${formatHours(roundedMinutes)}</div>
        </div>
      `;
    }).join('');

    hourTypesBreakdownListEl.innerHTML = html;
  }

  function handleCalendarClick(dateIso) {
    state.selectedCalendarDate = dateIso;
    setManualDate(dateIso);
    updateTabStates();
    renderCalendar();

    // Check if there's an existing entry for this date
    const existingEntries = state.entries.filter(entry => entry.date === dateIso);
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;

    if (existingEntries.length > 0) {
      const existingEntry = existingEntries[0];

      const entryType = resolveEntryType(existingEntry);

      // Prepopulate the form with the existing entry
      if (entryType === 'basic') {
        populateManualForm(existingEntry, true);
      } else {
        // For advanced entries, switch to advanced tab and populate
        state.currentTab = 'punch';
        state.editingEntryType = entryType;
        activateTab('punch');
        if (punchDate) punchDate.value = existingEntry.date;
        ensurePunchDraft(existingEntry.contract_id);
        if (state.punchDraft) {
          state.punchDraft.entryId = existingEntry.id;
          state.punchDraft.contractId = existingEntry.contract_id;
          state.punchDraft.date = existingEntry.date;
          state.punchDraft.punches = clonePunches(existingEntry.punches || []);
          state.punchDraft.dirty = false;
          renderPunchDraft();
        }
      }
    } else {
      // No existing entry, keep current tab but clear editing state
      if (state.currentTab === 'manual') {
        clearManualEditing();
      } else {
        // For advanced mode, just clear the editing state without changing tabs
        state.editingEntryId = null;
        state.editingEntryType = null;
        setPunchDate(dateIso);
        ensurePunchDraft();
      }
    }
  }
  function changeCalendarMonth(delta) {
    ensureCalendarState();
    const oldYear = state.calendar.year;
    const next = new Date(state.calendar.year, state.calendar.month + delta, 1);
    state.calendar.year = next.getFullYear();
    state.calendar.month = next.getMonth();
    if (state.selectedCalendarDate) {
      const selected = parseIsoDate(state.selectedCalendarDate);
      if (selected.getFullYear() !== state.calendar.year || selected.getMonth() !== state.calendar.month) {
        state.selectedCalendarDate = null;
      }
    }
    // Reload public holidays if year changed
    if (oldYear !== state.calendar.year && getFeatureFlag('enable_public_holidays')) {
      loadPublicHolidays(true); // Re-render after load when year changes
    }
    renderCalendar();
  }
  document.getElementById('calendar-prev').onclick = () => changeCalendarMonth(-1);
  document.getElementById('calendar-next').onclick = () => changeCalendarMonth(1);

  // Month picker modal
  const monthPickerModal = document.getElementById('modal-month-picker');
  const monthPickerJumpBtn = document.getElementById('calendar-jump');
  const monthPickerYearDisplay = document.getElementById('month-picker-year-display');
  const monthPickerYearPrev = document.getElementById('month-picker-year-prev');
  const monthPickerYearNext = document.getElementById('month-picker-year-next');
  const monthPickerGrid = document.getElementById('month-picker-grid');

  var monthPickerState = {
    year: null
  };

  const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

  function openMonthPicker() {
    if (!state.calendar) return;
    monthPickerState.year = state.calendar.year;
    renderMonthPicker();
    monthPickerModal.style.display = 'flex';
  }

  function closeMonthPicker() {
    monthPickerModal.style.display = 'none';
  }

  function renderMonthPicker() {
    if (!state.calendar) return;
    monthPickerYearDisplay.textContent = monthPickerState.year;

    const currentDate = new Date();
    const currentYear = currentDate.getFullYear();
    const currentMonth = currentDate.getMonth();
    const activeYear = state.calendar.year;
    const activeMonth = state.calendar.month;

    monthPickerGrid.innerHTML = '';

    for (var i = 0; i < 12; i++) {
      var btn = document.createElement('button');
      btn.className = 'ts-month-picker-cell';
      btn.textContent = monthNames[i];
      btn.dataset.month = i;

      // Highlight current month
      if (i === currentMonth && monthPickerState.year === currentYear) {
        btn.classList.add('current-month');
      }

      // Highlight active month
      if (i === activeMonth && monthPickerState.year === activeYear) {
        btn.classList.add('active');
      }

      btn.onclick = function() {
        var selectedMonth = parseInt(this.dataset.month);
        state.calendar.month = selectedMonth;
        state.calendar.year = monthPickerState.year;
        renderCalendar();
        closeMonthPicker();
      };

      monthPickerGrid.appendChild(btn);
    }
  }

  monthPickerJumpBtn.onclick = openMonthPicker;

  monthPickerYearPrev.onclick = function() {
    monthPickerState.year--;
    renderMonthPicker();
  };

  monthPickerYearNext.onclick = function() {
    monthPickerState.year++;
    renderMonthPicker();
  };

  // Close modal when clicking the X or outside
  var monthPickerClose = monthPickerModal.querySelector('.ts-modal-close');
  if (monthPickerClose) {
    monthPickerClose.onclick = closeMonthPicker;
  }

  monthPickerModal.onclick = function(e) {
    if (e.target === monthPickerModal) {
      closeMonthPicker();
    }
  };

  // Calendar filtering
  const calendarFilterToggle = document.getElementById('calendar-filter-toggle');
  const calendarFilterPanel = document.getElementById('calendar-filter-panel');
  const calendarFilterList = document.getElementById('calendar-filter-list');
  const filterSelectAll = document.getElementById('filter-select-all');
  const filterSelectNone = document.getElementById('filter-select-none');
  const filterSelectIncome = document.getElementById('filter-select-income');

  function renderCalendarFilters() {
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;

    if (!hourTypesEnabled || !calendarFilterToggle) {
      if (calendarFilterToggle) calendarFilterToggle.style.display = 'none';
      if (calendarFilterPanel) calendarFilterPanel.style.display = 'none';
      return;
    }

    calendarFilterToggle.style.display = 'block';

    if (!calendarFilterList) return;

    // Initialize filter state if null
    if (state.calendarFilteredHourTypes === null) {
      state.calendarFilteredHourTypes = state.hourTypes.map(ht => ht.id);
    }

    calendarFilterList.innerHTML = '';
    state.hourTypes.forEach(hourType => {
      const isActive = state.calendarFilteredHourTypes.includes(hourType.id);

      const item = document.createElement('div');
      item.className = 'ts-calendar-filter-item' + (isActive ? ' active' : '');
      item.innerHTML = `
        <input type="checkbox" class="ts-calendar-filter-checkbox" ${isActive ? 'checked' : ''} data-hour-type-id="${hourType.id}" />
        <div class="ts-calendar-filter-color" style="background-color:${hourType.color};"></div>
        <span class="ts-calendar-filter-name">${hourType.name}</span>
      `;

      item.onclick = () => toggleHourTypeFilter(hourType.id);
      calendarFilterList.appendChild(item);
    });
  }

  function toggleHourTypeFilter(hourTypeId) {
    if (!state.calendarFilteredHourTypes) {
      state.calendarFilteredHourTypes = state.hourTypes.map(ht => ht.id);
    }

    const index = state.calendarFilteredHourTypes.indexOf(hourTypeId);
    if (index > -1) {
      state.calendarFilteredHourTypes.splice(index, 1);
    } else {
      state.calendarFilteredHourTypes.push(hourTypeId);
    }

    saveCache();
    renderCalendarFilters();
    renderCalendar();
  }

  if (calendarFilterToggle) {
    calendarFilterToggle.onclick = () => {
      if (calendarFilterPanel) {
        const isHidden = calendarFilterPanel.style.display === 'none';
        calendarFilterPanel.style.display = isHidden ? 'block' : 'none';
      }
    };
  }

  if (filterSelectAll) {
    filterSelectAll.onclick = () => {
      state.calendarFilteredHourTypes = state.hourTypes.map(ht => ht.id);
      saveCache();
      renderCalendarFilters();
      renderCalendar();
    };
  }

  if (filterSelectNone) {
    filterSelectNone.onclick = () => {
      state.calendarFilteredHourTypes = [];
      saveCache();
      renderCalendarFilters();
      renderCalendar();
    };
  }

  if (filterSelectIncome) {
    filterSelectIncome.onclick = () => {
      state.calendarFilteredHourTypes = state.hourTypes
        .filter(ht => ht.contributes_to_income)
        .map(ht => ht.id);
      saveCache();
      renderCalendarFilters();
      renderCalendar();
    };
  }

  // Settings configuration - add new settings here
  const SETTINGS_CONFIG = {
    round_to_nearest: {
      element: () => roundInput,
      getValue: (el) => parseInt(el.value, 10) || 0,
      setValue: (el, val) => el.value = val || 0,
      defaultValue: 0,
      event: 'input'
    },
    theme: {
      element: () => themeSelect,
      getValue: (el) => el.value,
      setValue: (el, val) => el.value = val || 'dark',
      defaultValue: 'dark',
      event: 'change'
    },
    status_notification_mode: {
      element: () => statusNotificationSelect,
      getValue: (el) => el.value,
      setValue: (el, val) => { if (el) el.value = val || 'status_bar'; },
      defaultValue: 'status_bar',
      event: 'change'
    },
    payg_instalment_rate: {
      element: () => paygRateInput,
      getValue: (el) => parseFloat(el.value) || 2,
      setValue: (el, val) => el.value = String(val || 2),
      defaultValue: () => Number(state.settings.payg_instalment_rate) || 2,
      event: 'input'
    },
    public_holiday_state: {
      element: () => publicHolidayStateSelect,
      getValue: (el) => el.value,
      setValue: (el, val) => el.value = val || 'ACT',
      defaultValue: 'ACT',
      event: 'change'
    },
    minimum_end_time: {
      element: () => minimumEndTimeInput,
      getValue: (el) => el.value,
      setValue: (el, val) => el.value = val || '17:00',
      defaultValue: '17:00',
      event: 'input'
    },
    lost_super_recovery_mode: {
      element: () => lostSuperRecoveryModeSelect,
      getValue: (el) => el.value,
      setValue: (el, val) => el.value = val || 'extra_contribution',
      defaultValue: 'extra_contribution',
      event: 'change'
    },
    invoice_template_reference: {
      element: () => invoiceTemplateInput,
      getValue: (el) => el.value.trim(),
      setValue: (el, val) => { el.value = val || ''; },
      defaultValue: '',
      event: 'input'
    },
    invoice_output_folder_path: {
      element: () => invoiceOutputFolderInput,
      getValue: (el) => el.value.trim(),
      setValue: (el, val) => { el.value = val || ''; },
      defaultValue: '',
      event: 'input'
    },
    invoice_line_item_limit: {
      element: () => invoiceLineLimitInput,
      getValue: (el) => {
        const val = el.value.trim();
        if (val === '') return '';
        const num = parseInt(val, 10);
        return Number.isFinite(num) && num > 0 ? num : '';
      },
      setValue: (el, val) => { el.value = val != null && val !== '' ? val : ''; },
      defaultValue: '',
      event: 'input'
    }
  };

  // Settings dirty state tracking
  var settingsInitialState = {};
  var settingsServerSynced = false;

  function captureSettingsState() {
    settingsInitialState = {};
    Object.keys(SETTINGS_CONFIG).forEach((key) => {
      const config = SETTINGS_CONFIG[key];
      const element = config.element();
      if (element) {
        settingsInitialState[key] = config.getValue(element);
      } else {
        // Preserve existing value from state, only default if truly missing
        settingsInitialState[key] = state.settings[key] !== undefined
          ? state.settings[key]
          : (typeof config.defaultValue === 'function' ? config.defaultValue() : config.defaultValue);
      }
    });
  }

  function checkSettingsDirty() {
    const current = {};
    Object.keys(SETTINGS_CONFIG).forEach((key) => {
      const config = SETTINGS_CONFIG[key];
      const element = config.element();
      if (element) {
        current[key] = config.getValue(element);
      } else {
        const defaultVal = typeof config.defaultValue === 'function' ? config.defaultValue() : config.defaultValue;
        current[key] = defaultVal;
      }
    });

    let isDirty = false;
    Object.keys(SETTINGS_CONFIG).forEach((key) => {
      if (current[key] !== settingsInitialState[key]) {
        isDirty = true;
      }
    });

    // Only enable save button if settings have changed AND server sync is complete
    if (saveSettingsBtn) {
      saveSettingsBtn.disabled = !isDirty || !settingsServerSynced;
      // Update tooltip to show why button is disabled
      if (!settingsServerSynced) {
        saveSettingsBtn.title = 'Loading settings from server...';
      } else if (!isDirty) {
        saveSettingsBtn.title = 'No changes to save';
      } else {
        saveSettingsBtn.title = 'Save settings to database';
      }
    }
    if (discardSettingsBtn) discardSettingsBtn.style.display = isDirty ? 'inline-flex' : 'none';

    return isDirty;
  }

  function resetSettingsToInitial() {
    Object.keys(SETTINGS_CONFIG).forEach((key) => {
      const config = SETTINGS_CONFIG[key];
      const element = config.element();
      if (element) {
        config.setValue(element, settingsInitialState[key]);
      }
    });
    applyTheme(settingsInitialState.theme || 'dark');
    checkSettingsDirty();
  }

  // Attach change listeners to all settings inputs
  Object.keys(SETTINGS_CONFIG).forEach((key) => {
    const config = SETTINGS_CONFIG[key];
    const element = config.element();
    if (element) {
      element.addEventListener(config.event, checkSettingsDirty);
    }
  });

  // Settings persistence
  if (saveSettingsBtn) {
    saveSettingsBtn.onclick = function () {
      const next = {};
      Object.keys(SETTINGS_CONFIG).forEach((key) => {
        const config = SETTINGS_CONFIG[key];
        const element = config.element();
        if (element) {
          next[key] = config.getValue(element);
        } else {
          // Preserve existing value from state, only default if truly missing
          next[key] = state.settings[key] !== undefined
            ? state.settings[key]
            : (typeof config.defaultValue === 'function' ? config.defaultValue() : config.defaultValue);
        }
      });

      // Only send changed settings to reduce blast radius
      const changedSettings = {};
      Object.keys(next).forEach((key) => {
        if (next[key] !== settingsInitialState[key]) {
          changedSettings[key] = next[key];
        }
      });

      // Apply all settings locally for immediate UI update
      applyTheme(next.theme);
      if (paygRateInput) paygRateInput.value = String(next.payg_instalment_rate);
      state.settings = { ...state.settings, ...next };
      saveCache();
      applyStatusDisplay();
      // Clear annual data cache when lost super recovery mode changes to force recalculation
      if (state.annualData && next.lost_super_recovery_mode && next.lost_super_recovery_mode !== settingsInitialState.lost_super_recovery_mode) {
        state.annualData = null;
      }
      renderCalendar();
      setStatus('Saving settings...', 'warn');
      google.script.run
        .withSuccessHandler(() => {
          setStatus('Settings saved', 'success');
          captureSettingsState();
          checkSettingsDirty();
          renderIncomeSummary();
        })
        .withFailureHandler((error) => {
          console.error('[Settings] Save failed:', error);
          setStatus('Settings failed', 'error');
        })
        .api_updateSettings(changedSettings);
    };
  }

  // Discard settings changes
  if (discardSettingsBtn) {
    discardSettingsBtn.onclick = function () {
      resetSettingsToInitial();
    };
  }

  if (themeSelect) {
    themeSelect.addEventListener('change', () => {
      applyTheme(themeSelect.value);
      saveCache();
    });
  }

  // Initial load
  function init() {
    loadCache();
    renderEntries();
    // Load settings into UI inputs from cache
    Object.keys(SETTINGS_CONFIG).forEach((key) => {
      const config = SETTINGS_CONFIG[key];
      const element = config.element();
      if (element) {
        const value = state.settings[key] !== undefined ? state.settings[key] : (typeof config.defaultValue === 'function' ? config.defaultValue() : config.defaultValue);
        config.setValue(element, value);
      }
    });
    applyTheme(state.settings.theme || 'dark');
    captureSettingsState();
    checkSettingsDirty();
    applyStatusDisplay();
    renderContractsUI();
    renderDeductionsList();
    hideContractForm();
    refreshContractBindings();
    state.featureFlags = normalizeFeatureFlags(state.featureFlags);
    renderFeatureFlags();
    applyFeatureFlags();
    setStatus('Syncing...', 'warn');
    google.script.run
      .withSuccessHandler((entries) => {
        state.entries = (entries || []).map(sanitizeEntry);
        state.entriesLoaded = true;
        saveCache();
        renderEntries();
        updateTabStates();
        ensurePunchDraft(state.punchDraft ? state.punchDraft.contractId : undefined);
        setStatus('Synced', 'success');
        renderBasReporting();
        maybeAutoPopulatePublicHolidayEntries();
      })
      .withFailureHandler(() => setStatus('Entries sync failed', 'error'))
      .api_getEntries({});
    // Settings loader with retry mechanism
    let settingsRetryCount = 0;
    const MAX_SETTINGS_RETRIES = 3;

    function loadSettingsWithRetry() {
      google.script.run
        .withSuccessHandler((settings) => {
          // If null or empty object received, retry up to MAX_SETTINGS_RETRIES times
          if (!settings || (typeof settings === 'object' && Object.keys(settings).length === 0)) {
            if (settingsRetryCount < MAX_SETTINGS_RETRIES) {
              settingsRetryCount++;
              const delay = Math.pow(2, settingsRetryCount) * 500; // Exponential backoff: 1s, 2s, 4s
              console.warn('[Settings] Received null/empty settings, retrying in ' + delay + 'ms (attempt ' + settingsRetryCount + '/' + MAX_SETTINGS_RETRIES + ')');
              setTimeout(loadSettingsWithRetry, delay);
              return;
            } else {
              console.error('[Settings] Received null/empty after ' + MAX_SETTINGS_RETRIES + ' retries, using cached settings');
              // Don't overwrite state.settings if we have cached data
              if (!state.settings || Object.keys(state.settings).length === 0) {
                state.settings = {};
              }
              settingsServerSynced = true;
              checkSettingsDirty();
              return;
            }
          }

          // Valid settings received
          const previousLastNonCustomTheme = state.settings && state.settings.last_non_custom_theme
            ? state.settings.last_non_custom_theme
            : '';
          state.settings = settings;

          // Parse custom_theme_config if it's a JSON string
          if (state.settings.custom_theme_config && typeof state.settings.custom_theme_config === 'string') {
            try {
              state.settings.custom_theme_config = JSON.parse(state.settings.custom_theme_config);
            } catch (e) {
              // If parsing fails, reset to default
              state.settings.custom_theme_config = null;
            }
          }

          if (!state.settings.last_non_custom_theme) {
            if (state.settings.theme && state.settings.theme !== 'custom') {
              state.settings.last_non_custom_theme = state.settings.theme;
            } else if (previousLastNonCustomTheme && previousLastNonCustomTheme !== 'custom') {
              state.settings.last_non_custom_theme = previousLastNonCustomTheme;
            }
          }

          saveCache();
          // Load settings into UI inputs
          Object.keys(SETTINGS_CONFIG).forEach((key) => {
            const config = SETTINGS_CONFIG[key];
            const element = config.element();
            if (element) {
              const value = state.settings[key] !== undefined ? state.settings[key] : (typeof config.defaultValue === 'function' ? config.defaultValue() : config.defaultValue);
              config.setValue(element, value);
            } else {
              console.warn('[Settings] Element not found for key:', key);
            }
          });
          applyTheme(state.settings.theme || 'dark');

          captureSettingsState();
          // Mark settings as synced from server - enables save button
          settingsServerSynced = true;
          checkSettingsDirty();
          applyStatusDisplay();
          renderCalendar();
        })
        .withFailureHandler((error) => {
          console.error('[Settings] Failed to load from server:', error);

          // Retry on failure too
          if (settingsRetryCount < MAX_SETTINGS_RETRIES) {
            settingsRetryCount++;
            const delay = Math.pow(2, settingsRetryCount) * 500;
            console.warn('[Settings] API call failed, retrying in ' + delay + 'ms (attempt ' + settingsRetryCount + '/' + MAX_SETTINGS_RETRIES + ')');
            setTimeout(loadSettingsWithRetry, delay);
            return;
          }

          // Even on failure, mark as synced to prevent user from being stuck
          // They can still save changes based on cached settings
          settingsServerSynced = true;
          checkSettingsDirty();
        })
        .api_getSettings();
    }

    // Start loading settings
    loadSettingsWithRetry();
    // Load super guarantee rates
    google.script.run
      .withSuccessHandler((rates) => {
        cacheSuperGuaranteeRates(rates);
      })
      .withFailureHandler(() => {})
      .api_getSuperGuaranteeRates();
    google.script.run
      .withSuccessHandler((contracts) => {
        state.contracts = (contracts || []).map(sanitizeContract);
        refreshContractBindings();
        ensureInvoiceFormOptions();
        saveCache();
        renderCalendar();
      })
      .withFailureHandler(() => setStatus('Contracts sync failed', 'error'))
      .api_getContracts();
    google.script.run
      .withSuccessHandler((flags) => {
        state.featureFlags = normalizeFeatureFlags(flags);
        saveCache();
        renderFeatureFlags();
        applyFeatureFlags();
        loadPublicHolidays();

        // Load deduction categories if feature is enabled
        if (isDeductionCategoriesEnabled()) {
          google.script.run
            .withSuccessHandler((categories) => {
              state.deductionCategories = (categories || []).map(sanitizeDeductionCategory);
              updateDeductionCategoryMap();
              ensureDeductionCategoryCollapseState();
              saveCache();
              renderDeductionCategoryOptions('');
              renderDeductionsList();
              renderAnnualCategorySection();
            })
            .withFailureHandler(() => {
              console.error('Failed to load deduction categories');
            })
            .api_getDeductionCategories();
        }

        // Load deduction exceptions (always loaded, not behind feature flag)
        google.script.run
          .withSuccessHandler((exceptions) => {
            state.deductionExceptions = (exceptions || []).map(sanitizeDeductionException);
            saveCache();
            renderIncomeSummary();
          })
          .withFailureHandler(() => {
            console.error('Failed to load deduction exceptions');
          })
          .api_getDeductionExceptions();
      })
      .withFailureHandler(() => {})
      .api_getFeatureFlags();
    google.script.run
      .withSuccessHandler((deductions) => {
        state.deductions = dedupeById((deductions || []).map(sanitizeDeduction));
        saveCache();
        renderDeductionsList();
        renderIncomeSummary();
        renderAnnualCategorySection();
      })
      .withFailureHandler(() => setStatus('Deductions sync failed', 'error'))
      .api_getDeductions();
    google.script.run
      .withSuccessHandler((actualIncome) => {
        state.actualIncome = actualIncome || [];
        refreshActualIncomeMap();
        saveCache();
        renderIncomeSummary();
      })
      .withFailureHandler((error) => {
        console.error('[ActualIncome] Failed to load:', error);
      })
      .api_getActualIncome();
    google.script.run
      .withSuccessHandler((submissions) => {
        state.basSubmissions = submissions || [];
        saveCache();
        renderBasReporting();
      })
      .withFailureHandler(() => {})
      .api_getBasSubmissions();
  }

  // Default Entries Functionality
  const state_defaults = {
    entryDefaults: { basic: [], advanced: [] },
    currentDefaultType: null,
    editingDefaultName: null
  };

  // Default entry UI elements
  const createManualDefaultBtn = document.getElementById('btn-create-manual-default');
  const enterManualDefaultBtn = document.getElementById('btn-enter-manual-default');
  const editManualDefaultsBtn = document.getElementById('btn-edit-manual-defaults');
  const createPunchDefaultBtn = document.getElementById('btn-create-punch-default');
  const enterPunchDefaultBtn = document.getElementById('btn-enter-punch-default');
  const editPunchDefaultsBtn = document.getElementById('btn-edit-punch-defaults');


  // Modal elements
  const createDefaultModal = document.getElementById('modal-create-default');
  const selectDefaultModal = document.getElementById('modal-select-default');
  const editDefaultsModal = document.getElementById('modal-edit-defaults');
  const editDefaultDetailsModal = document.getElementById('modal-edit-default-details');

  function updateDefaultButtonsVisibility() {
    const featureEnabled = state.featureFlags.default_inputs && state.featureFlags.default_inputs.enabled;

    if (!featureEnabled) {
      // Hide all default buttons if feature is disabled
      [createManualDefaultBtn, enterManualDefaultBtn, editManualDefaultsBtn,
       createPunchDefaultBtn, enterPunchDefaultBtn, editPunchDefaultsBtn].forEach(btn => {
        if (btn) btn.style.display = 'none';
      });
      return;
    }

    const defaults = state_defaults.entryDefaults;
    const hasBasicDefaults = defaults.basic.length > 0;
    const hasAdvancedDefaults = defaults.advanced.length > 0;

    // Basic/Manual tab buttons
    if (createManualDefaultBtn) createManualDefaultBtn.style.display = 'inline-flex';
    if (enterManualDefaultBtn) enterManualDefaultBtn.style.display = hasBasicDefaults ? 'inline-flex' : 'none';
    if (editManualDefaultsBtn) editManualDefaultsBtn.style.display = hasBasicDefaults ? 'inline-flex' : 'none';

    // Advanced/Punch tab buttons
    if (createPunchDefaultBtn) createPunchDefaultBtn.style.display = 'inline-flex';
    if (enterPunchDefaultBtn) enterPunchDefaultBtn.style.display = hasAdvancedDefaults ? 'inline-flex' : 'none';
    if (editPunchDefaultsBtn) editPunchDefaultsBtn.style.display = hasAdvancedDefaults ? 'inline-flex' : 'none';
  }

  function loadEntryDefaults() {
    google.script.run
      .withSuccessHandler((result) => {
        state_defaults.entryDefaults = result || { basic: [], advanced: [] };
        updateDefaultButtonsVisibility();
      })
      .withFailureHandler(() => {
        console.log('Failed to load entry defaults');
      })
      .api_getEntryDefaults();
  }

  function showModal(modal) {
    if (modal) modal.style.display = 'flex';
  }

  function hideModal(modal) {
    if (modal) modal.style.display = 'none';
  }

  function showMonthlyDeductionsModal(type) {
    if (!modalMonthlyDeductions || !monthlyDeductionsContent || !monthlyDeductionsTitle) return;

    ensureCalendarState();
    const baseDate = state.calendar
      ? new Date(state.calendar.year, state.calendar.month, 1)
      : new Date();
    const year = baseDate.getFullYear();
    const month = baseDate.getMonth();

    // Set modal title
    const monthName = MONTH_ABBREVIATIONS[month];
    const typeLabel = type === 'company' ? 'Company Expenses' : 'Pre-tax Deductions';
    monthlyDeductionsTitle.textContent = `${typeLabel} - ${monthName} ${year}`;

    // Calculate deductions for the month
    const monthStart = startOfDay(new Date(year, month, 1));
    const monthEnd = startOfDay(new Date(year, month + 1, 0));

    const deductionsList = [];
    if (Array.isArray(state.deductions) && state.deductions.length) {
      state.deductions.forEach((deduction) => {
        if (!deduction || deduction.active === false) return;

        // Filter by type
        const isCompany = deduction.company_expense === true;
        if (type === 'company' && !isCompany) return;
        if (type === 'personal' && isCompany) return;

        // Skip extra super for personal deductions (it's shown separately)
        if (type === 'personal' && deduction.deduction_type === 'extra_super') return;

        const occurrencesWithExceptions = getDeductionOccurrencesWithExceptions(deduction, monthStart, monthEnd);
        if (!occurrencesWithExceptions.length) return;

        let totalAmount = 0;
        occurrencesWithExceptions.forEach(occ => {
          const baseAmount = occ.amount !== null ? occ.amount : deduction.amount_value;
          let netAmount = baseAmount;
          if (type === 'company' && deduction.gst_inclusive) {
            netAmount = baseAmount / (1 + GST_RATE);
          }
          totalAmount += netAmount;
        });

        deductionsList.push({
          deduction: deduction,
          name: deduction.name,
          occurrences: occurrencesWithExceptions,
          totalAmount: totalAmount,
          frequency: deduction.frequency,
          gst_inclusive: deduction.gst_inclusive && type === 'company',
          category_id: deduction.category_id || ''
        });
      });
    }

    // Sort by total amount descending
    deductionsList.sort((a, b) => b.totalAmount - a.totalAmount);

    // Render content
    if (!deductionsList.length) {
      monthlyDeductionsContent.innerHTML = `
        <div class="ts-note">No ${typeLabel.toLowerCase()} found for this month.</div>
      `;
    } else {
      const categoriesEnabled = isDeductionCategoriesEnabled();
      let html = '<div class="ts-list" style="margin:0;">';

      deductionsList.forEach((item) => {
        const categoryMeta = categoriesEnabled ? getDeductionCategoryMeta(item.category_id) : null;
        const categoryBadge = categoriesEnabled && categoryMeta
          ? `<span class="ts-badge" style="background-color:${categoryMeta.color}20; color:${categoryMeta.color}; font-size:10px; padding:2px 6px;">${categoryMeta.name}</span>`
          : '';

        const deductionId = `deduction-${item.deduction.id}`;
        const expandedClass = state.monthlyDeductionsExpanded && state.monthlyDeductionsExpanded[item.deduction.id] ? 'expanded' : '';
        const exceptionCount = item.occurrences.filter(occ => occ.hasException).length;
        const exceptionBadge = exceptionCount > 0
          ? ` <span class="ts-badge" style="background-color:var(--warning)20; color:var(--warning); font-size:10px; padding:2px 6px;">${exceptionCount} adjustment${exceptionCount > 1 ? 's' : ''}</span>`
          : '';

        html += `
          <div class="ts-item ${expandedClass}" style="display:block;" data-deduction-id="${item.deduction.id}">
            <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" class="deduction-header">
              <div style="flex:1;">
                <div style="font-weight:600;">${item.name}${exceptionBadge}</div>
                <div class="ts-note" style="margin-top:4px;">
                  ${item.occurrences.length} occurrence${item.occurrences.length > 1 ? 's' : ''}
                  ${categoryBadge ? ' ' + categoryBadge : ''}
                </div>
              </div>
              <div style="font-weight:600; font-size:16px;">${formatCurrency(item.totalAmount)}</div>
            </div>
            <div class="deduction-occurrences" style="display:none; margin-top:12px; padding-left:16px;">
        `;

        item.occurrences.forEach(occ => {
          const baseAmount = occ.amount !== null ? occ.amount : item.deduction.amount_value;
          let netAmount = baseAmount;
          if (type === 'company' && item.gst_inclusive) {
            netAmount = baseAmount / (1 + GST_RATE);
          }

          const exceptionIcon = occ.hasException
            ? `<span style="color:var(--warning); margin-left:4px;" title="${occ.exceptionType === 'move' ? 'Moved from ' + (occ.originalDate || '') : occ.exceptionType === 'adjust_amount' ? 'Amount adjusted' : 'Exception'}">â ï¸</span>`
            : '';

          html += `
            <div style="display:flex; justify-content:space-between; align-items:center; padding:8px 0; border-bottom:1px solid var(--border);">
              <div>
                <span>${formatDate(new Date(occ.date))}${exceptionIcon}</span>
              </div>
              <div style="display:flex; align-items:center; gap:12px;">
                <span>${formatCurrency(netAmount)}</span>
                <button class="ghost small adjust-occurrence-btn" data-deduction-id="${item.deduction.id}" data-occurrence-date="${occ.date}" data-original-date="${occ.originalDate || occ.date}">Adjust</button>
              </div>
            </div>
          `;
        });

        html += `
            </div>
          </div>
        `;
      });

      const total = deductionsList.reduce((sum, item) => sum + item.totalAmount, 0);
      html += `
        <div class="ts-item" style="display:flex; justify-content:space-between; align-items:center; border-top:2px solid var(--border); padding-top:12px; margin-top:8px;">
          <div style="font-weight:600; font-size:16px;">Total</div>
          <div style="font-weight:600; font-size:18px;">${formatCurrency(total)}</div>
        </div>
      `;
      html += '</div>';

      monthlyDeductionsContent.innerHTML = html;

      // Add click handlers for expand/collapse
      const headers = monthlyDeductionsContent.querySelectorAll('.deduction-header');
      headers.forEach(header => {
        header.addEventListener('click', (e) => {
          const item = e.currentTarget.closest('.ts-item');
          const deductionId = item.dataset.deductionId;
          const occurrencesDiv = item.querySelector('.deduction-occurrences');

          if (!state.monthlyDeductionsExpanded) state.monthlyDeductionsExpanded = {};

          if (item.classList.contains('expanded')) {
            item.classList.remove('expanded');
            occurrencesDiv.style.display = 'none';
            state.monthlyDeductionsExpanded[deductionId] = false;
          } else {
            item.classList.add('expanded');
            occurrencesDiv.style.display = 'block';
            state.monthlyDeductionsExpanded[deductionId] = true;
          }
        });
      });

      // Add click handlers for adjust buttons
      const adjustBtns = monthlyDeductionsContent.querySelectorAll('.adjust-occurrence-btn');
      adjustBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't trigger expand/collapse
          const deductionId = btn.dataset.deductionId;
          const occurrenceDate = btn.dataset.occurrenceDate;
          const originalDate = btn.dataset.originalDate;
          const deduction = state.deductions.find(d => d.id === deductionId);
          if (deduction) {
            showAdjustOccurrenceModal(deduction, originalDate, type);
          }
        });
      });
    }

    showModal(modalMonthlyDeductions);
  }

  function showAdjustOccurrenceModal(deduction, originalDate, type) {
    if (!modalAdjustOccurrence || !deduction || !originalDate) return;

    adjustingDeduction = deduction;
    adjustingOriginalDate = originalDate;
    adjustingType = type;

    // Find if there's already an exception for this occurrence
    const existingException = state.deductionExceptions.find(ex =>
      ex.deduction_id === deduction.id && ex.original_date === originalDate
    );

    // Calculate the display amount
    let displayAmount = deduction.amount_value;
    if (type === 'company' && deduction.gst_inclusive) {
      displayAmount = deduction.amount_value / (1 + GST_RATE);
    }

    // Set form values
    if (adjustDeductionName) adjustDeductionName.textContent = deduction.name;
    if (adjustOriginalDate) adjustOriginalDate.textContent = formatDate(new Date(originalDate));
    if (adjustOriginalAmount) adjustOriginalAmount.textContent = formatCurrency(displayAmount);

    // Reset form
    const adjustSkip = document.getElementById('adjust-skip');
    if (adjustNotes) adjustNotes.value = '';
    if (adjustNewDate) adjustNewDate.value = '';
    if (adjustNewAmount) adjustNewAmount.value = '';
    if (adjustSkip) adjustSkip.checked = false;

    // If there's an existing exception, pre-fill the form
    if (existingException) {
      if (existingException.exception_type === 'skip') {
        if (adjustSkip) adjustSkip.checked = true;
      } else {
        if (existingException.exception_type === 'move' || existingException.exception_type === 'move_and_adjust') {
          if (adjustNewDate) adjustNewDate.value = existingException.new_date;
        }
        if (existingException.exception_type === 'adjust_amount' || existingException.exception_type === 'move_and_adjust') {
          if (adjustNewAmount) adjustNewAmount.value = existingException.new_amount;
        }
      }
      if (adjustNotes) adjustNotes.value = existingException.notes || '';

      // Show delete button
      if (btnDeleteException) btnDeleteException.style.display = 'inline-block';
    } else {
      // New exception
      if (btnDeleteException) btnDeleteException.style.display = 'none';
    }

    showModal(modalAdjustOccurrence);
  }

  function handleSaveException() {
    if (!adjustingDeduction || !adjustingOriginalDate) return;

    const adjustSkip = document.getElementById('adjust-skip');
    const hasSkip = adjustSkip && adjustSkip.checked;
    const hasNewDate = adjustNewDate && adjustNewDate.value;
    const hasNewAmount = adjustNewAmount && adjustNewAmount.value;

    // Determine exception type based on what fields are filled
    let selectedType = 'skip';
    if (!hasSkip) {
      if (hasNewDate && hasNewAmount) {
        selectedType = 'move_and_adjust';
      } else if (hasNewDate) {
        selectedType = 'move';
      } else if (hasNewAmount) {
        selectedType = 'adjust_amount';
      } else {
        setStatus('Please select a date, amount, or check skip', 'warn');
        return;
      }
    }

    const payload = {
      deduction_id: adjustingDeduction.id,
      original_date: adjustingOriginalDate,
      exception_type: selectedType,
      new_date: '',
      new_amount: 0,
      notes: adjustNotes ? adjustNotes.value.trim() : ''
    };

    // Find existing exception
    const existingException = state.deductionExceptions.find(ex =>
      ex.deduction_id === adjustingDeduction.id && ex.original_date === adjustingOriginalDate
    );
    if (existingException) {
      payload.id = existingException.id;
    }

    // Validate and set values based on type
    if (selectedType === 'move' || selectedType === 'move_and_adjust') {
      if (!adjustNewDate || !adjustNewDate.value) {
        setStatus('Please select a new date', 'warn');
        return;
      }
      payload.new_date = adjustNewDate.value;
    }

    if (selectedType === 'adjust_amount' || selectedType === 'move_and_adjust') {
      if (!adjustNewAmount || !adjustNewAmount.value) {
        setStatus('Please enter a new amount', 'warn');
        return;
      }
      const amount = parseFloat(adjustNewAmount.value);
      if (isNaN(amount) || amount < 0) {
        setStatus('Please enter a valid amount', 'warn');
        return;
      }
      payload.new_amount = amount;
    }

    const previousExceptions = state.deductionExceptions.slice();
    const optimisticId = payload.id ? String(payload.id) : `temp_exception_${Date.now()}`;
    const optimisticException = sanitizeDeductionException({
      id: optimisticId,
      deduction_id: payload.deduction_id,
      original_date: payload.original_date,
      exception_type: payload.exception_type,
      new_date: payload.new_date || '',
      new_amount: payload.new_amount || 0,
      notes: payload.notes || '',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    });

    const optimisticIndex = state.deductionExceptions.findIndex(ex => ex.id === optimisticException.id);
    if (optimisticIndex !== -1) {
      state.deductionExceptions.splice(optimisticIndex, 1, optimisticException);
    } else {
      state.deductionExceptions.push(optimisticException);
    }

    saveCache();
    renderIncomeSummary();
    renderAnnualCategorySection();
    showMonthlyDeductionsModal(adjustingType);

    // Close modal optimistically
    hideModal(modalAdjustOccurrence);
    setStatus('Saving adjustment...', 'info');

    const revertOptimistic = () => {
      state.deductionExceptions = previousExceptions;
      saveCache();
      renderIncomeSummary();
      renderAnnualCategorySection();
      showMonthlyDeductionsModal(adjustingType);
    };

    // Save to backend
    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success && res.exception) {
          // Update local state with real data
          const exception = sanitizeDeductionException(res.exception);
          const existingIndex = state.deductionExceptions.findIndex(ex => ex.id === optimisticId || ex.id === exception.id);
          if (existingIndex !== -1) {
            state.deductionExceptions.splice(existingIndex, 1, exception);
          } else {
            state.deductionExceptions.push(exception);
          }

          saveCache();
          setStatus('Adjustment saved', 'success');

          // Refresh the monthly deductions modal only if it's still open
          if (modalMonthlyDeductions && modalMonthlyDeductions.style.display !== 'none') {
            showMonthlyDeductionsModal(adjustingType);
          }
          renderIncomeSummary();
          renderAnnualCategorySection();
        } else {
          revertOptimistic();
          setStatus('Failed to save adjustment', 'error');
        }
      })
      .withFailureHandler(() => {
        revertOptimistic();
        setStatus('Failed to save adjustment', 'error');
      })
      .api_upsertDeductionException(payload);
  }

  function handleDeleteException() {
    if (!adjustingDeduction || !adjustingOriginalDate) return;

    const existingException = state.deductionExceptions.find(ex =>
      ex.deduction_id === adjustingDeduction.id && ex.original_date === adjustingOriginalDate
    );

    if (!existingException) {
      hideModal(modalAdjustOccurrence);
      return;
    }

    const previousExceptions = state.deductionExceptions.slice();
    state.deductionExceptions = state.deductionExceptions.filter(ex => ex.id !== existingException.id);
    saveCache();
    renderIncomeSummary();
    renderAnnualCategorySection();
    showMonthlyDeductionsModal(adjustingType);

    // Close modal optimistically
    hideModal(modalAdjustOccurrence);
    setStatus('Removing adjustment...', 'info');

    const revertDeleteOptimistic = () => {
      state.deductionExceptions = previousExceptions;
      saveCache();
      renderIncomeSummary();
      renderAnnualCategorySection();
      showMonthlyDeductionsModal(adjustingType);
    };

    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success) {
          setStatus('Adjustment removed', 'success');

          // Refresh the monthly deductions modal only if it's still open
          if (modalMonthlyDeductions && modalMonthlyDeductions.style.display !== 'none') {
            showMonthlyDeductionsModal(adjustingType);
          }
          renderIncomeSummary();
          renderAnnualCategorySection();
        } else {
          revertDeleteOptimistic();
          setStatus('Failed to remove adjustment', 'error');
        }
      })
      .withFailureHandler(() => {
        revertDeleteOptimistic();
        setStatus('Failed to remove adjustment', 'error');
      })
      .api_deleteDeductionException(existingException.id);
  }

  function resetInvoicesState() {
    state.invoices = [];
    state.invoiceMap = {};
    state.invoiceDefaults = [];
    state.invoiceDefaultMap = {};
    state.invoiceFilters = { year: '', month: '' };
    state.invoiceSelectedId = '';
    state.invoiceDetail = null;
    state.invoiceDetailLoading = false;
    state.invoiceListLoading = false;
    state.invoiceLineForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: 'hours' };
    state.invoiceDefaultForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: 'hours' };
    state.invoicePending = { savingInvoice: false, generating: false };
    state.invoicesInitialized = false;
    renderInvoicesPage();
    renderBasInvoiceTable();
    saveCache();
  }

  function initializeInvoicesFeature() {
    if (!getFeatureFlag('enable_invoices')) return;
    if (state.invoicesInitialized) {
      renderInvoicesPage();
      return;
    }
    state.invoicesInitialized = true;
    ensureInvoiceFiltersInitialized();
    ensureInvoiceFormOptions();
    loadInvoiceDefaults();
    loadInvoicesList();
    renderInvoicesPage();
  }

  function refreshInvoices(forceDetail) {
    if (!getFeatureFlag('enable_invoices')) return;
    loadInvoiceDefaults();
    loadInvoicesList(forceDetail);
  }

  function loadInvoiceDefaults() {
    if (!getFeatureFlag('enable_invoices')) return;
    google.script.run
      .withSuccessHandler((defaults) => {
        if (!Array.isArray(defaults)) {
          state.invoiceDefaults = [];
          state.invoiceDefaultMap = {};
        } else {
          state.invoiceDefaults = defaults.slice();
          state.invoiceDefaultMap = defaults.reduce((acc, item) => {
            if (item && item.id) acc[item.id] = item;
            return acc;
          }, {});
        }
        renderInvoiceDefaults();
        saveCache();
      })
      .withFailureHandler(() => {
        setStatus('Failed to load invoice defaults', 'error');
      })
      .api_listInvoiceDefaultLineItems();
  }

  function loadInvoicesList(forceDetail) {
    if (!getFeatureFlag('enable_invoices')) return;
    state.invoiceListLoading = true;
    renderInvoiceSelector();
    google.script.run
      .withSuccessHandler((invoices) => {
        const list = Array.isArray(invoices) ? invoices.slice() : [];
        state.invoices = list;
        sortInvoices();
        updateInvoiceMaps();
        if (state.invoiceSelectedId && !state.invoiceMap[state.invoiceSelectedId]) {
          state.invoiceSelectedId = '';
          state.invoiceDetail = null;
        }
        state.invoiceListLoading = false;
        renderInvoiceNavigator();
        renderInvoiceSelector();
        if (!state.invoiceSelectedId) {
          const filtered = getFilteredInvoices();
          if (filtered.length) {
            selectInvoice(filtered[0].id, { autoLoad: true });
          } else {
            renderInvoiceDetail();
          }
        } else if (forceDetail) {
          loadInvoiceDetail(state.invoiceSelectedId, { force: true });
        } else {
          renderInvoiceDetail();
        }
        renderBasInvoiceTable();
        saveCache();
      })
      .withFailureHandler(() => {
        state.invoiceListLoading = false;
        setStatus('Failed to load invoices', 'error');
        renderInvoiceSelector();
      })
      .api_listInvoices({ include_summary: true });
  }

  function updateInvoiceMaps() {
    state.invoiceMap = state.invoices.reduce((acc, invoice) => {
      if (invoice && invoice.id) acc[invoice.id] = invoice;
      return acc;
    }, {});
  }

  function ensureInvoiceFiltersInitialized() {
    if (state.invoiceFilters.year) return;
    const now = new Date();
    state.invoiceFilters.year = String(now.getFullYear());
    state.invoiceFilters.month = String(now.getMonth() + 1);
  }

  const INVOICE_MONTH_NAMES = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  var invoiceMonthPickerState = { year: null };

  function renderInvoiceNavigator() {
    if (!invoiceNavJump) return;
    ensureInvoiceFiltersInitialized();
    const year = Number(state.invoiceFilters.year);
    const month = Number(state.invoiceFilters.month);
    const monthIndex = Math.max(1, Math.min(12, month)) - 1;
    invoiceNavJump.textContent = `${INVOICE_MONTH_NAMES[monthIndex]} ${year}`;
  }

  function renderInvoiceSelector() {
    if (!invoiceSelector) return;
    ensureInvoiceFiltersInitialized();
    if (state.invoiceListLoading) {
      invoiceSelector.innerHTML = '<option>Loadingâ¦</option>';
      invoiceSelector.disabled = true;
      return;
    }
    const filtered = getFilteredInvoices();
    if (!filtered.length) {
      invoiceSelector.innerHTML = '<option value=\"\">No invoices this month</option>';
      invoiceSelector.disabled = true;
      state.invoiceSelectedId = '';
      state.invoiceDetail = null;
      renderInvoiceDetail();
      invoiceSelector.value = '';
      return;
    }
    invoiceSelector.innerHTML = '';
    filtered.forEach((invoice) => {
      const option = document.createElement('option');
      option.value = invoice.id;
      const description = invoice.invoice_number || `Invoice ${invoice.sequence || ''}`;
      option.textContent = description;
      invoiceSelector.appendChild(option);
    });
    const hasSelection = filtered.some((invoice) => invoice.id === state.invoiceSelectedId);
    if (hasSelection) {
      invoiceSelector.value = state.invoiceSelectedId;
    } else {
      invoiceSelector.value = filtered[0].id;
      selectInvoice(filtered[0].id, { autoLoad: true });
    }
    invoiceSelector.disabled = filtered.length <= 1;
  }

  function changeInvoiceMonth(offset) {
    ensureInvoiceFiltersInitialized();
    let year = Number(state.invoiceFilters.year);
    let month = Number(state.invoiceFilters.month);
    if (!Number.isFinite(year) || !Number.isFinite(month)) {
      const now = new Date();
      year = now.getFullYear();
      month = now.getMonth() + 1;
    }
    month += offset;
    while (month < 1) { month += 12; year -= 1; }
    while (month > 12) { month -= 12; year += 1; }
    state.invoiceFilters.year = String(year);
    state.invoiceFilters.month = String(month);
    state.invoiceSelectedId = '';
    state.invoiceDetail = null;
    renderInvoiceNavigator();
    renderInvoiceSelector();
    renderInvoiceDetail();
    saveCache();
  }

  function openInvoiceMonthPicker() {
    if (!invoiceMonthPickerModal) return;
    ensureInvoiceFiltersInitialized();
    invoiceMonthPickerState.year = Number(state.invoiceFilters.year);
    renderInvoiceMonthPicker();
    invoiceMonthPickerModal.style.display = 'flex';
  }

  function closeInvoiceMonthPicker() {
    if (invoiceMonthPickerModal) invoiceMonthPickerModal.style.display = 'none';
  }

  function renderInvoiceMonthPicker() {
    if (!invoiceMonthPickerModal || !invoiceMonthPickerGrid) return;
    invoiceMonthPickerYearDisplay.textContent = invoiceMonthPickerState.year;
    invoiceMonthPickerGrid.innerHTML = '';
    for (var i = 0; i < 12; i++) {
      const btn = document.createElement('button');
      btn.className = 'ts-month-picker-cell';
      btn.textContent = INVOICE_MONTH_NAMES[i].slice(0, 3);
      btn.dataset.month = String(i + 1);
      const current = new Date();
      if (invoiceMonthPickerState.year === current.getFullYear() && i === current.getMonth()) {
        btn.classList.add('current-month');
      }
      const activeMonth = Number(state.invoiceFilters.month);
      const activeYear = Number(state.invoiceFilters.year);
      if (invoiceMonthPickerState.year === activeYear && (i + 1) === activeMonth) {
        btn.classList.add('active');
      }
      btn.onclick = function() {
        const selectedMonth = Number(this.dataset.month);
        state.invoiceFilters.year = String(invoiceMonthPickerState.year);
        state.invoiceFilters.month = String(selectedMonth);
        state.invoiceSelectedId = '';
        state.invoiceDetail = null;
        renderInvoiceNavigator();
        renderInvoiceSelector();
        renderInvoiceDetail();
        closeInvoiceMonthPicker();
        saveCache();
      };
      invoiceMonthPickerGrid.appendChild(btn);
    }
  }

  function renderInvoicesPage() {
    if (!pageInvoices) return;
    if (!getFeatureFlag('enable_invoices')) {
      pageInvoices.style.display = 'none';
      return;
    }
    updateInvoiceConfigNote();
    renderInvoiceNavigator();
    renderInvoiceSelector();
    renderInvoiceDefaults();
    renderInvoiceDetail();
  }

  function updateInvoiceConfigNote() {
    if (!invoiceConfigNote) return;
    const templateConfigured = !!(state.settings.invoice_template_doc_id || state.settings.invoice_template_path || state.settings.invoice_template_reference);
    const folderConfigured = !!(state.settings.invoice_output_folder_id || state.settings.invoice_output_folder_path);
    if (templateConfigured && folderConfigured) {
      invoiceConfigNote.style.display = 'none';
      invoiceConfigNote.textContent = '';
      return;
    }
    const parts = [];
    if (!templateConfigured) parts.push('set an invoice template path or document ID');
    if (!folderConfigured) parts.push('choose an output folder path');
    invoiceConfigNote.style.display = 'block';
    invoiceConfigNote.innerHTML = `Finish setup in Settings: ${parts.join(' and ')}.`;
  }

  function renderInvoiceDefaults() {
    if (!invoiceDefaultList || !invoiceDefaultEmpty) return;
    invoiceDefaultList.innerHTML = '';
    if (!state.invoiceDefaults.length) {
      invoiceDefaultEmpty.style.display = 'block';
    } else {
      invoiceDefaultEmpty.style.display = 'none';
      const sortedDefaults = state.invoiceDefaults.slice().sort((a, b) => Number(a.position || 0) - Number(b.position || 0));
      sortedDefaults.forEach((item) => {
        const card = createInvoiceDefaultCard(item);
        const wrapper = document.createElement('li');
        wrapper.style.listStyle = 'none';
        wrapper.style.margin = '0';
        wrapper.style.padding = '0';
        wrapper.style.marginBottom = '8px';
        wrapper.appendChild(card);
        invoiceDefaultList.appendChild(wrapper);
      });
    }
    if (invoiceDefaultForm) {
      mountInvoiceDefaultFormForMode();
      if (state.invoiceDefaultForm.mode === 'hidden') {
        invoiceDefaultForm.style.display = 'none';
      } else {
        invoiceDefaultForm.style.display = 'block';
        const draft = state.invoiceDefaultForm.draft || {};
        if (invoiceDefaultLabelInput) invoiceDefaultLabelInput.value = draft.default_label || '';
        if (invoiceDefaultDescriptionInput) invoiceDefaultDescriptionInput.value = draft.description || '';
        if (invoiceDefaultHoursInput) invoiceDefaultHoursInput.value = draft.hours != null ? draft.hours : '';
        if (invoiceDefaultHourTypeSelect) populateInvoiceHourTypeOptions(invoiceDefaultHourTypeSelect, draft.hour_type_id || '');
        if (invoiceDefaultContractSelect) populateContractOptions(invoiceDefaultContractSelect, draft.contract_id || '');
        if (invoiceDefaultAmountInput) invoiceDefaultAmountInput.value = draft.amount != null ? draft.amount : '';
        if (!state.invoiceDefaultForm.amountMode) {
          state.invoiceDefaultForm.amountMode = determineInvoiceDefaultAmountMode(draft);
        }
        updateInvoiceDefaultAmountModeUI();
      }
    }
  }

  function renderInvoiceDetail() {
    if (!invoiceDetail || !invoiceDetailEmpty) return;
    if (state.invoiceDetailLoading) {
      invoiceDetail.style.display = 'none';
      invoiceDetailEmpty.style.display = 'block';
      if (invoiceDetailEmptyText) invoiceDetailEmptyText.textContent = 'Loading invoice...';
      return;
    }
    if (!state.invoiceDetail || !state.invoiceSelectedId) {
      invoiceDetail.style.display = 'none';
      invoiceDetailEmpty.style.display = 'block';
      if (invoiceDetailEmptyText) invoiceDetailEmptyText.textContent = 'Select an invoice to start editing, or create a new one.';
      return;
    }
    invoiceDetailEmpty.style.display = 'none';
    invoiceDetail.style.display = 'block';
    const detail = state.invoiceDetail.invoice || {};
    if (invoiceSelector) {
      invoiceSelector.value = state.invoiceSelectedId || '';
      invoiceSelector.disabled = state.invoiceListLoading || getFilteredInvoices().length <= 1;
    }
    if (invoiceDetailNumberInput) invoiceDetailNumberInput.value = detail.invoice_number || '';
    if (invoiceDetailDateInput) invoiceDetailDateInput.value = detail.invoice_date || '';
    if (invoiceDetailStatusSelect) invoiceDetailStatusSelect.value = detail.status || 'draft';
    const hasInvoice = !!state.invoiceDetail && !!state.invoiceDetail.invoice;
    if (btnInvoiceDelete) btnInvoiceDelete.disabled = !hasInvoice || !!state.invoicePending.savingInvoice;
    if (btnInvoiceSave) btnInvoiceSave.disabled = !hasInvoice || !!state.invoicePending.savingInvoice;
    if (btnInvoiceAddLine) btnInvoiceAddLine.disabled = !hasInvoice || state.invoiceDetailLoading;
    if (btnInvoiceGenerate) {
      const templateConfigured = !!(state.settings.invoice_template_doc_id || state.settings.invoice_template_path || state.settings.invoice_template_reference);
      const folderConfigured = !!(state.settings.invoice_output_folder_id || state.settings.invoice_output_folder_path);
      btnInvoiceGenerate.disabled = !templateConfigured || !folderConfigured || !!state.invoicePending.generating || !hasInvoice;
    }
    const summary = state.invoiceDetail.summary || { lineCount: 0, totalHours: 0, totalAmount: 0, gstAmount: 0, totalWithGst: 0 };
    if (invoiceLineSummary) {
      const countText = `${summary.lineCount} line${summary.lineCount === 1 ? '' : 's'}`;
      const hoursText = `${Number(summary.totalHours || 0).toFixed(2)} hrs`;
      invoiceLineSummary.textContent = `${countText} â¢ ${hoursText} â¢ ${formatCurrency(summary.totalAmount || 0)}`;
    }
    const subtotalAmount = Number(summary.totalAmount || 0);
    const gstAmount = summary.gstAmount != null ? Number(summary.gstAmount) : Math.round(subtotalAmount * GST_RATE * 100) / 100;
    const totalAmount = summary.totalWithGst != null ? Number(summary.totalWithGst) : Math.round((subtotalAmount + gstAmount) * 100) / 100;
    if (invoiceLineSubtotal) {
      invoiceLineSubtotal.textContent = formatCurrency(subtotalAmount);
    }
    if (invoiceLineGst) {
      invoiceLineGst.textContent = formatCurrency(gstAmount);
    }
    if (invoiceLineTotal) {
      invoiceLineTotal.textContent = formatCurrency(totalAmount);
    }
    renderInvoiceLineItems();
    if (invoiceLineForm) {
      mountInvoiceLineFormForMode();
      if (state.invoiceLineForm.mode === 'hidden') {
        invoiceLineForm.style.display = 'none';
      } else {
        invoiceLineForm.style.display = 'block';
        applyInvoiceLineDraftToForm(state.invoiceLineForm.draft || {});
      }
    }
  }

  function renderInvoiceLineItems() {
    if (!invoiceLineItemsBody) return;
    invoiceLineItemsBody.innerHTML = '';
    const items = (state.invoiceDetail && Array.isArray(state.invoiceDetail.lineItems)) ? state.invoiceDetail.lineItems : [];
    if (invoiceLineEmpty) {
      invoiceLineEmpty.style.display = items.length ? 'none' : 'block';
    }
    if (invoiceLineItemsBody) {
      invoiceLineItemsBody.style.display = items.length ? 'flex' : 'none';
    }
    if (!items.length) return;
    items.forEach((item) => {
      const card = createInvoiceLineCard(item);
      invoiceLineItemsBody.appendChild(card);
    });
  }

  function createInvoiceLineCard(item) {
    const amountValue = formatCurrency(item.amount != null ? item.amount : 0);
    const hoursValue = Number(item.hours);
    const hasHours = Number.isFinite(hoursValue) && hoursValue > 0;
    const infoItems = [
      { label: 'Amount', value: amountValue, strong: true },
      { label: 'Date', value: item.line_date || '' },
      hasHours ? { label: 'Hours', value: `${hoursValue.toFixed(2)} hrs` } : null,
      hasHours && item.hour_type_name_snapshot ? { label: 'Hour type', value: item.hour_type_name_snapshot } : null,
      item.contract_name_snapshot ? { label: 'Contract', value: item.contract_name_snapshot } : null
    ].filter(Boolean);

    const hasEntry = !!item.timesheet_entry_id;
    const statusItems = [];
    if (item.entry_pending) {
      statusItems.push({
        type: 'badge',
        text: hasEntry ? 'Entry updating' : 'Entry pending',
        variant: 'warn'
      });
    } else if (hasEntry) {
      statusItems.push({
        type: 'badge',
        text: item.entry_modified ? 'Modified' : 'Synced',
        variant: item.entry_modified ? 'warn' : 'default'
      });
    } else {
      statusItems.push({ type: 'note', text: 'No linked entry' });
    }
    if ((item.entry_pending || hasEntry)) {
      const entrySummary = buildInvoiceEntrySummary(item);
      if (entrySummary) {
        const text = item.entry_pending ? `${entrySummary} (pending sync)` : entrySummary;
        statusItems.push({ type: 'note', text: `Linked entry: ${text}` });
      }
    }
    if (hasEntry && item.source_default_id) {
      const source = state.invoiceDefaultMap && state.invoiceDefaultMap[item.source_default_id]
        ? state.invoiceDefaultMap[item.source_default_id].default_label || 'Saved default'
        : 'Saved default';
      statusItems.push({ type: 'note', text: `Seeded from: ${source}` });
    }

    const actions = [
      { label: 'Edit', action: 'edit-line', id: item.id },
      { label: 'Delete', action: 'delete-line', id: item.id },
      { label: 'Save as default', action: 'default-line', id: item.id }
    ];
    if (item.timesheet_entry_id) {
      actions.push({ label: 'Refresh', action: 'refresh-line', id: item.id });
    }

    return buildInvoiceCardLayout({
      id: item.id,
      kind: 'invoice-line',
      title: item.description || '(No description)',
      infoItems: infoItems,
      statusItems: statusItems,
      actions: actions
    });
  }

  function buildInvoiceCardLayout(config) {
    const card = document.createElement('div');
    card.className = 'ts-item';
    card.style.padding = '12px';
    if (config.id) card.dataset.id = config.id;
    if (config.kind) card.dataset.kind = config.kind;

    const container = document.createElement('div');
    container.style.display = 'flex';
    container.style.alignItems = 'stretch';
    container.style.gap = '16px';
    container.style.width = '100%';

    const left = document.createElement('div');
    left.style.flex = '0 0 220px';
    left.style.display = 'flex';
    left.style.alignItems = 'center';
    left.style.fontWeight = '600';
    left.style.lineHeight = '1.4';
    left.textContent = config.title || '';
    container.appendChild(left);

    const middle = document.createElement('div');
    middle.style.flex = '1 1 auto';
    middle.style.display = 'flex';
    middle.style.flexDirection = 'column';
    middle.style.justifyContent = 'center';
    middle.style.gap = '8px';

    const infoRow = document.createElement('div');
    infoRow.style.display = 'flex';
    infoRow.style.flexWrap = 'wrap';
    infoRow.style.alignItems = 'center';
    infoRow.style.gap = '16px';

    (config.infoItems || []).forEach((item) => {
      if (!item || !item.value) return;
      const wrap = document.createElement('div');
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '4px';

      const labelEl = document.createElement('span');
      labelEl.className = 'ts-note';
      labelEl.textContent = item.label;
      wrap.appendChild(labelEl);

      const valueEl = document.createElement('span');
      if (item.strong) valueEl.style.fontWeight = '600';
      valueEl.textContent = item.value;
      wrap.appendChild(valueEl);

      infoRow.appendChild(wrap);
    });

    middle.appendChild(infoRow);

    const statusItems = config.statusItems || [];
    if (statusItems.length) {
      const statusRow = document.createElement('div');
      statusRow.style.display = 'flex';
      statusRow.style.flexWrap = 'wrap';
      statusRow.style.alignItems = 'center';
      statusRow.style.gap = '12px';

      statusItems.forEach((status) => {
        if (!status || !status.text) return;
        if (status.type === 'badge') {
          const badge = document.createElement('span');
          badge.className = status.variant === 'warn' ? 'ts-badge ts-badge--warn' : 'ts-badge';
          badge.textContent = status.text;
          statusRow.appendChild(badge);
        } else {
          const note = document.createElement('span');
          note.className = 'ts-note';
          note.textContent = status.text;
          statusRow.appendChild(note);
        }
      });

      middle.appendChild(statusRow);
    }

    container.appendChild(middle);

    const rightWrapper = document.createElement('div');
    rightWrapper.style.display = 'flex';
    rightWrapper.style.alignItems = 'center';
    rightWrapper.style.justifyContent = 'flex-end';
    rightWrapper.style.flex = '0 0 260px';

    const actionsGrid = document.createElement('div');
    actionsGrid.style.display = 'grid';
    actionsGrid.style.gridTemplateColumns = 'repeat(2, minmax(0, 1fr))';
    actionsGrid.style.gap = '8px';
    actionsGrid.style.width = '100%';
    actionsGrid.style.maxWidth = '260px';

    const actions = (config.actions || []).slice();
    while (actions.length < 4) {
      actions.push(null);
    }

    actions.forEach((action) => {
      if (!action) {
        const placeholder = document.createElement('span');
        placeholder.style.display = 'block';
        placeholder.style.visibility = 'hidden';
        placeholder.textContent = 'Placeholder';
        actionsGrid.appendChild(placeholder);
        return;
      }
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'ghost';
      btn.dataset.action = action.action;
      if (action.id) btn.dataset.id = action.id;
      if (action.disabled) btn.disabled = true;
      if (action.title) btn.title = action.title;
      btn.textContent = action.label;
      btn.style.fontSize = '12px';
      btn.style.minWidth = '120px';
      btn.style.whiteSpace = 'nowrap';
      actionsGrid.appendChild(btn);
    });

    rightWrapper.appendChild(actionsGrid);
    container.appendChild(rightWrapper);

    card.appendChild(container);
    return card;
  }

  function getInvoiceLineCard(lineId) {
    if (!invoiceLineItemsBody || !lineId) return null;
    return invoiceLineItemsBody.querySelector(`.ts-item[data-kind="invoice-line"][data-id="${lineId}"]`);
  }

  function clearInvoiceLineEditingCard() {
    if (!invoiceLineItemsBody) return;
    const editingCards = invoiceLineItemsBody.querySelectorAll('.ts-item[data-kind="invoice-line"][data-editing="true"]');
    editingCards.forEach((card) => {
      card.style.display = '';
      card.removeAttribute('data-editing');
    });
  }

  function mountInvoiceLineFormForMode() {
    if (!invoiceLineForm) return;
    clearInvoiceLineEditingCard();
    if (state.invoiceLineForm.mode === 'edit' && state.invoiceLineForm.editingId) {
      const card = getInvoiceLineCard(state.invoiceLineForm.editingId);
      if (card && card.parentNode) {
        card.dataset.editing = 'true';
        card.style.display = 'none';
        card.parentNode.insertBefore(invoiceLineForm, card);
        invoiceLineForm.style.marginBottom = '8px';
        return;
      }
    }
    if (invoiceLineFormAnchor) {
      invoiceLineFormAnchor.appendChild(invoiceLineForm);
      invoiceLineForm.style.marginBottom = '12px';
    }
  }

  function getInvoiceDefaultCard(defaultId) {
    if (!invoiceDefaultList || !defaultId) return null;
    return invoiceDefaultList.querySelector(`.ts-item[data-kind="invoice-default"][data-id="${defaultId}"]`);
  }

  function clearInvoiceDefaultEditingCard() {
    if (!invoiceDefaultList) return;
    const editingCards = invoiceDefaultList.querySelectorAll('.ts-item[data-kind="invoice-default"][data-editing="true"]');
    editingCards.forEach((card) => {
      card.style.display = '';
      card.removeAttribute('data-editing');
    });
  }

  function mountInvoiceDefaultFormForMode() {
    if (!invoiceDefaultForm) return;
    clearInvoiceDefaultEditingCard();
    if (state.invoiceDefaultForm.mode === 'edit' && state.invoiceDefaultForm.editingId) {
      const card = getInvoiceDefaultCard(state.invoiceDefaultForm.editingId);
      if (card && card.parentNode) {
        card.dataset.editing = 'true';
        card.style.display = 'none';
        card.parentNode.insertBefore(invoiceDefaultForm, card);
        invoiceDefaultForm.style.marginTop = '0';
        return;
      }
    }
    if (invoiceDefaultFormAnchor) {
      invoiceDefaultFormAnchor.appendChild(invoiceDefaultForm);
      invoiceDefaultForm.style.marginTop = '12px';
    }
  }

  function buildInvoiceEntrySummary(item) {
    if (!item) return '';
    const entrySnapshot = item.entry_state && item.entry_state.snapshot ? item.entry_state.snapshot : null;
    const date = item.line_date || (entrySnapshot ? entrySnapshot.date : '');
    let hoursValue = Number(item.hours);
    if (!Number.isFinite(hoursValue) || hoursValue <= 0) {
      const minutes = entrySnapshot ? Number(entrySnapshot.duration_minutes) : 0;
      hoursValue = Number.isFinite(minutes) ? minutes / 60 : 0;
    }
    const contractName = item.contract_name_snapshot || getContractName(item.contract_id);
    let hourTypeName = '';
    if (Number.isFinite(hoursValue) && hoursValue > 0) {
      hourTypeName = item.hour_type_name_snapshot || getHourTypeName(item.hour_type_id);
    }
    const segments = [];
    if (date) segments.push(date);
    if (contractName) segments.push(contractName);
    if (Number.isFinite(hoursValue) && hoursValue > 0) {
      segments.push(`${hoursValue.toFixed(2)} hrs`);
    }
    if (hourTypeName) segments.push(hourTypeName);
    return segments.join(' â¢ ');
  }

  function createInvoiceDefaultCard(item) {
    const amountValue = (item.amount || item.amount === 0) ? formatCurrency(item.amount) : '';
    const hoursValue = Number(item.hours);
    const infoItems = [
      amountValue ? { label: 'Amount', value: amountValue, strong: true } : null,
      Number.isFinite(hoursValue) && hoursValue > 0 ? { label: 'Hours', value: `${hoursValue.toFixed(2)} hrs` } : null,
      Number.isFinite(hoursValue) && hoursValue > 0 && item.hour_type_name_snapshot ? { label: 'Hour type', value: item.hour_type_name_snapshot } : null,
      item.contract_name_snapshot ? { label: 'Contract', value: item.contract_name_snapshot } : null
    ].filter(Boolean);

    const statusItems = [];
    if (item.description) {
      statusItems.push({ type: 'note', text: item.description });
    }
    statusItems.push({ type: 'note', text: 'Default line item' });

    const canAddToInvoice = !!(state.invoiceDetail && state.invoiceDetail.invoice && !state.invoiceDetailLoading);
    const defaultActions = [];
    const addAction = {
      label: 'Add to invoice',
      action: 'insert-default',
      id: item.id,
      disabled: !canAddToInvoice
    };
    if (!canAddToInvoice) {
      addAction.title = 'Select an invoice to add this default';
    }
    defaultActions.push(addAction);
    defaultActions.push({ label: 'Edit', action: 'edit-default', id: item.id });
    defaultActions.push({ label: 'Delete', action: 'delete-default', id: item.id });

    return buildInvoiceCardLayout({
      id: item.id,
      kind: 'invoice-default',
      title: item.default_label || '(untitled)',
      infoItems,
      statusItems,
      actions: defaultActions
    });
  }

  function formatInvoiceMonthName(month) {
    if (!month) return '';
    const idx = Number(month) - 1;
    if (idx < 0 || idx >= INVOICE_MONTH_NAMES.length) return '';
    return INVOICE_MONTH_NAMES[idx];
  }

  function getFilteredInvoices() {
    return state.invoices.filter((invoice) => {
      if (state.invoiceFilters.year && String(invoice.year) !== state.invoiceFilters.year) return false;
      if (state.invoiceFilters.month && String(invoice.month) !== state.invoiceFilters.month) return false;
      return true;
    });
  }

  function selectInvoice(invoiceId, options) {
    const opts = options || {};
    if (!invoiceId) {
      state.invoiceSelectedId = '';
      state.invoiceDetail = null;
      state.invoiceDetailLoading = false;
      renderInvoiceDetail();
      saveCache();
      return;
    }
    if (state.invoiceSelectedId === invoiceId && !opts.force) {
      renderInvoiceDetail();
      return;
    }
    state.invoiceSelectedId = invoiceId;
    state.invoiceDetail = null;
    state.invoiceDetailLoading = true;
    renderInvoiceDetail();
    loadInvoiceDetail(invoiceId, opts);
  }

  function loadInvoiceDetail(invoiceId, options) {
    if (!invoiceId) return;
    const opts = options || {};
    state.invoiceDetailLoading = true;
    renderInvoiceDetail();
    google.script.run
      .withSuccessHandler((detail) => {
        if (state.invoiceSelectedId !== invoiceId) return;
        state.invoiceDetailLoading = false;
        if (detail && detail.invoice) {
          const summary = detail.summary || summarizeInvoiceLineItems(detail.lineItems || []);
          state.invoiceDetail = {
            invoice: detail.invoice,
            lineItems: Array.isArray(detail.lineItems) ? detail.lineItems.slice() : [],
            summary: summary
          };
          const invoiceWithSummary = Object.assign({}, detail.invoice, { summary: summary });
          upsertInvoiceInState(invoiceWithSummary);
          if (Array.isArray(detail.defaults)) {
            state.invoiceDefaults = detail.defaults.slice();
            state.invoiceDefaultMap = detail.defaults.reduce((acc, item) => {
              if (item && item.id) acc[item.id] = item;
              return acc;
            }, {});
          }
          renderInvoiceDefaults();
          ensureInvoiceFormOptions();
        } else {
          state.invoiceDetail = null;
        }
        renderInvoiceDetail();
        renderBasInvoiceTable();
        saveCache();
      })
      .withFailureHandler(() => {
        if (state.invoiceSelectedId !== invoiceId) return;
        state.invoiceDetailLoading = false;
        setStatus('Failed to load invoice', 'error');
        renderInvoiceDetail();
      })
      .api_getInvoice(invoiceId);
  }

  function upsertInvoiceInState(invoice) {
    if (!invoice || !invoice.id) return;
    const idx = state.invoices.findIndex((item) => item.id === invoice.id);
    if (idx === -1) {
      state.invoices.push(invoice);
    } else {
      state.invoices[idx] = Object.assign({}, state.invoices[idx], invoice);
    }
    sortInvoices();
    updateInvoiceMaps();
    renderInvoiceNavigator();
    renderInvoiceSelector();
  }

  function removeInvoiceFromState(invoiceId) {
    const idx = state.invoices.findIndex((item) => item.id === invoiceId);
    if (idx !== -1) {
      state.invoices.splice(idx, 1);
      updateInvoiceMaps();
      renderInvoiceNavigator();
      renderInvoiceSelector();
    }
  }

  function sortInvoices() {
    state.invoices.sort((a, b) => {
      if (a.year !== b.year) return b.year - a.year;
      if (a.month !== b.month) return b.month - a.month;
      return (b.sequence || 0) - (a.sequence || 0);
    });
  }

  function summarizeInvoiceLineItems(items) {
    const list = Array.isArray(items) ? items : [];
    const summary = list.reduce((acc, item) => {
      const amount = Number(item && item.amount != null ? item.amount : 0);
      const hours = Number(item && item.hours != null ? item.hours : 0);
      if (Number.isFinite(amount)) acc.totalAmount += amount;
      if (Number.isFinite(hours)) acc.totalHours += hours;
      return acc;
    }, { totalAmount: 0, totalHours: 0, lineCount: list.length });
    summary.totalAmount = Math.round(summary.totalAmount * 100) / 100;
    summary.totalHours = Math.round(summary.totalHours * 1000) / 1000;
    summary.gstAmount = Math.round(summary.totalAmount * GST_RATE * 100) / 100;
    summary.totalWithGst = Math.round((summary.totalAmount + summary.gstAmount) * 100) / 100;
    return summary;
  }

  function recalculateInvoiceSummary() {
    if (!state.invoiceDetail) return;
    const summary = summarizeInvoiceLineItems(state.invoiceDetail.lineItems || []);
    state.invoiceDetail.summary = summary;
  }

  function ensureInvoiceFormOptions() {
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes && state.hourTypes.length > 0;
    if (invoiceLineHourTypeSelect) populateInvoiceHourTypeOptions(invoiceLineHourTypeSelect, state.invoiceLineForm.draft && state.invoiceLineForm.draft.hour_type_id);
    if (invoiceDefaultHourTypeSelect) populateInvoiceHourTypeOptions(invoiceDefaultHourTypeSelect, state.invoiceDefaultForm.draft && state.invoiceDefaultForm.draft.hour_type_id);
    if (invoiceLineHourTypeCol) invoiceLineHourTypeCol.style.display = hourTypesEnabled ? '' : 'none';
    if (!hourTypesEnabled) {
      if (invoiceLineHourTypeSelect) invoiceLineHourTypeSelect.value = '';
      if (invoiceDefaultHourTypeSelect) invoiceDefaultHourTypeSelect.value = '';
    }
    if (invoiceLineContractSelect) populateContractOptions(invoiceLineContractSelect, state.invoiceLineForm.draft && state.invoiceLineForm.draft.contract_id);
    if (invoiceDefaultContractSelect) populateContractOptions(invoiceDefaultContractSelect, state.invoiceDefaultForm.draft && state.invoiceDefaultForm.draft.contract_id);
    updateInvoiceLineAmountModeUI();
    updateInvoiceDefaultAmountModeUI();
  }

  function populateInvoiceHourTypeOptions(selectEl, selectedId) {
    if (!selectEl) return;
    const value = selectedId || '';
    selectEl.innerHTML = '';
    const emptyOpt = document.createElement('option');
    emptyOpt.value = '';
    emptyOpt.textContent = 'None';
    selectEl.appendChild(emptyOpt);
    const types = state.hourTypes && state.hourTypes.length ? state.hourTypes : [];
    types.forEach((type) => {
      const opt = document.createElement('option');
      opt.value = type.id;
      opt.textContent = type.name;
      selectEl.appendChild(opt);
    });
    selectEl.value = value;
  }

  function populateContractOptions(selectEl, selectedId) {
    if (!selectEl) return;
    const value = selectedId || '';
    selectEl.innerHTML = '';
    const emptyOpt = document.createElement('option');
    emptyOpt.value = '';
    emptyOpt.textContent = 'None';
    selectEl.appendChild(emptyOpt);
    const contracts = state.contracts && state.contracts.length ? state.contracts : [];
    contracts.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      selectEl.appendChild(opt);
    });
    selectEl.value = value;
  }

  function getHourTypeName(hourTypeId) {
    if (!hourTypeId) return '';
    const existing = state.hourTypeMap && state.hourTypeMap[hourTypeId];
    if (existing) return existing.name || '';
    const found = state.hourTypes ? state.hourTypes.find((type) => type.id === hourTypeId) : null;
    return found ? found.name || '' : '';
  }

  function getContractName(contractId) {
    if (!contractId) return '';
    const existing = state.contractMap && state.contractMap[contractId];
    if (existing) return existing.name || '';
    const found = state.contracts ? state.contracts.find((contract) => contract.id === contractId) : null;
    return found ? found.name || '' : '';
  }

  function getContractRate(contractId) {
    if (!contractId) return 0;
    const existing = state.contractMap && state.contractMap[contractId];
    if (existing && Number.isFinite(Number(existing.hourly_rate))) {
      return Number(existing.hourly_rate);
    }
    const found = state.contracts ? state.contracts.find((contract) => contract.id === contractId) : null;
    if (found && Number.isFinite(Number(found.hourly_rate))) {
      return Number(found.hourly_rate);
    }
    return 0;
  }

  function generateTempId(prefix) {
    return `${prefix}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }

  function getNextInvoiceSequenceLocal(year, month) {
    const relevant = state.invoices.filter((invoice) => invoice.year === year && invoice.month === month);
    const maxSeq = relevant.reduce((max, invoice) => Math.max(max, Number(invoice.sequence || 0)), 0);
    return maxSeq + 1;
  }

  function startCreateInvoice() {
    if (!getFeatureFlag('enable_invoices')) return;
    ensureInvoiceFiltersInitialized();
    const now = new Date();
    const year = Number(state.invoiceFilters.year) || now.getFullYear();
    const month = Number(state.invoiceFilters.month) || (now.getMonth() + 1);
    const dateValue = `${year}-${String(month).padStart(2, '0')}-01`;
    const tempId = generateTempId('invoice');
    const sequence = getNextInvoiceSequenceLocal(year, month);
    const invoiceNumber = `INV-${year}${String(month).padStart(2, '0')}-${String(sequence).padStart(3, '0')}`;
    const draftInvoice = {
      id: tempId,
      year: year,
      month: month,
      sequence: sequence,
      invoice_number: invoiceNumber,
      invoice_date: dateValue,
      status: 'draft',
      generated_doc_id: '',
      generated_doc_url: ''
    };
    upsertInvoiceInState(draftInvoice);
    state.invoiceSelectedId = tempId;
    state.invoiceDetail = {
      invoice: draftInvoice,
      lineItems: [],
      summary: { lineCount: 0, totalHours: 0, totalAmount: 0, gstAmount: 0, totalWithGst: 0 }
    };
    renderInvoicesPage();
    setStatus('Creating invoice...', 'warn');
    google.script.run
      .withSuccessHandler((saved) => {
        if (!saved || !saved.id) {
          removeInvoiceFromState(tempId);
          state.invoiceSelectedId = '';
          state.invoiceDetail = null;
          renderInvoicesPage();
          setStatus('Failed to create invoice', 'error');
          return;
        }
        removeInvoiceFromState(tempId);
        upsertInvoiceInState(saved);
        state.invoiceSelectedId = saved.id;
        state.invoiceDetail = null;
        renderInvoicesPage();
        loadInvoiceDetail(saved.id, { force: true });
        setStatus('Invoice created', 'success');
      })
      .withFailureHandler(() => {
        removeInvoiceFromState(tempId);
        state.invoiceSelectedId = '';
        state.invoiceDetail = null;
        renderInvoicesPage();
        setStatus('Failed to create invoice', 'error');
      })
      .api_upsertInvoice({
        invoice_date: dateValue,
        status: 'draft',
        invoice_number: invoiceNumber
      });
  }

  function handleInvoiceSave(event) {
    if (event) event.preventDefault();
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) return;
    const invoice = state.invoiceDetail.invoice;
    const numberValue = invoiceDetailNumberInput ? invoiceDetailNumberInput.value.trim() : (invoice.invoice_number || '');
    const dateValue = invoiceDetailDateInput ? invoiceDetailDateInput.value : (invoice.invoice_date || '');
    if (!dateValue) {
      setStatus('Invoice date is required.', 'warn');
      return;
    }
    const statusValue = invoiceDetailStatusSelect ? invoiceDetailStatusSelect.value : (invoice.status || 'draft');
    const year = Number(dateValue.slice(0, 4)) || invoice.year;
    const month = Number(dateValue.slice(5, 7)) || invoice.month;
    const previous = Object.assign({}, invoice);
    const updatedInvoice = Object.assign({}, invoice, {
      invoice_number: numberValue,
      invoice_date: dateValue,
      status: statusValue,
      year: year,
      month: month
    });
    state.invoiceFilters.year = String(year);
    state.invoiceFilters.month = String(month);
    state.invoiceDetail.invoice = updatedInvoice;
    upsertInvoiceInState(updatedInvoice);
    state.invoicePending.savingInvoice = true;
    renderInvoiceDetail();
    setStatus('Saving invoice...', 'warn');
    google.script.run
      .withSuccessHandler((saved) => {
        state.invoicePending.savingInvoice = false;
        if (saved && saved.id) {
          state.invoiceDetail.invoice = saved;
          upsertInvoiceInState(saved);
          renderInvoiceDetail();
          setStatus('Invoice saved', 'success');
        } else {
          state.invoiceDetail.invoice = previous;
          upsertInvoiceInState(previous);
          renderInvoiceDetail();
          setStatus('Invoice save failed', 'error');
        }
        saveCache();
      })
      .withFailureHandler(() => {
        state.invoicePending.savingInvoice = false;
        state.invoiceDetail.invoice = previous;
        upsertInvoiceInState(previous);
        renderInvoiceDetail();
        setStatus('Invoice save failed', 'error');
        saveCache();
      })
      .api_upsertInvoice({
        id: invoice.id,
        invoice_number: numberValue,
        invoice_date: dateValue,
        status: statusValue
      });
  }

  async function handleInvoiceDelete() {
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) return;
    const invoice = state.invoiceDetail.invoice;
    const confirmed = await customConfirm('Delete this invoice?', { danger: true, okText: 'Delete' });
    if (!confirmed) return;
    const previousInvoices = state.invoices.slice();
    const previousSelected = state.invoiceSelectedId;
    const previousDetail = state.invoiceDetail ? JSON.parse(JSON.stringify(state.invoiceDetail)) : null;
    removeInvoiceFromState(invoice.id);
    state.invoiceSelectedId = '';
    state.invoiceDetail = null;
    renderBasInvoiceTable();
    renderInvoicesPage();
    setStatus('Deleting invoice...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success) {
          setStatus('Invoice deleted', 'success');
          const filtered = getFilteredInvoices();
          if (filtered.length) {
            selectInvoice(filtered[0].id, { autoLoad: true });
          } else {
            renderInvoicesPage();
          }
        } else {
          state.invoices = previousInvoices;
          updateInvoiceMaps();
          state.invoiceSelectedId = previousSelected;
          state.invoiceDetail = previousDetail;
          renderInvoicesPage();
          setStatus('Failed to delete invoice', 'error');
        }
        renderBasInvoiceTable();
        saveCache();
      })
      .withFailureHandler(() => {
        state.invoices = previousInvoices;
        updateInvoiceMaps();
        state.invoiceSelectedId = previousSelected;
        state.invoiceDetail = previousDetail;
        renderInvoicesPage();
        setStatus('Failed to delete invoice', 'error');
        renderBasInvoiceTable();
        saveCache();
      })
      .api_deleteInvoice(invoice.id, { deleteEntries: false });
  }

  function handleInvoiceGenerate(event) {
    if (event) event.preventDefault();
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) return;
    const invoice = state.invoiceDetail.invoice;
    const templateConfigured = !!(state.settings.invoice_template_doc_id || state.settings.invoice_template_path || state.settings.invoice_template_reference);
    const folderConfigured = !!(state.settings.invoice_output_folder_id || state.settings.invoice_output_folder_path);
    if (!templateConfigured || !folderConfigured) {
      setStatus('Configure the invoice template and output folder first.', 'warn');
      return;
    }
    state.invoicePending.generating = true;
    renderInvoiceDetail();
    setStatus('Publishing invoice...', 'info');
    google.script.run
      .withSuccessHandler((res) => {
        state.invoicePending.generating = false;
        if (res && res.success) {
          setStatus('Invoice published', 'success');
          loadInvoiceDetail(invoice.id, { force: true });
        } else {
          setStatus('Failed to publish invoice', 'error');
          renderInvoiceDetail();
        }
      })
      .withFailureHandler(() => {
        state.invoicePending.generating = false;
        renderInvoiceDetail();
        setStatus('Failed to publish invoice', 'error');
      })
      .api_generateInvoiceDocument({ invoice_id: invoice.id });
  }

  function openInvoiceLineForm(mode, baseDraft) {
    if (!state.invoiceDetail) return;
    const invoiceDate = state.invoiceDetail.invoice ? (state.invoiceDetail.invoice.invoice_date || todayIso()) : todayIso();
    const draft = Object.assign({
      id: baseDraft && baseDraft.id,
      line_date: baseDraft && baseDraft.line_date ? baseDraft.line_date : invoiceDate,
      description: baseDraft && baseDraft.description ? baseDraft.description : '',
      hours: baseDraft && baseDraft.hours != null ? baseDraft.hours : '',
      amount: baseDraft && baseDraft.amount != null ? baseDraft.amount : '',
      hour_type_id: baseDraft && baseDraft.hour_type_id ? baseDraft.hour_type_id : '',
      contract_id: baseDraft && baseDraft.contract_id ? baseDraft.contract_id : '',
      source_default_id: baseDraft && baseDraft.source_default_id ? baseDraft.source_default_id : ''
    }, {});
    const amountMode = determineInvoiceLineAmountMode(draft);
    state.invoiceLineForm = {
      mode: mode,
      editingId: mode === 'edit' ? draft.id : null,
      draft: draft,
      amountMode: amountMode
    };
    ensureInvoiceFormOptions();
    mountInvoiceLineFormForMode();
    applyInvoiceLineDraftToForm(draft);
    if (invoiceLineForm) invoiceLineForm.style.display = 'block';
  }

  function resetInvoiceLineForm() {
    state.invoiceLineForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: 'hours' };
    mountInvoiceLineFormForMode();
    if (invoiceLineForm) invoiceLineForm.style.display = 'none';
    updateInvoiceLineAmountModeUI();
  }

  function handleInvoiceLineAmountModeChange() {
    const mode = invoiceLineAmountModeSelect ? invoiceLineAmountModeSelect.value : 'hours';
    if (!state.invoiceLineForm) {
      state.invoiceLineForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: mode };
    } else {
      state.invoiceLineForm.amountMode = mode;
      if (!state.invoiceLineForm.draft) {
        state.invoiceLineForm.draft = {};
      }
      if (mode === 'hours') {
        state.invoiceLineForm.draft.amount = '';
        if (invoiceLineAmountInput) invoiceLineAmountInput.value = '';
      } else {
        state.invoiceLineForm.draft.hours = '';
        state.invoiceLineForm.draft.hour_type_id = '';
        if (invoiceLineHoursInput) invoiceLineHoursInput.value = '';
        if (invoiceLineHourTypeSelect) invoiceLineHourTypeSelect.value = '';
      }
    }
    updateInvoiceLineAmountModeUI();
  }

  function determineInvoiceLineAmountMode(draft) {
    if (!draft) return 'hours';
    if (draft.hours != null && draft.hours !== '' && Number(draft.hours) > 0) {
      return 'hours';
    }
    if (draft.amount != null && draft.amount !== '' && Number(draft.amount) > 0) {
      return 'amount';
    }
    return 'hours';
  }

  function updateInvoiceLineAmountModeUI() {
    const mode = state.invoiceLineForm && state.invoiceLineForm.amountMode ? state.invoiceLineForm.amountMode : 'hours';
    if (invoiceLineAmountModeSelect) invoiceLineAmountModeSelect.value = mode;
    const showHours = mode === 'hours';
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes && state.hourTypes.length > 0;
    if (invoiceLineContractCol) invoiceLineContractCol.style.display = '';
    if (invoiceLineAmountCol) invoiceLineAmountCol.style.display = showHours ? 'none' : '';
    if (invoiceLineHoursCol) invoiceLineHoursCol.style.display = showHours ? '' : 'none';
    if (invoiceLineHourTypeCol) invoiceLineHourTypeCol.style.display = showHours && hourTypesEnabled ? '' : 'none';
    if (invoiceLineHoursInput) {
      if (!showHours) {
        invoiceLineHoursInput.value = '';
      }
      invoiceLineHoursInput.disabled = !showHours;
    }
    if (invoiceLineHourTypeSelect) {
      if (!showHours || !hourTypesEnabled) {
        invoiceLineHourTypeSelect.value = '';
      }
      invoiceLineHourTypeSelect.disabled = !showHours || !hourTypesEnabled;
    }
    if (invoiceLineAmountInput) {
      invoiceLineAmountInput.disabled = showHours;
      invoiceLineAmountInput.style.display = showHours ? 'none' : 'block';
      if (showHours) {
        invoiceLineAmountInput.value = '';
      }
    }
  }

  function determineInvoiceDefaultAmountMode(draft) {
    if (!draft) return 'hours';
    if (draft.hours != null && draft.hours !== '' && Number(draft.hours) > 0) {
      return 'hours';
    }
    if (draft.amount != null && draft.amount !== '' && Number(draft.amount) > 0) {
      return 'amount';
    }
    return 'hours';
  }

  function handleInvoiceDefaultAmountModeChange() {
    const mode = invoiceDefaultAmountModeSelect ? invoiceDefaultAmountModeSelect.value : 'hours';
    if (!state.invoiceDefaultForm) {
      state.invoiceDefaultForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: mode };
    } else {
      state.invoiceDefaultForm.amountMode = mode;
      if (!state.invoiceDefaultForm.draft) state.invoiceDefaultForm.draft = {};
      if (mode === 'hours') {
        state.invoiceDefaultForm.draft.amount = '';
        if (invoiceDefaultAmountInput) invoiceDefaultAmountInput.value = '';
      } else {
        state.invoiceDefaultForm.draft.hours = '';
        state.invoiceDefaultForm.draft.hour_type_id = '';
        if (invoiceDefaultHoursInput) invoiceDefaultHoursInput.value = '';
        if (invoiceDefaultHourTypeSelect) invoiceDefaultHourTypeSelect.value = '';
      }
    }
    updateInvoiceDefaultAmountModeUI();
  }

  function updateInvoiceDefaultAmountModeUI() {
    const mode = state.invoiceDefaultForm && state.invoiceDefaultForm.amountMode ? state.invoiceDefaultForm.amountMode : 'hours';
    if (invoiceDefaultAmountModeSelect) invoiceDefaultAmountModeSelect.value = mode;
    const showHours = mode === 'hours';
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes && state.hourTypes.length > 0;
    if (invoiceDefaultContractCol) invoiceDefaultContractCol.style.display = '';
    if (invoiceDefaultAmountCol) invoiceDefaultAmountCol.style.display = showHours ? 'none' : '';
    if (invoiceDefaultHoursCol) invoiceDefaultHoursCol.style.display = showHours ? '' : 'none';
    if (invoiceDefaultHourTypeCol) invoiceDefaultHourTypeCol.style.display = showHours && hourTypesEnabled ? '' : 'none';
    if (invoiceDefaultHoursInput) {
      if (!showHours) {
        invoiceDefaultHoursInput.value = '';
      }
      invoiceDefaultHoursInput.disabled = !showHours;
    }
    if (invoiceDefaultHourTypeSelect) {
      if (!showHours || !hourTypesEnabled) {
        invoiceDefaultHourTypeSelect.value = '';
      }
      invoiceDefaultHourTypeSelect.disabled = !showHours || !hourTypesEnabled;
    }
    if (invoiceDefaultAmountInput) {
      invoiceDefaultAmountInput.disabled = showHours;
      invoiceDefaultAmountInput.style.display = showHours ? 'none' : 'block';
      if (showHours) {
        invoiceDefaultAmountInput.value = '';
      }
    }
  }

  function applyInvoiceLineDraftToForm(draft) {
    ensureInvoiceFormOptions();
    if (state.invoiceLineForm) {
      const inferredMode = state.invoiceLineForm.amountMode || determineInvoiceLineAmountMode(draft);
      state.invoiceLineForm.amountMode = inferredMode;
    }
    updateInvoiceLineAmountModeUI();
    if (invoiceLineDateInput) invoiceLineDateInput.value = draft.line_date || '';
    if (invoiceLineDescriptionInput) invoiceLineDescriptionInput.value = draft.description || '';
    if (invoiceLineHoursInput) invoiceLineHoursInput.value = draft.hours !== undefined && draft.hours !== null ? draft.hours : '';
  if (invoiceLineAmountInput) {
    const manualMode = state.invoiceLineForm && state.invoiceLineForm.amountMode === 'amount';
    if (manualMode && draft.amount !== undefined && draft.amount !== null && draft.amount !== '') {
      invoiceLineAmountInput.value = draft.amount;
    } else {
      invoiceLineAmountInput.value = '';
    }
  }
    if (invoiceLineHourTypeSelect) invoiceLineHourTypeSelect.value = draft.hour_type_id || '';
    if (invoiceLineContractSelect) invoiceLineContractSelect.value = draft.contract_id || '';
  }

  function buildInvoiceLineDraftFromForm() {
    if (!invoiceLineDateInput || !invoiceLineDescriptionInput) return null;
    const base = state.invoiceLineForm.draft || {};
    const amountMode = state.invoiceLineForm && state.invoiceLineForm.amountMode ? state.invoiceLineForm.amountMode : 'hours';
    const lineDate = invoiceLineDateInput.value || '';
    const description = invoiceLineDescriptionInput.value.trim();
    const hoursValue = amountMode === 'hours' && invoiceLineHoursInput && invoiceLineHoursInput.value !== '' ? Number(invoiceLineHoursInput.value) : null;
    const amountProvided = amountMode === 'amount' && invoiceLineAmountInput && invoiceLineAmountInput.value !== '';
    const amountValue = amountProvided ? Number(invoiceLineAmountInput.value) : null;
    const hourTypeId = invoiceLineHourTypeSelect ? invoiceLineHourTypeSelect.value : '';
    const contractId = invoiceLineContractSelect ? invoiceLineContractSelect.value : '';
    return {
      id: base.id,
      line_date: lineDate,
      description: description,
      hours: hoursValue,
      amount: amountValue,
      amountProvided: amountProvided,
      hour_type_id: hourTypeId,
      contract_id: contractId,
      source_default_id: base.source_default_id || ''
    };
  }

  function handleInvoiceLineSave(event) {
    if (event) event.preventDefault();
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) return;
    const draft = buildInvoiceLineDraftFromForm();
    if (!draft) return;
    if (!draft.description) {
      setStatus('Line item description is required.', 'warn');
      return;
    }
    if (!draft.contract_id) {
      setStatus('Select a contract for this line item.', 'warn');
      return;
    }
    const hasHours = draft.hours != null && draft.hours !== '' && Number.isFinite(Number(draft.hours)) && Number(draft.hours) > 0;
    const amountInputValid = draft.amountProvided && draft.amount != null && !Number.isNaN(Number(draft.amount));
    if (!hasHours && !amountInputValid) {
      setStatus('Enter hours to auto-calculate or provide a raw amount.', 'warn');
      return;
    }
    if (draft.amountProvided && (draft.amount == null || Number.isNaN(Number(draft.amount)))) {
      setStatus('Enter a valid amount.', 'warn');
      return;
    }
    let amount = draft.amountProvided ? Number(draft.amount) : null;
    const contractRate = getContractRate(draft.contract_id);
    if (hasHours && !draft.amountProvided) {
      if (contractRate > 0) {
        amount = Math.round(Number(draft.hours) * contractRate * 100) / 100;
      } else {
        setStatus('Contract rate missing. Enter an amount manually.', 'warn');
        return;
      }
    }
    draft.hours = hasHours ? Number(draft.hours) : null;
    if (amount === null || Number.isNaN(amount)) {
      setStatus('Enter a valid amount for this line item.', 'warn');
      return;
    }
    amount = Math.round(Number(amount) * 100) / 100;
    const lineItems = state.invoiceDetail.lineItems || [];
    const hourTypeName = draft.hour_type_id ? getHourTypeName(draft.hour_type_id) : '';
    const payload = {
      invoice_id: state.invoiceDetail.invoice.id,
      line_date: draft.line_date || state.invoiceDetail.invoice.invoice_date || todayIso(),
      description: draft.description,
      hours: draft.hours != null ? Number(draft.hours) : 0,
      amount: Number(amount),
      hour_type_id: draft.hour_type_id || '',
      hour_type_name_snapshot: hourTypeName,
      contract_id: draft.contract_id || '',
      source_default_id: draft.source_default_id || ''
    };
    payload.amount_provided = draft.amountProvided === true || !hasHours;
    const isEdit = state.invoiceLineForm.mode === 'edit' && state.invoiceLineForm.editingId;
    if (isEdit) payload.id = state.invoiceLineForm.editingId;
    const tempId = isEdit ? state.invoiceLineForm.editingId : generateTempId('invoice-line');
    const position = isEdit
      ? (lineItems.find((item) => item.id === state.invoiceLineForm.editingId)?.position || 0)
      : (lineItems.reduce((max, item) => Math.max(max, Number(item.position || 0)), 0) + 1);
    payload.position = position;

    const optimisticItem = {
      id: tempId,
      invoice_id: state.invoiceDetail.invoice.id,
      position: position,
      line_date: payload.line_date,
      description: payload.description,
      hours: payload.hours,
      amount: payload.amount,
      hour_type_id: payload.hour_type_id,
      hour_type_name_snapshot: hourTypeName,
      contract_id: payload.contract_id,
      contract_name_snapshot: getContractName(payload.contract_id),
      timesheet_entry_id: isEdit ? (lineItems.find((item) => item.id === payload.id)?.timesheet_entry_id || '') : '',
      entry_modified: false,
      entry_state: null,
      source_default_id: payload.source_default_id || '',
      amount_provided: payload.amount_provided ? true : false,
      entry_pending: hasHours
    };
    if (isEdit) {
      const previousItem = lineItems.find((item) => item.id === payload.id);
      const previousSnapshot = previousItem ? Object.assign({}, previousItem) : null;
      mergeLineItemIntoDetail(optimisticItem);
      updateInvoiceSummaryAndRender();
      setStatus('Saving line item...', 'warn');
      google.script.run
        .withSuccessHandler((saved) => {
          if (saved && saved.id) {
            mergeLineItemIntoDetail(saved);
            updateInvoiceSummaryAndRender();
            setStatus('Line item saved', 'success');
          } else if (previousSnapshot) {
            mergeLineItemIntoDetail(previousSnapshot);
            updateInvoiceSummaryAndRender();
            setStatus('Failed to save line item', 'error');
          }
        })
        .withFailureHandler(() => {
          if (previousSnapshot) {
            mergeLineItemIntoDetail(previousSnapshot);
            updateInvoiceSummaryAndRender();
          }
          setStatus('Failed to save line item', 'error');
        })
        .api_upsertInvoiceLineItem(payload);
    } else {
      mergeLineItemIntoDetail(optimisticItem);
      updateInvoiceSummaryAndRender();
      setStatus('Saving line item...', 'warn');
      google.script.run
        .withSuccessHandler((saved) => {
          if (saved && saved.id) {
            if (tempId && tempId !== saved.id) {
              removeLineItemFromDetail(tempId);
            }
            mergeLineItemIntoDetail(saved);
            updateInvoiceSummaryAndRender();
            setStatus('Line item saved', 'success');
          } else {
            removeLineItemFromDetail(tempId);
            updateInvoiceSummaryAndRender();
            setStatus('Failed to save line item', 'error');
          }
        })
        .withFailureHandler(() => {
          removeLineItemFromDetail(tempId);
          updateInvoiceSummaryAndRender();
          setStatus('Failed to save line item', 'error');
        })
        .api_upsertInvoiceLineItem(payload);
    }
    resetInvoiceLineForm();
  }

  function handleInvoiceLineCancel(event) {
    if (event) event.preventDefault();
    resetInvoiceLineForm();
  }

  function handleInvoiceLineItemAction(event) {
    const button = event.target instanceof HTMLElement ? event.target.closest('button[data-action]') : null;
    if (!button) return;
    const action = button.dataset.action;
    const id = button.dataset.id;
    if (!action || !id) return;
    if (action === 'edit-line') {
      const lineItem = state.invoiceDetail && state.invoiceDetail.lineItems ? state.invoiceDetail.lineItems.find((item) => item.id === id) : null;
      if (!lineItem) return;
      openInvoiceLineForm('edit', lineItem);
    }
    if (action === 'delete-line') {
      handleInvoiceLineDelete(id);
    }
    if (action === 'default-line') {
      const lineItem = state.invoiceDetail && state.invoiceDetail.lineItems ? state.invoiceDetail.lineItems.find((item) => item.id === id) : null;
      if (lineItem) startDefaultFromLine(lineItem);
    }
    if (action === 'refresh-line') {
      handleInvoiceLineRefresh(id);
    }
  }

  async function handleInvoiceLineDelete(lineId) {
    if (!state.invoiceDetail) return;
    const lineItem = state.invoiceDetail.lineItems ? state.invoiceDetail.lineItems.find((item) => item.id === lineId) : null;
    if (!lineItem) return;
    const confirmed = await customConfirm('Delete this line item?', { danger: true, okText: 'Delete' });
    if (!confirmed) return;
    removeLineItemFromDetail(lineId);
    updateInvoiceSummaryAndRender();
    setStatus('Deleting line item...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success) {
          setStatus('Line item deleted', 'success');
        } else {
          mergeLineItemIntoDetail(lineItem);
          updateInvoiceSummaryAndRender();
          setStatus('Failed to delete line item', 'error');
        }
      })
      .withFailureHandler(() => {
        mergeLineItemIntoDetail(lineItem);
        updateInvoiceSummaryAndRender();
        setStatus('Failed to delete line item', 'error');
      })
      .api_deleteInvoiceLineItem(lineId, { preserveEntry: false });
  }

  function handleInvoiceLineRefresh(lineId) {
    if (!state.invoiceDetail) return;
    const lineItem = state.invoiceDetail.lineItems ? state.invoiceDetail.lineItems.find((item) => item.id === lineId) : null;
    if (!lineItem) return;
    setStatus('Refreshing entry status...', 'info');
    google.script.run
      .withSuccessHandler((updated) => {
        if (updated && updated.id) {
          mergeLineItemIntoDetail(updated);
          updateInvoiceSummaryAndRender();
          setStatus('Entry synced', 'success');
        } else {
          setStatus('Failed to refresh entry', 'error');
        }
      })
      .withFailureHandler(() => {
        setStatus('Failed to refresh entry', 'error');
      })
      .api_refreshInvoiceLineItemEntry(lineId);
  }

  function startDefaultFromLine(lineItem) {
    if (!lineItem) return;
    const draft = {
      default_label: lineItem.description || '',
      description: lineItem.description || '',
      hours: lineItem.hours != null ? Number(lineItem.hours) : '',
      amount: lineItem.amount != null && lineItem.amount !== '' ? Number(lineItem.amount) : '',
      hour_type_id: lineItem.hour_type_id || '',
      contract_id: lineItem.contract_id || ''
    };
    const amountMode = determineInvoiceDefaultAmountMode(draft);
    draft.hours = amountMode === 'hours' ? draft.hours : '';
    draft.amount = amountMode === 'amount' ? draft.amount : '';
    if (amountMode !== 'hours') {
      draft.hour_type_id = '';
    }
    state.invoiceDefaultForm = {
      mode: 'create',
      editingId: null,
      draft: draft,
      amountMode: amountMode
    };
    ensureInvoiceFormOptions();
    renderInvoiceDefaults();
    if (invoiceDefaultForm) {
      invoiceDefaultForm.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }

  function mergeLineItemIntoDetail(item) {
    if (!state.invoiceDetail) return;
    const list = state.invoiceDetail.lineItems || [];
    const idx = list.findIndex((existing) => existing.id === item.id);
    if (idx === -1) {
      list.push(Object.assign({}, item));
    } else {
      const merged = Object.assign({}, list[idx], item);
      if (!('entry_pending' in item) && Object.prototype.hasOwnProperty.call(merged, 'entry_pending')) {
        delete merged.entry_pending;
      }
      list[idx] = merged;
    }
    state.invoiceDetail.lineItems = list.slice().sort((a, b) => {
      const posA = Number(a.position || 0);
      const posB = Number(b.position || 0);
      if (posA !== posB) return posA - posB;
      return String(a.created_at || '').localeCompare(String(b.created_at || ''));
    });
  }

  function syncInvoiceSummaryToList() {
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) return;
    const invoiceId = state.invoiceDetail.invoice.id;
    if (!invoiceId) return;
    const summary = state.invoiceDetail.summary || summarizeInvoiceLineItems(state.invoiceDetail.lineItems || []);
    const idx = state.invoices.findIndex((inv) => inv.id === invoiceId);
    if (idx !== -1) {
      const updated = Object.assign({}, state.invoices[idx], { summary: summary });
      state.invoices[idx] = updated;
      state.invoiceMap[invoiceId] = updated;
    }
  }

  function removeLineItemFromDetail(lineId) {
    if (!state.invoiceDetail) return;
    state.invoiceDetail.lineItems = (state.invoiceDetail.lineItems || []).filter((item) => item.id !== lineId).sort((a, b) => {
      const posA = Number(a.position || 0);
      const posB = Number(b.position || 0);
      if (posA !== posB) return posA - posB;
      return String(a.created_at || '').localeCompare(String(b.created_at || ''));
    });
  }

  function insertDefaultLineIntoInvoice(defaultId) {
    if (!defaultId) return;
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) {
      setStatus('Select an invoice before adding a default line.', 'warn');
      return;
    }
    const def = state.invoiceDefaultMap[defaultId];
    if (!def) {
      setStatus('Default line not found', 'error');
      return;
    }
    openInvoiceLineForm('create', {
      line_date: state.invoiceDetail && state.invoiceDetail.invoice ? (state.invoiceDetail.invoice.invoice_date || todayIso()) : todayIso(),
      description: def.description || '',
      hours: def.hours != null && Number(def.hours) > 0 ? Number(def.hours) : '',
      amount: def.amount != null && def.amount !== '' ? def.amount : '',
      hour_type_id: def.hours != null && Number(def.hours) > 0 ? (def.hour_type_id || '') : '',
      contract_id: def.contract_id || '',
      source_default_id: def.id
    });
  }

  function handleInvoiceDefaultNew(event) {
    if (event) event.preventDefault();
    state.invoiceDefaultForm = {
      mode: 'create',
      editingId: null,
      draft: {
        default_label: '',
        description: '',
        hours: '',
        amount: '',
        hour_type_id: '',
        contract_id: ''
      },
      amountMode: 'hours'
    };
    ensureInvoiceFormOptions();
    renderInvoiceDefaults();
  }

  function handleInvoiceDefaultCancel(event) {
    if (event) event.preventDefault();
    state.invoiceDefaultForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: 'hours' };
    renderInvoiceDefaults();
  }

  function handleInvoiceDefaultSave(event) {
    if (event) event.preventDefault();
    if (!invoiceDefaultLabelInput) return;
    const label = invoiceDefaultLabelInput.value.trim();
    if (!label) {
      setStatus('Default label is required.', 'warn');
      return;
    }
    const description = invoiceDefaultDescriptionInput ? invoiceDefaultDescriptionInput.value : '';
    const amountMode = state.invoiceDefaultForm && state.invoiceDefaultForm.amountMode ? state.invoiceDefaultForm.amountMode : 'hours';
    const hoursValue = amountMode === 'hours' && invoiceDefaultHoursInput && invoiceDefaultHoursInput.value !== ''
      ? Number(invoiceDefaultHoursInput.value)
      : null;
    const amountValue = amountMode === 'amount' && invoiceDefaultAmountInput && invoiceDefaultAmountInput.value !== ''
      ? Number(invoiceDefaultAmountInput.value)
      : null;
    const hourTypeId = amountMode === 'hours' && invoiceDefaultHourTypeSelect ? invoiceDefaultHourTypeSelect.value : '';
    const hourTypeName = hourTypeId ? getHourTypeName(hourTypeId) : '';
    const contractId = invoiceDefaultContractSelect ? invoiceDefaultContractSelect.value : '';
    if (!contractId) {
      setStatus('Select a contract for this default line.', 'warn');
      return;
    }
    const contractRate = getContractRate(contractId);
    let resolvedHours = 0;
    let amount = null;
    if (amountMode === 'hours') {
      if (hoursValue == null || !Number.isFinite(hoursValue) || hoursValue <= 0) {
        setStatus('Enter hours to auto-calculate the amount.', 'warn');
        return;
      }
      if (!(contractRate > 0)) {
        setStatus('Contract rate missing. Enter an amount manually.', 'warn');
        return;
      }
      resolvedHours = Number(hoursValue);
      amount = Math.round(resolvedHours * contractRate * 100) / 100;
    } else {
      if (amountValue == null || !Number.isFinite(amountValue) || amountValue <= 0) {
        setStatus('Enter a valid amount for this default.', 'warn');
        return;
      }
      amount = Math.round(Number(amountValue) * 100) / 100;
    }
    if (amount == null || Number.isNaN(amount)) {
      setStatus('Enter a valid amount for this default.', 'warn');
      return;
    }
    const payload = {
      default_label: label,
      description: description,
      hours: amountMode === 'hours' ? resolvedHours : 0,
      amount: Number(amount),
      hour_type_id: amountMode === 'hours' ? (hourTypeId || '') : '',
      hour_type_name_snapshot: amountMode === 'hours' ? hourTypeName : '',
      contract_id: contractId || ''
    };
    const isEdit = state.invoiceDefaultForm.mode === 'edit' && state.invoiceDefaultForm.editingId;
    if (isEdit) payload.id = state.invoiceDefaultForm.editingId;
    const tempId = isEdit ? payload.id : generateTempId('invoice-default');
    const optimistic = Object.assign({}, payload, {
      id: tempId,
      hours: payload.hours === '' ? 0 : payload.hours,
      amount: payload.amount
    });
    if (!isEdit) {
      optimistic.position = state.invoiceDefaults.length + 1;
    }
    const previousDefaults = state.invoiceDefaults.slice();
    const previousDefaultForm = JSON.parse(JSON.stringify(state.invoiceDefaultForm));
    if (isEdit) {
      const idx = state.invoiceDefaults.findIndex((item) => item.id === payload.id);
      if (idx !== -1) state.invoiceDefaults[idx] = Object.assign({}, state.invoiceDefaults[idx], optimistic);
    } else {
      state.invoiceDefaults.push(optimistic);
    }
    state.invoiceDefaultMap[optimistic.id] = optimistic;
    state.invoiceDefaultForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: 'hours' };
    renderInvoiceDefaults();
    saveCache();
    setStatus('Saving default line...', 'warn');
    google.script.run
      .withSuccessHandler((saved) => {
        if (saved && saved.id) {
          state.invoiceDefaults = previousDefaults.filter((item) => item.id !== tempId && item.id !== saved.id).concat([saved]);
          state.invoiceDefaults.sort((a, b) => Number(a.position || 0) - Number(b.position || 0));
          state.invoiceDefaultMap = state.invoiceDefaults.reduce((acc, item) => {
            acc[item.id] = item;
            return acc;
          }, {});
          state.invoiceDefaultForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: 'hours' };
          renderInvoiceDefaults();
          setStatus('Default saved', 'success');
          saveCache();
          loadInvoiceDefaults();
        } else {
          state.invoiceDefaults = previousDefaults;
          state.invoiceDefaultMap = previousDefaults.reduce((acc, item) => {
            acc[item.id] = item;
            return acc;
          }, {});
          state.invoiceDefaultForm = previousDefaultForm;
          renderInvoiceDefaults();
          setStatus('Failed to save default', 'error');
          saveCache();
        }
      })
      .withFailureHandler(() => {
        state.invoiceDefaults = previousDefaults;
        state.invoiceDefaults.sort((a, b) => Number(a.position || 0) - Number(b.position || 0));
        state.invoiceDefaultMap = previousDefaults.reduce((acc, item) => {
          acc[item.id] = item;
          return acc;
        }, {});
        state.invoiceDefaultForm = previousDefaultForm;
        renderInvoiceDefaults();
        setStatus('Failed to save default', 'error');
        saveCache();
      })
      .api_upsertInvoiceDefaultLineItem(payload);
  }

  function handleInvoiceDefaultAction(event) {
    const button = event.target instanceof HTMLElement ? event.target.closest('button[data-action]') : null;
    if (!button) return;
    const action = button.dataset.action;
    const id = button.dataset.id;
    if (!action || !id) return;
    if (action === 'edit-default') {
      const def = state.invoiceDefaultMap[id];
      if (!def) return;
      const amountMode = determineInvoiceDefaultAmountMode(def);
      const hoursDraft = amountMode === 'hours' && def.hours != null ? def.hours : '';
      const amountDraft = amountMode === 'amount' && def.amount != null ? def.amount : '';
      state.invoiceDefaultForm = {
        mode: 'edit',
        editingId: id,
        draft: {
          id: id,
          default_label: def.default_label || '',
          description: def.description || '',
          hours: hoursDraft,
          amount: amountDraft,
          hour_type_id: amountMode === 'hours' ? (def.hour_type_id || '') : '',
          contract_id: def.contract_id || ''
        },
        amountMode: amountMode
      };
      ensureInvoiceFormOptions();
      renderInvoiceDefaults();
    }
    if (action === 'insert-default') {
      insertDefaultLineIntoInvoice(id);
    }
    if (action === 'delete-default') {
      deleteInvoiceDefault(id);
    }
  }

  async function deleteInvoiceDefault(id) {
    const def = state.invoiceDefaultMap[id];
    if (!def) return;
    const confirmed = await customConfirm(`Delete the "${def.default_label || 'default'}" line?`, { danger: true, okText: 'Delete' });
    if (!confirmed) return;
    const previousDefaults = state.invoiceDefaults.slice();
    state.invoiceDefaults = state.invoiceDefaults.filter((item) => item.id !== id);
    delete state.invoiceDefaultMap[id];
    renderInvoiceDefaults();
    saveCache();
    setStatus('Deleting default...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success) {
          setStatus('Default deleted', 'success');
          saveCache();
        } else {
          state.invoiceDefaults = previousDefaults;
          state.invoiceDefaults.sort((a, b) => Number(a.position || 0) - Number(b.position || 0));
          state.invoiceDefaultMap = previousDefaults.reduce((acc, item) => {
            acc[item.id] = item;
            return acc;
          }, {});
          renderInvoiceDefaults();
          setStatus('Failed to delete default', 'error');
          saveCache();
        }
      })
      .withFailureHandler(() => {
        state.invoiceDefaults = previousDefaults;
        state.invoiceDefaults.sort((a, b) => Number(a.position || 0) - Number(b.position || 0));
        state.invoiceDefaultMap = previousDefaults.reduce((acc, item) => {
          acc[item.id] = item;
          return acc;
        }, {});
        renderInvoiceDefaults();
        setStatus('Failed to delete default', 'error');
        saveCache();
      })
      .api_deleteInvoiceDefaultLineItem(id);
  }

  function updateInvoiceSummaryAndRender() {
    recalculateInvoiceSummary();
    syncInvoiceSummaryToList();
    renderInvoiceDetail();
    renderBasInvoiceTable();
    saveCache();
  }

  function handleInvoiceAddLine(event) {
    if (event) event.preventDefault();
    openInvoiceLineForm('create', {});
  }

  // Custom confirm dialog replacement
  function customConfirm(message, options) {
    return new Promise((resolve) => {
      const opts = options || {};
      const title = opts.title || 'Confirm';
      const okText = opts.okText || 'OK';
      const cancelText = opts.cancelText || 'Cancel';
      const isDanger = opts.danger || false;

      const modal = document.getElementById('modal-confirm');
      const titleEl = document.getElementById('confirm-title');
      const messageEl = document.getElementById('confirm-message');
      const okBtn = document.getElementById('btn-confirm-ok');
      const cancelBtn = document.getElementById('btn-confirm-cancel');

      if (!modal || !titleEl || !messageEl || !okBtn || !cancelBtn) {
        // Fallback to native confirm if modal not found
        resolve(confirm(message));
        return;
      }

      titleEl.textContent = title;
      messageEl.textContent = message;
      okBtn.textContent = okText;
      cancelBtn.textContent = cancelText;

      // Apply danger styling if requested
      if (isDanger) {
        okBtn.className = 'danger';
      } else {
        okBtn.className = '';
      }

      const handleOk = () => {
        cleanup();
        resolve(true);
      };

      const handleCancel = () => {
        cleanup();
        resolve(false);
      };

      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          handleCancel();
        } else if (e.key === 'Enter' && !isDanger) {
          // Only allow Enter to confirm if not a danger action
          handleOk();
        }
      };

      const cleanup = () => {
        okBtn.removeEventListener('click', handleOk);
        cancelBtn.removeEventListener('click', handleCancel);
        document.removeEventListener('keydown', handleEscape);
        hideModal(modal);
      };

      okBtn.addEventListener('click', handleOk);
      cancelBtn.addEventListener('click', handleCancel);
      document.addEventListener('keydown', handleEscape);

      showModal(modal);
      // Focus the appropriate button
      if (isDanger) {
        cancelBtn.focus();
      } else {
        okBtn.focus();
      }
    });
  }

  // Custom alert dialog replacement
  function customAlert(message, options) {
    return new Promise((resolve) => {
      const opts = options || {};
      const title = opts.title || 'Notice';
      const okText = opts.okText || 'OK';

      const modal = document.getElementById('modal-alert');
      const titleEl = document.getElementById('alert-title');
      const messageEl = document.getElementById('alert-message');
      const okBtn = document.getElementById('btn-alert-ok');

      if (!modal || !titleEl || !messageEl || !okBtn) {
        // Fallback to native alert if modal not found
        alert(message);
        resolve();
        return;
      }

      titleEl.textContent = title;
      messageEl.textContent = message;
      okBtn.textContent = okText;

      const handleOk = () => {
        cleanup();
        resolve();
      };

      const handleEscape = (e) => {
        if (e.key === 'Escape' || e.key === 'Enter') {
          handleOk();
        }
      };

      const cleanup = () => {
        okBtn.removeEventListener('click', handleOk);
        document.removeEventListener('keydown', handleEscape);
        hideModal(modal);
      };

      okBtn.addEventListener('click', handleOk);
      document.addEventListener('keydown', handleEscape);

      showModal(modal);
      okBtn.focus();
    });
  }

  // BAS Detail Modal
  let currentBasPeriod = { fyYear: null, quarter: null, month: null };

  async function copyToClipboard(text, element) {
    try {
      await navigator.clipboard.writeText(text);
      // Visual feedback
      if (element) {
        element.classList.add('copied');
        setTimeout(() => {
          element.classList.remove('copied');
        }, 300);
      }
      return true;
    } catch (err) {
      console.error('Failed to copy:', err);
      return false;
    }
  }

  function openBasDetailModal(fyYear, quarter, month) {
    currentBasPeriod = { fyYear, quarter, month };

    const modal = document.getElementById('modal-bas-detail');
    const titleEl = document.getElementById('bas-detail-title');

    const monthRows = buildMonthlyBasRows(fyYear);
    let periodData;
    let periodLabel;

    if (quarter) {
      // Quarterly BAS
      const quarterlyRows = buildQuarterlyBasRows(monthRows);
      periodData = quarterlyRows[quarter - 1];
      periodLabel = ['Q1 (JulâSep)', 'Q2 (OctâDec)', 'Q3 (JanâMar)', 'Q4 (AprâJun)'][quarter - 1];
    } else if (month !== null && month !== undefined) {
      // Monthly BAS
      periodData = monthRows.find(r => r.month === month);
      const date = new Date(periodData.year, month, 1);
      periodLabel = MONTH_YEAR_FORMATTER.format(date);
    }

    if (!periodData) {
      customAlert('Unable to load BAS data for this period.');
      return;
    }

    // Calculate BAS fields
    const g1TotalSales = periodData.invoiceTotal;
    const field1aGstOnSales = periodData.invoiceGst;
    const field1bGstOnPurchases = periodData.companyExpensesGst;

    // Get PAYG rate from settings (default 2%)
    const paygRate = Number(state.settings.payg_instalment_rate || 2) / 100;

    // Calculate T1 based on sole trader flag
    const isSoleTrader = getFeatureFlag('is_sole_trader');
    const t1PaygIncome = isSoleTrader
      ? periodData.employeeGrossIncome // For sole traders: gross income minus expenses
      : periodData.companyIncome; // For companies: company income

    const t2InstalmentRate = paygRate * 100; // Convert back to percentage for display

    // Update modal title
    if (titleEl) {
      titleEl.textContent = `BAS Details - FY ${fyYear}-${String(fyYear + 1).slice(-2)} ${periodLabel}`;
    }

    // Update field values
    const g1El = document.getElementById('bas-g1-value');
    const field1aEl = document.getElementById('bas-1a-value');
    const field1bEl = document.getElementById('bas-1b-value');
    const t1El = document.getElementById('bas-t1-value');
    const t2El = document.getElementById('bas-t2-value');

    if (g1El) g1El.textContent = formatCurrency(g1TotalSales);
    if (field1aEl) field1aEl.textContent = formatCurrency(field1aGstOnSales);
    if (field1bEl) field1bEl.textContent = formatCurrency(field1bGstOnPurchases);
    if (t1El) t1El.textContent = formatCurrency(t1PaygIncome);
    if (t2El) t2El.textContent = t2InstalmentRate.toFixed(2) + '%';

    // Load submission status
    const submission = state.basSubmissions.find(s => {
      if (s.financial_year !== fyYear) return false;
      if (quarter) {
        return s.period_type === 'quarterly' && s.quarter === quarter;
      } else {
        return s.period_type === 'monthly' && s.month === month;
      }
    });
    const submittedToggle = document.getElementById('bas-submitted-toggle');
    if (submittedToggle) {
      submittedToggle.checked = submission ? submission.submitted : false;
    }

    // Attach click-to-copy handlers
    attachBasFieldCopyHandlers();

    showModal(modal);
  }

  function attachBasFieldCopyHandlers() {
    const fields = document.querySelectorAll('.bas-field-value[data-field]');
    fields.forEach(field => {
      const handler = async () => {
        // Extract numeric value (remove $ and ,)
        const text = field.textContent.replace(/[$,]/g, '').trim();
        const success = await copyToClipboard(text, field);
        if (success) {
          // Optional: show a toast notification
          setStatus('Copied to clipboard', 'success');
        }
      };
      // Remove existing listeners to avoid duplicates
      field.replaceWith(field.cloneNode(true));
    });
    // Re-query and attach
    document.querySelectorAll('.bas-field-value[data-field]').forEach(field => {
      field.addEventListener('click', async () => {
        const text = field.textContent.replace(/[$,]/g, '').trim();
        const success = await copyToClipboard(text, field);
        if (success) {
          setStatus('Copied to clipboard', 'success');
        }
      });
    });
  }

  // BAS Detail Modal - Close and Save handlers
  const basDetailCloseBtn = document.getElementById('btn-bas-detail-close');
  const basDetailSaveBtn = document.getElementById('btn-bas-detail-save');

  if (basDetailCloseBtn) {
    basDetailCloseBtn.addEventListener('click', () => {
      const modal = document.getElementById('modal-bas-detail');
      hideModal(modal);
    });
  }

  if (basDetailSaveBtn) {
    basDetailSaveBtn.addEventListener('click', async () => {
      const submittedToggle = document.getElementById('bas-submitted-toggle');
      const submitted = submittedToggle ? submittedToggle.checked : false;

      const { fyYear, quarter, month } = currentBasPeriod;
      if (!fyYear) return;
      if (!quarter && (month === null || month === undefined)) return;

      // Calculate all fields
      const monthRows = buildMonthlyBasRows(fyYear);
      let periodData;

      if (quarter) {
        const quarterlyRows = buildQuarterlyBasRows(monthRows);
        periodData = quarterlyRows[quarter - 1];
      } else {
        periodData = monthRows.find(r => r.month === month);
      }

      if (!periodData) return;

      const paygRate = Number(state.settings.payg_instalment_rate || 2) / 100;
      const isSoleTrader = getFeatureFlag('is_sole_trader');

      const basData = {
        financial_year: fyYear,
        period_type: quarter ? 'quarterly' : 'monthly',
        quarter: quarter || null,
        month: month !== null && month !== undefined ? month : null,
        g1_total_sales: periodData.invoiceTotal,
        g1_includes_gst: true,
        field_1a_gst_on_sales: periodData.invoiceGst,
        field_1b_gst_on_purchases: periodData.companyExpensesGst,
        t1_payg_income: isSoleTrader ? periodData.employeeGrossIncome : periodData.companyIncome,
        t2_instalment_rate: paygRate,
        submitted: submitted
      };

      // Save to backend
      setStatus('Saving BAS submission...', 'warn');
      basDetailSaveBtn.disabled = true;
      basDetailSaveBtn.textContent = 'Saving...';

      google.script.run
        .withSuccessHandler((savedSubmission) => {
          // Update local state
          const index = state.basSubmissions.findIndex(s => {
            if (s.financial_year !== fyYear) return false;
            if (quarter) {
              return s.period_type === 'quarterly' && s.quarter === quarter;
            } else {
              return s.period_type === 'monthly' && s.month === month;
            }
          });
          if (index >= 0) {
            state.basSubmissions[index] = savedSubmission;
          } else {
            state.basSubmissions.push(savedSubmission);
          }
          saveCache();

          // Close modal and refresh BAS report
          const modal = document.getElementById('modal-bas-detail');
          hideModal(modal);
          renderBasReporting();
          setStatus('BAS submission saved', 'success');
          basDetailSaveBtn.disabled = false;
          basDetailSaveBtn.textContent = 'Save';
        })
        .withFailureHandler((error) => {
          console.error('Failed to save BAS submission:', error);
          customAlert('Failed to save BAS submission: ' + error.message, { title: 'Error' });
          basDetailSaveBtn.disabled = false;
          basDetailSaveBtn.textContent = 'Save';
          setStatus('Failed to save', 'error');
        })
        .api_upsertBasSubmission(basData);
    });
  }

  function getCurrentFormData(type) {
    if (type === 'basic') {
      const hours = Number(manualHoursInput ? manualHoursInput.value : '');
      return {
        duration_minutes: Math.round(hours * 60)
      };
    } else if (type === 'advanced') {
      const draft = state.punchDraft;
      if (!draft || !draft.punches) return { punches: [] };
      return {
        punches: draft.punches.filter(p => p.in && p.out) // Only include closed punches
      };
    }
    return null;
  }

  function applyDefaultToForm(defaultData, type) {
    if (type === 'basic') {
      const hours = (defaultData.duration_minutes || 0) / 60;
      if (manualHoursInput) manualHoursInput.value = hours > 0 ? hours.toString() : '';
      updateBasicSaveEnabled();
    } else if (type === 'advanced') {
      // Apply punches to advanced form
      ensurePunchDraft();
      if (state.punchDraft) {
        state.punchDraft.punches = [...(defaultData.punches || [])];
        setPunchDraftDirty();
        renderPunchDraft();
        updatePunchSummary();
      }
    }
  }

  function handleCreateDefault(type) {
    const formData = getCurrentFormData(type);
    if (!formData) {
      setStatus('Please enter some time data first', 'warn');
      return;
    }

    if (type === 'basic' && (!formData.duration_minutes || formData.duration_minutes <= 0)) {
      setStatus('Please enter a valid number of hours', 'warn');
      return;
    }

    if (type === 'advanced' && (!formData.punches || formData.punches.length === 0)) {
      setStatus('Please add some punch times first', 'warn');
      return;
    }

    state_defaults.currentDefaultType = type;
    state_defaults.currentFormData = formData;

    const nameInput = document.getElementById('default-name');
    if (nameInput) nameInput.value = '';
    showModal(createDefaultModal);
    if (nameInput) nameInput.focus();
  }

  function handleEnterDefault(type) {
    const defaults = state_defaults.entryDefaults[type] || [];

    if (defaults.length === 0) {
      setStatus('No defaults available', 'warn');
      return;
    }

    if (defaults.length === 1) {
      // Single default - apply directly and submit
      applyDefaultToForm(defaults[0], type);

      // Trigger the appropriate save handler
      setTimeout(() => {
        if (type === 'basic' && manualSaveBtn) {
          manualSaveBtn.click();
        } else if (type === 'advanced' && punchSaveBtn) {
          punchSaveBtn.click();
        }
      }, 100);
    } else {
      // Multiple defaults - show selection modal
      state_defaults.currentDefaultType = type;
      renderDefaultSelection(defaults);
      showModal(selectDefaultModal);
    }
  }

  function renderDefaultSelection(defaults) {
    const listEl = document.getElementById('default-selection-list');
    if (!listEl) return;

    listEl.innerHTML = '';
    defaults.forEach((defaultData, index) => {
      const item = document.createElement('div');
      item.className = 'ts-default-item';
      item.style.cssText = 'padding: 12px; margin: 8px 0; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; transition: background-color 0.2s;';

      const title = document.createElement('div');
      title.style.fontWeight = 'bold';
      title.textContent = defaultData.name;

      const details = document.createElement('div');
      details.style.fontSize = '0.9em';
      details.style.color = 'var(--text-secondary)';
      details.style.marginTop = '4px';

      if (state_defaults.currentDefaultType === 'basic') {
        const hours = (defaultData.duration_minutes || 0) / 60;
        details.textContent = `${hours} hours`;
      } else {
        const punchCount = (defaultData.punches || []).length;
        details.textContent = `${punchCount} punch ${punchCount === 1 ? 'range' : 'ranges'}`;
      }

      item.appendChild(title);
      item.appendChild(details);

      item.addEventListener('click', () => {
        applyDefaultToForm(defaultData, state_defaults.currentDefaultType);
        hideModal(selectDefaultModal);

        // Trigger the appropriate save handler
        setTimeout(() => {
          if (state_defaults.currentDefaultType === 'basic' && manualSaveBtn) {
            manualSaveBtn.click();
          } else if (state_defaults.currentDefaultType === 'advanced' && punchSaveBtn) {
            punchSaveBtn.click();
          }
        }, 100);
      });

      item.addEventListener('mouseenter', () => {
        item.style.backgroundColor = 'var(--hover-bg)';
      });

      item.addEventListener('mouseleave', () => {
        item.style.backgroundColor = '';
      });

      listEl.appendChild(item);
    });
  }

  function handleEditDefaults(type) {
    state_defaults.currentDefaultType = type;
    renderEditDefaultsList();
    showModal(editDefaultsModal);
  }

  function renderEditDefaultsList() {
    const listEl = document.getElementById('edit-defaults-list');
    if (!listEl) return;

    const defaults = state_defaults.entryDefaults[state_defaults.currentDefaultType] || [];

    listEl.innerHTML = '';

    if (defaults.length === 0) {
      listEl.innerHTML = '<div class="ts-note">No defaults created yet.</div>';
      return;
    }

    defaults.forEach((defaultData, index) => {
      const item = document.createElement('div');
      item.className = 'ts-edit-default-item';
      item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px; margin: 8px 0; border: 1px solid var(--border-color); border-radius: 4px;';

      const content = document.createElement('div');
      content.style.flex = '1';
      content.style.cursor = 'pointer';

      const title = document.createElement('div');
      title.style.fontWeight = 'bold';
      title.textContent = defaultData.name;

      const details = document.createElement('div');
      details.style.fontSize = '0.9em';
      details.style.color = 'var(--text-secondary)';
      details.style.marginTop = '4px';

      if (state_defaults.currentDefaultType === 'basic') {
        const hours = (defaultData.duration_minutes || 0) / 60;
        details.textContent = `${hours} hours`;
      } else {
        const punchCount = (defaultData.punches || []).length;
        details.textContent = `${punchCount} punch ${punchCount === 1 ? 'range' : 'ranges'}`;
      }

      content.appendChild(title);
      content.appendChild(details);

      content.addEventListener('click', () => {
        openEditDefaultDetails(defaultData);
      });

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.className = 'ghost';
      deleteBtn.style.marginLeft = '12px';
      deleteBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const confirmed = await customConfirm(`Delete the "${defaultData.name}" default?`, { danger: true });
        if (confirmed) {
          deleteEntryDefault(defaultData.name, deleteBtn);
        }
      });

      item.appendChild(content);
      item.appendChild(deleteBtn);
      listEl.appendChild(item);
    });
  }

  function openEditDefaultDetails(defaultData) {
    state_defaults.editingDefaultName = defaultData.name;

    const nameInput = document.getElementById('edit-default-name');
    if (nameInput) nameInput.value = defaultData.name;

    const formEl = document.getElementById('edit-default-form');
    if (!formEl) return;

    formEl.innerHTML = '';

    if (state_defaults.currentDefaultType === 'basic') {
      const hours = (defaultData.duration_minutes || 0) / 60;

      formEl.innerHTML = `
        <div class="ts-row">
          <div class="ts-col">
            <label>Total hours</label>
            <input type="number" id="edit-default-hours" min="0" step="0.01" value="${hours}" />
          </div>
        </div>
      `;
    } else {
      const punchesHtml = (defaultData.punches || []).map((punch, i) => `
        <div class="ts-row" style="margin-top: 8px;">
          <div class="ts-col">
            <label>Punch ${i + 1} In</label>
            <input type="time" id="edit-punch-${i}-in" value="${punch.in || ''}" />
          </div>
          <div class="ts-col">
            <label>Punch ${i + 1} Out</label>
            <input type="time" id="edit-punch-${i}-out" value="${punch.out || ''}" />
          </div>
          <div class="ts-col" style="display:flex; align-items:flex-end;">
            <button type="button" class="ghost" onclick="removePunchRow(${i})">Remove</button>
          </div>
        </div>
      `).join('');

      formEl.innerHTML = `
        <div id="edit-punch-rows">
          ${punchesHtml}
        </div>
        <div style="margin-top: 12px;">
          <button type="button" class="ghost" onclick="addEditPunchRow()">Add Punch Range</button>
        </div>
      `;
    }

    hideModal(editDefaultsModal);
    showModal(editDefaultDetailsModal);
  }

  // Global functions for punch editing (needed for onclick handlers)
  window.addEditPunchRow = function() {
    const container = document.getElementById('edit-punch-rows');
    if (!container) return;

    const existingRows = container.children.length;
    const newRow = document.createElement('div');
    newRow.className = 'ts-row';
    newRow.style.marginTop = '8px';
    newRow.innerHTML = `
      <div class="ts-col">
        <label>Punch ${existingRows + 1} In</label>
        <input type="time" id="edit-punch-${existingRows}-in" />
      </div>
      <div class="ts-col">
        <label>Punch ${existingRows + 1} Out</label>
        <input type="time" id="edit-punch-${existingRows}-out" />
      </div>
      <div class="ts-col" style="display:flex; align-items:flex-end;">
        <button type="button" class="ghost" onclick="removePunchRow(${existingRows})">Remove</button>
      </div>
    `;
    container.appendChild(newRow);
  };

  window.removePunchRow = function(index) {
    const container = document.getElementById('edit-punch-rows');
    if (!container || container.children.length <= 1) return;

    if (container.children[index]) {
      container.removeChild(container.children[index]);

      // Update labels and IDs
      Array.from(container.children).forEach((row, i) => {
        const labels = row.querySelectorAll('label');
        const inputs = row.querySelectorAll('input');
        const button = row.querySelector('button');

        if (labels[0]) labels[0].textContent = `Punch ${i + 1} In`;
        if (labels[1]) labels[1].textContent = `Punch ${i + 1} Out`;
        if (inputs[0]) inputs[0].id = `edit-punch-${i}-in`;
        if (inputs[1]) inputs[1].id = `edit-punch-${i}-out`;
        if (button) button.setAttribute('onclick', `removePunchRow(${i})`);
      });
    }
  };

  function saveDefaultFromModal() {
    const nameInput = document.getElementById('default-name');
    const name = nameInput ? nameInput.value.trim() : '';
    const saveBtn = document.getElementById('btn-save-default');

    if (!name) {
      setStatus('Please enter a name for the default', 'warn');
      return;
    }

    const type = state_defaults.currentDefaultType;
    const formData = state_defaults.currentFormData;

    if (!type || !formData) {
      setStatus('Invalid default data', 'error');
      return;
    }

    // Disable save button and show saving state
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }
    setStatus('Saving default...', 'warn');

    google.script.run
      .withSuccessHandler((result) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Default';
        }

        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          hideModal(createDefaultModal);
          setStatus(`Default "${name}" created`, 'success');
        } else {
          setStatus('Failed to create default', 'error');
        }
      })
      .withFailureHandler((error) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Default';
        }
        setStatus('Failed to create default: ' + error.message, 'error');
      })
      .api_saveEntryDefault(type, name, formData);
  }

  function saveDefaultDetails() {
    const nameInput = document.getElementById('edit-default-name');
    const newName = nameInput ? nameInput.value.trim() : '';

    if (!newName) {
      setStatus('Please enter a name for the default', 'warn');
      return;
    }

    const type = state_defaults.currentDefaultType;
    const oldName = state_defaults.editingDefaultName;

    let formData;
    if (type === 'basic') {
      const hoursInput = document.getElementById('edit-default-hours');
      const hours = Number(hoursInput ? hoursInput.value : '');

      if (!Number.isFinite(hours) || hours <= 0) {
        setStatus('Please enter valid hours', 'warn');
        return;
      }

      formData = {
        duration_minutes: Math.round(hours * 60)
      };
    } else {
      const container = document.getElementById('edit-punch-rows');
      if (!container) return;

      const punches = [];
      Array.from(container.children).forEach((row, i) => {
        const inInput = document.getElementById(`edit-punch-${i}-in`);
        const outInput = document.getElementById(`edit-punch-${i}-out`);
        const inTime = inInput ? inInput.value : '';
        const outTime = outInput ? outInput.value : '';

        if (inTime && outTime) {
          punches.push({ in: inTime, out: outTime });
        }
      });

      if (punches.length === 0) {
        setStatus('Please add at least one complete punch range', 'warn');
        return;
      }

      formData = { punches };
    }

    // Disable save button and show saving state
    const saveBtn = document.getElementById('btn-save-default-details');
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }
    setStatus('Updating default...', 'warn');

    google.script.run
      .withSuccessHandler((result) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Changes';
        }

        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          hideModal(editDefaultDetailsModal);
          setStatus(`Default "${newName}" updated`, 'success');
          // Refresh the edit list if still open
          if (editDefaultsModal && editDefaultsModal.style.display !== 'none') {
            renderEditDefaultsList();
            showModal(editDefaultsModal);
          }
        } else {
          setStatus('Failed to update default', 'error');
        }
      })
      .withFailureHandler((error) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Changes';
        }
        setStatus('Failed to update default: ' + error.message, 'error');
      })
      .api_updateEntryDefault(type, oldName, newName, formData);
  }

  function deleteEntryDefault(name, deleteBtn) {
    const type = state_defaults.currentDefaultType;

    // Disable delete button and show deleting state
    if (deleteBtn) {
      deleteBtn.disabled = true;
      deleteBtn.textContent = 'Deleting...';
    }
    setStatus('Deleting default...', 'warn');

    google.script.run
      .withSuccessHandler((result) => {
        // Re-enable delete button
        if (deleteBtn) {
          deleteBtn.disabled = false;
          deleteBtn.textContent = 'Delete';
        }

        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          renderEditDefaultsList();
          setStatus(`Default "${name}" deleted`, 'success');
        } else {
          setStatus('Failed to delete default', 'error');
        }
      })
      .withFailureHandler((error) => {
        // Re-enable delete button
        if (deleteBtn) {
          deleteBtn.disabled = false;
          deleteBtn.textContent = 'Delete';
        }
        setStatus('Failed to delete default: ' + error.message, 'error');
      })
      .api_deleteEntryDefault(type, name);
  }

  // Event handlers for default entry buttons
  if (createManualDefaultBtn) {
    createManualDefaultBtn.addEventListener('click', () => handleCreateDefault('basic'));
  }

  if (enterManualDefaultBtn) {
    enterManualDefaultBtn.addEventListener('click', () => handleEnterDefault('basic'));
  }

  if (editManualDefaultsBtn) {
    editManualDefaultsBtn.addEventListener('click', () => handleEditDefaults('basic'));
  }

  if (createPunchDefaultBtn) {
    createPunchDefaultBtn.addEventListener('click', () => handleCreateDefault('advanced'));
  }

  if (enterPunchDefaultBtn) {
    enterPunchDefaultBtn.addEventListener('click', () => handleEnterDefault('advanced'));
  }

  if (editPunchDefaultsBtn) {
    editPunchDefaultsBtn.addEventListener('click', () => handleEditDefaults('advanced'));
  }

  // Modal event handlers
  function setupModalHandlers() {
    // Close buttons
    document.querySelectorAll('.ts-modal-close').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const modal = e.target.closest('.ts-modal');
        if (modal === deductionFormModal) {
          closeDeductionForm();
        } else if (modal === actualIncomeModal) {
          closeActualIncomeModal();
        } else if (modal === printViewConfigModal) {
          closePrintViewConfigModal();
        } else {
          hideModal(modal);
        }
      });
    });

    // Click outside to close
    document.querySelectorAll('.ts-modal').forEach(modal => {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          if (modal === deductionFormModal) {
            closeDeductionForm();
          } else if (modal === actualIncomeModal) {
            closeActualIncomeModal();
          } else if (modal === printViewConfigModal) {
            closePrintViewConfigModal();
          } else {
            hideModal(modal);
          }
        }
      });
    });

    // Specific button handlers
    const cancelCreateBtn = document.getElementById('btn-cancel-create-default');
    if (cancelCreateBtn) {
      cancelCreateBtn.addEventListener('click', () => hideModal(createDefaultModal));
    }

    const closeXeroHelperBtn = document.getElementById('btn-close-xero-helper');
    if (closeXeroHelperBtn && xeroHelperModal) {
      closeXeroHelperBtn.addEventListener('click', () => hideModal(xeroHelperModal));
    }

    const closeMyobHelperBtn = document.getElementById('btn-close-myob-helper');
    if (closeMyobHelperBtn && myobHelperModal) {
      closeMyobHelperBtn.addEventListener('click', () => hideModal(myobHelperModal));
    }

    if (btnCloseMonthlyDeductions && modalMonthlyDeductions) {
      btnCloseMonthlyDeductions.addEventListener('click', () => hideModal(modalMonthlyDeductions));
    }

    if (btnCompanyExpensesDetails) {
      btnCompanyExpensesDetails.addEventListener('click', () => showMonthlyDeductionsModal('company'));
    }

    if (btnDeductionsDetails) {
      btnDeductionsDetails.addEventListener('click', () => showMonthlyDeductionsModal('personal'));
    }

    if (btnCancelAdjust && modalAdjustOccurrence) {
      btnCancelAdjust.addEventListener('click', () => hideModal(modalAdjustOccurrence));
    }

    if (btnSaveException) {
      btnSaveException.addEventListener('click', handleSaveException);
    }

    if (btnDeleteException) {
      btnDeleteException.addEventListener('click', handleDeleteException);
    }

    const saveDefaultBtn = document.getElementById('btn-save-default');
    if (saveDefaultBtn) {
      saveDefaultBtn.addEventListener('click', saveDefaultFromModal);
    }

    const cancelSelectBtn = document.getElementById('btn-cancel-select-default');
    if (cancelSelectBtn) {
      cancelSelectBtn.addEventListener('click', () => hideModal(selectDefaultModal));
    }

    const closeEditBtn = document.getElementById('btn-close-edit-defaults');
    if (closeEditBtn) {
      closeEditBtn.addEventListener('click', () => hideModal(editDefaultsModal));
    }

    const cancelEditDetailsBtn = document.getElementById('btn-cancel-edit-default-details');
    if (cancelEditDetailsBtn) {
      cancelEditDetailsBtn.addEventListener('click', () => {
        hideModal(editDefaultDetailsModal);
        if (editDefaultsModal) showModal(editDefaultsModal);
      });
    }

    const saveDetailsBtn = document.getElementById('btn-save-default-details');
    if (saveDetailsBtn) {
      saveDetailsBtn.addEventListener('click', saveDefaultDetails);
    }

    // Enter key handlers
    const defaultNameInput = document.getElementById('default-name');
    if (defaultNameInput) {
      defaultNameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          saveDefaultFromModal();
        }
      });
    }
  }

  setupModalHandlers();

  // Initialize default entries after all functions are defined
  updateDefaultButtonsVisibility();
  loadEntryDefaults();

  // Hour Types Management
  function generateRandomColor() {
    const colors = [
      '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16', '#22c55e',
      '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', '#3b82f6', '#6366f1',
      '#8b5cf6', '#a855f7', '#d946ef', '#ec4899', '#f43f5e'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  function loadHourTypes() {
    if (!state.featureFlags.hour_types) return;

    setStatus('Loading hour types...', 'warn');
    google.script.run
      .withSuccessHandler((hourTypes) => {
        state.hourTypes = Array.isArray(hourTypes) ? hourTypes.map(sanitizeHourType) : [];
        updateHourTypeMap();
        ensureInvoiceFormOptions();
        if (getFeatureFlag('enable_invoices')) {
          renderInvoiceDefaults();
          renderInvoiceDetail();
        }
        renderHourTypes();
        updateHourTypeFormVisibility();
        renderCalendarFilters();
        renderCalendar();
        saveCache();
        setStatus('Idle');
        maybeAutoPopulatePublicHolidayEntries();
      })
      .withFailureHandler((error) => {
        console.error('Failed to load hour types:', error);
        setStatus('Error loading hour types', 'error');
      })
      .api_getHourTypes();
  }

  function renderHourTypes() {
    const container = document.getElementById('hour-types-list');
    if (!container) return;

    if (state.hourTypes.length === 0) {
      container.innerHTML = '<div class="ts-note">No hour types configured. Click "Add Hour Type" to create your first one.</div>';
      return;
    }

    const html = state.hourTypes.map(hourType => {
      const badges = [];
      if (hourType.is_default) badges.push('<span class="ts-hour-type-badge default">Default</span>');
      if (hourType.contributes_to_income) badges.push('<span class="ts-hour-type-badge income">Income</span>');
      if (hourType.use_for_rate_calculation) badges.push('<span class="ts-hour-type-badge rate-calc">Rate calculation</span>');
      if (hourType.auto_populate_public_holidays) {
        const hoursValue = Number(hourType.auto_populate_hours) || 0;
        const hoursLabel = hoursValue % 1 === 0 ? hoursValue.toFixed(0) : hoursValue.toFixed(2).replace(/0$/, '');
        badges.push(`<span class="ts-hour-type-badge holiday">Public holiday auto (${hoursLabel}h)</span>`);
      }

      const isWork = hourType.slug === 'work';

      return `
        <div class="ts-hour-type-item ${isWork ? 'work' : ''}" data-id="${hourType.id}">
          <div class="ts-hour-type-color" style="background-color: ${hourType.color}"></div>
          <div class="ts-hour-type-info">
            <h4 class="ts-hour-type-name">${hourType.name}${isWork ? ' (Built-in)' : ''}</h4>
            <p class="ts-hour-type-details">Slug: ${hourType.slug}</p>
            <div class="ts-hour-type-badges">${badges.join('')}</div>
          </div>
          <div class="ts-hour-type-actions">
            <button class="ghost small" onclick="editHourType('${hourType.id}')">Edit</button>
            <button class="ghost small danger" onclick="deleteHourType('${hourType.id}')" ${isWork ? 'style="display:none;"' : ''}>Delete</button>
          </div>
        </div>
      `;
    }).join('');

    container.innerHTML = html;
  }

  function loadPublicHolidays(renderAfterLoad = false) {
    if (!state.featureFlags.enable_public_holidays || !state.featureFlags.enable_public_holidays.enabled) return;

    ensureCalendarState();
    const year = state.calendar.year;

    // Background sync with backend
    google.script.run
      .withSuccessHandler((holidays) => {
        const newHolidays = Array.isArray(holidays) ? holidays : [];
        // Only update and re-render if data actually changed
        const oldJson = JSON.stringify(state.publicHolidays);
        const newJson = JSON.stringify(newHolidays);

        if (oldJson !== newJson) {
          state.publicHolidays = newHolidays;
          updatePublicHolidayMap();
          saveCache();
          renderCalendar();
        } else if (renderAfterLoad) {
          renderCalendar();
        }
        maybeAutoPopulatePublicHolidayEntries();
      })
      .withFailureHandler((error) => {
        console.error('Failed to load public holidays:', error);
      })
      .api_getPublicHolidays({ year: year });
  }

  function updatePublicHolidayMap() {
    const map = {};
    state.publicHolidays.forEach(holiday => {
      const normalizedDate = normalizeHolidayDate(holiday.date);
      if (!normalizedDate) return;
      if (holiday.date !== normalizedDate) holiday.date = normalizedDate;
      map[normalizedDate] = holiday;
    });
    state.publicHolidayMap = map;
  }

  function maybeAutoPopulatePublicHolidayEntries() {
    if (state.isAutoPopulatingPublicHolidays) return;
    if (!state.entriesLoaded) return;
    const publicHolidayFeature = getFeatureFlag('enable_public_holidays');
    const hourTypesFeature = getFeatureFlag('hour_types');
    if (!publicHolidayFeature || !hourTypesFeature) return;
    if (!state.publicHolidays.length || !state.hourTypes.length) return;

    const eligibleHourTypes = state.hourTypes.filter(ht => ht.auto_populate_public_holidays && Number(ht.auto_populate_hours) > 0);
    if (!eligibleHourTypes.length) return;

    const entryKeys = new Set(state.entries.map(entry => `${entry.date}__${entry.hour_type_id || getDefaultHourTypeId()}`));

    const queue = [];
    state.publicHolidays.forEach(holiday => {
      const iso = normalizeHolidayDate(holiday.date);
      if (!iso) return;
      const dateObj = parseIsoDate(iso);
      if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) return;
      const day = dateObj.getDay();
      if (day === 0 || day === 6) return; // Skip weekends

      eligibleHourTypes.forEach(hourType => {
        if (hourType.requires_contract) return;
        const key = `${iso}__${hourType.id}`;
        if (entryKeys.has(key)) return;
        entryKeys.add(key);
        queue.push({
          date: iso,
          hourTypeId: hourType.id,
          hours: Number(hourType.auto_populate_hours) || 0
        });
      });
    });

    if (!queue.length) return;

    state.isAutoPopulatingPublicHolidays = true;
    processHolidayAutoPopulateQueue(queue, []);
  }

  function processHolidayAutoPopulateQueue(queue, createdEntries) {
    if (!queue.length) {
      if (createdEntries.length) {
        createdEntries.forEach(entry => {
          state.entries.push(entry);
        });
        saveCache();
        renderEntries();
        updateTabStates();
      }
      state.isAutoPopulatingPublicHolidays = false;
      return;
    }

    const next = queue.shift();
    const minutes = Math.round(next.hours * 60);
    if (!minutes || minutes <= 0) {
      processHolidayAutoPopulateQueue(queue, createdEntries);
      return;
    }

    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success && res.entry) {
          const sanitized = sanitizeEntry(res.entry);
          createdEntries.push(sanitized);
        }
        processHolidayAutoPopulateQueue(queue, createdEntries);
      })
      .withFailureHandler((error) => {
        processHolidayAutoPopulateQueue(queue, createdEntries);
      })
      .api_addEntry({
        date: next.date,
        duration_minutes: minutes,
        entry_type: 'basic',
        hour_type_id: next.hourTypeId,
        contract_id: ''
      });
  }

  function showHourTypeModal(hourType = null) {
    const modal = document.getElementById('modal-hour-type');
    const title = document.getElementById('hour-type-modal-title');
    const nameInput = document.getElementById('hour-type-name');
    const slugInput = document.getElementById('hour-type-slug');
    const colorInput = document.getElementById('hour-type-color');
    const contributesInput = document.getElementById('hour-type-contributes-income');
    const defaultInput = document.getElementById('hour-type-is-default');
    const rateCalcInput = document.getElementById('hour-type-use-for-rate-calc');

    if (!modal) return;

    state.editingHourTypeId = hourType ? hourType.id : null;
    const isWork = hourType && hourType.slug === 'work';
    const publicHolidayFlag = getFeatureFlag('enable_public_holidays');

    title.textContent = isWork ? 'Work Hour Type Settings' : (hourType ? 'Edit Hour Type' : 'Add Hour Type');
    nameInput.value = hourType ? hourType.name : '';
    slugInput.value = hourType ? hourType.slug : '';
    colorInput.value = hourType ? hourType.color : generateRandomColor();
    contributesInput.checked = hourType ? hourType.contributes_to_income : false;
    defaultInput.checked = hourType ? hourType.is_default : false;
    if (rateCalcInput) rateCalcInput.checked = hourType ? hourType.use_for_rate_calculation : false;

    if (hourTypeAutoHolidayToggle) {
      hourTypeAutoHolidayToggle.checked = hourType ? !!hourType.auto_populate_public_holidays : false;
      hourTypeAutoHolidayToggle.disabled = !publicHolidayFlag;
    }
    if (hourTypeAutoHolidayHoursInput) {
      const hoursValue = hourType && Number(hourType.auto_populate_hours) > 0 ? Number(hourType.auto_populate_hours) : 7.5;
      hourTypeAutoHolidayHoursInput.value = hoursValue;
    }
    if (hourTypeAutoHolidayRow) {
      hourTypeAutoHolidayRow.style.display = publicHolidayFlag ? 'flex' : 'none';
    }
    if (!publicHolidayFlag && hourTypeAutoHolidayHoursRow) {
      hourTypeAutoHolidayHoursRow.style.display = 'none';
    } else {
      syncHourTypeHolidayHoursVisibility();
    }

    // Disable editing core properties of work hour type
    nameInput.disabled = isWork;
    slugInput.disabled = isWork;
    contributesInput.disabled = isWork;

    // For work hour type, only allow changing default status and color
    if (isWork) {
      nameInput.style.opacity = '0.6';
      slugInput.style.opacity = '0.6';
      contributesInput.parentElement.style.opacity = '0.6';
    } else {
      nameInput.style.opacity = '1';
      slugInput.style.opacity = '1';
      contributesInput.parentElement.style.opacity = '1';
    }

    modal.style.display = 'flex';

    // Validate color when modal opens
    setTimeout(function() {
      if (typeof validateHourTypeColor === 'function') {
        validateHourTypeColor();
      }
    }, 50);
  }

  function hideHourTypeModal() {
    const modal = document.getElementById('modal-hour-type');
    if (modal) modal.style.display = 'none';
    state.editingHourTypeId = null;
  }

  function saveHourType() {
    const nameInput = document.getElementById('hour-type-name');
    const slugInput = document.getElementById('hour-type-slug');
    const colorInput = document.getElementById('hour-type-color');
    const contributesInput = document.getElementById('hour-type-contributes-income');
    const defaultInput = document.getElementById('hour-type-is-default');
    const rateCalcInput = document.getElementById('hour-type-use-for-rate-calc');
    const saveBtn = document.getElementById('btn-save-hour-type');

    const name = nameInput.value.trim();
    const slug = slugInput.value.trim().toLowerCase();
    const color = colorInput.value;
    const contributesToIncome = contributesInput.checked;
    const isDefault = defaultInput.checked;
    const useForRateCalc = rateCalcInput ? rateCalcInput.checked : false;

    if (!name || !slug) {
      customAlert('Name and slug are required');
      return;
    }

    // Check slug uniqueness
    const existingType = state.hourTypes.find(ht => ht.slug === slug && ht.id !== state.editingHourTypeId);
    if (existingType) {
      customAlert('A hour type with this slug already exists');
      return;
    }

    const publicHolidayFeatureEnabled = getFeatureFlag('enable_public_holidays');
    const autoPopulateHolidays = publicHolidayFeatureEnabled && hourTypeAutoHolidayToggle && hourTypeAutoHolidayToggle.checked;
    let autoHolidayHours = hourTypeAutoHolidayHoursInput ? parseFloat(hourTypeAutoHolidayHoursInput.value) : 7.5;
    if (Number.isNaN(autoHolidayHours) || autoHolidayHours < 0) autoHolidayHours = 0;
    if (autoPopulateHolidays && autoHolidayHours <= 0) {
      customAlert('Please enter a positive number of hours to apply on public holidays.');
      return;
    }

    saveBtn.textContent = 'Saving...';
    saveBtn.disabled = true;

    const data = {
      name,
      slug,
      color,
      contributes_to_income: contributesToIncome,
      is_default: isDefault,
      use_for_rate_calculation: useForRateCalc,
      auto_populate_public_holidays: autoPopulateHolidays,
      auto_populate_hours: autoPopulateHolidays ? autoHolidayHours : 0
    };

    if (state.editingHourTypeId) {
      // Optimistically update the UI if setting as default or use_for_rate_calculation
      if (isDefault || useForRateCalc) {
        // Unset default on all other hour types if setting as default
        if (isDefault) {
          state.hourTypes.forEach(ht => {
            if (ht.id !== state.editingHourTypeId) {
              ht.is_default = false;
            }
          });
        }
        // Unset use_for_rate_calculation on all other hour types if setting this flag
        if (useForRateCalc) {
          state.hourTypes.forEach(ht => {
            if (ht.id !== state.editingHourTypeId) {
              ht.use_for_rate_calculation = false;
            }
          });
        }
        // Update this hour type
        const index = state.hourTypes.findIndex(ht => ht.id === state.editingHourTypeId);
        if (index !== -1) {
          state.hourTypes[index] = {
            ...state.hourTypes[index],
            name,
            slug,
            color,
            contributes_to_income: contributesToIncome,
            is_default: isDefault,
            use_for_rate_calculation: useForRateCalc,
            auto_populate_public_holidays: autoPopulateHolidays,
            auto_populate_hours: autoPopulateHolidays ? autoHolidayHours : 0
          };
        }
        updateHourTypeMap();
        renderHourTypes();
      }

      // Update existing
      google.script.run
        .withSuccessHandler((result) => {
          const index = state.hourTypes.findIndex(ht => ht.id === state.editingHourTypeId);
          if (index !== -1) {
            state.hourTypes[index] = sanitizeHourType(result);
          }
          updateHourTypeMap();
          renderHourTypes();
          updateHourTypeFormVisibility();
          renderCalendarFilters();
          renderCalendar();
          saveCache();
          maybeAutoPopulatePublicHolidayEntries();
          hideHourTypeModal();
          setStatus('Hour type updated');
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .withFailureHandler((error) => {
          console.error('Failed to update hour type:', error);
          customAlert('Failed to update hour type: ' + error.message, { title: 'Error' });
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
          // Reload hour types to revert optimistic update
          loadHourTypes();
        })
        .api_updateHourType(state.editingHourTypeId, data);
    } else {
      // Create new
      google.script.run
        .withSuccessHandler((result) => {
          const newHourType = sanitizeHourType(result);
          state.hourTypes.push(newHourType);

          // Add new hour type to calendar filter so it's immediately visible
          if (state.calendarFilteredHourTypes) {
            state.calendarFilteredHourTypes.push(newHourType.id);
          }

          updateHourTypeMap();
          renderHourTypes();
          updateHourTypeFormVisibility();
          renderCalendarFilters();
          renderCalendar();
          saveCache();
          maybeAutoPopulatePublicHolidayEntries();
          hideHourTypeModal();
          setStatus('Hour type created');
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .withFailureHandler((error) => {
          console.error('Failed to create hour type:', error);
          customAlert('Failed to create hour type: ' + error.message, { title: 'Error' });
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .api_createHourType(data);
    }
  }

  function editHourType(id) {
    const hourType = state.hourTypes.find(ht => ht.id === id);
    if (hourType) {
      showHourTypeModal(hourType);
    }
  }

  function deleteHourType(id) {
    const hourType = state.hourTypes.find(ht => ht.id === id);
    if (!hourType) return;

    const modal = document.getElementById('modal-delete-hour-type');
    const nameSpan = document.getElementById('delete-hour-type-name');

    if (!modal || !nameSpan) return;

    nameSpan.textContent = hourType.name;
    modal.style.display = 'flex';

    // Store the ID for the confirm handler
    modal.dataset.hourTypeId = id;
  }

  function confirmDeleteHourType() {
    const modal = document.getElementById('modal-delete-hour-type');
    const confirmBtn = document.getElementById('btn-confirm-delete-hour-type');
    const id = modal.dataset.hourTypeId;

    if (!id) return;

    confirmBtn.textContent = 'Deleting...';
    confirmBtn.disabled = true;

    google.script.run
      .withSuccessHandler(() => {
        state.hourTypes = state.hourTypes.filter(ht => ht.id !== id);

        // Remove from calendar filter
        if (state.calendarFilteredHourTypes) {
          state.calendarFilteredHourTypes = state.calendarFilteredHourTypes.filter(htId => htId !== id);
        }

        updateHourTypeMap();
        renderHourTypes();
        updateHourTypeFormVisibility();
        renderCalendarFilters();
        renderCalendar();
        saveCache();
        modal.style.display = 'none';
        setStatus('Hour type deleted');
        confirmBtn.textContent = 'Delete Hour Type';
        confirmBtn.disabled = false;
      })
      .withFailureHandler((error) => {
        console.error('Failed to delete hour type:', error);
        customAlert('Failed to delete hour type: ' + error.message, { title: 'Error' });
        confirmBtn.textContent = 'Delete Hour Type';
        confirmBtn.disabled = false;
      })
      .api_deleteHourType(id);
  }

  // Hour Types Event Listeners
  const btnAddHourType = document.getElementById('btn-add-hour-type');
  const btnSaveHourType = document.getElementById('btn-save-hour-type');
  const btnCancelHourType = document.getElementById('btn-cancel-hour-type');
  const btnConfirmDeleteHourType = document.getElementById('btn-confirm-delete-hour-type');
  const btnCancelDeleteHourType = document.getElementById('btn-cancel-delete-hour-type');

  if (btnAddHourType) {
    btnAddHourType.addEventListener('click', () => showHourTypeModal());
  }

  if (btnSaveHourType) {
    btnSaveHourType.addEventListener('click', saveHourType);
  }

  if (btnCancelHourType) {
    btnCancelHourType.addEventListener('click', hideHourTypeModal);
  }

  if (btnConfirmDeleteHourType) {
    btnConfirmDeleteHourType.addEventListener('click', confirmDeleteHourType);
  }

  if (btnCancelDeleteHourType) {
    btnCancelDeleteHourType.addEventListener('click', () => {
      document.getElementById('modal-delete-hour-type').style.display = 'none';
    });
  }

  // Custom Theme Event Listeners
  const btnConfigureTheme = document.getElementById('btn-configure-theme');
  const btnSaveCustomTheme = document.getElementById('btn-save-custom-theme');
  const btnCancelCustomTheme = document.getElementById('btn-cancel-custom-theme');
  const modalCustomTheme = document.getElementById('modal-custom-theme');
  const customThemeInputs = {
    bg: document.getElementById('custom-theme-bg'),
    panel: document.getElementById('custom-theme-panel'),
    primary: document.getElementById('custom-theme-primary'),
    success: document.getElementById('custom-theme-success'),
    warning: document.getElementById('custom-theme-warning'),
    danger: document.getElementById('custom-theme-danger'),
    text: document.getElementById('custom-theme-text'),
    muted: document.getElementById('custom-theme-muted')
  };
  const customThemePreview = document.getElementById('custom-theme-preview');
  const customThemeValidation = document.getElementById('custom-theme-validation');

  function readCustomThemeInputs() {
    return {
      bg: customThemeInputs.bg ? customThemeInputs.bg.value : CUSTOM_THEME_DEFAULTS.bg,
      panel: customThemeInputs.panel ? customThemeInputs.panel.value : '',
      primary: customThemeInputs.primary ? customThemeInputs.primary.value : '',
      success: customThemeInputs.success ? customThemeInputs.success.value : '',
      warning: customThemeInputs.warning ? customThemeInputs.warning.value : '',
      danger: customThemeInputs.danger ? customThemeInputs.danger.value : '',
      text: customThemeInputs.text ? customThemeInputs.text.value : '',
      muted: customThemeInputs.muted ? customThemeInputs.muted.value : ''
    };
  }

  function validateCustomThemeConfig(config) {
    var normalized = normalizeCustomThemeConfig(config);
    var issues = [];

    var bgContrast = getContrastRatio(normalized.bg, normalized.text);
    if (bgContrast < 4.5) {
      issues.push({
        level: 'error',
        message: 'Background and text contrast is ' + formatContrast(bgContrast) + ':1 (needs 4.5:1).'
      });
    }

    var panelContrast = getContrastRatio(normalized.panel, normalized.text);
    if (panelContrast < 4.5) {
      issues.push({
        level: 'error',
        message: 'Surface and text contrast is ' + formatContrast(panelContrast) + ':1 (needs 4.5:1).'
      });
    }

    var primaryContrast = getContrastRatio(normalized.primary, '#ffffff');
    if (primaryContrast < 4.5) {
      issues.push({
        level: primaryContrast < 3 ? 'error' : 'warning',
        message: 'Primary buttons contrast with white text is ' + formatContrast(primaryContrast) + ':1.'
      });
    }

    var successContrast = getContrastRatio(normalized.success, normalized.panel);
    if (successContrast < 3) {
      issues.push({
        level: 'warning',
        message: 'Success text on surfaces may be low contrast (' + formatContrast(successContrast) + ':1).'
      });
    }

    var warningContrast = getContrastRatio(normalized.warning, normalized.panel);
    if (warningContrast < 3) {
      issues.push({
        level: 'warning',
        message: 'Warning text on surfaces may be low contrast (' + formatContrast(warningContrast) + ':1).'
      });
    }

    var dangerContrast = getContrastRatio(normalized.danger, normalized.panel);
    if (dangerContrast < 3) {
      issues.push({
        level: 'warning',
        message: 'Danger text on surfaces may be low contrast (' + formatContrast(dangerContrast) + ':1).'
      });
    }

    return {
      normalized,
      issues,
      hasErrors: issues.some(function(issue) { return issue.level === 'error'; })
    };
  }

  function renderCustomThemeValidation(validation) {
    if (!customThemeValidation) return;
    if (!validation.issues.length) {
      customThemeValidation.style.display = 'none';
      customThemeValidation.textContent = '';
      return;
    }

    customThemeValidation.style.display = 'block';
    customThemeValidation.style.color = validation.hasErrors ? 'var(--danger)' : 'var(--warning)';
    customThemeValidation.innerHTML = validation.issues.map(function(issue) {
      return issue.message;
    }).join('<br/>');
  }

  function updateCustomThemePreview() {
    var inputConfig = readCustomThemeInputs();
    var validation = validateCustomThemeConfig(inputConfig);

    if (customThemePreview) {
      var themeVars = generateCustomTheme(validation.normalized);
      Object.keys(themeVars).forEach(function(token) {
        customThemePreview.style.setProperty(token, themeVars[token]);
      });
    }

    renderCustomThemeValidation(validation);

    if (btnSaveCustomTheme) {
      btnSaveCustomTheme.disabled = validation.hasErrors;
    }

    return validation;
  }

  function showCustomThemeModal() {
    if (!modalCustomTheme) return;

    var config = normalizeCustomThemeConfig(state.settings.custom_theme_config);

    Object.keys(customThemeInputs).forEach(function(key) {
      var input = customThemeInputs[key];
      if (input && config[key]) {
        input.value = config[key];
      } else if (input && CUSTOM_THEME_DEFAULTS[key]) {
        input.value = CUSTOM_THEME_DEFAULTS[key];
      }
    });

    if (btnSaveCustomTheme) {
      btnSaveCustomTheme.disabled = false;
    }

    updateCustomThemePreview();
    modalCustomTheme.style.display = 'flex';
  }

  function hideCustomThemeModal() {
    if (modalCustomTheme) {
      modalCustomTheme.style.display = 'none';
    }
    if (btnSaveCustomTheme) {
      btnSaveCustomTheme.disabled = false;
    }
  }

  function saveCustomTheme() {
    var validation = updateCustomThemePreview() || { normalized: readCustomThemeInputs(), hasErrors: false };
    if (validation.hasErrors) {
      showNotification('Fix the highlighted contrast issues before saving.', 'danger');
      return;
    }

    var normalized = validation.normalized;
    state.settings.custom_theme_config = normalized;
    applyCustomTheme();

    google.script.run
      .withSuccessHandler(function() {
        showNotification('Custom theme saved successfully', 'success');
        hideCustomThemeModal();
      })
      .withFailureHandler(function(error) {
        showNotification('Failed to save custom theme: ' + error.message, 'danger');
      })
      .api_updateSettings({
        custom_theme_config: JSON.stringify(normalized)
      });
  }

  if (btnConfigureTheme) {
    btnConfigureTheme.addEventListener('click', showCustomThemeModal);
  }

  if (btnSaveCustomTheme) {
    btnSaveCustomTheme.addEventListener('click', saveCustomTheme);
  }

  if (btnCancelCustomTheme) {
    btnCancelCustomTheme.addEventListener('click', hideCustomThemeModal);
  }

  Object.keys(customThemeInputs).forEach(function(key) {
    var input = customThemeInputs[key];
    if (input) {
      input.addEventListener('input', updateCustomThemePreview);
    }
  });

  if (modalCustomTheme) {
    modalCustomTheme.addEventListener('click', function(e) {
      if (e.target === modalCustomTheme) {
        hideCustomThemeModal();
      }
    });

    const closeBtn = modalCustomTheme.querySelector('.ts-modal-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', hideCustomThemeModal);
    }
  }

  // Super Guarantee Rates Modal
  const btnSuperGuaranteeRates = document.getElementById('btn-super-guarantee-rates');
  const btnSaveSuperRates = document.getElementById('btn-save-super-rates');
  const btnCancelSuperRates = document.getElementById('btn-cancel-super-rates');
  const btnAddSuperRate = document.getElementById('btn-add-super-rate');
  const modalSuperGuaranteeRates = document.getElementById('modal-super-guarantee-rates');
  const superRatesList = document.getElementById('super-rates-list');

  let superRatesWorkingCopy = [];

  function loadSuperGuaranteeRates() {
    google.script.run
      .withSuccessHandler(function(rates) {
        superRatesWorkingCopy = JSON.parse(JSON.stringify(rates || []));
        cacheSuperGuaranteeRates(rates);
        renderSuperRatesList();
      })
      .withFailureHandler(function(error) {
        showNotification('Failed to load super guarantee rates: ' + error.message, 'danger');
      })
      .api_getSuperGuaranteeRates();
  }

  function detectOverlappingRates(rates) {
    const overlapping = new Set();
    for (let i = 0; i < rates.length; i++) {
      for (let j = i + 1; j < rates.length; j++) {
        const rate1 = rates[i];
        const rate2 = rates[j];
        const start1 = rate1.start_date;
        const end1 = rate1.end_date || '9999-12-31';
        const start2 = rate2.start_date;
        const end2 = rate2.end_date || '9999-12-31';

        // Check if date ranges overlap
        if (start1 <= end2 && start2 <= end1) {
          overlapping.add(i);
          overlapping.add(j);
        }
      }
    }
    return overlapping;
  }

  function renderSuperRatesList() {
    if (!superRatesList) return;

    // Sort by start date descending (most recent first)
    const sorted = [...superRatesWorkingCopy].sort((a, b) => {
      return (b.start_date || '').localeCompare(a.start_date || '');
    });

    const overlapping = detectOverlappingRates(sorted);
    const noEndDateCount = sorted.filter(r => !r.end_date).length;

    superRatesList.innerHTML = '';

    sorted.forEach((rate, index) => {
      const hasOverlap = overlapping.has(index);
      const rateDiv = document.createElement('div');
      rateDiv.style.cssText = 'display:grid; grid-template-columns: auto 1fr 1fr 1fr auto; gap:8px; align-items:center; padding:8px; border:1px solid var(--border-color); border-radius:4px;';

      // Warning icon
      const warnIcon = document.createElement('span');
      if (hasOverlap) {
        warnIcon.textContent = 'â ï¸';
        warnIcon.title = 'This rate overlaps with another rate';
        warnIcon.style.cursor = 'help';
      }
      rateDiv.appendChild(warnIcon);

      // Start date
      const startInput = document.createElement('input');
      startInput.type = 'date';
      startInput.value = rate.start_date || '';
      startInput.style.cssText = 'padding:4px;';
      startInput.addEventListener('change', function() {
        rate.start_date = this.value;
        renderSuperRatesList(); // Re-render to update overlaps and sorting
      });
      rateDiv.appendChild(startInput);

      // End date
      const endInput = document.createElement('input');
      endInput.type = 'date';
      endInput.value = rate.end_date || '';
      endInput.placeholder = 'No end date';
      endInput.style.cssText = 'padding:4px;';
      endInput.addEventListener('change', function() {
        rate.end_date = this.value || null;
        renderSuperRatesList(); // Re-render to check if multiple rates have no end date
      });
      rateDiv.appendChild(endInput);

      // Percentage
      const percentInput = document.createElement('input');
      percentInput.type = 'number';
      percentInput.value = rate.percentage ? rate.percentage.toFixed(2) : '';
      percentInput.placeholder = '12.00';
      percentInput.step = '0.01';
      percentInput.min = '0';
      percentInput.style.cssText = 'padding:4px;';
      percentInput.addEventListener('change', function() {
        const val = parseFloat(this.value) || 0;
        rate.percentage = parseFloat(val.toFixed(2));
        this.value = rate.percentage.toFixed(2);
      });
      rateDiv.appendChild(percentInput);

      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.className = 'ghost';
      deleteBtn.style.cssText = 'padding:4px 8px; white-space:nowrap;';
      deleteBtn.addEventListener('click', function() {
        superRatesWorkingCopy = superRatesWorkingCopy.filter(r => r !== rate);
        renderSuperRatesList();
      });
      rateDiv.appendChild(deleteBtn);

      superRatesList.appendChild(rateDiv);
    });

    // Show warning if multiple rates have no end date
    if (noEndDateCount > 1) {
      const warningDiv = document.createElement('div');
      warningDiv.style.cssText = 'padding:8px; background:var(--danger-bg); color:var(--danger-text); border-radius:4px; margin-top:8px;';
      warningDiv.textContent = `â ï¸ Warning: ${noEndDateCount} rates have no end date. Only one rate should be open-ended (the current rate).`;
      superRatesList.appendChild(warningDiv);
    }
  }

  function showSuperGuaranteeRatesModal() {
    if (!modalSuperGuaranteeRates) return;

    // Load rates (from cache first, then server)
    const cached = getCachedSuperGuaranteeRates();
    if (cached) {
      superRatesWorkingCopy = JSON.parse(JSON.stringify(cached));
      renderSuperRatesList();
    }

    loadSuperGuaranteeRates();
    modalSuperGuaranteeRates.style.display = 'flex';
  }

  function hideSuperGuaranteeRatesModal() {
    if (modalSuperGuaranteeRates) {
      modalSuperGuaranteeRates.style.display = 'none';
    }
  }

  function saveSuperGuaranteeRates() {
    // Validate rates
    for (const rate of superRatesWorkingCopy) {
      if (!rate.start_date) {
        showNotification('All rates must have a start date', 'danger');
        return;
      }
      if (typeof rate.percentage !== 'number' || rate.percentage < 0) {
        showNotification('All rates must have a valid percentage', 'danger');
        return;
      }
    }

    btnSaveSuperRates.disabled = true;
    btnSaveSuperRates.textContent = 'Saving...';

    google.script.run
      .withSuccessHandler(function(response) {
        btnSaveSuperRates.disabled = false;
        btnSaveSuperRates.textContent = 'Save Rates';
        showNotification('Super guarantee rates saved successfully', 'success');
        cacheSuperGuaranteeRates(response.rates);
        hideSuperGuaranteeRatesModal();
      })
      .withFailureHandler(function(error) {
        btnSaveSuperRates.disabled = false;
        btnSaveSuperRates.textContent = 'Save Rates';
        showNotification('Failed to save super guarantee rates: ' + error.message, 'danger');
      })
      .api_setSuperGuaranteeRates(superRatesWorkingCopy);
  }

  function addNewSuperRate() {
    const today = new Date().toISOString().substring(0, 10);
    const newRate = {
      start_date: today,
      end_date: null,
      percentage: 12.00
    };
    superRatesWorkingCopy.push(newRate);
    renderSuperRatesList();
  }

  if (btnSuperGuaranteeRates) {
    btnSuperGuaranteeRates.addEventListener('click', showSuperGuaranteeRatesModal);
  }

  if (btnAddSuperRate) {
    btnAddSuperRate.addEventListener('click', addNewSuperRate);
  }

  if (btnSaveSuperRates) {
    btnSaveSuperRates.addEventListener('click', saveSuperGuaranteeRates);
  }

  if (btnCancelSuperRates) {
    btnCancelSuperRates.addEventListener('click', hideSuperGuaranteeRatesModal);
  }

  // Close modal when clicking outside
  if (modalSuperGuaranteeRates) {
    modalSuperGuaranteeRates.addEventListener('click', function(e) {
      if (e.target === modalSuperGuaranteeRates) {
        hideSuperGuaranteeRatesModal();
      }
    });

    // Close modal on X button
    const closeBtnSuper = modalSuperGuaranteeRates.querySelector('.ts-modal-close');
    if (closeBtnSuper) {
      closeBtnSuper.addEventListener('click', hideSuperGuaranteeRatesModal);
    }
  }

  // Auto-generate slug from name
  const hourTypeNameInput = document.getElementById('hour-type-name');
  const hourTypeSlugInput = document.getElementById('hour-type-slug');
  const hourTypeAutoHolidayRow = document.getElementById('hour-type-holiday-toggle-row');
  const hourTypeAutoHolidayHoursRow = document.getElementById('hour-type-holiday-hours-row');
  const hourTypeAutoHolidayToggle = document.getElementById('hour-type-auto-public-holidays');
  const hourTypeAutoHolidayHoursInput = document.getElementById('hour-type-holiday-hours');

  function syncHourTypeHolidayHoursVisibility() {
    if (!hourTypeAutoHolidayHoursRow) return;
    const shouldShow = hourTypeAutoHolidayToggle && hourTypeAutoHolidayToggle.checked;
    hourTypeAutoHolidayHoursRow.style.display = shouldShow ? 'flex' : 'none';
  }

  if (hourTypeNameInput && hourTypeSlugInput) {
    hourTypeNameInput.addEventListener('input', () => {
      if (!state.editingHourTypeId) { // Only auto-generate for new hour types
        const slug = hourTypeNameInput.value
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .replace(/^-|-$/g, '');
        hourTypeSlugInput.value = slug;
      }
    });
  }

  if (hourTypeAutoHolidayToggle) {
    hourTypeAutoHolidayToggle.addEventListener('change', syncHourTypeHolidayHoursVisibility);
  }

  // Colorblind color validation
  function isColorProblematicForColorblindness(hexColor) {
    // Convert hex to RGB
    var r = parseInt(hexColor.substr(1, 2), 16);
    var g = parseInt(hexColor.substr(3, 2), 16);
    var b = parseInt(hexColor.substr(5, 2), 16);

    // Problematic colors for colorblindness are typically:
    // 1. Pure or near-pure reds (high R, low G and B)
    // 2. Pure or near-pure greens (high G, low R and B)
    // 3. Red-green combinations or similar values for R and G with low B
    // 4. Browns and muddy colors (R and G similar, relatively low B)

    var maxComponent = Math.max(r, g, b);
    var minComponent = Math.min(r, g, b);
    var range = maxComponent - minComponent;

    // Pure or near-pure red
    if (r > 150 && g < 100 && b < 100) return true;

    // Pure or near-pure green
    if (g > 150 && r < 100 && b < 100) return true;

    // Red-green similar with low blue (brown/muddy colors)
    if (Math.abs(r - g) < 50 && r > 80 && g > 80 && b < 100) return true;

    // Low saturation colors in the red-green range
    if (range < 60 && r > 60 && g > 60 && Math.abs(r - g) < 40) return true;

    return false;
  }

  function validateHourTypeColor() {
    var colorblindFlag = state.featureFlags.enable_colorblind_themes || DEFAULT_FEATURE_FLAGS.enable_colorblind_themes || { enabled: false };
    if (!colorblindFlag.enabled) return;

    var colorInput = document.getElementById('hour-type-color');
    var warningEl = document.getElementById('hour-type-color-warning');

    if (!colorInput || !warningEl) return;

    var color = colorInput.value;
    var isProblematic = isColorProblematicForColorblindness(color);

    warningEl.style.display = isProblematic ? 'flex' : 'none';
  }

  var hourTypeColorInput = document.getElementById('hour-type-color');
  if (hourTypeColorInput) {
    hourTypeColorInput.addEventListener('input', validateHourTypeColor);
    hourTypeColorInput.addEventListener('change', validateHourTypeColor);
  }

  // Close modals when clicking close button or outside
  document.addEventListener('click', (event) => {
    if (event.target.classList.contains('ts-modal-close')) {
      const modal = event.target.closest('.ts-modal');
      if (modal) {
        modal.style.display = 'none';
        if (modal === modalDeductionCategories) hideDeductionCategoryForm();
      }
    }
    if (event.target.classList.contains('ts-modal')) {
      event.target.style.display = 'none';
      if (event.target === modalDeductionCategories) hideDeductionCategoryForm();
    }
  });

  // Hour Type Form Management
  function updateHourTypeFormVisibility() {
    const hourTypesEnabled = !!(state.featureFlags.hour_types && state.featureFlags.hour_types.enabled);
    const hasMultipleTypes = state.hourTypes.length > 1;
    const shouldShow = hourTypesEnabled && hasMultipleTypes;

    if (manualHourTypeCol) {
      manualHourTypeCol.style.display = shouldShow ? 'block' : 'none';
    }
    if (punchHourTypeCol) {
      punchHourTypeCol.style.display = shouldShow ? 'block' : 'none';
    }

    if (shouldShow) {
      populateHourTypeOptions();
    }
  }

  function populateHourTypeOptions() {
    if (!state.hourTypes.length) return;

    [manualHourType, punchHourType].forEach(select => {
      if (!select) return;

      const currentValue = select.value;
      select.innerHTML = '';

      state.hourTypes.forEach(hourType => {
        const option = document.createElement('option');
        option.value = hourType.id;
        option.textContent = hourType.name;
        if (hourType.is_default && !currentValue) {
          option.selected = true;
        }
        select.appendChild(option);
      });

      // Restore previous selection if it still exists
      if (currentValue && state.hourTypeMap[currentValue]) {
        select.value = currentValue;
      }

      // Update contract visibility when hour type changes
      if (select === manualHourType) {
        updateManualContractVisibility();
      } else if (select === punchHourType) {
        updatePunchContractVisibility();
      }
    });
  }

  function updateManualContractVisibility() {
    if (!manualHourType || !manualContract) return;

    const selectedHourType = state.hourTypeMap[manualHourType.value];
    if (selectedHourType && !selectedHourType.requires_contract) {
      // Show "Not required" for non-contract hour types
      manualContract.innerHTML = '<option value="">Not required (optional)</option>';
      const validContracts = validContractsForDate(manualDate ? manualDate.value : todayIso());
      validContracts.forEach(contract => {
        const option = document.createElement('option');
        option.value = contract.id;
        option.textContent = contract.name;
        manualContract.appendChild(option);
      });
      manualContract.value = '';
      manualContract.disabled = false;
      manualContract.style.fontStyle = 'italic';
      manualContract.style.opacity = '0.8';
      if (manualContractWarning) manualContractWarning.style.display = 'none';
    } else {
      // Normal contract requirement
      manualContract.style.fontStyle = 'normal';
      manualContract.style.opacity = '1';
      updateManualContractOptions();
    }
    updateBasicSaveEnabled();
  }

  function updatePunchContractVisibility() {
    if (!punchHourType || !punchContract) return;

    const selectedHourType = state.hourTypeMap[punchHourType.value];
    if (selectedHourType && !selectedHourType.requires_contract) {
      // Show "Not required" for non-contract hour types
      punchContract.innerHTML = '<option value="">Not required (optional)</option>';
      const validContracts = validContractsForDate(punchDate ? punchDate.value : todayIso());
      validContracts.forEach(contract => {
        const option = document.createElement('option');
        option.value = contract.id;
        option.textContent = contract.name;
        punchContract.appendChild(option);
      });
      punchContract.value = '';
      punchContract.disabled = false;
      punchContract.style.fontStyle = 'italic';
      punchContract.style.opacity = '0.8';
      if (punchContractWarning) punchContractWarning.style.display = 'none';
    } else {
      // Normal contract requirement
      punchContract.style.fontStyle = 'normal';
      punchContract.style.opacity = '1';
      updatePunchContractOptions();
    }
  }

  function getDefaultHourTypeId() {
    if (!state.hourTypes.length) return null;
    const defaultType = state.hourTypes.find(ht => ht.is_default);
    return defaultType ? defaultType.id : state.hourTypes[0].id;
  }

  function findEntryForDateAndHourType(dateIso, hourTypeId) {
    if (!dateIso) return null;
    const fallbackHourTypeId = getDefaultHourTypeId();
    const targetHourTypeId = hourTypeId || fallbackHourTypeId;
    return state.entries.find(entry => {
      if (entry.date !== dateIso) return false;
      const entryHourTypeId = entry.hour_type_id || fallbackHourTypeId;
      return entryHourTypeId === targetHourTypeId;
    }) || null;
  }

  // Event listeners for hour type changes
  if (manualHourType) {
    manualHourType.addEventListener('change', () => {
      updateManualContractVisibility();
      handleManualHourTypeChange();
    });
  }

  if (punchHourType) {
    punchHourType.addEventListener('change', () => {
      updatePunchContractVisibility();
      handlePunchHourTypeChange();
    });
  }

  function handleManualHourTypeChange() {
    if (!manualHourType || !manualDate) return;

    const selectedHourTypeId = manualHourType.value || getDefaultHourTypeId();
    const currentDate = manualDate.value;

    if (!currentDate) return;

    const existingEntry = findEntryForDateAndHourType(currentDate, selectedHourTypeId);

    if (existingEntry) {
      const entryType = resolveEntryType(existingEntry);

      if (entryType === 'advanced') {
        if (punchHourType) punchHourType.value = selectedHourTypeId;
        if (punchDate) punchDate.value = currentDate;
        state.selectedCalendarDate = currentDate;
        activateTab('punch');
        return;
      }

      populateManualForm(existingEntry, true);
    } else {
      // Clear the form for new entry but keep date and hour type
      const currentHourType = manualHourType.value;
      clearManualEditing();
      if (manualDate) manualDate.value = currentDate;
      if (manualHourType) manualHourType.value = currentHourType;
      updateManualContractVisibility();
    }

    // Update tab states to enable/disable the other tab
    updateTabStates();
  }

  function handlePunchHourTypeChange() {
    if (!punchHourType || !punchDate || !punchContract) return;

    const selectedHourTypeId = punchHourType.value || getDefaultHourTypeId();
    const currentDate = punchDate.value;

    if (!currentDate) return;

    const existingEntry = findEntryForDateAndHourType(currentDate, selectedHourTypeId);

    if (existingEntry) {
      const entryType = resolveEntryType(existingEntry);

      if (entryType === 'basic') {
        if (manualDate) manualDate.value = currentDate;
        if (manualHourType) manualHourType.value = selectedHourTypeId;
        state.selectedCalendarDate = currentDate;
        activateTab('manual');
        return;
      }

      // Load the existing advanced entry
      state.editingEntryId = existingEntry.id;
      state.editingEntryType = entryType;

      if (punchContract) {
        updatePunchContractOptions(existingEntry.contract_id);
        punchContract.value = existingEntry.contract_id || '';
      }

      state.punchDraft = {
        entryId: existingEntry.id,
        contractId: existingEntry.contract_id || '',
        date: existingEntry.date,
        punches: clonePunches(existingEntry.punches || []),
        dirty: false
      };

      renderPunchDraft();
      updatePunchSummary();
    } else {
      // Clear for new entry but keep date and hour type
      const currentHourType = punchHourType.value;
      state.editingEntryId = null;
      state.editingEntryType = null;

      updatePunchContractOptions();

      state.punchDraft = {
        entryId: null,
        contractId: punchContract.value || '',
        date: currentDate,
        punches: [{ in: '', out: '' }],
        dirty: false
      };

      if (punchHourType) punchHourType.value = currentHourType;
      renderPunchDraft();
      updatePunchSummary();
    }

    updatePunchContractVisibility();

    // Update tab states to enable/disable the other tab
    updateTabStates();
  }

  // Call the main init function
  init();
</script>
