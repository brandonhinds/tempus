<script>
  // Layout navigation
  const pageTime = document.getElementById('page-time');
  const pageContracts = document.getElementById('page-contracts');
  const pageSettings = document.getElementById('page-settings');
  const navToggle = document.getElementById('nav-toggle');
  const navMenu = document.getElementById('nav-menu');
  const navTimeBtn = document.getElementById('nav-time');
  const navContractsBtn = document.getElementById('nav-contracts');
  const navSettingsBtn = document.getElementById('nav-settings');

  const state = {
    isRunning: false,
    startTs: null,
    timerInterval: null,
    cacheKey: 'ts_cache',
    entries: [],
    settings: {},
    contracts: [],
    contractMap: {},
    featureFlags: {},
    editingEntryId: null,
    editingContractId: null,
    calendar: null,
    selectedCalendarDate: null,
    currentPage: 'time'
  };

  const PAGE_KEYS = ['time', 'contracts', 'settings'];
  const LAST_PAGE_KEY = 'ts_last_page';

  function persistLastPage(page) {
    if (!PAGE_KEYS.includes(page)) return;
    try {
      if (state.featureFlags.remember_last_page) {
        localStorage.setItem(LAST_PAGE_KEY, page);
      } else {
        localStorage.removeItem(LAST_PAGE_KEY);
      }
    } catch (e) {}
  }

  function showPage(target, options) {
    const opts = options || {};
    const normalized = PAGE_KEYS.includes(target) ? target : 'time';
    const pages = {
      time: pageTime,
      contracts: pageContracts,
      settings: pageSettings
    };
    Object.keys(pages).forEach((key) => {
      const page = pages[key];
      if (page) page.style.display = key === normalized ? 'block' : 'none';
    });
    state.currentPage = normalized;
    if (!opts.skipRemember) {
      persistLastPage(normalized);
    }
  }

  function closeNavMenu() {
    if (!navMenu) return;
    navMenu.hidden = true;
    if (navToggle) navToggle.setAttribute('aria-expanded', 'false');
  }

  function openNavMenu() {
    if (!navMenu) return;
    navMenu.hidden = false;
    if (navToggle) navToggle.setAttribute('aria-expanded', 'true');
  }

  function toggleNavMenu() {
    if (!navMenu) return;
    const expanded = navToggle && navToggle.getAttribute('aria-expanded') === 'true';
    if (expanded) {
      closeNavMenu();
    } else {
      openNavMenu();
    }
  }

  if (navToggle && navMenu) {
    navToggle.addEventListener('click', (event) => {
      event.stopPropagation();
      toggleNavMenu();
    });
  }

  if (navMenu) {
    navMenu.addEventListener('click', (event) => {
      if ((event.target instanceof HTMLElement) && event.target.tagName === 'BUTTON') {
        closeNavMenu();
      }
    });
  }

  document.addEventListener('click', (event) => {
    if (!navMenu || navMenu.hidden) return;
    if (navToggle && (event.target === navToggle || navToggle.contains(event.target))) return;
    if (navMenu.contains(event.target)) return;
    closeNavMenu();
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') closeNavMenu();
  });

  if (navTimeBtn) navTimeBtn.onclick = () => { closeNavMenu(); showPage('time'); };
  if (navContractsBtn) navContractsBtn.onclick = () => { closeNavMenu(); showPage('contracts'); };
  if (navSettingsBtn) navSettingsBtn.onclick = () => { closeNavMenu(); showPage('settings'); };
  closeNavMenu();
  showPage('time', { skipRemember: true });

  // Helpers

  const $ = (selector) => document.querySelector(selector);
  const $$ = (selector) => Array.from(document.querySelectorAll(selector));
  const fmt = (minutes) => {
    const total = Number(minutes) || 0;
    const h = Math.floor(total / 60);
    const mm = total % 60;
    return (h > 0 ? h + ':' : '') + String(mm).padStart(2, '0');
  };
  const fmtTimer = (ms) => {
    const total = Math.floor(ms / 1000);
    const mm = Math.floor(total / 60);
    const ss = total % 60;
    const minutesPortion = mm >= 60 ? Math.floor(mm / 60) + ':' + String(mm % 60).padStart(2, '0') : mm;
    return minutesPortion + ':' + String(ss).padStart(2, '0');
  };
  const setStatus = (text, cls) => {
    const el = document.getElementById('status');
    el.textContent = text;
    el.className = 'ts-badge ' + (cls || '');
  };
  const isoDate = (date) => {
    const d = new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };
  const isoDateTime = (date) => new Date(date).toISOString().replace(/\.\d{3}Z$/, 'Z');
  const parseIsoDate = (value) => {
    const [y, m, d] = value.split('-').map(Number);
    return new Date(y, m - 1, d);
  };
  const todayIso = () => isoDate(new Date());
  const formatHours = (minutes) => {
    const hrs = (Number(minutes) || 0) / 60;
    let out = (Math.round(hrs * 100) / 100).toFixed(2);
    out = out.replace(/\.00$/, '');
    out = out.replace(/(\.\d)0$/, '$1');
    return out === '' ? '0' : out;
  };

  const getRoundInterval = () => {
    const value = Number(state.settings.round_to_nearest);
    return Number.isFinite(value) && value > 1 ? value : 0;
  };
  const roundDuration = (minutes) => {
    const base = Math.max(0, Math.round(Number(minutes) || 0));
    const interval = getRoundInterval();
    if (!interval) return Math.max(1, base);
    const rounded = Math.round(base / interval) * interval;
    return Math.max(interval, rounded);
  };

  const sanitizeEntry = (entry) => {
    if (!entry) return entry;
    const clone = { ...entry };
    clone.duration_minutes = Math.max(0, Math.round(Number(clone.duration_minutes) || 0));
    const rawBreak = clone.break_minutes != null ? clone.break_minutes : clone.break;
    clone.break_minutes = Math.max(0, Math.round(Number(rawBreak) || 0));
    delete clone.description;
    if (clone.break_minutes > clone.duration_minutes) {
      clone.break_minutes = clone.duration_minutes;
    }
    const contractId = clone.contract_id || clone.contractId || clone.project || '';
    clone.contract_id = contractId ? String(contractId).trim() : '';
    delete clone.project;
    delete clone.contractId;
    return clone;
  };

  const sanitizeContract = (contract) => {
    if (!contract) return contract;
    const clone = { ...contract };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.start_date = clone.start_date || clone.startDate || '';
    clone.end_date = clone.end_date || clone.endDate || '';
    clone.hourly_rate = Number(clone.hourly_rate != null ? clone.hourly_rate : 0);
    if (Number.isNaN(clone.hourly_rate)) clone.hourly_rate = 0;
    delete clone.startDate;
    delete clone.endDate;
    delete clone.hourlyRate;
    return clone;
  };

  const DEFAULT_FEATURE_FLAGS = {
    remember_last_page: {
      name: 'Remember last page on refresh',
      description: 'When enabled, the app reopens on the most recently viewed page.'
    },
    show_clear_cache: {
      name: 'Show cache clear button',
      description: 'Displays a button that lets you clear cached entries and settings from this browser.'
    }
  };

  const normalizeFeatureFlags = (raw) => {
    const out = {};
    if (raw && typeof raw === 'object') {
      Object.keys(raw).forEach((key) => {
        const value = raw[key];
        const enabled = value && typeof value === 'object' ? !!value.enabled : !!value;
        const name = value && typeof value === 'object' && value.name ? String(value.name) : '';
        const description = value && typeof value === 'object' && value.description ? String(value.description) : '';
        out[key] = {
          enabled,
          name,
          description
        };
      });
    }
    Object.keys(DEFAULT_FEATURE_FLAGS).forEach((key) => {
      if (!out[key]) {
        out[key] = {
          enabled: false,
          name: DEFAULT_FEATURE_FLAGS[key].name,
          description: DEFAULT_FEATURE_FLAGS[key].description
        };
      } else {
        out[key].name = out[key].name || DEFAULT_FEATURE_FLAGS[key].name;
        out[key].description = out[key].description || DEFAULT_FEATURE_FLAGS[key].description;
      }
    });
    return out;
  };

  function updateContractMap() {
    state.contractMap = state.contracts.reduce((map, contract) => {
      map[contract.id] = contract;
      return map;
    }, {});
  }

  const contractIsValid = (contract, dateIso) => {
    if (!contract || !dateIso) return false;
    if (contract.start_date && contract.start_date > dateIso) return false;
    if (contract.end_date && contract.end_date !== '' && contract.end_date < dateIso) return false;
    return true;
  };

  function validContractsForDate(dateIso) {
    if (!dateIso) return [];
    return state.contracts.filter((contract) => contractIsValid(contract, dateIso));
  }

  function getContractName(id) {
    if (!id) return '';
    const match = state.contractMap[id];
    if (match) return match.name;
    return '';
  }

  const contractBadge = (entry) => {
    const name = getContractName(entry.contract_id);
    if (name) return `<span class="ts-badge">${name}</span>`;
    if (entry.contract_id) return `<span class="ts-badge warn">Unknown contract</span>`;
    return `<span class="ts-badge warn">No contract</span>`;
  };

  function loadCache() {
    try {
      const raw = localStorage.getItem(state.cacheKey);
      if (!raw) return;
      const obj = JSON.parse(raw);
      state.entries = Array.isArray(obj.entries) ? obj.entries.map(sanitizeEntry) : [];
      state.settings = obj.settings || {};
      state.contracts = Array.isArray(obj.contracts) ? obj.contracts.map(sanitizeContract) : [];
      state.featureFlags = normalizeFeatureFlags(obj.featureFlags);
      updateContractMap();
    } catch (e) {}
  }
  function saveCache() {
    try {
      const payload = {
        entries: state.entries.map(sanitizeEntry),
        settings: state.settings,
        contracts: state.contracts.map(sanitizeContract),
        featureFlags: normalizeFeatureFlags(state.featureFlags)
      };
      localStorage.setItem(state.cacheKey, JSON.stringify(payload));
    } catch (e) {}
  }

  // Tabs
  function activateTab(id) {
    $$('.ts-tab').forEach((tab) => {
      const target = tab.getAttribute('data-tab');
      tab.classList.toggle('active', target === id);
    });
    ['manual', 'timer'].forEach((pane) => {
      const el = document.getElementById('tab-' + pane);
      if (el) el.style.display = pane === id ? 'block' : 'none';
    });
  }
  $$('.ts-tab').forEach((tab) => {
    tab.addEventListener('click', () => activateTab(tab.getAttribute('data-tab')));
  });
  activateTab('manual');

  // Timer controls
  function startTimer() {
    if (state.isRunning) return;
    if (!timerContract || !timerContract.value) {
      alert('Select a contract before starting the timer.');
      return;
    }
    state.isRunning = true;
    state.startTs = Date.now();
    state.timerInterval = setInterval(() => {
      document.getElementById('timer-display').textContent = fmtTimer(Date.now() - state.startTs);
    }, 1000);
    refreshTimerButtons();
  }
  function pauseTimer() {
    if (!state.isRunning) return;
    state.isRunning = false;
    clearInterval(state.timerInterval);
    refreshTimerButtons();
  }
  function resetTimer() {
    state.isRunning = false;
    clearInterval(state.timerInterval);
    state.startTs = null;
    document.getElementById('timer-display').textContent = '0:00';
    if (timerBreak) timerBreak.value = '0';
    refreshTimerButtons();
  }
  function stopAndSave() {
    if (!state.startTs) return;
    if (!timerContract || !timerContract.value) {
      alert('Select a contract before saving the timer entry.');
      return;
    }
    const end = Date.now();
    const rawDuration = Math.max(1, Math.floor((end - state.startTs) / 60000));
    const breakMinutes = Math.max(0, Math.round(Number(timerBreak.value || 0)));
    if (breakMinutes >= rawDuration) {
      alert('Break must be shorter than the recorded time.');
      return;
    }
    const durMin = roundDuration(rawDuration - breakMinutes);
    const now = new Date();
    const contract = state.contractMap[timerContract.value];
    const todayIsoString = isoDate(now);
    if (!contract || !contractIsValid(contract, todayIsoString)) {
      alert('Selected contract is not valid for today.');
      return;
    }
    const entry = sanitizeEntry({
      id: 'temp_' + Date.now(),
      date: todayIsoString,
      start_time: new Date(state.startTs).toTimeString().slice(0, 5),
      end_time: new Date(end).toTimeString().slice(0, 5),
      duration_minutes: durMin,
      break_minutes: breakMinutes,
      contract_id: timerContract.value,
      created_at: isoDateTime(now)
    });
    state.entries.unshift(entry);
    saveCache();
    renderEntries();
    resetTimer();
    setStatus('Saving...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success) {
          const idx = state.entries.findIndex((e) => e.id === entry.id);
          if (idx > -1) state.entries[idx] = sanitizeEntry(res.entry);
          saveCache();
          renderEntries();
          setStatus('Saved', 'success');
        } else {
          setStatus('Save failed', 'error');
        }
      })
      .withFailureHandler(() => setStatus('Save failed (offline?)', 'error'))
      .api_addEntry(entry);
  }
  document.getElementById('btn-start').onclick = startTimer;
  document.getElementById('btn-pause').onclick = pauseTimer;
  document.getElementById('btn-reset').onclick = resetTimer;
  document.getElementById('btn-stop').onclick = stopAndSave;

  // Manual form helpers
  const manualDate = document.getElementById('manual-date');
  const manualStart = document.getElementById('manual-start');
  const manualEnd = document.getElementById('manual-end');
  const manualBreak = document.getElementById('manual-break');
  const manualContract = document.getElementById('manual-contract');
  const manualContractWarning = document.getElementById('manual-contract-warning');
  const manualSaveBtn = document.getElementById('btn-add-manual');
  const manualCancelBtn = document.getElementById('btn-cancel-edit');
  const timerBreak = document.getElementById('timer-break');
  const timerContract = document.getElementById('timer-contract');
  const timerContractWarning = document.getElementById('timer-contract-warning');
  const btnStart = document.getElementById('btn-start');
  const btnPause = document.getElementById('btn-pause');
  const btnStop = document.getElementById('btn-stop');

  function refreshTimerButtons() {
    if (!btnStart || !btnStop || !btnPause) return;
    const hasContract = !!(timerContract && timerContract.value);
    btnStart.disabled = !hasContract || state.isRunning;
    btnStop.disabled = !state.isRunning;
    btnPause.disabled = !state.isRunning;
  }

  function updateManualContractOptions(preferredContractId) {
    if (!manualContract) return '';
    const dateIso = manualDate && manualDate.value ? manualDate.value : todayIso();
    const valid = validContractsForDate(dateIso);
    const currentValue = preferredContractId != null ? preferredContractId : manualContract.value;
    const options = [...valid];
    if (currentValue && !options.some((contract) => contract.id === currentValue)) {
      const fallback = state.contractMap[currentValue];
      if (fallback) options.push(fallback);
    }
    options.sort((a, b) => a.name.localeCompare(b.name));
    manualContract.innerHTML = '';
    if (!options.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts';
      manualContract.appendChild(placeholder);
      manualContract.value = '';
      manualContract.disabled = true;
      if (manualContractWarning) manualContractWarning.style.display = 'block';
      if (manualSaveBtn) manualSaveBtn.disabled = true;
      return '';
    }
    if (options.length > 1) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select contract';
      manualContract.appendChild(placeholder);
    }
    options.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      manualContract.appendChild(opt);
    });
    let selected = currentValue && options.some((contract) => contract.id === currentValue) ? currentValue : '';
    if (!selected && valid.length === 1) {
      selected = valid[0].id;
    }
    manualContract.value = selected;
    manualContract.disabled = valid.length === 1 && options.length === valid.length;
    if (manualContractWarning) manualContractWarning.style.display = 'none';
    if (manualSaveBtn) manualSaveBtn.disabled = !manualContract.value;
    return manualContract.value;
  }

  function updateTimerContractOptions(preferredContractId) {
    if (!timerContract) {
      refreshTimerButtons();
      return '';
    }
    const dateIso = todayIso();
    const valid = validContractsForDate(dateIso);
    const currentValue = preferredContractId != null ? preferredContractId : timerContract.value;
    const options = [...valid];
    if (currentValue && !options.some((contract) => contract.id === currentValue)) {
      const fallback = state.contractMap[currentValue];
      if (fallback) options.push(fallback);
    }
    options.sort((a, b) => a.name.localeCompare(b.name));
    timerContract.innerHTML = '';
    if (!options.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts';
      timerContract.appendChild(placeholder);
      timerContract.value = '';
      timerContract.disabled = true;
      if (timerContractWarning) timerContractWarning.style.display = 'block';
      refreshTimerButtons();
      return '';
    }
    if (options.length > 1) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select contract';
      timerContract.appendChild(placeholder);
    }
    options.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      timerContract.appendChild(opt);
    });
    let selected = currentValue && options.some((contract) => contract.id === currentValue) ? currentValue : '';
    if (!selected && valid.length === 1) {
      selected = valid[0].id;
    }
    timerContract.value = selected;
    timerContract.disabled = valid.length === 1 && options.length === valid.length;
    if (timerContractWarning) timerContractWarning.style.display = 'none';
    refreshTimerButtons();
    return timerContract.value;
  }

  function refreshContractBindings(preferredManualContractId, preferredTimerContractId) {
    updateContractMap();
    const manualDateIso = manualDate && manualDate.value ? manualDate.value : todayIso();
    const manualPreferred = preferredManualContractId && contractIsValid(state.contractMap[preferredManualContractId], manualDateIso)
      ? preferredManualContractId
      : undefined;
    const timerDateIso = todayIso();
    const timerPreferred = preferredTimerContractId && contractIsValid(state.contractMap[preferredTimerContractId], timerDateIso)
      ? preferredTimerContractId
      : undefined;
    updateManualContractOptions(manualPreferred);
    updateTimerContractOptions(timerPreferred);
  }

  function setManualDate(dateIso, preferredContractId) {
    if (!manualDate) return;
    manualDate.value = dateIso || todayIso();
    updateManualContractOptions(preferredContractId != null ? preferredContractId : (manualContract ? manualContract.value : ''));
  }

  function setManualMode(isEdit) {
    manualSaveBtn.textContent = isEdit ? 'Update Entry' : 'Add Entry';
    manualCancelBtn.style.display = isEdit ? 'inline-flex' : 'none';
  }
  function populateManualForm(entry, isEdit) {
    showPage('time');
    activateTab('manual');
    const preferredDate = entry.date || todayIso();
    const preferredContractId = entry.contract_id || '';
    setManualDate(preferredDate, preferredContractId);
    manualStart.value = entry.start_time || '';
    manualEnd.value = entry.end_time || '';
    manualBreak.value = String(entry.break_minutes != null ? entry.break_minutes : 0);
    state.editingEntryId = isEdit ? entry.id : null;
    setManualMode(!!isEdit);
    if (isEdit) manualStart.focus();
  }
  function clearManualEditing() {
    state.editingEntryId = null;
    setManualMode(false);
    manualStart.value = '';
    manualEnd.value = '';
    manualBreak.value = '0';
    updateManualContractOptions();
  }
  function getManualPayload() {
    const date = manualDate.value || todayIso();
    const start = manualStart.value;
    const end = manualEnd.value;
    if (!date || !start || !end) {
      alert('Date, start time, and end time are required.');
      return null;
    }
    const startTs = new Date(`${date}T${start}:00`);
    const endTs = new Date(`${date}T${end}:00`);
    const duration = Math.floor((endTs - startTs) / 60000);
    if (duration <= 0) {
      alert('End time must be after start time.');
      return null;
    }
    const breakMin = Math.max(0, Math.round(Number(manualBreak.value || 0)));
    if (breakMin >= duration) {
      alert('Break must be shorter than the total time.');
      return null;
    }
    const rounded = roundDuration(duration - breakMin);
    const contractId = manualContract ? manualContract.value : '';
    if (!contractId) {
      alert('Select a contract for this date.');
      return null;
    }
    const contract = state.contractMap[contractId];
    if (!contract) {
      alert('Selected contract is no longer available.');
      return null;
    }
    if (!contractIsValid(contract, date) && !state.editingEntryId) {
      alert('Selected contract is not valid for this date.');
      return null;
    }
    return {
      date,
      start_time: start,
      end_time: end,
      duration_minutes: rounded,
      break_minutes: breakMin,
      contract_id: contractId
    };
  }

  manualSaveBtn.onclick = function () {
    const payload = getManualPayload();
    if (!payload) return;
    if (state.editingEntryId) {
      const idx = state.entries.findIndex((e) => e.id === state.editingEntryId);
      if (idx === -1) return;
      const backup = { ...state.entries[idx] };
      const update = { id: state.editingEntryId, ...payload };
      state.entries[idx] = sanitizeEntry({ ...backup, ...update });
      saveCache();
      renderEntries();
      setStatus('Saving...', 'warn');
      google.script.run
        .withSuccessHandler((res) => {
          if (res && res.success) {
            state.entries[idx] = sanitizeEntry(res.entry);
            clearManualEditing();
            saveCache();
            renderEntries();
            setStatus('Saved', 'success');
          } else {
            state.entries[idx] = backup;
            saveCache();
            renderEntries();
            setStatus('Save failed', 'error');
          }
        })
        .withFailureHandler(() => {
          state.entries[idx] = backup;
          saveCache();
          renderEntries();
          setStatus('Save failed', 'error');
        })
        .api_updateEntry(update);
    } else {
      const now = new Date();
      const entry = {
        id: 'temp_' + Date.now(),
        ...payload,
        created_at: isoDateTime(now)
      };
      state.entries.unshift(sanitizeEntry(entry));
      saveCache();
      renderEntries();
      clearManualEditing();
      setStatus('Saving...', 'warn');
      google.script.run
        .withSuccessHandler((res) => {
          if (res && res.success) {
            const idx = state.entries.findIndex((e) => e.id === entry.id);
            if (idx > -1) state.entries[idx] = sanitizeEntry(res.entry);
            saveCache();
            renderEntries();
            setStatus('Saved', 'success');
          } else {
            setStatus('Save failed', 'error');
          }
        })
        .withFailureHandler(() => setStatus('Save failed (offline?)', 'error'))
        .api_addEntry(entry);
    }
    state.selectedCalendarDate = payload.date;
    setManualDate(state.selectedCalendarDate, payload.contract_id);
    renderCalendar();
    renderCalendarDetail();
  };
  manualCancelBtn.onclick = function () {
    clearManualEditing();
    activateTab('manual');
  };

  if (manualDate) {
    manualDate.addEventListener('change', () => {
      state.selectedCalendarDate = manualDate.value;
      updateManualContractOptions();
      renderCalendar();
      renderCalendarDetail();
    });
  }

  if (manualContract) {
    manualContract.addEventListener('change', () => {
      if (manualSaveBtn) manualSaveBtn.disabled = !manualContract.value;
    });
  }

  if (timerContract) {
    timerContract.addEventListener('change', () => {
      refreshTimerButtons();
    });
  }

  if (manualBreak) manualBreak.value = '0';
  if (timerBreak) timerBreak.value = '0';
  setManualDate(todayIso());

  const contractsListEl = document.getElementById('contracts-list');
  const featureFlagsListEl = document.getElementById('feature-flags-list');
  const contractNameInput = document.getElementById('contract-name');
  const contractStartInput = document.getElementById('contract-start');
  const contractEndInput = document.getElementById('contract-end');
  const contractRateInput = document.getElementById('contract-rate');
  const contractSaveBtn = document.getElementById('contract-save');
  const contractCancelBtn = document.getElementById('contract-cancel');
  const clearCacheWrapper = document.getElementById('clear-cache-wrapper');
  const clearCacheBtn = document.getElementById('btn-clear-cache');

  function setContractFormMode(isEdit) {
    if (contractSaveBtn) contractSaveBtn.textContent = isEdit ? 'Update Contract' : 'Add Contract';
    if (contractCancelBtn) contractCancelBtn.style.display = isEdit ? 'inline-flex' : 'none';
  }

  function contractEndSortValue(contract) {
    return contract.end_date && contract.end_date !== '' ? contract.end_date : '9999-12-31';
  }

  function renderContractsList() {
    if (!contractsListEl) return;
    contractsListEl.innerHTML = '';
    if (!state.contracts.length) {
      const empty = document.createElement('div');
      empty.className = 'ts-note';
      empty.textContent = 'No contracts yet. Add one to start tracking time.';
      contractsListEl.appendChild(empty);
      return;
    }
    const sorted = [...state.contracts].sort((a, b) => {
      const endA = contractEndSortValue(a);
      const endB = contractEndSortValue(b);
      if (endA !== endB) return endB.localeCompare(endA);
      const startA = a.start_date || '';
      const startB = b.start_date || '';
      if (startA !== startB) return (startB || '').localeCompare(startA || '');
      return a.name.localeCompare(b.name);
    });
    sorted.forEach((contract) => {
      const hasEntries = state.entries.some((entry) => entry.contract_id === contract.id);
      const deleteDisabledAttr = hasEntries
        ? 'disabled aria-disabled="true" title="Cannot delete a contract with time entries"'
        : '';
      const item = document.createElement('div');
      item.className = 'ts-item';
      const rangeLabel = contract.end_date ? `${contract.start_date || '—'} → ${contract.end_date}` : `${contract.start_date || '—'} → Present`;
      const rate = Number(contract.hourly_rate || 0);
      item.innerHTML = `
        <div style="flex:1;">
          <div style="font-weight:600;">${contract.name || 'Unnamed contract'}</div>
          <div class="ts-note">Dates: ${rangeLabel}</div>
          <div class="ts-note">Rate: ${rate.toFixed(2)} / hr</div>
        </div>
        <div style="display:flex; gap:8px;">
          <button class="ghost" data-contract-edit="${contract.id}">Edit</button>
          <button class="danger" data-contract-delete="${contract.id}" ${deleteDisabledAttr}>Delete</button>
        </div>
      `;
      contractsListEl.appendChild(item);
    });
    contractsListEl.querySelectorAll('[data-contract-edit]').forEach((btn) => {
      btn.onclick = () => handleContractEdit(btn.getAttribute('data-contract-edit'));
    });
    contractsListEl.querySelectorAll('[data-contract-delete]').forEach((btn) => {
      const locked = btn.hasAttribute('disabled');
      btn.disabled = locked;
      if (locked) {
        btn.onclick = null;
      } else {
        btn.onclick = () => handleContractDelete(btn.getAttribute('data-contract-delete'));
      }
    });
  }

  function clearContractForm() {
    state.editingContractId = null;
    if (contractNameInput) contractNameInput.value = '';
    if (contractStartInput) contractStartInput.value = '';
    if (contractEndInput) contractEndInput.value = '';
    if (contractRateInput) contractRateInput.value = '';
    setContractFormMode(false);
  }

  function populateContractForm(contract) {
    state.editingContractId = contract.id;
    if (contractNameInput) contractNameInput.value = contract.name || '';
    if (contractStartInput) contractStartInput.value = contract.start_date || '';
    if (contractEndInput) contractEndInput.value = contract.end_date || '';
    if (contractRateInput) contractRateInput.value = contract.hourly_rate != null ? Number(contract.hourly_rate).toFixed(2) : '';
    setContractFormMode(true);
  }

  function getContractFormPayload() {
    const name = contractNameInput ? contractNameInput.value.trim() : '';
    const startDate = contractStartInput ? contractStartInput.value : '';
    const endDate = contractEndInput ? contractEndInput.value : '';
    const hourlyRateRaw = contractRateInput ? contractRateInput.value : '';
    const hourlyRate = Number(hourlyRateRaw || 0);
    if (!name) {
      alert('Contract name is required.');
      return null;
    }
    if (!startDate) {
      alert('Contract start date is required.');
      return null;
    }
    if (endDate && endDate < startDate) {
      alert('End date must be on or after the start date.');
      return null;
    }
    if (hourlyRate < 0) {
      alert('Hourly rate must be zero or greater.');
      return null;
    }
    return {
      name,
      start_date: startDate,
      end_date: endDate,
      hourly_rate: Math.round(hourlyRate * 100) / 100
    };
  }

  function handleContractSave() {
    if (!contractSaveBtn) return;
    const payload = getContractFormPayload();
    if (!payload) return;
    contractSaveBtn.disabled = true;
    const isEdit = !!state.editingContractId;
    setStatus(isEdit ? 'Updating contract...' : 'Saving contract...', 'warn');
    const handler = (res) => {
      contractSaveBtn.disabled = false;
      if (res && res.success && res.contract) {
        const normalized = sanitizeContract(res.contract);
        state.contracts = [...state.contracts.filter((c) => c.id !== normalized.id), normalized];
        refreshContractBindings(normalized.id, normalized.id);
        renderContractsList();
        saveCache();
        clearContractForm();
        setStatus(isEdit ? 'Contract updated' : 'Contract saved', 'success');
      } else {
        setStatus('Contract save failed', 'error');
      }
    };
    const failure = () => {
      contractSaveBtn.disabled = false;
      setStatus('Contract save failed', 'error');
    };
    if (isEdit) {
      google.script.run
        .withSuccessHandler(handler)
        .withFailureHandler(failure)
        .api_updateContract({ id: state.editingContractId, ...payload });
    } else {
      google.script.run
        .withSuccessHandler(handler)
        .withFailureHandler(failure)
        .api_addContract(payload);
    }
  }

  function handleContractEdit(id) {
    const contract = state.contracts.find((c) => c.id === id);
    if (!contract) return;
    populateContractForm(contract);
    showPage('contracts');
  }

  function handleContractDelete(id) {
    if (!id) return;
    const hasEntries = state.entries.some((entry) => entry.contract_id === id);
    if (hasEntries) {
      alert('This contract already has time entries and cannot be deleted.');
      return;
    }
    if (!confirm('Delete this contract?')) return;
    setStatus('Deleting contract...', 'warn');
    google.script.run
      .withSuccessHandler(() => {
        state.contracts = state.contracts.filter((contract) => contract.id !== id);
        if (state.editingContractId === id) {
          clearContractForm();
        }
        refreshContractBindings();
        renderContractsList();
        saveCache();
        setStatus('Contract deleted', 'success');
      })
      .withFailureHandler(() => setStatus('Contract delete failed', 'error'))
      .api_deleteContract(id);
  }

  function renderFeatureFlags() {
    if (!featureFlagsListEl) return;
    featureFlagsListEl.innerHTML = '';
    const entries = Object.keys(state.featureFlags).map((key) => ({
      key,
      enabled: !!state.featureFlags[key].enabled,
      name: state.featureFlags[key].name || key,
      description: state.featureFlags[key].description || ''
    })).sort((a, b) => a.name.localeCompare(b.name));
    if (!entries.length) {
      const empty = document.createElement('div');
      empty.className = 'ts-note';
      empty.textContent = 'No feature flags configured.';
      featureFlagsListEl.appendChild(empty);
      return;
    }
    entries.forEach((flag) => {
      const row = document.createElement('div');
      row.className = 'ts-flag-row';

      const meta = document.createElement('div');
      meta.className = 'ts-flag-meta';
      meta.innerHTML = `<div class="ts-flag-title">${flag.name}</div>` + (flag.description ? `<div class="ts-flag-desc">${flag.description}</div>` : '');

      const toggleLabel = document.createElement('label');
      toggleLabel.className = 'ts-toggle';
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = flag.enabled;
      input.dataset.flag = flag.key;
      input.setAttribute('aria-label', flag.name);
      const track = document.createElement('span');
      track.className = 'ts-toggle-track';
      const thumb = document.createElement('span');
      thumb.className = 'ts-toggle-thumb';
      track.appendChild(thumb);
      toggleLabel.appendChild(input);
      toggleLabel.appendChild(track);

      input.addEventListener('change', () => {
        if (!!state.featureFlags[flag.key]?.enabled === input.checked) return;
        updateFeatureFlag(flag.key, input.checked);
      });

      row.append(meta, toggleLabel);
      featureFlagsListEl.appendChild(row);
    });
  }

  function updateFeatureFlag(featureKey, enabled) {
    const toggleInput = featureFlagsListEl ? featureFlagsListEl.querySelector(`input[data-flag="${featureKey}"]`) : null;
    if (toggleInput) toggleInput.disabled = true;
    const currentMeta = state.featureFlags[featureKey] || DEFAULT_FEATURE_FLAGS[featureKey] || { name: featureKey, description: '' };
    setStatus('Updating feature flags...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (toggleInput) toggleInput.disabled = false;
        if (res && res.success && res.flags) {
          state.featureFlags = normalizeFeatureFlags(res.flags);
          saveCache();
          renderFeatureFlags();
          applyFeatureFlags();
          setStatus('Feature flags updated', 'success');
        } else {
          if (toggleInput) toggleInput.checked = !!currentMeta.enabled;
          setStatus('Feature flag update failed', 'error');
        }
      })
      .withFailureHandler(() => {
        if (toggleInput) {
          toggleInput.disabled = false;
          toggleInput.checked = !!currentMeta.enabled;
        }
        setStatus('Feature flag update failed', 'error');
      })
      .api_setFeatureFlag({
        feature: featureKey,
        enabled: enabled,
        name: currentMeta.name || featureKey,
        description: currentMeta.description || ''
      });
  }

  function applyFeatureFlags() {
    const rememberFlag = state.featureFlags.remember_last_page || DEFAULT_FEATURE_FLAGS.remember_last_page || { enabled: false };
    if (rememberFlag.enabled) {
      let stored = null;
      try {
        stored = localStorage.getItem(LAST_PAGE_KEY);
      } catch (e) {}
      if (!stored) {
        persistLastPage(state.currentPage);
      } else if (stored && PAGE_KEYS.includes(stored) && stored !== state.currentPage) {
        showPage(stored);
      }
    } else {
      try {
        localStorage.removeItem(LAST_PAGE_KEY);
      } catch (e) {}
    }
    updateClearCacheVisibility();
  }

  if (contractSaveBtn) {
    contractSaveBtn.onclick = handleContractSave;
  }
  if (contractCancelBtn) {
    contractCancelBtn.onclick = () => {
      clearContractForm();
    };
  }
  setContractFormMode(false);

  function updateClearCacheVisibility() {
    if (!clearCacheWrapper) return;
    const enabled = !!(state.featureFlags.show_clear_cache && state.featureFlags.show_clear_cache.enabled);
    clearCacheWrapper.style.display = enabled ? 'block' : 'none';
  }

  if (clearCacheBtn) {
    clearCacheBtn.addEventListener('click', () => {
      if (!confirm('Clear cached entries and settings from this browser?')) return;
      try {
        localStorage.removeItem(state.cacheKey);
        localStorage.removeItem(LAST_PAGE_KEY);
      } catch (e) {}
      setStatus('Local cache cleared. Data will be reloaded from the server on next sync.', 'success');
    });
  }

  // Entries & KPIs
  function minutesForDate(date) {
    return state.entries
      .filter((e) => e.date === date)
      .reduce((acc, entry) => acc + (Number(entry.duration_minutes) || 0), 0);
  }
  function renderEntries() {
    renderCalendar();
    renderCalendarDetail();
    renderContractsList();
  }
  function deleteEntry(id) {
    const idx = state.entries.findIndex((e) => e.id === id);
    if (idx === -1) return;
    const backup = state.entries[idx];
    state.entries.splice(idx, 1);
    saveCache();
    renderEntries();
    setStatus('Deleting...', 'warn');
    google.script.run
      .withSuccessHandler(() => setStatus('Deleted', 'success'))
      .withFailureHandler(() => {
        state.entries.splice(idx, 0, backup);
        saveCache();
        renderEntries();
        setStatus('Delete failed', 'error');
      })
      .api_deleteEntry(id);
  }
  function editEntry(id) {
    const entry = state.entries.find((e) => e.id === id);
    if (!entry) return;
    state.selectedCalendarDate = entry.date;
    populateManualForm(entry, true);
    renderCalendar();
    renderCalendarDetail();
  }

  // Calendar rendering
  function ensureCalendarState() {
    if (!state.calendar) {
      const today = new Date();
      state.calendar = { year: today.getFullYear(), month: today.getMonth() };
    }
    if (!state.selectedCalendarDate) {
      state.selectedCalendarDate = todayIso();
      if (!state.editingEntryId) setManualDate(state.selectedCalendarDate);
    }
  }
  function calendarStartDate(year, month) {
    const first = new Date(year, month, 1);
    const offset = (first.getDay() + 6) % 7; // shift so Monday=0
    return new Date(year, month, 1 - offset);
  }
  function minutesByDate() {
    return state.entries.reduce((map, entry) => {
      if (!entry.date) return map;
      const key = entry.date;
      map[key] = (map[key] || 0) + (Number(entry.duration_minutes) || 0);
      return map;
    }, {});
  }
  function renderCalendar() {
    ensureCalendarState();
    const totals = minutesByDate();
    const grid = document.getElementById('calendar-grid');
    const label = document.getElementById('calendar-label');
    const monthTotalEl = document.getElementById('calendar-month-total');
    const activeMonth = new Date(state.calendar.year, state.calendar.month, 1);
    label.textContent = activeMonth.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    const monthKey = `${activeMonth.getFullYear()}-${String(activeMonth.getMonth() + 1).padStart(2, '0')}`;
    const monthTotalMinutes = Object.keys(totals).reduce((acc, key) => {
      if (key.startsWith(monthKey)) {
        acc += totals[key];
      }
      return acc;
    }, 0);
    monthTotalEl.textContent = `Total hours: ${formatHours(monthTotalMinutes)}`;
    grid.innerHTML = '';
    const start = calendarStartDate(state.calendar.year, state.calendar.month);
    for (let i = 0; i < 42; i++) {
      const current = new Date(start.getFullYear(), start.getMonth(), start.getDate() + i);
      const iso = isoDate(current);
      const cell = document.createElement('div');
      cell.className = 'ts-calendar-cell';
      if (current.getMonth() !== state.calendar.month) cell.classList.add('inactive');
      if (iso === todayIso()) cell.classList.add('today');
      const totalMinutes = totals[iso] || 0;
      if (totalMinutes > 0) cell.classList.add('has-entries');
      if (iso === state.selectedCalendarDate) cell.classList.add('selected');
      const dayEl = document.createElement('div');
      dayEl.className = 'ts-calendar-day';
      dayEl.textContent = current.getDate();
      const totalEl = document.createElement('div');
      totalEl.className = 'ts-calendar-total';
      if (totalMinutes === 0) totalEl.classList.add('empty');
      totalEl.textContent = totalMinutes === 0 ? '0' : formatHours(totalMinutes);
      cell.append(dayEl, totalEl);
      cell.onclick = () => handleCalendarClick(iso);
      grid.appendChild(cell);
    }
  }
  function renderCalendarDetail() {
    ensureCalendarState();
    const detail = document.getElementById('calendar-detail');
    const title = document.getElementById('calendar-detail-date');
    const totalEl = document.getElementById('calendar-detail-total');
    const list = document.getElementById('calendar-detail-list');
    const dateIso = state.selectedCalendarDate;
    if (!dateIso) {
      detail.classList.remove('active');
      title.textContent = 'Select a day';
      totalEl.textContent = '';
      list.innerHTML = '';
      return;
    }
    detail.classList.add('active');
    const dateObj = parseIsoDate(dateIso);
    title.textContent = dateObj.toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric' });
    const entries = state.entries
      .filter((entry) => entry.date === dateIso)
      .sort((a, b) => (a.start_time || '').localeCompare(b.start_time || ''));
    const totalMinutes = entries.reduce((acc, entry) => acc + (Number(entry.duration_minutes) || 0), 0);
    totalEl.textContent = `${formatHours(totalMinutes)} hours`;
    list.innerHTML = '';
    if (!entries.length) {
      const empty = document.createElement('div');
      empty.className = 'ts-calendar-detail-empty';
      empty.textContent = 'No entries for this day yet.';
      list.appendChild(empty);
      return;
    }
    entries.forEach((entry) => {
      const el = document.createElement('div');
      el.className = 'ts-item';
      el.innerHTML = `
        <div style="flex:1;">
          <div style="display:flex; gap:8px; align-items:center;">
            <strong>${entry.start_time || '--:--'} - ${entry.end_time || '--:--'}</strong>
            <span class="ts-badge success">${fmt(entry.duration_minutes || 0)}</span>
            ${contractBadge(entry)}
            ${entry.break_minutes ? `<span class="ts-badge">Break ${entry.break_minutes}m</span>` : ''}
          </div>
        </div>
        <div>
          <button class="ghost" data-edit="${entry.id}">Edit</button>
          <button class="danger" data-del="${entry.id}" style="margin-left:6px;">Delete</button>
        </div>
      `;
      list.appendChild(el);
    });
    list.querySelectorAll('button[data-edit]').forEach((btn) => (btn.onclick = () => editEntry(btn.getAttribute('data-edit'))));
    list.querySelectorAll('button[data-del]').forEach((btn) => (btn.onclick = () => deleteEntry(btn.getAttribute('data-del'))));
  }
  function handleCalendarClick(dateIso) {
    state.selectedCalendarDate = dateIso;
    setManualDate(dateIso);
    renderCalendar();
    renderCalendarDetail();
  }
  function changeCalendarMonth(delta) {
    ensureCalendarState();
    const next = new Date(state.calendar.year, state.calendar.month + delta, 1);
    state.calendar.year = next.getFullYear();
    state.calendar.month = next.getMonth();
    if (state.selectedCalendarDate) {
      const selected = parseIsoDate(state.selectedCalendarDate);
      if (selected.getFullYear() !== state.calendar.year || selected.getMonth() !== state.calendar.month) {
        state.selectedCalendarDate = null;
      }
    }
    renderCalendar();
    renderCalendarDetail();
  }
  document.getElementById('calendar-prev').onclick = () => changeCalendarMonth(-1);
  document.getElementById('calendar-next').onclick = () => changeCalendarMonth(1);
  document.getElementById('calendar-add-entry').onclick = () => {
    ensureCalendarState();
    const date = state.selectedCalendarDate || todayIso();
    const preferredContract = manualContract ? manualContract.value : '';
    populateManualForm({ date, start_time: '', end_time: '', break_minutes: 0, contract_id: preferredContract }, false);
  };

  // Settings persistence
  const roundInput = document.getElementById('set-round');
  document.getElementById('btn-save-settings').onclick = function () {
    const next = {
      round_to_nearest: parseInt(roundInput.value || '0', 10) || 0
    };
    state.settings = { ...state.settings, ...next };
    saveCache();
    setStatus('Saving settings...', 'warn');
    google.script.run
      .withSuccessHandler(() => setStatus('Settings saved', 'success'))
      .withFailureHandler(() => setStatus('Settings failed', 'error'))
      .api_updateSettings(next);
  };

  // Initial load
  function init() {
    loadCache();
    renderEntries();
    if (roundInput) roundInput.value = state.settings.round_to_nearest || 0;
    renderContractsList();
    clearContractForm();
    refreshContractBindings();
    refreshTimerButtons();
    state.featureFlags = normalizeFeatureFlags(state.featureFlags);
    renderFeatureFlags();
    applyFeatureFlags();
    setStatus('Syncing...', 'warn');
    google.script.run
      .withSuccessHandler((entries) => {
        state.entries = (entries || []).map(sanitizeEntry);
        saveCache();
        renderEntries();
        setStatus('Synced', 'success');
      })
      .withFailureHandler(() => setStatus('Entries sync failed', 'error'))
      .api_getEntries({});
    google.script.run
      .withSuccessHandler((settings) => {
        state.settings = settings || {};
        saveCache();
        if (roundInput) roundInput.value = state.settings.round_to_nearest || 0;
      })
      .withFailureHandler(() => {})
      .api_getSettings();
    google.script.run
      .withSuccessHandler((contracts) => {
        state.contracts = (contracts || []).map(sanitizeContract);
        refreshContractBindings();
        renderContractsList();
        saveCache();
      })
      .withFailureHandler(() => setStatus('Contracts sync failed', 'error'))
      .api_getContracts();
    google.script.run
      .withSuccessHandler((flags) => {
        state.featureFlags = normalizeFeatureFlags(flags);
        saveCache();
        renderFeatureFlags();
        applyFeatureFlags();
      })
      .withFailureHandler(() => {})
      .api_getFeatureFlags();
  }
  init();
</script>
