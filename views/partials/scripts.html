<script>

  const ISO_DATE_PATTERN = /^\d{4}-\d{2}-\d{2}$/;
  function normalizeDateInput(value) {
    if (value === null || value === undefined) return '';
    if (value instanceof Date) {
      if (Number.isNaN(value.getTime())) return '';
      const year = value.getFullYear();
      const month = String(value.getMonth() + 1).padStart(2, '0');
      const day = String(value.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }
    if (typeof value === 'number') {
      return normalizeDateInput(new Date(value));
    }
    const str = String(value).trim();
    if (!str) return '';
    if (ISO_DATE_PATTERN.test(str)) return str;
    if (str.includes('T')) {
      const [dateOnly] = str.split('T');
      if (ISO_DATE_PATTERN.test(dateOnly)) return dateOnly;
    }
    const parsed = new Date(str);
    if (!Number.isNaN(parsed.getTime())) return normalizeDateInput(parsed);
    return '';
  }

  const isoDate = (value) => normalizeDateInput(value);

  const normalizeHolidayDate = (value) => {
    if (!value && value !== 0) return '';
    if (value instanceof Date) return isoDate(value);
    if (typeof value === 'number') return isoDate(new Date(value));
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (trimmed === '') return '';
      if (!trimmed.includes('T')) return trimmed;
      const parsed = new Date(trimmed);
      if (!Number.isNaN(parsed.getTime())) {
        return isoDate(parsed);
      }
      return trimmed.split('T')[0];
    }
    return '';
  };

  const isoDateTime = (date) => new Date(date).toISOString().replace(/\.\d{3}Z$/, 'Z');

  const parseIsoDate = (value) => {
    const normalized = normalizeDateInput(value);
    if (!normalized) return null;
    const [y, m, d] = normalized.split('-').map(Number);
    return new Date(y, m - 1, d);
  };

  const todayIso = () => isoDate(new Date());
  const MONTH_ABBREVIATIONS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const WEEKDAY_SHORT = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  const WEEKDAY_LONG = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  const BULK_DEFAULT_DAILY_HOURS = 7.5;
  const BULK_DEFAULT_MONTHLY_HOURS = 150;
  const BULK_DEFAULT_DAILY_MINUTES = Math.round(BULK_DEFAULT_DAILY_HOURS * 60);
  const BULK_DEFAULT_MONTHLY_MINUTES = Math.round(BULK_DEFAULT_MONTHLY_HOURS * 60);

  const formatMonthShortYear = (dateObj) => {
    if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) return '';
    const month = MONTH_ABBREVIATIONS[dateObj.getMonth()] || '';
    const year = dateObj.getFullYear();
    return `${month} ${String(year).slice(-2)}`;
  };

  // Layout navigation
  const pageTime = document.getElementById('page-time');
  const pageContracts = document.getElementById('page-contracts');
  const pageHourTypes = document.getElementById('page-hour-types');
  const pageDeductions = document.getElementById('page-deductions');
  const pageBas = document.getElementById('page-bas');
  const pageAnnualViews = document.getElementById('page-annual-views');
  const pageRatePreview = document.getElementById('page-rate-preview');
  const pageSettings = document.getElementById('page-settings');
  const pageInvoices = document.getElementById('page-invoices');
  const pageAbout = document.getElementById('page-about');
  const aboutVersionDisplay = document.getElementById('about-version-display');
  const aboutVersionStatus = document.getElementById('about-version-status');
  const navToggle = document.getElementById('nav-toggle');
  const navHomeBtn = document.getElementById('nav-home');
  const navMenu = document.getElementById('nav-menu');
  const navTimeBtn = document.getElementById('nav-time');
  const navContractsBtn = document.getElementById('nav-contracts');
  const navRatePreviewBtn = document.getElementById('nav-rate-preview');
  const navHourTypesBtn = document.getElementById('nav-hour-types');
  const navDeductionsBtn = document.getElementById('nav-deductions');
  const navBasBtn = document.getElementById('nav-bas');
  const navAnnualViewsBtn = document.getElementById('nav-annual-views');
  const navInvoicesBtn = document.getElementById('nav-invoices');
  const navSettingsBtn = document.getElementById('nav-settings');
  const navDocsLink = document.getElementById('nav-docs');
  const navAboutBtn = document.getElementById('nav-about');
  const ratePreviewContractSelect = document.getElementById('rate-preview-contract');
  const ratePreviewPercentInput = document.getElementById('rate-preview-percent');
  const ratePreviewRateInput = document.getElementById('rate-preview-rate');
  const ratePreviewResetBtn = document.getElementById('rate-preview-reset');
  const ratePreviewEmpty = document.getElementById('rate-preview-empty');
  const ratePreviewContent = document.getElementById('rate-preview-content');
  const ratePreviewLoadingOverlay = document.getElementById('rate-preview-loading');
  const ratePreviewAdjustedRateEl = document.getElementById('rate-preview-adjusted-rate');
  const ratePreviewCurrentRateEl = document.getElementById('rate-preview-current-rate');
  const ratePreviewRateDeltaEl = document.getElementById('rate-preview-rate-delta');
  const ratePreviewTotalHoursEl = document.getElementById('rate-preview-total-hours');
  const ratePreviewTotalEarnScenarioEl = document.getElementById('rate-preview-total-earn-scenario');
  const ratePreviewTotalEarnCurrentEl = document.getElementById('rate-preview-total-earn-current');
  const ratePreviewTotalEarnVarianceEl = document.getElementById('rate-preview-total-earn-variance');
  const ratePreviewTotalSuperScenarioEl = document.getElementById('rate-preview-total-super-scenario');
  const ratePreviewTotalSuperCurrentEl = document.getElementById('rate-preview-total-super-current');
  const ratePreviewTotalSuperVarianceEl = document.getElementById('rate-preview-total-super-variance');
  const ratePreviewTotalTaxScenarioEl = document.getElementById('rate-preview-total-tax-scenario');
  const ratePreviewTotalTaxCurrentEl = document.getElementById('rate-preview-total-tax-current');
  const ratePreviewTotalTaxVarianceEl = document.getElementById('rate-preview-total-tax-variance');
  const ratePreviewTotalNetScenarioEl = document.getElementById('rate-preview-total-net-scenario');
  const ratePreviewTotalNetCurrentEl = document.getElementById('rate-preview-total-net-current');
  const ratePreviewTotalNetVarianceEl = document.getElementById('rate-preview-total-net-variance');
  const ratePreviewRemainingCard = document.getElementById('rate-preview-remaining-card');
  const ratePreviewRemainingScenarioEl = document.getElementById('rate-preview-remaining-scenario');
  const ratePreviewRemainingCurrentEl = document.getElementById('rate-preview-remaining-current');
const ratePreviewRemainingVarianceEl = document.getElementById('rate-preview-remaining-variance');
const ratePreviewContractHoursEl = document.getElementById('rate-preview-contract-hours');
const ratePreviewRemainingSuperScenarioEl = document.getElementById('rate-preview-remaining-super-scenario');
const ratePreviewRemainingSuperCurrentEl = document.getElementById('rate-preview-remaining-super-current');
const ratePreviewRemainingSuperVarianceEl = document.getElementById('rate-preview-remaining-super-variance');
  const ratePreviewRemainingTaxScenarioEl = document.getElementById('rate-preview-remaining-tax-scenario');
  const ratePreviewRemainingTaxCurrentEl = document.getElementById('rate-preview-remaining-tax-current');
  const ratePreviewRemainingTaxVarianceEl = document.getElementById('rate-preview-remaining-tax-variance');
  const ratePreviewRemainingNetScenarioEl = document.getElementById('rate-preview-remaining-net-scenario');
  const ratePreviewRemainingNetCurrentEl = document.getElementById('rate-preview-remaining-net-current');
  const ratePreviewRemainingNetVarianceEl = document.getElementById('rate-preview-remaining-net-variance');
  const ratePreviewSummaryFootnote = document.getElementById('rate-preview-summary-footnote');
  const ratePreviewNoEntriesNote = document.getElementById('rate-preview-no-entries');
  const ratePreviewMonthlyBody = document.getElementById('rate-preview-monthly-body');
  const invoiceConfigNote = document.getElementById('invoice-config-note');
  const invoiceSelector = document.getElementById('invoice-selector');
  const btnInvoiceNew = document.getElementById('btn-invoice-new');
  const invoiceNavPrev = document.getElementById('invoice-nav-prev');
  const invoiceNavNext = document.getElementById('invoice-nav-next');
  const invoiceNavJump = document.getElementById('invoice-nav-jump');
const invoiceDetailEmpty = document.getElementById('invoice-detail-empty');
const invoiceDetailEmptyText = document.getElementById('invoice-detail-empty-text');
  const invoiceDetail = document.getElementById('invoice-detail');
  const invoiceDetailNumberInput = document.getElementById('invoice-detail-number');
  const invoiceDetailDateInput = document.getElementById('invoice-detail-date');
  const invoiceDetailStatusSelect = document.getElementById('invoice-detail-status');
  const btnInvoiceDelete = document.getElementById('btn-invoice-delete');
  const btnInvoiceSave = document.getElementById('btn-invoice-save');
  const btnInvoiceGenerate = document.getElementById('btn-invoice-generate');
  const invoiceLineSummary = document.getElementById('invoice-line-summary');
  const invoiceLineEmpty = document.getElementById('invoice-line-empty');
  const btnInvoiceAddLine = document.getElementById('btn-invoice-add-line');
  const invoiceLineFormAnchor = document.getElementById('invoice-line-form-anchor');
  const invoiceLineForm = document.getElementById('invoice-line-form');
  const invoiceLineDateInput = document.getElementById('invoice-line-date');
  const invoiceLineDescriptionInput = document.getElementById('invoice-line-description');
  const invoiceLineAmountModeSelect = document.getElementById('invoice-line-amount-mode');
  const invoiceLineHoursInput = document.getElementById('invoice-line-hours');
  const invoiceLineContractCol = document.getElementById('invoice-line-contract-col');
  const invoiceLineHoursCol = document.getElementById('invoice-line-hours-col');
  const invoiceLineHourTypeSelect = document.getElementById('invoice-line-hour-type');
  const invoiceLineHourTypeCol = document.getElementById('invoice-line-hour-type-col');
  const invoiceLineAmountInput = document.getElementById('invoice-line-amount');
  const invoiceLineAmountCol = document.getElementById('invoice-line-amount-col');
  const invoiceLineContractSelect = document.getElementById('invoice-line-contract');
  const btnInvoiceLineCancel = document.getElementById('btn-invoice-line-cancel');
  const btnInvoiceLineSave = document.getElementById('btn-invoice-line-save');
  const invoiceLineItemsBody = document.getElementById('invoice-line-items');
  const invoiceLineSubtotal = document.getElementById('invoice-line-subtotal');
  const invoiceLineGst = document.getElementById('invoice-line-gst');
  const invoiceLineTotal = document.getElementById('invoice-line-total');
  const invoiceDefaultList = document.getElementById('invoice-default-list');
const invoiceDefaultEmpty = document.getElementById('invoice-default-empty');
  const btnInvoiceDefaultNew = document.getElementById('btn-invoice-default-new');
  const invoiceDefaultFormAnchor = document.getElementById('invoice-default-form-anchor');
  const invoiceDefaultForm = document.getElementById('invoice-default-form');
  const invoiceDefaultLabelInput = document.getElementById('invoice-default-label');
  const invoiceDefaultDescriptionInput = document.getElementById('invoice-default-description');
  const invoiceDefaultAmountModeSelect = document.getElementById('invoice-default-amount-mode');
  const invoiceDefaultHoursInput = document.getElementById('invoice-default-hours');
  const invoiceDefaultAmountInput = document.getElementById('invoice-default-amount');
  const invoiceDefaultHourTypeSelect = document.getElementById('invoice-default-hour-type');
  const invoiceDefaultHourTypeCol = document.getElementById('invoice-default-hour-type-col');
  const invoiceDefaultContractCol = document.getElementById('invoice-default-contract-col');
  const invoiceDefaultAmountCol = document.getElementById('invoice-default-amount-col');
  const invoiceDefaultHoursCol = document.getElementById('invoice-default-hours-col');
  const invoiceDefaultContractSelect = document.getElementById('invoice-default-contract');
  const invoiceDefaultTemplateCol = document.getElementById('invoice-default-template-col');
  const invoiceDefaultTemplateSelect = document.getElementById('invoice-default-template');
  const btnInvoiceDefaultCancel = document.getElementById('btn-invoice-default-cancel');
  const btnInvoiceDefaultSave = document.getElementById('btn-invoice-default-save');
  const invoiceLineTemplateCol = document.getElementById('invoice-line-template-col');
  const invoiceLineTemplateSelect = document.getElementById('invoice-line-template');
  const invoiceTemplateInput = document.getElementById('set-invoice-template');
  const invoiceOutputFolderInput = document.getElementById('set-invoice-output-folder');
  const invoiceLineLimitInput = document.getElementById('set-invoice-line-limit');
  const invoiceHoursLabelInput = document.getElementById('set-invoice-hours-label');
  const invoiceMonthPickerModal = document.getElementById('modal-invoice-month-picker');
  const invoiceMonthPickerYearDisplay = document.getElementById('invoice-month-picker-year-display');
  const invoiceMonthPickerYearPrev = document.getElementById('invoice-month-picker-year-prev');
  const invoiceMonthPickerYearNext = document.getElementById('invoice-month-picker-year-next');
  const invoiceMonthPickerGrid = document.getElementById('invoice-month-picker-grid');

  const deductionsListEl = document.getElementById('deductions-list');
  const deductionsEmptyEl = document.getElementById('deductions-empty');
  const deductionCompanyDisabledNote = document.getElementById('deduction-company-disabled-note');
  const btnAddDeduction = document.getElementById('btn-add-deduction');
  const btnManageDeductionCategories = document.getElementById('btn-manage-deduction-categories');
  const deductionCategoryCollapseControls = document.getElementById('deduction-category-collapse-controls');
  const btnExpandAllDeductionCategories = document.getElementById('btn-expand-all-deduction-categories');
  const btnCollapseAllDeductionCategories = document.getElementById('btn-collapse-all-deduction-categories');
  const deductionFormModal = document.getElementById('modal-deduction-form');
  const deductionFormTitle = document.getElementById('deduction-form-title');
  const deductionNameInput = document.getElementById('deduction-name');
  const deductionCategorySelect = document.getElementById('deduction-category');
  const deductionCategoryColumn = document.getElementById('deduction-category-column');
const deductionCategoryEmptyNote = document.getElementById('deduction-category-empty-note');
  const deductionTypeSelect = document.getElementById('deduction-type');
  const deductionAmountInput = document.getElementById('deduction-amount');
  const deductionPercentInput = document.getElementById('deduction-percent');
  const deductionAmountModeWrapper = document.getElementById('deduction-amount-mode-wrapper');
  const deductionAmountModeSelect = document.getElementById('deduction-amount-mode');
  const deductionAmountWrapper = document.getElementById('deduction-amount-wrapper');
  const deductionPercentWrapper = document.getElementById('deduction-percent-wrapper');
  const deductionGstWrapper = document.getElementById('deduction-gst-wrapper');
  const deductionGstToggle = document.getElementById('deduction-gst');
  const deductionCompanyWrapper = document.getElementById('deduction-company-wrapper');
  const deductionCompanyToggle = document.getElementById('deduction-company-expense');
  const deductionCompanyGstNote = document.getElementById('deduction-company-gst-note');
  const deductionFrequencySelect = document.getElementById('deduction-frequency');
  const deductionStartDateInput = document.getElementById('deduction-start-date');
  const deductionEndDateInput = document.getElementById('deduction-end-date');
  const deductionEndDateWrapper = document.getElementById('deduction-end-date-wrapper');
  const deductionNotesInput = document.getElementById('deduction-notes');
  const deductionOccurrencePreview = document.getElementById('deduction-occurrence-preview');
  const btnCancelDeduction = document.getElementById('btn-cancel-deduction');
  const btnSaveDeduction = document.getElementById('btn-save-deduction');
  const modalDeductionCategories = document.getElementById('modal-deduction-categories');
  const deductionCategoryListWrapper = document.getElementById('deduction-category-list-wrapper');
  const deductionCategoryList = document.getElementById('deduction-category-list');
  const deductionCategoryEmptyState = document.getElementById('deduction-category-empty-state');
  const deductionCategoryFormWrapper = document.getElementById('deduction-category-form-wrapper');
  const deductionCategoryNameInput = document.getElementById('deduction-category-name');
  const deductionCategoryColorInput = document.getElementById('deduction-category-color');
  const deductionCategoryListFooter = document.getElementById('deduction-category-list-footer');
  const deductionCategoryFormFooter = document.getElementById('deduction-category-form-footer');
  const btnAddDeductionCategory = document.getElementById('btn-add-deduction-category');
  const btnCloseDeductionCategories = document.getElementById('btn-close-deduction-categories');
  const btnCancelDeductionCategory = document.getElementById('btn-cancel-deduction-category');
  const btnSaveDeductionCategory = document.getElementById('btn-save-deduction-category');
  const modalSplitDeduction = document.getElementById('modal-split-deduction');
  const openMobileViewWrapper = document.getElementById('open-mobile-view-wrapper');
  const openMobileViewBtn = document.getElementById('btn-open-mobile-view');
  const btnCancelSplit = document.getElementById('btn-cancel-split');
  const btnConfirmSplit = document.getElementById('btn-confirm-split');
  let pendingDeductionPayload = null;
  let originalDeductionForSplit = null;
  const basFySelect = document.getElementById('bas-fy-select');
  const basTableBody = document.getElementById('bas-table-body');
  const basQuarterlyNote = document.getElementById('bas-quarterly-note');
  const basEmptyNote = document.getElementById('bas-empty');
  const basInvoiceSection = document.getElementById('bas-invoice-section');
  const basInvoiceEmpty = document.getElementById('bas-invoice-empty');
  const basInvoiceEmptyText = document.getElementById('bas-invoice-empty-text');
  const basInvoiceTableBody = document.getElementById('bas-invoice-table-body');
  const RATE_PREVIEW_DEBOUNCE_MS = 350;
let ratePreviewDebounceTimer = null;
let ratePreviewInputSyncing = false;


  const state = {
    cacheKey: 'ts_cache',
    entries: [],
    settings: {},
    contracts: [],
    contractMap: {},
    hourTypes: [],
    hourTypeMap: {},
    recurringTimeEntries: [],
    recurringEntriesInitialized: false,
    recurringEntriesSyncing: false,
    recurringEntryForm: {
      editingId: '',
      draft: null,
      deleteConfirm: false
    },
    bulkEntries: [],
    bulkEntriesInitialized: false,
    bulkEntriesSyncing: false,
    bulkEntryForm: {
      editingId: '',
      draft: null,
      deleteConfirm: false
    },
    bulkEntriesSyncingEntryId: '',
    deductions: [],
    deductionCategories: [],
    deductionCategoryMap: {},
    deductionCategoryCollapse: {},
    settingsSectionCollapse: {},
    featureFlagCollapse: {},
    deductionExceptions: [],
    deductionExceptionsMap: {},
    actualIncome: [],
    actualIncomeMap: {},
    editingActualIncomeId: null,
    featureFlags: {},
    publicHolidays: [],
    publicHolidayMap: {},
    editingEntryId: null,
    editingEntryType: null,
    editingContractId: null,
    editingHourTypeId: null,
    editingDeductionId: null,
    contractFormMode: 'hidden',
    calendar: null,
    selectedCalendarDate: null,
    showZeroHours: false,
    currentPage: 'time',
    incomeSummary: null,
    incomeSummaryCache: {},
    dirtyIncomeMonths: new Set(),
    pendingTaxRequest: null,
    pendingEntryAdds: new Map(),
    pendingEntryUpdates: new Map(),
    pendingEntryDeletes: new Set(),
    selectedContractId: '',
    punchDraft: null,
    currentTab: 'manual',
    calendarFilteredHourTypes: null,
    expectedHoursSummary: null,
    potentialIncomeScenarios: {},
    potentialIncomeTaxRequests: {},
    potentialIncomeContextKey: '',
    potentialIncomeStats: null,
    potentialIncomeCache: {},
    companyTrackingEnabled: false,
    companyBasQuarterly: false,
    basCurrentFy: null,
    basSubmissions: [],
    entriesLoaded: false,
    isAutoPopulatingPublicHolidays: false,
    annualYearType: 'financial',
    annualCurrentYear: null,
    annualFilteredContracts: [],
    annualCategoryFilters: [],
    annualCategoryExpansion: {},
    annualData: null,
    invoices: [],
    invoiceMap: {},
    invoiceDefaults: [],
    invoiceDefaultMap: {},
    invoiceFilters: {
      year: '',
      month: ''
    },
    invoiceSelectedId: '',
    invoiceDetail: null,
    invoiceDetailLoading: false,
    invoiceListLoading: false,
    invoiceLineForm: {
      mode: 'hidden',
      editingId: null,
      draft: {},
      amountMode: 'hours'
    },
    invoiceDefaultForm: {
      mode: 'hidden',
      editingId: null,
      draft: {},
      amountMode: 'hours'
    },
    invoicePending: {
      savingInvoice: false,
      generating: false
    },
    invoicesInitialized: false,
    loadingTiers: {
      tier1Complete: false,
      tier2Complete: false,
      tier3Complete: false,
      tier4Complete: false,
      features: {
        hourTypes: { loaded: false, loading: false, lastUpdate: null },
        basSubmissions: { loaded: false, loading: false, lastUpdate: null },
        invoices: { loaded: false, loading: false, lastUpdate: null },
        publicHolidays: { loaded: false, loading: false, lastUpdate: null },
        recurringEntries: { loaded: false, loading: false, lastUpdate: null },
        deductionCategories: { loaded: false, loading: false, lastUpdate: null }
      }
    },
    incomeCacheMetadata: {},
    lazyLoadQueue: {
      monthsToCalculate: [],
      currentlyCalculating: null,
      progressiveLoadComplete: false
    },
    annualCharts: {
      income: null,
      incomePie: null,
      contractPie: null,
      hourTypesPie: null,
      totalHoursPie: null,
      totalHoursByTypePie: null
    },
    contractCharts: {
      monthlyHours: null
    },
    ratePreview: {
      selectedContractId: '',
      data: null,
      loading: false,
      requestToken: 0,
      inputs: {
        percentChange: null,
        newRate: null
      }
    }
  };

  let mobileViewUrl = '';
  if (openMobileViewWrapper && openMobileViewBtn) {
    google.script.run
      .withSuccessHandler((url) => {
        if (!url) return;
        mobileViewUrl = url + '?view=mobile';
        openMobileViewWrapper.style.display = 'flex';
      })
      .api_getWebAppUrl();

    openMobileViewBtn.addEventListener('click', () => {
      if (!mobileViewUrl) return;
      window.open(mobileViewUrl, '_blank', 'noopener');
    });
  }

  const deductionFormState = {
    mode: 'create',
    editingId: null,
    original: null
  };

  function createDefaultLoadingTiers() {
    return {
      tier1Complete: false,
      tier2Complete: false,
      tier3Complete: false,
      tier4Complete: false,
      features: {
        hourTypes: { loaded: false, loading: false, lastUpdate: null },
        basSubmissions: { loaded: false, loading: false, lastUpdate: null },
        invoices: { loaded: false, loading: false, lastUpdate: null },
        publicHolidays: { loaded: false, loading: false, lastUpdate: null },
        recurringEntries: { loaded: false, loading: false, lastUpdate: null },
        deductionCategories: { loaded: false, loading: false, lastUpdate: null }
      }
    };
  }

  function createDefaultLazyLoadQueue() {
    return {
      monthsToCalculate: [],
      currentlyCalculating: null,
      progressiveLoadComplete: false
    };
  }

  function initializeLazyLoadingState() {
    if (!state.loadingTiers || typeof state.loadingTiers !== 'object') {
      state.loadingTiers = createDefaultLoadingTiers();
    } else {
      const defaults = createDefaultLoadingTiers().features;
      if (!state.loadingTiers.features || typeof state.loadingTiers.features !== 'object') {
        state.loadingTiers.features = createDefaultLoadingTiers().features;
      } else {
        Object.keys(defaults).forEach((feature) => {
          if (!state.loadingTiers.features[feature]) {
            state.loadingTiers.features[feature] = { ...defaults[feature] };
          } else {
            state.loadingTiers.features[feature] = {
              loaded: !!state.loadingTiers.features[feature].loaded,
              loading: false,
              lastUpdate: state.loadingTiers.features[feature].lastUpdate || null
            };
          }
        });
      }
    }
    if (!state.incomeCacheMetadata || typeof state.incomeCacheMetadata !== 'object') {
      state.incomeCacheMetadata = {};
    }
    if (!state.lazyLoadQueue || typeof state.lazyLoadQueue !== 'object') {
      state.lazyLoadQueue = createDefaultLazyLoadQueue();
    }
  }

  function resetLazyLoadQueue() {
    state.lazyLoadQueue = createDefaultLazyLoadQueue();
  }

  function updateLoadingFeatureState(feature, updates) {
    initializeLazyLoadingState();
    if (!state.loadingTiers.features[feature]) {
      state.loadingTiers.features[feature] = { loaded: false, loading: false, lastUpdate: null };
    }
    state.loadingTiers.features[feature] = {
      ...state.loadingTiers.features[feature],
      ...updates
    };
  }

  function hydrateLoadingTierCache(raw) {
    if (!raw || typeof raw !== 'object') return;
    initializeLazyLoadingState();
    if (raw.features && typeof raw.features === 'object') {
      Object.keys(raw.features).forEach((feature) => {
        const source = raw.features[feature] || {};
        state.loadingTiers.features[feature] = {
          loaded: !!source.loaded,
          loading: false,
          lastUpdate: source.lastUpdate || null
        };
      });
    }
  }

  function serializeLoadingTierCache() {
    const features = {};
    if (state.loadingTiers && state.loadingTiers.features) {
      Object.keys(state.loadingTiers.features).forEach((feature) => {
        const meta = state.loadingTiers.features[feature] || {};
        features[feature] = {
          loaded: !!meta.loaded,
          lastUpdate: meta.lastUpdate || null
        };
      });
    }
    return { features };
  }

  const deductionCategoryFormState = {
    mode: 'list',
    editingId: null
  };

  state.recurringEntryForm.draft = defaultRecurringDraft();
  state.bulkEntryForm.draft = defaultBulkDraft();

  let entriesSyncInFlight = false;

  function recordPendingEntryAdd(entry) {
    if (!entry || !entry.id) return;
    state.pendingEntryAdds.set(String(entry.id), {
      entry,
      timestamp: Date.now()
    });
  }

  function updatePendingEntryAddId(previousId, nextEntry) {
    if (!previousId && !nextEntry) return;
    if (previousId != null) {
      state.pendingEntryAdds.delete(String(previousId));
    }
    if (nextEntry && nextEntry.id) {
      state.pendingEntryAdds.set(String(nextEntry.id), {
        entry: nextEntry,
        timestamp: Date.now()
      });
    }
  }

  function resolvePendingEntryAdd(id) {
    if (id == null) return;
    state.pendingEntryAdds.delete(String(id));
  }

  function recordPendingEntryUpdate(id, entry) {
    if (id == null || !entry) return;
    state.pendingEntryUpdates.set(String(id), {
      entry,
      timestamp: Date.now()
    });
  }

  function resolvePendingEntryUpdate(id) {
    if (id == null) return;
    state.pendingEntryUpdates.delete(String(id));
  }

  function recordPendingEntryDelete(id) {
    if (id == null) return;
    state.pendingEntryDeletes.add(String(id));
  }

  function resolvePendingEntryDelete(id) {
    if (id == null) return;
    state.pendingEntryDeletes.delete(String(id));
  }

  function buildEntryHashMap(entries) {
    const buckets = {};
    (entries || []).forEach((entry) => {
      if (!entry || !entry.date) return;
      const monthKey = monthKeyFromDateIso(entry.date);
      if (!monthKey) return;
      if (!buckets[monthKey]) buckets[monthKey] = [];
      buckets[monthKey].push(entry);
    });
    const hashes = {};
    Object.keys(buckets).forEach((monthKey) => {
      hashes[monthKey] = calculateEntryListHash(buckets[monthKey]);
    });
    return hashes;
  }

  function reconcileIncomeMetadataWithEntries(previousEntries, nextEntries) {
    ensureIncomeCacheStructures();
    const prevHashes = buildEntryHashMap(previousEntries);
    const nextHashes = buildEntryHashMap(nextEntries);
    const monthKeys = new Set([...Object.keys(prevHashes), ...Object.keys(nextHashes)]);
    monthKeys.forEach((monthKey) => {
      const before = prevHashes[monthKey] || '';
      const after = nextHashes[monthKey] || '';
      if (before !== after) {
        markMonthDirty(monthKey);
        if (!state.incomeCacheMetadata[monthKey]) state.incomeCacheMetadata[monthKey] = {};
        state.incomeCacheMetadata[monthKey].entryHash = after;
      }
    });
  }

  function mergeEntriesWithServerEntries(freshEntries) {
    const previousEntries = Array.isArray(state.entries) ? state.entries.slice() : [];
    const serverEntries = Array.isArray(freshEntries) ? freshEntries : [];
    const merged = [];
    const seenIds = new Set();
    const serverIdSet = new Set();

    serverEntries.forEach((entry) => {
      if (!entry || !entry.id) return;
      const id = String(entry.id);
      serverIdSet.add(id);
      if (state.pendingEntryDeletes.has(id)) {
        return;
      }

      const pendingAdd = state.pendingEntryAdds.get(id);
      if (pendingAdd && pendingAdd.entry) {
        if (!seenIds.has(id)) {
          merged.push(pendingAdd.entry);
          seenIds.add(id);
        }
        state.pendingEntryAdds.delete(id);
        return;
      }

      const pendingUpdate = state.pendingEntryUpdates.get(id);
      if (pendingUpdate && pendingUpdate.entry) {
        if (!seenIds.has(id)) {
          merged.push(pendingUpdate.entry);
          seenIds.add(id);
        }
        state.pendingEntryUpdates.delete(id);
        return;
      }

      if (!seenIds.has(id)) {
        merged.push(entry);
        seenIds.add(id);
      }
    });

    state.entries.forEach((entry) => {
      if (!entry || !entry.id) return;
      const id = String(entry.id);
      if (seenIds.has(id)) return;
      if (state.pendingEntryDeletes.has(id)) return;
      const isTemp = id.startsWith('temp_');
      const hasPendingAdd = state.pendingEntryAdds.has(id);
      if (isTemp || hasPendingAdd) {
        merged.push(entry);
        seenIds.add(id);
        if (hasPendingAdd) state.pendingEntryAdds.delete(id);
        return;
      }
      if (state.pendingEntryUpdates.has(id)) {
        merged.push(entry);
        seenIds.add(id);
        state.pendingEntryUpdates.delete(id);
      }
    });

    state.pendingEntryDeletes.forEach((id) => {
      if (!serverIdSet.has(id)) {
        state.pendingEntryDeletes.delete(id);
      }
    });

    merged.sort(entrySort);
    state.entries = merged;
    reconcileIncomeMetadataWithEntries(previousEntries, merged);
  }

  function entrySort(a, b) {
    const dateA = a && a.date ? String(a.date) : '';
    const dateB = b && b.date ? String(b.date) : '';
    if (dateA !== dateB) {
      return dateB.localeCompare(dateA);
    }
    const minutesA = entryFirstPunchMinutes(a);
    const minutesB = entryFirstPunchMinutes(b);
    if (minutesA !== minutesB) {
      return minutesA - minutesB;
    }
    const idA = a && a.id ? String(a.id) : '';
    const idB = b && b.id ? String(b.id) : '';
    return idA.localeCompare(idB);
  }

  let loadingDeductionCategories = false;
  let deductionCategoryDeleteId = null;
  let deductionCategorySavePending = false;

  const PAGE_KEYS = ['time', 'contracts', 'rate-preview', 'hour-types', 'deductions', 'bas', 'annual-views', 'invoices', 'settings', 'about'];
  const LAST_PAGE_KEY = 'ts_last_page';
  const SCRIPT_ID_CACHE_KEY = 'ts_script_id';

  function persistLastPage(page) {
    if (!PAGE_KEYS.includes(page)) return;
    try {
      if (state.featureFlags.remember_last_page) {
        localStorage.setItem(LAST_PAGE_KEY, page);
      } else {
        localStorage.removeItem(LAST_PAGE_KEY);
      }
    } catch (e) {}
  }

  async function showPage(target, options) {
    const opts = options || {};
    const normalized = PAGE_KEYS.includes(target) ? target : 'time';

    // Check if leaving settings page with unsaved changes
    if (state.currentPage === 'settings' && normalized !== 'settings') {
      if (typeof checkSettingsDirty === 'function' && checkSettingsDirty()) {
        const confirmed = await customConfirm(
          'You have unsaved changes in Settings. Do you want to discard them and continue?',
          {
            title: 'Unsaved Changes',
            okText: 'Discard and Continue',
            cancelText: 'Stay on Settings',
            danger: true
          }
        );
        if (!confirmed) {
          return; // Stay on settings page
        }
        // Discard changes and continue
        if (typeof resetSettingsToInitial === 'function') {
          resetSettingsToInitial();
        }
      }
    }

    const pages = {
      time: pageTime,
      contracts: pageContracts,
      'rate-preview': pageRatePreview,
      'hour-types': pageHourTypes,
      deductions: pageDeductions,
      bas: pageBas,
      'annual-views': pageAnnualViews,
      invoices: pageInvoices,
      settings: pageSettings,
      about: pageAbout
    };
    Object.keys(pages).forEach((key) => {
      const page = pages[key];
      if (page) page.style.display = key === normalized ? 'block' : 'none';
    });
    state.currentPage = normalized;
    if (normalized === 'bas') {
      renderBasReporting();
    }
    if (normalized === 'rate-preview') {
      renderRatePreviewPage();
    }
    if (normalized === 'annual-views') {
      renderAnnualViews();
    }
    if (normalized === 'invoices') {
      renderInvoicesPage();
    }
    if (normalized === 'about') {
      loadScriptId();
      loadBuildMeta();
    }
    if (!opts.skipRemember) {
      persistLastPage(normalized);
    }
  }

  function loadScriptId() {
    const scriptIdDisplay = document.getElementById('script-id-display');
    const scriptIdValue = document.getElementById('script-id-value');
    const scriptIdUpdate = document.getElementById('script-id-update');
    const scriptIdClone = document.getElementById('script-id-clone');

    if (!scriptIdDisplay && !scriptIdValue && !scriptIdUpdate && !scriptIdClone) {
      return;
    }

    const applyScriptId = (id) => {
      if (scriptIdDisplay) scriptIdDisplay.textContent = id;
      if (scriptIdValue) scriptIdValue.textContent = id;
      if (scriptIdUpdate) scriptIdUpdate.textContent = id;
      if (scriptIdClone) scriptIdClone.textContent = id;
    };

    const cachedId = (() => {
      try {
        return localStorage.getItem(SCRIPT_ID_CACHE_KEY);
      } catch (e) {
        return null;
      }
    })();

    if (cachedId) applyScriptId(cachedId);

    google.script.run
      .withSuccessHandler((scriptId) => {
        if (scriptId && typeof scriptId === 'string') {
          applyScriptId(scriptId);
          try {
            localStorage.setItem(SCRIPT_ID_CACHE_KEY, scriptId);
          } catch (e) {}
        }
      })
      .withFailureHandler(() => {
        if (!cachedId) {
          const fallback = '[Error loading Script ID]';
          if (scriptIdDisplay) scriptIdDisplay.textContent = fallback;
          if (scriptIdValue) scriptIdValue.textContent = 'Unable to load';
          if (scriptIdUpdate) scriptIdUpdate.textContent = fallback;
          if (scriptIdClone) scriptIdClone.textContent = fallback;
        }
      })
      .api_getScriptId();
  }

  function loadBuildMeta() {
    if (!aboutVersionDisplay) return;
    aboutVersionDisplay.textContent = 'Loading...';
    if (aboutVersionStatus) {
      aboutVersionStatus.textContent = 'Checking...';
      aboutVersionStatus.style.color = 'var(--muted)';
    }

    google.script.run
      .withSuccessHandler((meta) => {
        if (!meta || typeof meta !== 'object') {
          aboutVersionDisplay.textContent = 'Unavailable';
          return;
        }

        const buildDate = String(meta.buildDate || '').trim();
        if (!buildDate) {
          aboutVersionDisplay.textContent = 'Unavailable';
          return;
        }

        aboutVersionDisplay.textContent = 'Build date ' + buildDate;
      })
      .withFailureHandler(() => {
        aboutVersionDisplay.textContent = 'Unavailable';
      })
      .api_getBuildMeta();

    google.script.run
      .withSuccessHandler((result) => {
        if (!aboutVersionStatus) return;
        if (!result || (result.error && result.error.length)) {
          aboutVersionStatus.textContent = 'Status unavailable';
          aboutVersionStatus.style.color = 'var(--danger)';
          return;
        }
        if (result.hasUpdate) {
          const upstream = String(result.upstreamDate || result.upstreamTimestamp || '').trim();
          aboutVersionStatus.textContent = upstream ? 'Update available (since ' + upstream + ')' : 'Update available';
          aboutVersionStatus.style.color = 'var(--warning)';
        } else if (result.upstreamDate) {
          const dateLabel = String(result.localBuildDate || result.upstreamDate || '').trim();
          aboutVersionStatus.textContent = dateLabel ? 'Up to date (as of ' + dateLabel + ')' : 'Up to date';
          aboutVersionStatus.style.color = 'var(--success)';
        } else {
          aboutVersionStatus.textContent = 'Status unavailable';
          aboutVersionStatus.style.color = 'var(--muted)';
        }
      })
      .withFailureHandler(() => {
        if (!aboutVersionStatus) return;
        aboutVersionStatus.textContent = 'Status unavailable';
        aboutVersionStatus.style.color = 'var(--danger)';
      })
      .api_checkForUpdate();
  }

  // Backup sheet functionality
  const backupSheetBtn = document.getElementById('backup-sheet-btn');
  if (backupSheetBtn) {
    backupSheetBtn.onclick = function() {
      const originalText = backupSheetBtn.textContent;
      backupSheetBtn.disabled = true;
      backupSheetBtn.textContent = 'Creating backup...';

      google.script.run
        .withSuccessHandler((result) => {
          backupSheetBtn.disabled = false;
          backupSheetBtn.textContent = originalText;

          if (result.success) {
            setStatus('Backup created: ' + result.name, 'success');
            customAlert(
              'Your spreadsheet has been backed up successfully!\n\n' +
              'Backup name: ' + result.name + '\n\n' +
              'The backup is saved in the same folder as your original sheet.',
              { title: 'Backup Created' }
            );
          } else {
            setStatus('Backup failed: ' + result.error, 'error');
            customAlert(
              'Failed to create backup:\n\n' + result.error,
              { title: 'Backup Failed' }
            );
          }
        })
        .withFailureHandler((error) => {
          backupSheetBtn.disabled = false;
          backupSheetBtn.textContent = originalText;
          setStatus('Backup failed', 'error');
          customAlert(
            'Failed to create backup:\n\n' + error,
            { title: 'Backup Failed' }
          );
        })
        .api_backupSpreadsheet();
    };
  }

  // Copy-to-clipboard functionality for code blocks
  const copyButtons = document.querySelectorAll('.ts-copy-btn');
  copyButtons.forEach((button) => {
    button.addEventListener('click', function() {
      const codeBlock = this.parentElement.querySelector('code');
      if (!codeBlock) return;

      const textToCopy = codeBlock.textContent;
      const originalText = this.textContent;

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(textToCopy)
          .then(() => {
            this.textContent = 'Copied!';
            setTimeout(() => {
              this.textContent = originalText;
            }, 2000);
          })
          .catch((err) => {
            console.warn('Failed to copy text:', err);
            this.textContent = 'Failed';
            setTimeout(() => {
              this.textContent = originalText;
            }, 2000);
          });
      } else {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = textToCopy;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();

        try {
          document.execCommand('copy');
          this.textContent = 'Copied!';
          setTimeout(() => {
            this.textContent = originalText;
          }, 2000);
        } catch (err) {
          console.warn('Failed to copy text:', err);
          this.textContent = 'Failed';
          setTimeout(() => {
            this.textContent = originalText;
          }, 2000);
        }

        document.body.removeChild(textarea);
      }
    });
  });

  // Tab switching functionality for About page
  const tabButtons = document.querySelectorAll('.ts-tab-btn');
  tabButtons.forEach((button) => {
    button.addEventListener('click', function() {
      const targetTabId = this.getAttribute('data-tab');
      if (!targetTabId) return;

      // Get the parent tabs container to scope our selection
      const tabsContainer = this.parentElement;
      const contentContainer = tabsContainer.nextElementSibling.parentElement;

      // Remove active class from all tab buttons in this container
      tabsContainer.querySelectorAll('.ts-tab-btn').forEach((btn) => {
        btn.classList.remove('active');
      });

      // Add active class to clicked button
      this.classList.add('active');

      // Hide all tab content panels
      contentContainer.querySelectorAll('.ts-tab-content').forEach((content) => {
        content.classList.remove('active');
      });

      // Show the target tab content
      const targetContent = document.getElementById(targetTabId);
      if (targetContent) {
        targetContent.classList.add('active');
      }
    });
  });

  function closeNavMenu() {
    if (!navMenu) return;
    navMenu.hidden = true;
    if (navToggle) navToggle.setAttribute('aria-expanded', 'false');
  }

  function openNavMenu() {
    if (!navMenu) return;
    navMenu.hidden = false;
    if (navToggle) navToggle.setAttribute('aria-expanded', 'true');
  }

  function toggleNavMenu() {
    if (!navMenu) return;
    const expanded = navToggle && navToggle.getAttribute('aria-expanded') === 'true';
    if (expanded) {
      closeNavMenu();
    } else {
      openNavMenu();
    }
  }

  if (navToggle && navMenu) {
    navToggle.addEventListener('click', (event) => {
      event.stopPropagation();
      toggleNavMenu();
    });
  }

  if (navMenu) {
    navMenu.addEventListener('click', (event) => {
      if ((event.target instanceof HTMLElement) && event.target.tagName === 'BUTTON') {
        closeNavMenu();
      }
    });
  }

  document.addEventListener('click', (event) => {
    if (!navMenu || navMenu.hidden) return;
    if (navToggle && (event.target === navToggle || navToggle.contains(event.target))) return;
    if (navMenu.contains(event.target)) return;
    closeNavMenu();
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') closeNavMenu();
  });

  if (navHomeBtn) {
    navHomeBtn.addEventListener('click', async () => {
      closeNavMenu();
      await showPage('time');
      if (state.currentPage !== 'time') return;

      ensureCalendarState();
      const now = new Date();
      const previousYear = state.calendar.year;
      const targetYear = now.getFullYear();
      const targetMonth = now.getMonth();
      const yearChanged = previousYear !== targetYear;
      state.calendar.year = targetYear;
      state.calendar.month = targetMonth;

      const today = todayIso();
      if (yearChanged && getFeatureFlag('enable_public_holidays')) {
        loadPublicHolidays(true);
      }
      handleCalendarClick(today);
    });
  }

  if (navTimeBtn) navTimeBtn.onclick = () => { closeNavMenu(); showPage('time'); };
  if (navContractsBtn) navContractsBtn.onclick = () => { closeNavMenu(); showPage('contracts'); };
  if (navRatePreviewBtn) navRatePreviewBtn.onclick = () => { closeNavMenu(); showPage('rate-preview'); };
  if (navHourTypesBtn) navHourTypesBtn.onclick = () => { closeNavMenu(); showPage('hour-types'); };
  if (navDeductionsBtn) navDeductionsBtn.onclick = () => { closeNavMenu(); showPage('deductions'); };
  if (navBasBtn) navBasBtn.onclick = () => { closeNavMenu(); showPage('bas'); };
  if (navAnnualViewsBtn) navAnnualViewsBtn.onclick = () => { closeNavMenu(); showPage('annual-views'); };
  if (navInvoicesBtn) navInvoicesBtn.onclick = () => { closeNavMenu(); showPage('invoices'); };
  if (navSettingsBtn) navSettingsBtn.onclick = () => { closeNavMenu(); showPage('settings'); };
  if (navDocsLink) {
    navDocsLink.onclick = () => {
      closeNavMenu();
      window.open('https://github.com/brandonhinds/tempus/blob/main/docs/README.md', '_blank', 'noopener');
    };
  }
  if (navAboutBtn) navAboutBtn.onclick = () => { closeNavMenu(); showPage('about'); };
  if (ratePreviewContractSelect) ratePreviewContractSelect.addEventListener('change', handleRatePreviewContractChange);
  if (ratePreviewPercentInput) {
    ratePreviewPercentInput.addEventListener('input', handleRatePreviewPercentInput);
    ratePreviewPercentInput.addEventListener('blur', handleRatePreviewPercentBlur);
  }
  if (ratePreviewRateInput) {
    ratePreviewRateInput.addEventListener('input', handleRatePreviewRateInput);
    ratePreviewRateInput.addEventListener('blur', handleRatePreviewRateBlur);
  }
  if (ratePreviewResetBtn) {
    ratePreviewResetBtn.addEventListener('click', (event) => {
      event.preventDefault();
      resetRatePreviewInputs();
    });
  }
  closeNavMenu();
  showPage('time', { skipRemember: true });

  if (btnAddDeduction) {
    btnAddDeduction.addEventListener('click', () => openDeductionForm('create'));
  }
  if (btnCancelDeduction) {
    btnCancelDeduction.addEventListener('click', (event) => {
      event.preventDefault();
      closeDeductionForm();
    });
  }
  if (btnSaveDeduction) {
    btnSaveDeduction.addEventListener('click', (event) => {
      event.preventDefault();
      handleSaveDeduction();
    });
  }

  if (btnInvoiceNew) btnInvoiceNew.addEventListener('click', (event) => { event.preventDefault(); startCreateInvoice(); });
  if (invoiceSelector) invoiceSelector.addEventListener('change', (event) => {
    const invoiceId = event.target.value;
    if (invoiceId) {
      selectInvoice(invoiceId);
    } else {
      state.invoiceSelectedId = '';
      state.invoiceDetail = null;
      renderInvoiceDetail();
    }
  });
  if (invoiceNavPrev) invoiceNavPrev.addEventListener('click', () => changeInvoiceMonth(-1));
  if (invoiceNavNext) invoiceNavNext.addEventListener('click', () => changeInvoiceMonth(1));
  if (invoiceNavJump) invoiceNavJump.addEventListener('click', openInvoiceMonthPicker);
  if (invoiceMonthPickerYearPrev) invoiceMonthPickerYearPrev.addEventListener('click', () => { invoiceMonthPickerState.year--; renderInvoiceMonthPicker(); });
  if (invoiceMonthPickerYearNext) invoiceMonthPickerYearNext.addEventListener('click', () => { invoiceMonthPickerState.year++; renderInvoiceMonthPicker(); });
  if (invoiceMonthPickerModal) {
    const invoiceMonthPickerClose = invoiceMonthPickerModal.querySelector('.ts-modal-close');
    if (invoiceMonthPickerClose) {
      invoiceMonthPickerClose.addEventListener('click', closeInvoiceMonthPicker);
    }
    invoiceMonthPickerModal.addEventListener('click', (event) => {
      if (event.target === invoiceMonthPickerModal) closeInvoiceMonthPicker();
    });
  }
  if (btnInvoiceSave) btnInvoiceSave.addEventListener('click', handleInvoiceSave);
  if (btnInvoiceDelete) btnInvoiceDelete.addEventListener('click', (event) => { event.preventDefault(); handleInvoiceDelete(); });
  if (btnInvoiceGenerate) btnInvoiceGenerate.addEventListener('click', handleInvoiceGenerate);
  if (btnInvoiceAddLine) btnInvoiceAddLine.addEventListener('click', handleInvoiceAddLine);
  if (btnInvoiceLineSave) btnInvoiceLineSave.addEventListener('click', handleInvoiceLineSave);
  if (btnInvoiceLineCancel) btnInvoiceLineCancel.addEventListener('click', handleInvoiceLineCancel);
  if (invoiceLineItemsBody) invoiceLineItemsBody.addEventListener('click', handleInvoiceLineItemAction);
  if (invoiceLineAmountModeSelect) invoiceLineAmountModeSelect.addEventListener('change', handleInvoiceLineAmountModeChange);
  if (invoiceLineContractSelect) invoiceLineContractSelect.addEventListener('change', handleInvoiceLineContractChange);
  if (invoiceLineTemplateSelect) invoiceLineTemplateSelect.addEventListener('change', handleInvoiceLineTemplateChange);
  if (btnInvoiceDefaultNew) btnInvoiceDefaultNew.addEventListener('click', handleInvoiceDefaultNew);
  if (btnInvoiceDefaultCancel) btnInvoiceDefaultCancel.addEventListener('click', handleInvoiceDefaultCancel);
  if (btnInvoiceDefaultSave) btnInvoiceDefaultSave.addEventListener('click', handleInvoiceDefaultSave);
  if (invoiceDefaultList) invoiceDefaultList.addEventListener('click', handleInvoiceDefaultAction);
  if (invoiceDefaultAmountModeSelect) invoiceDefaultAmountModeSelect.addEventListener('change', handleInvoiceDefaultAmountModeChange);
  if (invoiceDefaultContractSelect) invoiceDefaultContractSelect.addEventListener('change', handleInvoiceDefaultContractChange);
  if (invoiceDefaultTemplateSelect) invoiceDefaultTemplateSelect.addEventListener('change', handleInvoiceDefaultTemplateChange);
  if (deductionTypeSelect) deductionTypeSelect.addEventListener('change', updateDeductionFormVisibility);
  if (deductionCategorySelect) deductionCategorySelect.addEventListener('change', () => {
    updateDeductionFormVisibility();
  });
  if (deductionAmountModeSelect) deductionAmountModeSelect.addEventListener('change', updateDeductionFormVisibility);
  if (deductionFrequencySelect) deductionFrequencySelect.addEventListener('change', updateDeductionFormVisibility);
  if (deductionCompanyToggle) deductionCompanyToggle.addEventListener('change', updateDeductionFormVisibility);
  if (deductionStartDateInput) deductionStartDateInput.addEventListener('change', updateDeductionOccurrencePreview);
  if (deductionEndDateInput) deductionEndDateInput.addEventListener('change', updateDeductionOccurrencePreview);
  if (basFySelect) {
    basFySelect.addEventListener('change', () => {
      state.basCurrentFy = Number(basFySelect.value);
      renderBasReporting();
    });
  }
  if (btnManageDeductionCategories) {
    btnManageDeductionCategories.addEventListener('click', (event) => {
      event.preventDefault();
      loadDeductionCategories();
      openDeductionCategoryModal();
    });
  }
  if (btnCloseDeductionCategories) {
    btnCloseDeductionCategories.addEventListener('click', (event) => {
      event.preventDefault();
      closeDeductionCategoryModal();
    });
  }
  if (btnAddDeductionCategory) {
    btnAddDeductionCategory.addEventListener('click', (event) => {
      event.preventDefault();
      showDeductionCategoryForm('create', null);
    });
  }
  if (btnCancelDeductionCategory) {
    btnCancelDeductionCategory.addEventListener('click', (event) => {
      event.preventDefault();
      hideDeductionCategoryForm();
    });
  }
  if (btnSaveDeductionCategory) {
    btnSaveDeductionCategory.addEventListener('click', handleSaveDeductionCategory);
  }
  if (btnExpandAllDeductionCategories) {
    btnExpandAllDeductionCategories.addEventListener('click', (event) => {
      event.preventDefault();
      setAllDeductionCategoryCollapse(false);
    });
  }
  if (btnCollapseAllDeductionCategories) {
    btnCollapseAllDeductionCategories.addEventListener('click', (event) => {
      event.preventDefault();
      setAllDeductionCategoryCollapse(true);
    });
  }
  if (btnCancelSplit) {
    btnCancelSplit.addEventListener('click', (event) => {
      event.preventDefault();
      hideModal(modalSplitDeduction);
      pendingDeductionPayload = null;
      originalDeductionForSplit = null;
    });
  }
  if (btnConfirmSplit) {
    btnConfirmSplit.addEventListener('click', (event) => {
      event.preventDefault();
      const splitDecisionRadios = document.getElementsByName('split-decision');
      let selectedDecision = 'split'; // default
      for (let i = 0; i < splitDecisionRadios.length; i++) {
        if (splitDecisionRadios[i].checked) {
          selectedDecision = splitDecisionRadios[i].value;
          break;
        }
      }

      hideModal(modalSplitDeduction);

      if (selectedDecision === 'split') {
        performSplitDeduction(originalDeductionForSplit, pendingDeductionPayload);
      } else {
        performOverrideDeduction(pendingDeductionPayload, originalDeductionForSplit);
      }

      // Clear state
      pendingDeductionPayload = null;
      originalDeductionForSplit = null;
    });
  }

  // Helpers

  const $ = (selector) => document.querySelector(selector);
  const $$ = (selector) => Array.from(document.querySelectorAll(selector));
  const toastContainer = document.getElementById('ts-toast-container');
  const TOAST_CLASS_MAP = {
    success: 'ts-toast--success',
    warn: 'ts-toast--warn',
    error: 'ts-toast--error',
    info: ''
  };
  const fmt = (minutes) => {
    const total = Number(minutes) || 0;
    const h = Math.floor(total / 60);
    const mm = total % 60;
    return (h > 0 ? h + ':' : '') + String(mm).padStart(2, '0');
  };
  function getStatusPreference() {
    const selectValue = statusNotificationSelect && typeof statusNotificationSelect.value === 'string'
      ? statusNotificationSelect.value.trim()
      : '';
    if (selectValue) return selectValue;
    const stateValue = (typeof state !== 'undefined' && state.settings && typeof state.settings.status_notification_mode === 'string')
      ? state.settings.status_notification_mode
      : '';
    if (stateValue) return stateValue;
    return 'status_bar';
  }

  function applyStatusDisplay() {
    const el = document.getElementById('status');
    if (!el) return;
    const mode = getStatusPreference();
    const showStatus = mode === 'status_bar' || mode === 'both';
    el.style.display = showStatus ? '' : 'none';
  }

  const setStatus = (text, cls) => {
    const mode = getStatusPreference();
    const showStatus = mode === 'status_bar' || mode === 'both';
    const showToast = mode === 'toast' || mode === 'both';
    const el = document.getElementById('status');
    if (el) {
      el.textContent = text;
      el.className = 'ts-badge ' + (cls || '');
      el.style.display = showStatus ? '' : 'none';
    }
    if (showToast && toastContainer && text) {
      const toast = document.createElement('div');
      toast.className = 'ts-toast';
      if (cls && TOAST_CLASS_MAP[cls]) {
        toast.classList.add(TOAST_CLASS_MAP[cls]);
      }
      toast.textContent = text;
      toastContainer.appendChild(toast);
      requestAnimationFrame(() => toast.classList.add('ts-toast--visible'));
      setTimeout(() => {
        toast.classList.remove('ts-toast--visible');
        setTimeout(() => toast.remove(), 200);
      }, 3200);
    }
  };
  const formatHours = (minutes) => {
    const hrs = (Number(minutes) || 0) / 60;
    let out = (Math.round(hrs * 10000) / 10000).toFixed(4);
    out = out.replace(/\.?0+$/, '');
    return out === '' ? '0' : out;
  };
  const startOfDay = (date) => new Date(date.getFullYear(), date.getMonth(), date.getDate());
  const isWeekendDate = (date) => {
    const day = date.getDay();
    return day === 0 || day === 6;
  };
  function collectBusinessDays(startDate, endDate, includeWeekends) {
    if (!(startDate instanceof Date) || Number.isNaN(startDate.getTime())) return [];
    if (!(endDate instanceof Date) || Number.isNaN(endDate.getTime())) return [];
    const start = startOfDay(startDate);
    const end = startOfDay(endDate);
    if (end < start) return [];
    const days = [];
    const cursor = new Date(start);
    while (cursor <= end) {
      if (includeWeekends || !isWeekendDate(cursor)) {
        days.push(isoDate(cursor));
      }
      cursor.setDate(cursor.getDate() + 1);
    }
    return days;
  }

  /**
   * Calculate pro-rated months between two dates
   * Returns fractional months based on actual days in each month
   * Example: Jan 15 - Mar 20 = 0.548 (Jan) + 1.0 (Feb) + 0.645 (Mar) = 2.193 months
   */
  function calculateProRatedMonths(startDate, endDate) {
    if (!(startDate instanceof Date) || Number.isNaN(startDate.getTime())) return 0;
    if (!(endDate instanceof Date) || Number.isNaN(endDate.getTime())) return 0;
    const start = startOfDay(startDate);
    const end = startOfDay(endDate);
    if (end < start) return 0;

    let totalMonths = 0;
    const cursor = new Date(start);

    while (cursor <= end) {
      const monthStart = new Date(cursor.getFullYear(), cursor.getMonth(), 1);
      const monthEnd = new Date(cursor.getFullYear(), cursor.getMonth() + 1, 0);
      const daysInMonth = monthEnd.getDate();

      // Determine the actual start and end dates within this month
      const periodStart = cursor < monthStart ? monthStart : cursor;
      const periodEnd = end < monthEnd ? end : monthEnd;

      // Count days in this month's period (inclusive)
      const daysInPeriod = Math.round((periodEnd - periodStart) / (1000 * 60 * 60 * 24)) + 1;
      const monthFraction = daysInPeriod / daysInMonth;
      totalMonths += monthFraction;

      // Move to first day of next month
      cursor.setMonth(cursor.getMonth() + 1);
      cursor.setDate(1);
    }

    return totalMonths;
  }

  /**
   * Calculate trend average hours per day using the selected method
   * Returns { averageDailyHours, method, fallbackApplied }
   */
  function calculateTrendAverage(contract, allEntries, selectedMethod, currentMonth, currentYear, currentMonthData) {
    const methods = ['standard_contract_hours', 'current_month', 'last_3_months', 'contract_lifetime', 'same_month_last_year'];
    if (!methods.includes(selectedMethod)) selectedMethod = 'standard_contract_hours';
    const methodIndex = methods.indexOf(selectedMethod);

    // Try selected method first
    let result = tryTrendMethod(contract, allEntries, selectedMethod, currentMonth, currentYear, currentMonthData);
    if (result.success) {
      return { averageDailyHours: result.average, method: selectedMethod, fallbackApplied: false };
    }

    // Fall back through methods requiring less data
    const fallbackChain = methods.slice(0, methodIndex);
    for (let i = fallbackChain.length - 1; i >= 0; i--) {
      result = tryTrendMethod(contract, allEntries, fallbackChain[i], currentMonth, currentYear, currentMonthData);
      if (result.success) {
        return { averageDailyHours: result.average, method: fallbackChain[i], fallbackApplied: true };
      }
    }

    // Ultimate fallback: current month
    return {
      averageDailyHours: currentMonthData.average,
      method: 'current_month',
      fallbackApplied: selectedMethod !== 'current_month'
    };
  }

  function tryTrendMethod(contract, allEntries, method, currentMonth, currentYear, currentMonthData) {
    switch (method) {
      case 'standard_contract_hours':
        if (Number.isFinite(currentMonthData.standardHoursPerDay) && currentMonthData.standardHoursPerDay > 0) {
          return { success: true, average: currentMonthData.standardHoursPerDay };
        }
        return { success: false };
      case 'current_month':
        return { success: true, average: currentMonthData.average };
      case 'last_3_months':
        return calculateLast3MonthsAverage(contract, allEntries, currentMonth, currentYear);
      case 'contract_lifetime':
        return calculateContractLifetimeAverage(contract, allEntries);
      case 'same_month_last_year':
        return calculateSameMonthLastYearAverage(contract, allEntries, currentMonth, currentYear);
      default:
        return { success: false };
    }
  }

  function calculateLast3MonthsAverage(contract, allEntries, currentMonth, currentYear) {
    const includeWeekends = !!contract.include_weekends;
    const months = [];

    // Get last 3 complete months (not including current month)
    for (let i = 1; i <= 3; i++) {
      let m = currentMonth - i;
      let y = currentYear;
      if (m < 0) {
        m += 12;
        y -= 1;
      }
      months.push({ month: m, year: y });
    }

    const monthData = months.map(({ month, year }) => {
      const monthKey = monthKeyFor(year, month);
      const monthEntries = allEntries.filter((e) => {
        const dateIso = getEntryDateIso(e);
        return dateIso ? dateIso.startsWith(monthKey) : false;
      });
      const incomeMinutes = monthEntries.reduce((sum, e) => sum + (Number(e.duration_minutes) || 0), 0);
      const businessDaysSet = new Set();
      monthEntries.forEach((e) => {
        const dateIso = getEntryDateIso(e);
        const dateObj = parseIsoDate(dateIso);
        if (dateObj && !Number.isNaN(dateObj.getTime())) {
          if (includeWeekends || !isWeekendDate(dateObj)) {
            businessDaysSet.add(dateIso);
          }
        }
      });
      return { hours: incomeMinutes / 60, businessDays: businessDaysSet.size };
    });

    // Check for zero-hour months at the oldest position or consecutive zeros
    const hasOldestZero = monthData.length > 0 && monthData[monthData.length - 1].hours === 0;
    let consecutiveZeros = 0;
    for (let i = monthData.length - 1; i >= 0; i--) {
      if (monthData[i].hours === 0) consecutiveZeros++;
      else break;
    }

    if (hasOldestZero || consecutiveZeros >= 2) {
      return { success: false }; // Fall back to simpler method
    }

    const totalHours = monthData.reduce((sum, d) => sum + d.hours, 0);
    const totalBusinessDays = monthData.reduce((sum, d) => sum + d.businessDays, 0);

    if (totalBusinessDays === 0) return { success: false };
    return { success: true, average: totalHours / totalBusinessDays };
  }

  function calculateContractLifetimeAverage(contract, allEntries) {
    const includeWeekends = !!contract.include_weekends;
    const contractEntries = allEntries.filter(e => e.contract_id === contract.id);

    if (!contractEntries.length) return { success: false };

    const incomeMinutes = contractEntries.reduce((sum, e) => sum + (Number(e.duration_minutes) || 0), 0);
    const businessDaysSet = new Set();
    contractEntries.forEach(e => {
      const dateIso = getEntryDateIso(e);
      const dateObj = parseIsoDate(dateIso);
      if (dateObj && !Number.isNaN(dateObj.getTime())) {
        if (includeWeekends || !isWeekendDate(dateObj)) {
          businessDaysSet.add(dateIso);
        }
      }
    });

    if (businessDaysSet.size === 0) return { success: false };
    return { success: true, average: (incomeMinutes / 60) / businessDaysSet.size };
  }

  function calculateSameMonthLastYearAverage(contract, allEntries, currentMonth, currentYear) {
    const includeWeekends = !!contract.include_weekends;
    const lastYearMonth = currentMonth;
    const lastYear = currentYear - 1;
    const monthKey = monthKeyFor(lastYear, lastYearMonth);

    const monthEntries = allEntries.filter(e => {
      if (e.contract_id !== contract.id) return false;
      const dateIso = getEntryDateIso(e);
      return dateIso ? dateIso.startsWith(monthKey) : false;
    });
    if (!monthEntries.length) return { success: false };

    const incomeMinutes = monthEntries.reduce((sum, e) => sum + (Number(e.duration_minutes) || 0), 0);
    const businessDaysSet = new Set();
    monthEntries.forEach(e => {
      const dateIso = getEntryDateIso(e);
      const dateObj = parseIsoDate(dateIso);
      if (dateObj && !Number.isNaN(dateObj.getTime())) {
        if (includeWeekends || !isWeekendDate(dateObj)) {
          businessDaysSet.add(dateIso);
        }
      }
    });

    const hours = incomeMinutes / 60;
    if (hours === 0) return { success: false }; // Zero-hour month, fall back

    if (businessDaysSet.size === 0) return { success: false };
    return { success: true, average: hours / businessDaysSet.size };
  }

  const minutesToTime = (minutes) => {
    const mins = Math.max(0, Math.round(Number(minutes) || 0));
    if (mins >= 24 * 60) return '23:59';
    const h = Math.floor(mins / 60);
    const m = mins % 60;
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
  };
  const DEFAULT_SUPER_RATE = 0.12;
  const GST_RATE = 0.1;
  const currencyFormatter = new Intl.NumberFormat(undefined, {
    style: 'currency',
    currency: 'AUD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
  const formatCurrency = (value) => {
    if (value === null || value === undefined || value === '') return '--';
    const num = Number(value);
    if (!Number.isFinite(num)) return '--';
    return currencyFormatter.format(num);
  };
  const formatSignedCurrency = (value) => {
    const num = Math.round((Number(value) || 0) * 100) / 100;
    if (num === 0) return formatCurrency(0);
    const abs = Math.abs(num);
    const formattedAbs = currencyFormatter.format(abs);
    return num > 0 ? `+${formattedAbs}` : `-${formattedAbs}`;
  };
  const formatPercentValue = (value, decimals = 2) => {
    if (!Number.isFinite(value)) return '--';
    const factor = Math.pow(10, decimals);
    const rounded = Math.round(Number(value) * factor) / factor;
    if (rounded === 0) return '0%';
    const abs = Math.abs(rounded).toFixed(decimals).replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
    return `${rounded > 0 ? '+' : '-'}${abs}%`;
  };

  // Restripe table rows based on visible rows only
  // This is needed because CSS nth-child counts hidden rows
  const restripeTable = (tableBodyId) => {
    const tbody = document.getElementById(tableBodyId);
    if (!tbody) return;

    const rows = Array.from(tbody.querySelectorAll('tr'));
    let visibleIndex = 0;

    rows.forEach((row) => {
      // Check if row is visible (not display:none)
      const isVisible = row.style.display !== 'none' && window.getComputedStyle(row).display !== 'none';

      if (isVisible) {
        // Apply stripe class to even visible rows (0-indexed, so 1, 3, 5... get striped)
        if (visibleIndex % 2 === 1) {
          row.classList.add('ts-stripe');
        } else {
          row.classList.remove('ts-stripe');
        }
        visibleIndex++;
      } else {
        // Hidden rows shouldn't have stripe class
        row.classList.remove('ts-stripe');
      }
    });
  };

  function resolveInvoiceDate(invoice) {
    if (!invoice) return null;
    if (invoice.invoice_date) {
      const parsed = new Date(invoice.invoice_date);
      if (!Number.isNaN(parsed.getTime())) {
        return parsed;
      }
    }
    if (invoice.year != null && invoice.month != null) {
      const parsedFallback = new Date(Number(invoice.year), Number(invoice.month) - 1, 1);
      if (!Number.isNaN(parsedFallback.getTime())) {
        return parsedFallback;
      }
    }
    return null;
  }

  const formatDate = (value) => {
    if (!value) return '';
    const date = value instanceof Date ? value : new Date(value);
    if (Number.isNaN(date.getTime())) return '';
    return DATE_FULL_FORMATTER.format(date);
  };
  const addDays = (date, amount) => {
    const next = new Date(date.getTime());
    next.setDate(next.getDate() + amount);
    return next;
  };
  const addMonthsClamped = (date, amount) => {
    const year = date.getFullYear();
    const month = date.getMonth();
    const day = date.getDate();
    const target = new Date(year, month + amount + 1, 0);
    const maxDay = target.getDate();
    target.setDate(Math.min(day, maxDay));
    return startOfDay(target);
  };
  const getSuperRateSetting = () => {
    const raw = state.settings ? state.settings.superannuation_rate : undefined;
    const num = Number(raw);
    if (Number.isFinite(num) && num >= 0) {
      return num > 1 ? num / 100 : num;
    }
    return DEFAULT_SUPER_RATE;
  };
  const getSuperRatePercentage = () => Math.round(getSuperRateSetting() * 1000) / 10;

  // Super Guarantee Rates Cache Functions
  const cacheSuperGuaranteeRates = (rates) => {
    try {
      localStorage.setItem('super_guarantee_rates', JSON.stringify(rates));
    } catch (e) {
      console.warn('Failed to cache super guarantee rates:', e);
    }
  };

  const getCachedSuperGuaranteeRates = () => {
    try {
      const cached = localStorage.getItem('super_guarantee_rates');
      return cached ? JSON.parse(cached) : null;
    } catch (e) {
      return null;
    }
  };

  // Get super guarantee rate for a specific date
  const getSuperGuaranteeRateForDate = (targetDate) => {
    const cached = getCachedSuperGuaranteeRates();
    const rates = cached || [];

    if (rates.length === 0) {
      // Fallback to old setting or default
      return getSuperRateSetting();
    }

    // Parse target date as yyyy-MM-dd
    const targetStr = String(targetDate).substring(0, 10);

    const matchingRates = [];
    for (const rate of rates) {
      const startDate = String(rate.start_date).substring(0, 10);
      const endDate = rate.end_date ? String(rate.end_date).substring(0, 10) : null;

      // Check if target date falls within this rate's range
      if (targetStr >= startDate) {
        if (endDate === null || targetStr <= endDate) {
          matchingRates.push(rate);
        }
      }
    }

    if (matchingRates.length === 0) {
      // No matching rate found, return default
      return DEFAULT_SUPER_RATE;
    }

    // If multiple matches, use the one with the most recent start date
    if (matchingRates.length > 1) {
      matchingRates.sort((a, b) => String(b.start_date).localeCompare(String(a.start_date)));
    }

    const percentage = matchingRates[0].percentage;
    // Convert percentage to decimal (e.g., 12 -> 0.12)
    return percentage > 1 ? percentage / 100 : percentage;
  };
  const sanitizeSuperRateInputValue = (value) => {
    const num = Number(value);
    if (Number.isFinite(num) && num >= 0) return Math.round(num * 10) / 10;
    return Math.round(DEFAULT_SUPER_RATE * 1000) / 10;
  };
  const deriveGrossFromPackage = (packageAmount, superRate) => {
    const total = Math.max(0, Number(packageAmount) || 0);
    const rate = Math.max(0, Number(superRate) || 0);
    if (!Number.isFinite(rate) || rate === 0) return total;
    const denominator = 1 + rate;
    if (denominator <= 0) return total;
    return total / denominator;
  };
  const clampRoundIntervalValue = (value) => {
    const num = Number(value);
    if (!Number.isFinite(num) || num <= 0) return 0;
    return Math.min(60, Math.max(0, num));
  };

  const getRoundInterval = () => clampRoundIntervalValue(state.settings ? state.settings.round_to_nearest : 0);

  const getTrendMethod = () => {
    const value = state.settings ? state.settings.monthly_insights_trend_method : undefined;
    const validMethods = ['standard_contract_hours', 'current_month', 'last_3_months', 'contract_lifetime', 'same_month_last_year'];
    return validMethods.includes(value) ? value : 'standard_contract_hours';
  };
  const getProjectionsVarianceValue = () => {
    const value = state.settings ? state.settings.projections_variance_value : undefined;
    const validValues = ['monthly_capacity', 'contract_pace', 'projected_vs_contract', 'projected_vs_standard'];
    return validValues.includes(value) ? value : 'monthly_capacity';
  };
  const roundDuration = (minutes) => {
    const base = Math.max(0, Math.round(Number(minutes) || 0));
    const interval = getRoundInterval();
    if (!interval) return base;
    const rounded = Math.round(base / interval) * interval;
    return Math.max(0, rounded);
  };

  const TIME_PATTERN = /^\d{2}:\d{2}$/;
  const normalizeTimeValue = (value) => {
    if (!value && value !== 0) return '';
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (TIME_PATTERN.test(trimmed)) return trimmed;
      const parsed = new Date(`1970-01-01T${trimmed}:00`);
      if (!Number.isNaN(parsed.getTime())) return parsed.toTimeString().slice(0, 5);
    } else if (value instanceof Date) {
      return value.toTimeString().slice(0, 5);
    }
    const coerced = new Date(value);
    if (!Number.isNaN(coerced.getTime())) return coerced.toTimeString().slice(0, 5);
    return '';
  };
  const timeToMinutes = (time) => {
    if (!time || !TIME_PATTERN.test(time)) return null;
    const parts = time.split(':');
    return Number(parts[0]) * 60 + Number(parts[1]);
  };
  const clonePunches = (punches) => (Array.isArray(punches) ? punches.map((p) => ({ in: p.in || '', out: p.out || '' })) : []);
  const normalizePunchList = (value) => {
    if (!value) return [];
    let source = value;
    if (typeof source === 'string') {
      try {
        source = JSON.parse(source);
      } catch (e) {
        source = [];
      }
    }
    if (!Array.isArray(source)) source = source ? [source] : [];
    const punches = source.reduce((acc, raw) => {
      if (!raw) return acc;
      const start = normalizeTimeValue(raw.in || raw.start || raw.start_time || raw.startTime);
      if (!start) return acc;
      let end = normalizeTimeValue(raw.out || raw.stop || raw.end || raw.end_time || raw.endTime);
      if (end && timeToMinutes(end) !== null && timeToMinutes(start) !== null && timeToMinutes(end) < timeToMinutes(start)) {
        end = '';
      }
      acc.push({ in: start, out: end || '' });
      return acc;
    }, []);
    punches.sort((a, b) => {
      if (a.in === b.in) return (a.out || '').localeCompare(b.out || '');
      return a.in.localeCompare(b.in);
    });
    return punches;
  };
  const summarizePunches = (punches) => {
    if (!Array.isArray(punches) || !punches.length) {
      return { totalMinutes: 0, earliest: '', latest: '', openCount: 0 };
    }
    let earliest = '';
    let latest = '';
    let total = 0;
    let openCount = 0;
    punches.forEach((punch) => {
      if (!punch || !punch.in) return;
      if (!earliest || punch.in < earliest) earliest = punch.in;
      if (punch.out) {
        if (!latest || punch.out > latest) latest = punch.out;
        const startMinutes = timeToMinutes(punch.in);
        const endMinutes = timeToMinutes(punch.out);
        if (startMinutes !== null && endMinutes !== null && endMinutes > startMinutes) {
          total += endMinutes - startMinutes;
        }
      } else {
        openCount += 1;
      }
    });
    return { totalMinutes: total, earliest, latest, openCount };
  };
  const validatePunches = (punches, options = {}) => {
    const { allowOpen = true, requireClosed = false } = options;
    const sorted = normalizePunchList(punches);
    let lastEnd = null;
    let openCount = 0;
    for (let idx = 0; idx < sorted.length; idx += 1) {
      const punch = sorted[idx];
      const startMinutes = timeToMinutes(punch.in);
      if (startMinutes === null) {
        return 'Each punch needs a valid start time.';
      }
      if (!punch.out) {
        openCount += 1;
        if (requireClosed) {
          return 'Please enter an end time for each punch.';
        }
        if (!allowOpen && openCount > 0) {
          return 'Close any open punches before saving.';
        }
        if (lastEnd !== null && startMinutes < lastEnd) {
          return 'Punch ranges cannot overlap.';
        }
        lastEnd = startMinutes;
        continue;
      }
      const endMinutes = timeToMinutes(punch.out);
      if (endMinutes === null || endMinutes <= startMinutes) {
        return 'Punch out must be later than punch in.';
      }
      if (lastEnd !== null && startMinutes < lastEnd) {
        return 'Punch ranges cannot overlap.';
      }
      lastEnd = endMinutes;
    }
    return null;
  };

  const entryPunches = (entry) => {
    if (entry && Array.isArray(entry.punches) && entry.punches.length) {
      return entry.punches.map((punch) => ({ in: punch.in || '', out: punch.out || '' }));
    }
    if (entry && entry.start_time && entry.end_time) {
      return [{ in: entry.start_time, out: entry.end_time }];
    }
    return [];
  };
  function resolveEntryType(entry) {
    if (!entry) return null;
    if (entry.entry_type) return entry.entry_type;
    const punches = entryPunches(entry);
    if (!punches.length) return 'basic';
    if (punches.length === 1 && punches[0].in === '00:00') {
      return 'basic';
    }
    return 'advanced';
  }
  const entryFirstPunchMinutes = (entry) => {
    const punches = entryPunches(entry);
    if (punches.length) {
      const mins = timeToMinutes(punches[0].in);
      if (mins !== null) return mins;
    }
    const fallback = timeToMinutes(entry && entry.start_time ? entry.start_time : '');
    return fallback !== null ? fallback : 24 * 60;
  };
  const getEntryPunchSummary = (entry) => {
    const punches = entryPunches(entry);
    if (!punches.length) {
      const start = entry && entry.start_time ? entry.start_time : '--:--';
      const end = entry && entry.end_time ? entry.end_time : '--:--';
      return `${start} - ${end}`;
    }
    const summary = summarizePunches(punches);
    const start = summary.earliest || '--:--';
    const end = summary.openCount > 0 ? 'Open' : (summary.latest || '--:--');
    return `${start} - ${end}`;
  };
  const getEntryPunchDetail = (entry) => {
    const punches = entryPunches(entry);
    if (!punches.length) return '';
    return punches.map((punch) => `${punch.in || '--:--'} - ${punch.out || 'Open'}`).join(', ');
  };

  const sanitizeEntry = (entry) => {
    if (!entry) return entry;
    const clone = { ...entry };
    const punches = normalizePunchList(clone.punches != null ? clone.punches : clone.punches_json);
    clone.punches = clonePunches(punches);
    clone.punches_json = JSON.stringify(clone.punches);
    const summary = summarizePunches(clone.punches);
    if (clone.punches.length) {
      let worked = summary.totalMinutes;
      if (clone.duration_minutes != null && Number.isFinite(Number(clone.duration_minutes))) {
        clone.duration_minutes = Math.max(0, Math.round(Number(clone.duration_minutes)));
      } else {
        clone.duration_minutes = Math.max(0, Math.round(worked));
      }
    } else {
      clone.duration_minutes = Math.max(0, Math.round(Number(clone.duration_minutes) || 0));
    }
    clone.open_punch_count = summary.openCount || 0;
    delete clone.break;
    delete clone.description;
    const contractId = clone.contract_id || clone.contractId || clone.project || '';
    clone.contract_id = contractId ? String(contractId).trim() : '';
    delete clone.project;
    delete clone.contractId;
    const recurrenceId = clone.recurrence_id || clone.recurrenceId || '';
    clone.recurrence_id = recurrenceId ? String(recurrenceId).trim() : '';
    delete clone.recurrenceId;
    // Preserve entry_type if it exists
    if (clone.entry_type) {
      clone.entry_type = String(clone.entry_type).trim();
    }
    return clone;
  };

  const sanitizeContract = (contract) => {
    if (!contract) return contract;
    const clone = { ...contract };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.start_date = clone.start_date || clone.startDate || '';
    clone.end_date = clone.end_date || clone.endDate || '';
    clone.hourly_rate = Number(clone.hourly_rate != null ? clone.hourly_rate : 0);
    if (Number.isNaN(clone.hourly_rate)) clone.hourly_rate = 0;
    clone.total_hours = Number(clone.total_hours != null ? clone.total_hours : (clone.totalHours != null ? clone.totalHours : 0));
    if (Number.isNaN(clone.total_hours) || clone.total_hours < 0) clone.total_hours = 0;
    clone.include_weekends = Boolean(
      clone.include_weekends === true ||
      clone.include_weekends === 'TRUE' ||
      String(clone.include_weekends != null ? clone.include_weekends : '').toLowerCase() === 'true'
    );
    delete clone.startDate;
    delete clone.endDate;
    delete clone.hourlyRate;
    delete clone.totalHours;
    return clone;
  };

  const sanitizeHourType = (hourType) => {
    if (!hourType) return hourType;
    const clone = { ...hourType };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.slug = clone.slug ? String(clone.slug).trim() : '';
    clone.color = clone.color ? String(clone.color).trim() : '#6b7280';
    clone.contributes_to_income = Boolean(clone.contributes_to_income === 'TRUE' || clone.contributes_to_income === true);
    clone.requires_contract = Boolean(clone.requires_contract === 'TRUE' || clone.requires_contract === true);
    clone.is_default = Boolean(clone.is_default === 'TRUE' || clone.is_default === true);
    clone.use_for_rate_calculation = Boolean(clone.use_for_rate_calculation === 'TRUE' || clone.use_for_rate_calculation === true);
    clone.auto_populate_public_holidays = Boolean(
      clone.auto_populate_public_holidays === 'TRUE' || clone.auto_populate_public_holidays === true
    );
    const autoHours = Number(clone.auto_populate_hours != null ? clone.auto_populate_hours : 0);
    clone.auto_populate_hours = Number.isFinite(autoHours) && autoHours > 0 ? autoHours : 0;
    clone.created_at = clone.created_at || '';
    const orderValue = Number(clone.display_order);
    clone.display_order = Number.isFinite(orderValue) ? orderValue : null;
    return clone;
  };

  const sanitizeRecurringEntry = (entry) => {
    if (!entry) return null;
    const clone = { ...entry };
    clone.id = clone.id ? String(clone.id) : '';
    clone.label = clone.label ? String(clone.label).trim() : '';
    clone.recurrence_type = clone.recurrence_type === 'monthly' ? 'monthly' : 'weekly';
    const weeklyInterval = Number(clone.weekly_interval);
    clone.weekly_interval = Number.isFinite(weeklyInterval) && weeklyInterval > 0 ? Math.floor(weeklyInterval) : 1;
    const weekdays = Array.isArray(clone.weekly_weekdays) ? clone.weekly_weekdays.slice() : [];
    clone.weekly_weekdays = weekdays
      .map((day) => Number(day))
      .filter((day) => Number.isInteger(day) && day >= 0 && day <= 6);
    const monthlyInterval = Number(clone.monthly_interval);
    clone.monthly_interval = Number.isFinite(monthlyInterval) && monthlyInterval > 0 ? Math.floor(monthlyInterval) : 1;
    clone.monthly_mode = clone.monthly_mode === 'weekday_of_month' ? 'weekday_of_month' : 'day_of_month';
    const monthlyDay = Number(clone.monthly_day);
    clone.monthly_day = Number.isFinite(monthlyDay) && monthlyDay >= 1 ? Math.min(31, Math.floor(monthlyDay)) : 1;
    const monthlyWeek = Number(clone.monthly_week);
    clone.monthly_week = Number.isFinite(monthlyWeek) && monthlyWeek >= 1 ? Math.min(5, Math.floor(monthlyWeek)) : 1;
    const monthlyWeekday = Number(clone.monthly_weekday);
    clone.monthly_weekday = Number.isFinite(monthlyWeekday) ? ((Math.floor(monthlyWeekday) % 7) + 7) % 7 : 1;
    const duration = Number(clone.duration_minutes);
    clone.duration_minutes = Number.isFinite(duration) && duration > 0 ? Math.floor(duration) : 0;
    clone.contract_id = clone.contract_id ? String(clone.contract_id) : '';
    clone.hour_type_id = clone.hour_type_id ? String(clone.hour_type_id) : '';
    clone.start_date = clone.start_date || '';
    clone.end_date = clone.end_date || '';
    clone.generated_until = clone.generated_until || '';
    clone.warning_message = clone.warning_message || '';
    return clone;
  };

  const sanitizeBulkEntry = (entry) => {
    if (!entry) return null;
    const clone = { ...entry };
    clone.id = clone.id ? String(clone.id) : '';
    clone.label = clone.label ? String(clone.label).trim() : '';
    clone.distribution_mode = clone.distribution_mode === 'monthly' ? 'monthly' : 'daily';
    const monthlyTotal = Number(clone.monthly_total_minutes);
    clone.monthly_total_minutes = Number.isFinite(monthlyTotal) && monthlyTotal > 0 ? Math.floor(monthlyTotal) : 0;
    const duration = Number(clone.duration_minutes);
    const normalizedDuration = Number.isFinite(duration) && duration > 0 ? Math.floor(duration) : 0;
    if (clone.distribution_mode === 'monthly') {
      clone.duration_minutes = normalizedDuration > 0 && clone.monthly_total_minutes <= 0 ? normalizedDuration : 0;
      if (clone.monthly_total_minutes <= 0 && normalizedDuration > 0) {
        clone.monthly_total_minutes = normalizedDuration;
        clone.duration_minutes = 0;
      }
    } else {
      clone.duration_minutes = normalizedDuration;
      clone.monthly_total_minutes = 0;
    }
    clone.contract_id = clone.contract_id ? String(clone.contract_id) : '';
    clone.hour_type_id = clone.hour_type_id ? String(clone.hour_type_id) : '';
    clone.start_date = clone.start_date || '';
    clone.end_date = clone.end_date || '';
    clone.include_weekends = clone.include_weekends === true || clone.include_weekends === 'TRUE';
    clone.skip_public_holidays = clone.skip_public_holidays === false || clone.skip_public_holidays === 'FALSE' ? false : true;
    clone.last_synced_at = clone.last_synced_at || '';
    const syncedCount = Number(clone.last_synced_count);
    clone.last_synced_count = Number.isFinite(syncedCount) && syncedCount >= 0 ? syncedCount : 0;
    clone.warning_message = clone.warning_message || '';
    return clone;
  };

  function hasFutureRecurringEntries(recurrenceId) {
    if (!recurrenceId) return false;
    const today = todayIso();
    return state.entries.some((entry) => entry && entry.recurrence_id === recurrenceId && entry.date && entry.date >= today);
  }

  function deleteFutureEntriesForSchedule(recurrenceId, options = {}) {
    if (!recurrenceId) return Promise.resolve();
    const cutoff = options.fromDate ? isoDate(options.fromDate) : todayIso();
    const silent = !!options.silent;
    const previousEntries = state.entries.slice();
    const filtered = previousEntries.filter((entry) => {
      if (!entry || entry.recurrence_id !== recurrenceId) return true;
      if (!entry.date) return false;
      return entry.date < cutoff;
    });
    const changed = filtered.length !== previousEntries.length;
    if (changed) {
      state.entries = filtered;
      markAllIncomeSummariesDirty();
      renderEntries();
      renderCalendar();
      saveCache();
      renderRecurringEntriesList();
    }
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(() => {
          if (!silent) setStatus('Future entries deleted', 'success');
          renderRecurringEntriesList();
          resolve();
        })
        .withFailureHandler((error) => {
          if (changed) {
            state.entries = previousEntries;
            markAllIncomeSummariesDirty();
            renderEntries();
            renderCalendar();
            saveCache();
            renderRecurringEntriesList();
          }
          if (!silent) setStatus('Failed to delete future entries', 'error');
          reject(error);
        })
        .api_deleteFutureRecurringEntries({
          recurrenceId: recurrenceId,
          fromDate: cutoff
        });
    });
  }

  function cloneRecurringEntries(list) {
    return Array.isArray(list) ? list.map((item) => ({ ...item })) : [];
  }

  function upsertRecurringEntryLocal(entry) {
    const sanitized = sanitizeRecurringEntry(entry);
    if (!sanitized || !sanitized.id) return;
    const idx = state.recurringTimeEntries.findIndex((item) => item.id === sanitized.id);
    if (idx === -1) {
      state.recurringTimeEntries = [...state.recurringTimeEntries, sanitized];
    } else {
      state.recurringTimeEntries[idx] = sanitized;
    }
  }

  function removeRecurringEntryLocal(id) {
    if (!id) return;
    state.recurringTimeEntries = state.recurringTimeEntries.filter((item) => item.id !== id);
  }

  function defaultRecurringDraft() {
    const today = todayIso();
    const dateObj = parseIsoDate(today) || new Date();
    const weekday = dateObj.getDay();
    const weekIndex = Math.floor((dateObj.getDate() - 1) / 7) + 1;
    return {
      id: '',
      label: '',
      recurrence_type: 'weekly',
      weekly_interval: 1,
      weekly_weekdays: [weekday],
      monthly_interval: 1,
      monthly_mode: 'day_of_month',
      monthly_day: dateObj.getDate(),
      monthly_week: Math.min(5, weekIndex),
      monthly_weekday: weekday,
      duration_minutes: 450,
      contract_id: '',
      hour_type_id: getDefaultHourTypeId() || '',
      start_date: today,
      end_date: '',
      generated_until: '',
      warning_message: ''
    };
  }

  function defaultBulkDraft() {
    const today = todayIso();
    return {
      id: '',
      label: '',
      duration_minutes: BULK_DEFAULT_DAILY_MINUTES,
      monthly_total_minutes: BULK_DEFAULT_MONTHLY_MINUTES,
      distribution_mode: 'daily',
      contract_id: '',
      hour_type_id: getDefaultHourTypeId() || '',
      start_date: today,
      end_date: today,
      include_weekends: false,
      skip_public_holidays: true,
      last_synced_at: '',
      last_synced_count: 0,
      warning_message: ''
    };
  }

  function describeRecurringEntry(entry) {
    if (!entry) return '';
    if (entry.recurrence_type === 'monthly') {
      return describeMonthlyRecurringEntry(entry);
    }
    return describeWeeklyRecurringEntry(entry);
  }

  function describeWeeklyRecurringEntry(entry) {
    const interval = Number(entry.weekly_interval) || 1;
    const intervalText = interval === 1 ? 'Every week' : `Every ${interval} weeks`;
    const weekdays = (entry.weekly_weekdays || []).map((day) => WEEKDAY_LONG[day]).filter(Boolean);
    const weekdayText = weekdays.length ? weekdays.join(', ') : 'selected days';
    return `${intervalText} on ${weekdayText}`;
  }

  function describeMonthlyRecurringEntry(entry) {
    const interval = Number(entry.monthly_interval) || 1;
    const intervalText = interval === 1 ? 'Every month' : `Every ${interval} months`;
    if (entry.monthly_mode === 'weekday_of_month') {
      const ordinalMap = ['First', 'Second', 'Third', 'Fourth', 'Last'];
      const ordinal = ordinalMap[Math.max(0, Math.min(4, (Number(entry.monthly_week) || 1) - 1))];
      const weekday = WEEKDAY_LONG[((Number(entry.monthly_weekday) || 0) + 7) % 7];
      return `${intervalText} on the ${ordinal} ${weekday || 'weekday'}`;
    }
    const day = Math.min(31, Math.max(1, Number(entry.monthly_day) || 1));
    return `${intervalText} on day ${day}`;
  }

  function describeBulkEntry(entry) {
    if (!entry) return '';
    if (entry.distribution_mode === 'monthly' && entry.start_date) {
      const monthDate = parseIsoDate(entry.start_date);
      if (monthDate) {
        return formatMonthShortYear(monthDate);
      }
    }
    const start = entry.start_date ? formatFriendlyDate(entry.start_date) : '';
    const end = entry.end_date ? formatFriendlyDate(entry.end_date) : '';
    if (start && end) return `${start}  ${end}`;
    return start || end || '';
  }

  function getMonthBoundsFromValue(value) {
    if (!value || !/^\d{4}-\d{2}$/.test(value)) return null;
    const parts = value.split('-');
    const year = Number(parts[0]);
    const monthIndex = Number(parts[1]) - 1;
    if (!Number.isFinite(year) || !Number.isFinite(monthIndex)) return null;
    const start = new Date(year, monthIndex, 1);
    const end = new Date(year, monthIndex + 1, 0);
    return { start: isoDate(start), end: isoDate(end) };
  }

  function getDefaultBulkMonthValue(draft) {
    const source = draft && draft.start_date ? draft.start_date : todayIso();
    return source ? source.slice(0, 7) : todayIso().slice(0, 7);
  }

  function applyBulkMonthSelection(value, updateDraftDates = true) {
    if (!value) return;
    if (bulkMonthInput) bulkMonthInput.value = value;
    const bounds = getMonthBoundsFromValue(value);
    if (!bounds) return;
    const parts = value.split('-');
    const year = Number(parts[0]);
    if (Number.isFinite(year)) {
      bulkMonthPickerState.year = year;
    }
    if (bulkStartDateInput) bulkStartDateInput.value = bounds.start;
    if (bulkEndDateInput) bulkEndDateInput.value = bounds.end;
    if (updateDraftDates && state.bulkEntryForm.draft) {
      state.bulkEntryForm.draft.start_date = bounds.start;
      state.bulkEntryForm.draft.end_date = bounds.end;
    }
    populateBulkContractOptions(bulkContractSelect ? bulkContractSelect.value : '');
    renderBulkMonthPicker(value);
  }

  function syncBulkMonthInputFromDates() {
    if (!bulkMonthInput || !bulkStartDateInput) return;
    const start = bulkStartDateInput.value;
    if (start && start.length >= 7) {
      const value = start.slice(0, 7);
      bulkMonthInput.value = value;
      const year = Number(value.split('-')[0]);
      if (Number.isFinite(year)) {
        bulkMonthPickerState.year = year;
      }
      renderBulkMonthPicker(value);
    }
  }

  function updateBulkDistributionUI(draft) {
    const mode = draft && draft.distribution_mode ? draft.distribution_mode : (bulkHoursModeSelect ? bulkHoursModeSelect.value : 'daily');
    if (bulkHoursModeSelect && bulkHoursModeSelect.value !== mode) {
      bulkHoursModeSelect.value = mode;
    }
    const isMonthly = mode === 'monthly';
    if (bulkHoursLabelText) bulkHoursLabelText.textContent = isMonthly ? 'Monthly hours' : 'Hours per day';
    if (bulkMonthWrapper) bulkMonthWrapper.style.display = isMonthly ? 'block' : 'none';
    if (bulkDateRangeRow) bulkDateRangeRow.style.display = isMonthly ? 'none' : 'grid';
    if (bulkStartDateWrapper) bulkStartDateWrapper.style.display = isMonthly ? 'none' : 'block';
    if (bulkEndDateWrapper) bulkEndDateWrapper.style.display = isMonthly ? 'none' : 'block';
    if (isMonthly) {
      let monthValue = bulkMonthInput && bulkMonthInput.value ? bulkMonthInput.value : '';
      if (!monthValue) {
        monthValue = getDefaultBulkMonthValue(draft);
      }
      applyBulkMonthSelection(monthValue, !!draft);
    } else {
      renderBulkMonthPicker('');
    }
    const desiredContract = state.bulkEntryForm && state.bulkEntryForm.draft
      ? state.bulkEntryForm.draft.contract_id
      : (bulkContractSelect ? bulkContractSelect.value : '');
    populateBulkContractOptions(desiredContract);
  }

  function renderBulkMonthPicker(selectedValue) {
    if (!bulkMonthGrid || !bulkMonthYearDisplay) return;
    const currentYear = Number.isFinite(bulkMonthPickerState.year) ? bulkMonthPickerState.year : (new Date()).getFullYear();
    bulkMonthPickerState.year = currentYear;
    const selection = selectedValue && /^\d{4}-\d{2}$/.test(selectedValue)
      ? selectedValue
      : (bulkMonthInput && /^\d{4}-\d{2}$/.test(bulkMonthInput.value) ? bulkMonthInput.value : '');
    const selectedParts = selection ? selection.split('-') : null;
    const selectedYear = selectedParts ? Number(selectedParts[0]) : null;
    const selectedMonth = selectedParts ? Number(selectedParts[1]) - 1 : null;
    bulkMonthYearDisplay.textContent = currentYear;
    bulkMonthGrid.innerHTML = '';
    for (let i = 0; i < MONTH_ABBREVIATIONS.length; i++) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'ts-month-picker-cell';
      btn.textContent = MONTH_ABBREVIATIONS[i];
      if (selectedYear === currentYear && selectedMonth === i) {
        btn.classList.add('active');
      }
      btn.addEventListener('click', () => {
        const value = `${bulkMonthPickerState.year}-${String(i + 1).padStart(2, '0')}`;
        applyBulkMonthSelection(value, true);
      });
      bulkMonthGrid.appendChild(btn);
    }
  }

  function buildRecurringPreview(entry, limit = 5) {
    const sanitized = sanitizeRecurringEntry(entry);
    if (!sanitized) return [];
    const startIso = sanitized.start_date || todayIso();
    let cursor = parseIsoDate(startIso) || new Date();
    cursor = new Date(cursor.getFullYear(), cursor.getMonth(), cursor.getDate());
    const results = [];
    const horizon = sanitized.recurrence_type === 'weekly' ? 200 : 600;
    const endCursor = new Date(cursor.getTime());
    endCursor.setDate(endCursor.getDate() + horizon);
    const anchorDate = parseIsoDate(sanitized.start_date) || cursor;
    const hardStop = sanitized.end_date ? parseIsoDate(sanitized.end_date) : null;
    while (cursor <= endCursor && results.length < limit) {
      if (hardStop && cursor > hardStop) break;
      const dateIso = isoDate(cursor);
      let shouldInclude = false;
      if (sanitized.recurrence_type === 'weekly') {
        shouldInclude = matchesWeeklyPreview(sanitized, cursor, anchorDate);
      } else {
        shouldInclude = matchesMonthlyPreview(sanitized, cursor, anchorDate);
      }
      if (shouldInclude && dateIso >= (sanitized.start_date || dateIso)) {
        results.push(dateIso);
      }
      cursor.setDate(cursor.getDate() + 1);
    }
    return results;
  }

  function matchesWeeklyPreview(entry, dateObj, anchorDate) {
    const weekdays = entry.weekly_weekdays || [];
    if (!weekdays.length) return false;
    const diffDays = Math.floor((startOfDay(dateObj) - startOfDay(anchorDate)) / (24 * 60 * 60 * 1000));
    if (diffDays < 0) return false;
    const weekIndex = Math.floor(diffDays / 7);
    if (weekIndex % entry.weekly_interval !== 0) return false;
    const weekday = dateObj.getDay();
    return weekdays.indexOf(weekday) !== -1;
  }

  function matchesMonthlyPreview(entry, dateObj, anchorDate) {
    const diffMonths = monthsBetween(anchorDate, dateObj);
    if (diffMonths < 0) return false;
    if (diffMonths % entry.monthly_interval !== 0) return false;
    if (entry.monthly_mode === 'weekday_of_month') {
      const weekday = dateObj.getDay();
      if (weekday !== (((entry.monthly_weekday || 0) + 7) % 7)) return false;
      const weekOfMonth = Math.floor((dateObj.getDate() - 1) / 7) + 1;
      if (entry.monthly_week === 5) {
        return isLastWeekdayOfMonth(dateObj);
      }
      return weekOfMonth === entry.monthly_week;
    }
    const day = Math.min(31, Math.max(1, entry.monthly_day));
    const daysInMonthCount = new Date(dateObj.getFullYear(), dateObj.getMonth() + 1, 0).getDate();
    const targetDay = Math.min(day, daysInMonthCount);
    return dateObj.getDate() === targetDay;
  }

  const getDisplayOrderValue = (item) => {
    if (!item) return Number.POSITIVE_INFINITY;
    const value = Number(item.display_order);
    return Number.isFinite(value) ? value : Number.POSITIVE_INFINITY;
  };

  const compareByDisplayOrder = (a, b, options = {}) => {
    const orderA = getDisplayOrderValue(a);
    const orderB = getDisplayOrderValue(b);
    if (orderA !== orderB) return orderA - orderB;
    if (options.activeFirst && a && b && (a.active !== b.active)) {
      return a.active ? -1 : 1;
    }
    const nameA = String(a && a.name ? a.name : '');
    const nameB = String(b && b.name ? b.name : '');
    return nameA.localeCompare(nameB);
  };

  const reorderByIds = (list, ids) => {
    if (!Array.isArray(list)) return [];
    if (!Array.isArray(ids) || !ids.length) return list.slice();
    const map = new Map(list.map((item) => [item.id, item]));
    const ordered = [];
    ids.forEach((id) => {
      const entry = map.get(id);
      if (entry) {
        ordered.push(entry);
        map.delete(id);
      }
    });
    map.forEach((remaining) => ordered.push(remaining));
    return ordered;
  };

  function monthsBetween(startDate, targetDate) {
    if (!(startDate instanceof Date) || Number.isNaN(startDate.getTime())) return 0;
    if (!(targetDate instanceof Date) || Number.isNaN(targetDate.getTime())) return 0;
    const start = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
    const end = new Date(targetDate.getFullYear(), targetDate.getMonth(), 1);
    return (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
  }

  function isLastWeekdayOfMonth(dateObj) {
    const probe = new Date(dateObj.getTime());
    probe.setDate(probe.getDate() + 7);
    return probe.getMonth() !== dateObj.getMonth();
  }

  const sanitizeDeductionCategory = (category) => {
    if (!category) return category;
    const clone = { ...category };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    const color = clone.color ? String(clone.color).trim() : '#6b7280';
    clone.color = /^#([0-9a-fA-F]{6})$/.test(color) ? color.toLowerCase() : '#6b7280';
    clone.created_at = clone.created_at || '';
    clone.updated_at = clone.updated_at || '';
    return clone;
  };

  const sanitizeDeduction = (deduction) => {
    if (!deduction) return deduction;
    const clone = { ...deduction };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.category_id = clone.category_id ? String(clone.category_id).trim() : '';
    if (clone.category_id === 'company' || clone.category_id === 'personal') {
      clone.category_id = '';
    }
    clone.company_expense = Boolean(clone.company_expense === true || clone.company_expense === 'TRUE');
    clone.deduction_type = clone.deduction_type === 'extra_super' ? 'extra_super' : 'standard';
    clone.amount_type = clone.amount_type === 'percent' ? 'percent' : 'flat';
    let amountValue = Number(clone.amount_value);
    if (!Number.isFinite(amountValue) || amountValue < 0) amountValue = 0;
    if (clone.amount_type === 'percent' && amountValue > 1) {
      amountValue = amountValue / 100;
    }
    clone.amount_value = amountValue;
    clone.gst_inclusive = Boolean(clone.gst_inclusive === true || clone.gst_inclusive === 'TRUE');
    clone.gst_amount = Number(clone.gst_amount) || 0;
    clone.frequency = DEDUCTION_FREQUENCIES.includes(clone.frequency) ? clone.frequency : 'once';
    clone.start_date = clone.start_date ? String(clone.start_date) : '';
    clone.end_date = clone.end_date ? String(clone.end_date) : '';
    clone.notes = clone.notes ? String(clone.notes) : '';
    clone.active = clone.active !== false;
    clone.created_at = clone.created_at || '';
    clone.updated_at = clone.updated_at || '';
    const orderValue = Number(clone.display_order);
    clone.display_order = Number.isFinite(orderValue) ? orderValue : null;
    return clone;
  };

  const sanitizeDeductionException = (exception) => {
    if (!exception) return exception;
    const clone = { ...exception };
    clone.id = clone.id ? String(clone.id) : '';
    clone.deduction_id = clone.deduction_id ? String(clone.deduction_id) : '';
    clone.original_date = clone.original_date ? String(clone.original_date) : '';
    clone.exception_type = ['skip', 'move', 'adjust_amount', 'move_and_adjust'].includes(clone.exception_type)
      ? clone.exception_type
      : 'skip';
    clone.new_date = clone.new_date ? String(clone.new_date) : '';
    clone.new_amount = Number(clone.new_amount) || 0;
    clone.notes = clone.notes ? String(clone.notes).trim() : '';
    clone.created_at = clone.created_at || '';
    clone.updated_at = clone.updated_at || '';
    return clone;
  };

  function nextOccurrenceDate(current, frequency) {
    if (!current) return null;
    switch (frequency) {
      case 'weekly':
        return addDays(current, 7);
      case 'fortnightly':
        return addDays(current, 14);
      case 'monthly':
        return addMonthsClamped(current, 1);
      case 'quarterly':
        return addMonthsClamped(current, 3);
      case 'yearly':
        return addMonthsClamped(current, 12);
      default:
        return null;
    }
  }

  function advanceOccurrenceTo(startDate, frequency, targetDate, endDate) {
    if (!startDate) return null;
    if (frequency === 'once') {
      return startDate;
    }
    var current = startDate;
    var safety = 0;
    while (current < targetDate && safety < 1000) {
      var next = nextOccurrenceDate(current, frequency);
      if (!next) return current;
      // Stop if advancing would go past the configured end datethere are no later occurrences to include.
      if (endDate && next > endDate) return null;
      if (next.getTime() === current.getTime()) return next;
      current = next;
      safety++;
    }
    return current;
  }

  function getDeductionOccurrencesBetween(deduction, rangeStart, rangeEnd, limit) {
    const occurrences = [];
    if (!deduction || !deduction.start_date) return occurrences;
    const startSource = parseIsoDate(deduction.start_date);
    if (!startSource || Number.isNaN(startSource.getTime())) return occurrences;
    let current = startOfDay(startSource);
    const endBoundary = deduction.end_date ? parseIsoDate(deduction.end_date) : null;
    const endDate = endBoundary ? startOfDay(endBoundary) : null;
    const frequency = deduction.frequency || 'once';
    const hasRangeStart = !!rangeStart;
    const hasRangeEnd = !!rangeEnd;
    const rangeStartDate = hasRangeStart ? startOfDay(rangeStart) : null;
    const rangeEndDate = hasRangeEnd ? startOfDay(rangeEnd) : null;

    if (rangeStartDate && current < rangeStartDate && frequency !== 'once') {
      current = advanceOccurrenceTo(current, frequency, rangeStartDate, endDate);
    }

    const maxIterations = 1000;
    let iterations = 0;
    while (current && iterations < maxIterations) {
      if (rangeStartDate && current < rangeStartDate) {
        // Occurrence is before range start; skip but continue advancing unless once
      } else if (!rangeEndDate || current <= rangeEndDate) {
        occurrences.push(startOfDay(current));
      } else {
        break;
      }

      if (limit && occurrences.length >= limit) break;
      if (frequency === 'once') break;

      const next = nextOccurrenceDate(current, frequency);
      if (!next) break;
      if (endDate && next > endDate) break;
      if (next.getTime() === current.getTime()) break;
      current = next;
      iterations++;
    }

    return occurrences;
  }

  function getDeductionPreviewDates(deduction, limit) {
    const occurrences = getDeductionOccurrencesBetween(
      deduction,
      parseIsoDate(deduction.start_date),
      deduction.end_date ? parseIsoDate(deduction.end_date) : null,
      limit || 5
    );
    return occurrences.map((occ) => isoDate(occ));
  }

  function getUpcomingDeductionDates(deduction, limit) {
    const today = startOfDay(new Date());
    const occurrences = getDeductionOccurrencesBetween(
      deduction,
      today,
      deduction.end_date ? parseIsoDate(deduction.end_date) : null,
      limit || 5
    );
    return occurrences.map((occ) => isoDate(occ));
  }

  function formatFrequencyLabel(frequency) {
    switch (frequency) {
      case 'weekly':
        return 'Weekly';
      case 'fortnightly':
        return 'Fortnightly';
      case 'monthly':
        return 'Monthly';
      case 'quarterly':
        return 'Quarterly';
      case 'yearly':
        return 'Yearly';
      case 'once':
      default:
        return 'One-off';
    }
  }

  /**
   * Get exceptions for a specific deduction
   */
  function getDeductionExceptions(deductionId) {
    if (!deductionId) return [];
    return state.deductionExceptions.filter(ex => ex.deduction_id === deductionId);
  }

  /**
   * Apply exceptions to occurrence dates
   * Returns array of occurrence objects with exception info
   */
  function applyExceptionsToOccurrences(occurrenceDates, deductionId, rangeStart, rangeEnd, exceptionsOverride) {
    const startIso = rangeStart ? isoDate(rangeStart) : null;
    const endIso = rangeEnd ? isoDate(rangeEnd) : null;
    const exceptions = Array.isArray(exceptionsOverride)
      ? exceptionsOverride
      : getDeductionExceptions(deductionId);
    const debugPrefix = '';

    const result = [];
    const seenKeys = new Set();

    const addOccurrence = (occ) => {
      if (!occ || !occ.date) return;
      if (startIso && occ.date < startIso) return;
      if (endIso && occ.date > endIso) return;
      const key = occ.date + '|' + (occ.originalDate || '');
      if (seenKeys.has(key)) return;
      seenKeys.add(key);
      result.push(occ);
    };

    if (Array.isArray(occurrenceDates) && occurrenceDates.length) {
      const exceptionMap = {};
      exceptions.forEach((ex) => {
        if (ex && ex.original_date) {
          exceptionMap[ex.original_date] = ex;
        }
      });

      occurrenceDates.forEach((dateObj) => {
        const dateStr = isoDate(dateObj);
        const exception = exceptionMap[dateStr];

        if (exception) {
          if (exception.exception_type === 'skip') {
            return;
          }
          if (exception.exception_type === 'move' && exception.new_date) {
            addOccurrence({
              date: exception.new_date,
              originalDate: dateStr,
              amount: null,
              hasException: true,
              exceptionType: 'move'
            });
            return;
          }
          if (exception.exception_type === 'move_and_adjust' && exception.new_date) {
            addOccurrence({
              date: exception.new_date,
              originalDate: dateStr,
              amount: Number(exception.new_amount) || 0,
              hasException: true,
              exceptionType: 'move_and_adjust'
            });
            return;
          }
          if (exception.exception_type === 'adjust_amount') {
            addOccurrence({
              date: dateStr,
              amount: Number(exception.new_amount) || 0,
              hasException: true,
              exceptionType: 'adjust_amount'
            });
            return;
          }
        }

        addOccurrence({
          date: dateStr,
          amount: null,
          hasException: false,
          exceptionType: null
        });
      });
    }

    // Include moved occurrences whose original dates were outside the requested range
    if (Array.isArray(exceptions) && exceptions.length) {
      exceptions.forEach((ex) => {
        if (!ex || !ex.new_date) return;
        if (ex.exception_type !== 'move' && ex.exception_type !== 'move_and_adjust') return;
        addOccurrence({
          date: ex.new_date,
          originalDate: ex.original_date || null,
          amount: ex.exception_type === 'move_and_adjust' ? (Number(ex.new_amount) || 0) : null,
          hasException: true,
          exceptionType: ex.exception_type
        });
      });
    }

    result.sort((a, b) => a.date.localeCompare(b.date));
    return result;
  }

  /**
   * Get deduction occurrences with exceptions applied
   * Returns array of occurrence objects
   */
  function getDeductionOccurrencesWithExceptions(deduction, rangeStart, rangeEnd, limit, exceptionsOverride) {
    if (!deduction) return [];

    // Get base occurrences
    const baseOccurrences = getDeductionOccurrencesBetween(deduction, rangeStart, rangeEnd, limit);

    // Apply exceptions
    return applyExceptionsToOccurrences(baseOccurrences, deduction.id, rangeStart, rangeEnd, exceptionsOverride);
  }

  function formatDeductionAmount(deduction) {
    if (deduction.amount_type === 'percent') {
      const pct = Math.round((deduction.amount_value * 100) * 100) / 100;
      return `${pct}% of gross income`;
    }
    const value = (deduction.company_expense && deduction.gst_inclusive)
      ? deduction.amount_value / (1 + GST_RATE)
      : deduction.amount_value;
    const rounded = Math.round((Number(value) || 0) * 100) / 100;
    return formatCurrency(rounded);
  }

  function computeMonthlyDeductionTotals(year, month) {
    const result = {
      standardTotal: 0,
      personalStandardTotal: 0,
      companyStandardTotal: 0,
      companyGstTotal: 0,
      extraSuperFlat: 0,
      extraSuperPercentRate: 0
    };
    if (!Array.isArray(state.deductions) || !state.deductions.length) return result;
    const monthStart = startOfDay(new Date(year, month, 1));
    const monthEnd = startOfDay(new Date(year, month + 1, 0));
    state.deductions.forEach((deduction) => {
      if (!deduction || deduction.active === false) return;
      const occurrences = getDeductionOccurrencesWithExceptions(deduction, monthStart, monthEnd);
      if (!occurrences.length) return;
      if (deduction.deduction_type === 'extra_super') {
        if (deduction.amount_type === 'percent') {
          result.extraSuperPercentRate += deduction.amount_value * occurrences.length;
        } else {
          // Sum up all occurrences, using adjusted amount if present
          occurrences.forEach(occ => {
            const amount = occ.amount !== null ? occ.amount : deduction.amount_value;
            result.extraSuperFlat += amount;
          });
        }
        return;
      }
      if (deduction.amount_type === 'percent') {
        return;
      }

      // Process each occurrence individually to handle amount adjustments
      occurrences.forEach(occ => {
        const baseAmount = occ.amount !== null ? occ.amount : deduction.amount_value;
        let netAmount = baseAmount;
        if (deduction.gst_inclusive) {
          netAmount = baseAmount / (1 + GST_RATE);
        }

        result.standardTotal += netAmount;
        if (deduction.company_expense) {
          result.companyStandardTotal += netAmount;
          if (deduction.gst_inclusive) {
            const gstComponent = baseAmount - (baseAmount / (1 + GST_RATE));
            result.companyGstTotal += gstComponent;
          }
        } else {
          result.personalStandardTotal += netAmount;
        }
      });
    });
    return result;
  }

  function collectFinancialYears() {
    const allYears = collectAllYears();
    const years = Array.isArray(allYears.financial) ? [...allYears.financial] : [];
    if (!years.length) {
      years.push(financialYearStartYear(new Date()));
    }
    return years;
  }

  function formatBasRow(label, values, fyYear, quarter, month) {
    const submittedIndicator = values.submitted ? '<span style="color:var(--success); font-weight:600;">\u2713</span>' : '';
    const rowClass = values.hasActivity ? 'bas-row-clickable' : '';
    const dataAttrs = [];
    if (fyYear) dataAttrs.push(`data-fy="${fyYear}"`);
    if (quarter) dataAttrs.push(`data-quarter="${quarter}"`);
    if (month) dataAttrs.push(`data-month="${month}"`);
    const dataAttrsStr = dataAttrs.length ? dataAttrs.join(' ') : '';

    return `
      <tr class="${rowClass}" ${dataAttrsStr} style="${rowClass ? 'cursor:pointer;' : ''}">
        <td>${label}</td>
        <td style="text-align:center;">${submittedIndicator}</td>
        <td>${formatCurrency(values.invoiceTotal)}</td>
        <td>${formatCurrency(values.invoiceGst)}</td>
        <td>${formatCurrency(values.companyIncome)}</td>
        <td>${formatCurrency(values.companyExpenses)}</td>
        <td>${formatCurrency(values.companyExpensesGst)}</td>
        <td>${formatCurrency(values.employeeGrossIncome)}</td>
        <td>${formatCurrency(values.employeeSuper)}</td>
        <td>${formatCurrency(values.employeeDeductions)}</td>
        <td>${formatCurrency(values.employeeTax)}</td>
        <td>${formatCurrency(values.employeeNetIncome)}</td>
      </tr>
    `;
  }

  function buildMonthlyBasRows(fyStartYear) {
    const months = getFinancialYearMonths(fyStartYear);
    return months.map(({ year, month }) => {
      const summary = buildIncomeSummary(year, month);
      const companyIncome = summary.companyIncome || 0;
      const invoiceTotal = summary.invoiceTotal || 0;
      const companyExpenses = summary.companyExpenses || 0;
      const companyExpensesGst = summary.companyExpensesGst || 0;
      const employeeGross = summary.grossIncome || 0;
      const employeeSuper = (summary.superGuarantee || 0) + (summary.extraSuper || 0);
      const employeeDeductions = summary.otherDeductions || 0;
      const tax = summary.tax != null ? summary.tax : 0;
      const netIncome = summary.netIncome != null ? summary.netIncome : Math.max(0, (summary.taxableIncome || 0) - tax);
      const invoiceGst = invoiceTotal - companyIncome;
      return {
        label: MONTH_YEAR_FORMATTER.format(new Date(year, month, 1)),
        year,
        month,
        invoiceTotal,
        invoiceGst,
        companyIncome,
        companyExpenses,
        companyExpensesGst,
        employeeGrossIncome: employeeGross,
        employeeSuper,
        employeeDeductions,
        employeeTax: tax,
        employeeNetIncome: netIncome,
        hasActivity: invoiceTotal > 0.01 || companyExpenses > 0.01 || employeeGross > 0.01 || employeeDeductions > 0.01 || employeeSuper > 0.01
      };
    });
  }

  function buildQuarterlyBasRows(monthRows) {
    const labels = ['Q1 (JulSep)', 'Q2 (OctDec)', 'Q3 (JanMar)', 'Q4 (AprJun)'];
    const quarters = [];
    for (let i = 0; i < 4; i += 1) {
      const slice = monthRows.slice(i * 3, i * 3 + 3);
      const totals = slice.reduce((acc, row) => {
        acc.invoiceTotal += row.invoiceTotal;
        acc.invoiceGst += row.invoiceGst;
        acc.companyIncome += row.companyIncome;
        acc.companyExpenses += row.companyExpenses;
        acc.companyExpensesGst += row.companyExpensesGst;
        acc.employeeGrossIncome += row.employeeGrossIncome;
        acc.employeeSuper += row.employeeSuper;
        acc.employeeDeductions += row.employeeDeductions;
        acc.employeeTax += row.employeeTax;
        acc.employeeNetIncome += row.employeeNetIncome;
        acc.hasActivity = acc.hasActivity || row.hasActivity;
        return acc;
      }, {
        invoiceTotal: 0,
        invoiceGst: 0,
        companyIncome: 0,
        companyExpenses: 0,
        companyExpensesGst: 0,
        employeeGrossIncome: 0,
        employeeSuper: 0,
        employeeDeductions: 0,
        employeeTax: 0,
        employeeNetIncome: 0,
        hasActivity: false
      });
      totals.label = labels[i] || `Q${i + 1}`;
      totals.quarter = i + 1; // Add quarter number for identification
      quarters.push(totals);
    }
    return quarters;
  }

  function renderBasReporting() {
    if (!pageBas) return;
    if (!state.companyTrackingEnabled) {
      if (basTableBody) basTableBody.innerHTML = '';
      if (basEmptyNote) basEmptyNote.style.display = 'none';
      if (basQuarterlyNote) basQuarterlyNote.style.display = 'none';
      if (basInvoiceSection) basInvoiceSection.style.display = 'none';
      return;
    }

    if (getFeatureFlag('enable_invoices') && !state.invoiceListLoading && !state.invoices.length) {
      loadInvoicesList();
    }

    const years = collectFinancialYears();
    if (!years.length) years.push(financialYearStartYear(new Date()));
    years.sort((a, b) => a - b);
    const latestYear = years[years.length - 1];
    if (!state.basCurrentFy || !years.includes(state.basCurrentFy)) {
      state.basCurrentFy = latestYear;
    }

    if (basFySelect) {
      basFySelect.innerHTML = years.map((year) => `<option value="${year}">${financialYearLabel(year)}</option>`).join('');
      basFySelect.value = String(state.basCurrentFy);
    }

    const monthRows = buildMonthlyBasRows(state.basCurrentFy);
    const dataset = state.companyBasQuarterly ? buildQuarterlyBasRows(monthRows) : monthRows;
    const hasActivity = dataset.some((row) => row.hasActivity);

    // Merge BAS submission data into dataset
    dataset.forEach((row) => {
      const submission = state.basSubmissions.find(s => {
        if (s.financial_year !== state.basCurrentFy) return false;
        if (state.companyBasQuarterly) {
          return s.period_type === 'quarterly' && s.quarter === row.quarter;
        } else {
          return s.period_type === 'monthly' && s.month === row.month;
        }
      });
      if (submission) {
        row.submitted = submission.submitted;
      }
    });

    if (basQuarterlyNote) basQuarterlyNote.style.display = state.companyBasQuarterly ? 'block' : 'none';
    if (basEmptyNote) basEmptyNote.style.display = hasActivity ? 'none' : 'block';

    if (basTableBody) {
      const bodyHtml = dataset
        .filter((row) => row.hasActivity || hasActivity) // keep blank rows when overall activity exists
        .map((row) => {
          const fyYear = state.basCurrentFy;
          const quarter = state.companyBasQuarterly ? row.quarter : null;
          const month = !state.companyBasQuarterly ? row.month : null;
          return formatBasRow(row.label, row, fyYear, quarter, month);
        })
        .join('');
      basTableBody.innerHTML = bodyHtml || '<tr><td colspan="12" style="text-align:center; padding:16px;">No company activity recorded.</td></tr>';

      // Add click handlers to clickable rows
      attachBasRowClickHandlers();
    }

    renderBasInvoiceTable();
  }

  function renderBasInvoiceTable() {
    if (!basInvoiceSection || !basInvoiceTableBody || !basInvoiceEmpty) return;
    if (!state.companyTrackingEnabled) {
      basInvoiceSection.style.display = 'none';
      return;
    }
    if (!getFeatureFlag('enable_invoices')) {
      basInvoiceSection.style.display = 'none';
      return;
    }
    basInvoiceSection.style.display = 'block';
    if (state.invoiceListLoading && !state.invoices.length) {
      basInvoiceEmpty.style.display = 'block';
      if (basInvoiceEmptyText) basInvoiceEmptyText.textContent = 'Loading invoices...';
      basInvoiceTableBody.innerHTML = '';
      return;
    }
    const fyYear = state.basCurrentFy;
    if (!fyYear) {
      basInvoiceEmpty.style.display = 'block';
      if (basInvoiceEmptyText) basInvoiceEmptyText.textContent = 'Select a financial year to view invoices.';
      basInvoiceTableBody.innerHTML = '';
      return;
    }
    const invoiceEntries = getInvoicesForFinancialYear(fyYear);
    if (!invoiceEntries.length) {
      basInvoiceEmpty.style.display = 'block';
      if (basInvoiceEmptyText) basInvoiceEmptyText.textContent = 'No invoices for this financial year.';
      basInvoiceTableBody.innerHTML = '';
      return;
    }
    basInvoiceEmpty.style.display = 'none';
    const rowsHtml = invoiceEntries.map(({ summary }) => {
      return [
        '<tr>',
        `<td>${summary.numberLabel}</td>`,
        `<td>${summary.dateLabel}</td>`,
        `<td>${summary.statusLabel}</td>`,
        `<td style="text-align:right;">${summary.lineCount}</td>`,
        `<td style="text-align:right;">${formatDecimalHours(summary.totalHours)}</td>`,
        `<td style="text-align:right;">${formatCurrency(summary.subtotal)}</td>`,
        `<td style="text-align:right;">${formatCurrency(summary.gstValue)}</td>`,
        `<td style="text-align:right;">${formatCurrency(summary.totalValue)}</td>`,
        '</tr>'
      ].join('');
    }).join('');
    basInvoiceTableBody.innerHTML = rowsHtml;
  }

  function getInvoicesForFinancialYear(fyYear) {
    if (!Array.isArray(state.invoices) || !fyYear) return [];
    const start = startOfFinancialYear(fyYear);
    const end = startOfFinancialYear(fyYear + 1);
    return state.invoices
      .map((invoice) => {
        const date = resolveInvoiceDate(invoice);
        if (!date || Number.isNaN(date.getTime()) || date < start || date >= end) return null;

        // Build summary inline
        const summarySource = invoice.summary || summarizeInvoiceLineItems(invoice.lineItems || []);
        const lineCount = Number(summarySource.lineCount ?? summarySource.totalLines ?? invoice.line_count ?? 0);
        const totalHours = Number(summarySource.totalHours ?? invoice.total_hours ?? 0);
        const subtotal = Number(summarySource.totalAmount != null ? summarySource.totalAmount : (invoice.total_amount || 0));
        const gstValue = Number(summarySource.gstAmount != null ? summarySource.gstAmount : Math.round(subtotal * GST_RATE * 100) / 100);
        const totalValue = Number(summarySource.totalWithGst != null ? summarySource.totalWithGst : subtotal + gstValue);
        const statusLabel = (invoice.status || 'draft').replace(/^./, (char) => char.toUpperCase());
        const dateLabel = date ? DATE_FULL_FORMATTER.format(date) : '';
        const baseNumber = invoice.invoice_number || (`Invoice ${invoice.sequence || ''}`).trim();
        const numberLabel = baseNumber || (invoice.id ? `Invoice ${invoice.id}` : 'Invoice');

        const summary = {
          numberLabel,
          dateLabel,
          statusLabel,
          lineCount,
          totalHours,
          subtotal,
          gstValue,
          totalValue
        };

        return { invoice, summary, date };
      })
      .filter(Boolean)
      .sort((a, b) => a.date - b.date);
  }

  function attachBasRowClickHandlers() {
    if (!basTableBody) return;
    const clickableRows = basTableBody.querySelectorAll('.bas-row-clickable');
    clickableRows.forEach(row => {
      row.addEventListener('click', () => {
        const fyYear = row.getAttribute('data-fy');
        const quarter = row.getAttribute('data-quarter');
        const month = row.getAttribute('data-month');
        if (fyYear && quarter) {
          openBasDetailModal(Number(fyYear), Number(quarter), null);
        } else if (fyYear && month) {
          openBasDetailModal(Number(fyYear), null, Number(month));
        }
      });
    });
  }

  // Annual Views
  const annualYearTypeToggle = document.getElementById('annual-year-type-toggle');
  const annualYearTypeLabel = document.getElementById('annual-year-type-label');
  const annualYearSelect = document.getElementById('annual-year-select');
  const annualContractFilterToggle = document.getElementById('annual-contract-filter-toggle');
  const annualContractFilterPanel = document.getElementById('annual-contract-filter-panel');
  const annualContractFilterList = document.getElementById('annual-contract-filter-list');
  const annualFilterSelectAll = document.getElementById('annual-filter-select-all');
  const annualEmpty = document.getElementById('annual-empty');
  const annualCategorySection = document.getElementById('annual-category-section');
  const annualCategoryFilterWrapper = document.getElementById('annual-category-filter-wrapper');
  const annualCategoryFilterList = document.getElementById('annual-category-filter-list');
  const annualCategoryFilterSelectAll = document.getElementById('annual-category-filter-select-all');
  const annualCategoryFilterClear = document.getElementById('annual-category-filter-clear');
  const annualCategoryTableHead = document.getElementById('annual-category-table-head');
  const annualCategoryTableBody = document.getElementById('annual-category-table-body');
  const annualCategoryEmpty = document.getElementById('annual-category-empty');
  const annualCategoryEmptyText = document.getElementById('annual-category-empty-text');

  function getThemeColors() {
    const computedStyle = getComputedStyle(document.body);
    return {
      text: computedStyle.getPropertyValue('--text').trim(),
      muted: computedStyle.getPropertyValue('--muted').trim(),
      border: computedStyle.getPropertyValue('--border').trim(),
      primary: computedStyle.getPropertyValue('--primary').trim(),
      danger: computedStyle.getPropertyValue('--danger').trim(),
      success: computedStyle.getPropertyValue('--success').trim(),
      warning: '#facc15'
    };
  }

  function destroyAnnualCharts() {
    if (state.annualCharts.income) {
      state.annualCharts.income.destroy();
      state.annualCharts.income = null;
    }
    if (state.annualCharts.incomePie) {
      state.annualCharts.incomePie.destroy();
      state.annualCharts.incomePie = null;
    }
    if (state.annualCharts.contractPie) {
      state.annualCharts.contractPie.destroy();
      state.annualCharts.contractPie = null;
    }
    if (state.annualCharts.hourTypesPie) {
      state.annualCharts.hourTypesPie.destroy();
      state.annualCharts.hourTypesPie = null;
    }
    if (state.annualCharts.totalHoursPie) {
      state.annualCharts.totalHoursPie.destroy();
      state.annualCharts.totalHoursPie = null;
    }
    if (state.annualCharts.totalHoursByTypePie) {
      state.annualCharts.totalHoursByTypePie.destroy();
      state.annualCharts.totalHoursByTypePie = null;
    }
  }

function ensureAnnualLoadingOverlay() {
  if (!pageAnnualViews) return null;
  let overlay = document.getElementById('annual-loading-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'annual-loading-overlay';
    overlay.innerHTML = `
      <div class="ts-loading-overlay__message">Loading annual data...</div>
      <div class="ts-loading-overlay__skeletons"></div>
    `;
    pageAnnualViews.appendChild(overlay);
  }
  return overlay;
}

function getAnnualSkeletonTargets() {
  const targets = [];
  const statIds = [
    'annual-stat-gross',
    'annual-stat-super',
    'annual-stat-tax',
    'annual-stat-net',
    'annual-stat-hours',
    'annual-stat-avg-monthly',
    'annual-stat-tax-rate',
    'annual-stat-hourly-rate'
  ];
  const seen = new Set();
  statIds.forEach((id) => {
    const el = document.getElementById(id);
    if (!el) return;
    const card = el.closest('.ts-annual-stat-card');
    const targetEl = card || el;
    if (seen.has(targetEl)) return;
    seen.add(targetEl);
    targets.push({ el: targetEl, type: 'block' });
  });
  const chartIds = [
    'annual-income-chart',
    'annual-income-pie-chart',
    'annual-contract-pie-chart',
    'annual-total-hours-pie-chart',
    'annual-total-hours-by-type-pie-chart'
  ];
  chartIds.forEach((id) => {
    const canvas = document.getElementById(id);
    if (canvas && canvas.parentElement) {
      targets.push({ el: canvas.parentElement, type: 'block' });
    }
  });
  const taxAnalysis = document.getElementById('annual-tax-analysis');
  if (taxAnalysis) targets.push({ el: taxAnalysis, type: 'block' });
  return targets;
}

function toggleAnnualSkeleton(enabled) {
  if (!pageAnnualViews) return;
  const targets = getAnnualSkeletonTargets();
  const overlay = enabled ? ensureAnnualLoadingOverlay() : document.getElementById('annual-loading-overlay');
  const skeletonLayer = overlay ? overlay.querySelector('.ts-loading-overlay__skeletons') : null;
  if (enabled) {
    if (!overlay || !skeletonLayer) return;
    overlay.classList.add('is-active');
    skeletonLayer.innerHTML = '';
    const baseRect = pageAnnualViews.getBoundingClientRect();
    targets.forEach((item) => {
      const { el, type, className } = item;
      if (!el) return;
      const rect = el.getBoundingClientRect();
      if (rect.width < 1 || rect.height < 1) return;
      if (el.dataset.prevVisibility === undefined) el.dataset.prevVisibility = el.style.visibility || '';
      el.style.visibility = 'hidden';
      const skeleton = document.createElement('div');
      skeleton.className = 'ts-skeleton';
      if (type === 'text' && className) skeleton.classList.add(className);
      skeleton.style.position = 'absolute';
      skeleton.style.top = `${rect.top - baseRect.top}px`;
      skeleton.style.left = `${rect.left - baseRect.left}px`;
      skeleton.style.width = `${rect.width}px`;
      skeleton.style.height = `${rect.height}px`;
      skeletonLayer.appendChild(skeleton);
    });
  } else {
    if (skeletonLayer) skeletonLayer.innerHTML = '';
    targets.forEach((item) => {
      const { el } = item;
      if (!el) return;
      if (el.dataset.prevVisibility !== undefined) {
        el.style.visibility = el.dataset.prevVisibility;
        delete el.dataset.prevVisibility;
      } else {
        el.style.visibility = '';
      }
    });
  }
}

function showAnnualLoadingState(useSkeleton) {
  if (!pageAnnualViews) return;
  const overlay = ensureAnnualLoadingOverlay();
  if (!overlay) return;
  const message = overlay.querySelector('.ts-loading-overlay__message');
  if (message) {
    message.textContent = useSkeleton ? 'Preparing annual insights...' : 'Loading annual data...';
  }
  overlay.classList.add('is-active');
  overlay.style.display = 'block';
  const skeletonLayer = overlay.querySelector('.ts-loading-overlay__skeletons');
  if (skeletonLayer && !useSkeleton) skeletonLayer.innerHTML = '';
  if (useSkeleton) {
    toggleAnnualSkeleton(true);
  } else {
    toggleAnnualSkeleton(false);
  }
}

function hideAnnualLoadingState() {
    const overlay = document.getElementById('annual-loading-overlay');
    if (overlay) {
      overlay.classList.remove('is-active');
      overlay.style.display = 'none';
      const skeletonLayer = overlay.querySelector('.ts-loading-overlay__skeletons');
      if (skeletonLayer) skeletonLayer.innerHTML = '';
    }
  }

function loadAnnualData() {
    const payload = {
      yearType: state.annualYearType,
      startYear: state.annualCurrentYear,
      contractIds: state.annualFilteredContracts
    };

    const hasAnyCachedData = state.annualData !== null;
    const useSkeleton = !hasAnyCachedData;

    showAnnualLoadingState(useSkeleton);

    if (hasAnyCachedData) {
      renderAnnualData();
      toggleAnnualSkeleton(false);
    }

    const statusMsg = hasAnyCachedData ? 'Updating annual data...' : 'Loading annual data...';
    setStatus(statusMsg, 'info');

    setTimeout(() => {
      try {
        const data = buildAnnualDataFromMonthlyCache(payload);
        state.annualData = data;
        saveCache();
        hideAnnualLoadingState();
        toggleAnnualSkeleton(false);
        renderAnnualData();
        setStatus('Ready', 'success');
      } catch (error) {
        console.error('Failed to build annual data:', error);
        hideAnnualLoadingState();
        toggleAnnualSkeleton(false);
        setStatus('Error loading annual data', 'error');
      }
    }, 0);
}

  function buildAnnualDataFromMonthlyCache({ yearType, startYear, contractIds }) {
    const normalizedContractIds = Array.isArray(contractIds)
      ? contractIds.filter((id) => id != null && id !== '').map((id) => String(id))
      : [];
    const months = yearType === 'financial'
      ? getFinancialYearMonths(startYear)
      : getCalendarYearMonths(startYear);
    const monthlyData = months.map(({ year, month }) => buildAnnualMonthSummary(year, month, normalizedContractIds));
    const yearTotals = monthlyData.reduce((acc, month) => {
      acc.grossIncome += month.grossIncome || 0;
      acc.superGuarantee += month.superGuarantee || 0;
      acc.superLost += month.superLost || 0;
      acc.extraSuper += month.extraSuper || 0;
      acc.otherDeductions += month.otherDeductions || 0;
      acc.tax += month.tax || 0;
      acc.netIncome += month.netIncome || 0;
      acc.totalHours += month.totalHours || 0;
      acc.rateCalcHours += month.rateCalcHours || 0;
      acc.companyIncome += month.companyIncome || 0;
      acc.companyExpenses += month.companyExpenses || 0;
      acc.invoiceTotal += month.invoiceTotal || 0;
      return acc;
    }, {
      grossIncome: 0,
      superGuarantee: 0,
      superLost: 0,
      extraSuper: 0,
      otherDeductions: 0,
      tax: 0,
      netIncome: 0,
      totalHours: 0,
      rateCalcHours: 0,
      companyIncome: 0,
      companyExpenses: 0,
      invoiceTotal: 0
    });
    return {
      yearType,
      startYear,
      monthlyData,
      yearTotals,
      contractBreakdown: buildAnnualContractBreakdown(monthlyData),
      hourTypeBreakdown: buildAnnualHourTypeBreakdown(monthlyData)
    };
  }

  function getMonthLabel(year, month) {
    return MONTH_YEAR_FORMATTER.format(new Date(year, month, 1));
  }

  function buildAnnualMonthSummary(year, month, contractIds) {
    ensureIncomeCacheStructures();
    const contractFilter = Array.isArray(contractIds) && contractIds.length ? new Set(contractIds.map(String)) : null;
    const monthEntries = entriesForMonth(year, month);
    const filteredEntries = contractFilter
      ? monthEntries.filter((entry) => contractFilter.has(String(entry.contract_id || '')))
      : monthEntries.slice();
    if (contractFilter) {
      // contract filter applied; filteredEntries already scoped
    }
    const periodStart = startOfDay(new Date(year, month, 1));
    const periodEnd = startOfDay(new Date(year, month + 1, 0));
    const periodStartIso = periodStart.toISOString().substring(0, 10);
    const superRate = getSuperGuaranteeRateForDate(periodStartIso);
    const contractIncome = {};
    let totalMinutes = 0; // income-contributing minutes only
    filteredEntries.forEach((entry) => {
      const minutes = Number(entry.duration_minutes) || 0;
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      const hourType = state.hourTypeMap[hourTypeId];
      const contributes = hourType ? hourType.contributes_to_income : true;
      if (!contributes) return;
      totalMinutes += minutes;
      const contractId = entry.contract_id || '';
      const contract = state.contractMap[contractId];
      let rate = 0;
      if (contract && contractIsValid(contract, entry.date)) {
        rate = Number(contract.hourly_rate || 0);
      } else {
        const valids = validContractsForDate(entry.date);
        if (valids.length === 1) rate = Number(valids[0].hourly_rate || 0);
      }
      const hours = minutes / 60;
      if (!contractIncome[contractId]) contractIncome[contractId] = 0;
      contractIncome[contractId] += hours * rate;
    });
    const roundingScale = totalMinutes > 0 ? 1 : 0;
    const totalHours = totalMinutes / 60;
    Object.keys(contractIncome).forEach((cid) => {
      contractIncome[cid] = contractIncome[cid] * roundingScale;
    });

    const hourTypeMinutes = {};
    const rateCalcHourTypeIds = new Set(
      (state.hourTypes || []).filter((ht) => ht && ht.use_for_rate_calculation).map((ht) => ht.id)
    );
    let rateCalcMinutes = 0;
    monthEntries.forEach((entry) => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      const minutes = Number(entry.duration_minutes) || 0;
      if (!hourTypeMinutes[hourTypeId]) hourTypeMinutes[hourTypeId] = 0;
      hourTypeMinutes[hourTypeId] += minutes;
      if (rateCalcHourTypeIds.has(hourTypeId)) {
        rateCalcMinutes += minutes;
      }
    });
    const rateCalcHours = rateCalcMinutes / 60;

    const monthStart = periodStart;
    const monthEnd = periodEnd;
    let extraSuperFlat = 0;
    let extraSuperPercentRate = 0;
    let otherDeductions = 0;
    let companyExpenses = 0;
    let companyExpensesGst = 0;
    const categoryTotals = {};
    const categoryDeductionMap = {};
    const activeDeductions = Array.isArray(state.deductions) ? state.deductions : [];
    activeDeductions.forEach((deduction) => {
      if (!deduction || deduction.active === false) return;
      const occurrences = getDeductionOccurrencesWithExceptions(deduction, monthStart, monthEnd);
      if (!occurrences.length) return;
      if (deduction.deduction_type === 'extra_super') {
        if (deduction.amount_type === 'percent') {
          extraSuperPercentRate += (Number(deduction.amount_value) || 0) * occurrences.length;
        } else {
          occurrences.forEach((occ) => {
            const amount = occ.amount !== null ? occ.amount : deduction.amount_value;
            extraSuperFlat += Number(amount) || 0;
          });
        }
        return;
      }
      if (deduction.amount_type === 'percent') {
        return;
      }
      occurrences.forEach((occ) => {
        const baseAmount = occ.amount !== null ? occ.amount : deduction.amount_value;
        let netAmount = Number(baseAmount) || 0;
        if (deduction.gst_inclusive) {
          netAmount = netAmount / (1 + GST_RATE);
        }
        const categoryId = deduction.category_id || '';
        categoryTotals[categoryId] = (categoryTotals[categoryId] || 0) + netAmount;
        const deductionId = deduction.id ? String(deduction.id) : '';
        if (deductionId) {
          if (!categoryDeductionMap[categoryId]) categoryDeductionMap[categoryId] = {};
          if (!categoryDeductionMap[categoryId][deductionId]) {
            categoryDeductionMap[categoryId][deductionId] = {
              deductionId,
              name: deduction.name,
              amount: 0,
              company_expense: !!deduction.company_expense
            };
          }
          categoryDeductionMap[categoryId][deductionId].amount += netAmount;
        }
        if (deduction.company_expense) {
          companyExpenses += netAmount;
          if (deduction.gst_inclusive) {
            const gstComponent = (Number(baseAmount) || 0) - netAmount;
            companyExpensesGst += gstComponent;
          }
        } else {
          otherDeductions += netAmount;
        }
      });
    });

    const companyEnabled = !!state.companyTrackingEnabled;
    if (!companyEnabled) {
      companyExpenses = 0;
      companyExpensesGst = 0;
    }

    const totalPackage = Object.values(contractIncome).reduce((sum, value) => sum + value, 0);
    const companyIncome = companyEnabled ? totalPackage : 0;
    const invoiceTotal = companyEnabled ? companyIncome * (1 + GST_RATE) : 0;
    const employeePackage = companyEnabled ? Math.max(0, companyIncome - companyExpenses) : totalPackage;
    const grossIncome = deriveGrossFromPackage(employeePackage, superRate);
    const extraSuperPercent = Math.max(0, extraSuperPercentRate);
    let extraSuper = extraSuperFlat + (extraSuperPercent * Math.max(0, grossIncome));

    let superBase = Math.max(0, grossIncome - otherDeductions);
    const idealSuper = Math.max(0, grossIncome * superRate);
    let superGuarantee = Math.max(0, superBase * superRate);
    let superLost = Math.max(0, idealSuper - superGuarantee);
    const noLostSuperEnabled = !!getFeatureFlag('no_lost_super_to_deductions');
    const recoveryMode = state.settings && state.settings.lost_super_recovery_mode
      ? state.settings.lost_super_recovery_mode
      : 'extra_contribution';
    let recoveredSuper = 0;
    let recoveredToSuperBase = 0;
    if (noLostSuperEnabled && superLost > 0) {
      if (recoveryMode === 'extra_contribution') {
        recoveredSuper = superLost;
        extraSuper += recoveredSuper;
        superLost = 0;
      } else if (recoveryMode === 'add_to_taxable') {
        recoveredToSuperBase = superLost;
        superBase = Math.max(0, superBase + recoveredToSuperBase);
        superGuarantee = Math.max(0, superBase * superRate);
        superLost = 0;
      }
    }

    const taxableIncome = Math.max(0, grossIncome - extraSuper - otherDeductions + recoveredToSuperBase);
    let tax = 0;
    if (taxableIncome > 0) {
      tax = estimateTaxLocal(grossIncome, periodStartIso);
    }
    const netIncome = Math.max(0, taxableIncome - tax);

    const hourTypeHours = {};
    Object.keys(hourTypeMinutes).forEach((id) => {
      hourTypeHours[id] = hourTypeMinutes[id] / 60;
    });

    const categoryBreakdown = buildAnnualCategoryBreakdown(categoryTotals, categoryDeductionMap);

    const actualIncome = state.actualIncomeMap ? state.actualIncomeMap[monthKeyFor(year, month)] : null;
    let finalGrossIncome = grossIncome;
    let finalSuperGuarantee = superGuarantee;
    let finalExtraSuper = extraSuper;
    let finalTax = tax;
    let finalNetIncome = netIncome;
    let hasActualIncome = false;
    if (actualIncome) {
      hasActualIncome = true;
      finalGrossIncome = Number(actualIncome.gross_income) || 0;
      const actualSuper = Number(actualIncome.superannuation) || 0;
      const estimatedTotalSuper = (superGuarantee + extraSuper) || 0;
      if (estimatedTotalSuper > 0) {
        const guaranteeRatio = superGuarantee / estimatedTotalSuper;
        finalSuperGuarantee = actualSuper * guaranteeRatio;
        finalExtraSuper = actualSuper * (1 - guaranteeRatio);
      } else {
        finalSuperGuarantee = actualSuper;
        finalExtraSuper = 0;
      }
      finalTax = Number(actualIncome.tax) || 0;
      finalNetIncome = Number(actualIncome.net_income) || 0;
    }

    return {
      year,
      month,
      label: getMonthLabel(year, month),
      monthKey: monthKeyFor(year, month),
      grossIncome: finalGrossIncome,
      superGuarantee: finalSuperGuarantee,
      superLost,
      extraSuper: finalExtraSuper,
      otherDeductions,
      taxableIncome,
      tax: finalTax,
      netIncome: finalNetIncome,
      totalHours,
      rateCalcHours,
      companyIncome,
      companyExpenses,
      companyExpensesGst,
      invoiceTotal,
      superRate,
      contractIncome,
      hourTypeHours,
      categoryBreakdown: {
        categories: categoryBreakdown
      },
      hasActualIncome
    };
  }

  function buildAnnualCategoryBreakdown(categoryTotals, categoryDeductionMap) {
    return Object.keys(categoryTotals).map((categoryId) => {
      const total = Math.round(categoryTotals[categoryId] * 100) / 100;
      const deductionMap = categoryDeductionMap[categoryId] || {};
      const deductions = Object.keys(deductionMap).map((deductionId) => {
        const item = deductionMap[deductionId];
        return {
          deductionId: item.deductionId,
          name: item.name,
          amount: Math.round((item.amount || 0) * 100) / 100,
          company_expense: !!item.company_expense
        };
      }).sort((a, b) => b.amount - a.amount);
      return {
        categoryId,
        total,
        deductions
      };
    });
  }

  function buildAnnualContractBreakdown(monthlyData) {
    const incomeByContract = {};
    monthlyData.forEach((month) => {
      const incomeMap = month.contractIncome || {};
      Object.keys(incomeMap).forEach((contractId) => {
        incomeByContract[contractId] = (incomeByContract[contractId] || 0) + incomeMap[contractId];
      });
    });
    const breakdown = [];
    Object.keys(incomeByContract).forEach((contractId) => {
      const contract = state.contractMap[contractId];
      if (!contract) return;
      breakdown.push({
        contractId,
        contractName: contract.name,
        grossIncome: incomeByContract[contractId]
      });
    });
    breakdown.sort((a, b) => b.grossIncome - a.grossIncome);
    return breakdown;
  }

  function buildAnnualHourTypeBreakdown(monthlyData) {
    const hoursByType = {};
    monthlyData.forEach((month) => {
      const hourMap = month.hourTypeHours || {};
      Object.keys(hourMap).forEach((hourTypeId) => {
        hoursByType[hourTypeId] = (hoursByType[hourTypeId] || 0) + hourMap[hourTypeId];
      });
    });
    const breakdown = [];
    Object.keys(hoursByType).forEach((hourTypeId) => {
      const hourType = state.hourTypeMap[hourTypeId];
      let resolvedId = hourTypeId;
      let resolvedName = 'Unknown';
      let resolvedColor = '#94a3b8';
      if (hourType) {
        resolvedId = hourType.id;
        resolvedName = hourType.name;
        resolvedColor = hourType.color || resolvedColor;
      } else if (!hourTypeId || hourTypeId === 'work') {
        resolvedId = 'work';
        resolvedName = 'Work';
        resolvedColor = '#3b82f6';
      }
      breakdown.push({
        hourTypeId: resolvedId,
        hourTypeName: resolvedName,
        hourTypeColor: resolvedColor,
        hours: hoursByType[hourTypeId]
      });
    });
    breakdown.sort((a, b) => b.hours - a.hours);
    return breakdown;
  }

  function estimateTaxLocal(grossIncome, currentDate) {
    let income = Number(grossIncome) || 0;
    if (income < 0) income = 0;
    const decimal = Number(((income % 1).toFixed(2)));
    if (decimal === 0.33) {
      income += 0.01;
    }
    const weeklyIncome = Math.floor(income * (3 / 13)) + 0.99;
    const targetDate = new Date(currentDate);
    let financialYear = '2024/2025';
    if (targetDate instanceof Date && !Number.isNaN(targetDate.getTime())) {
      if (targetDate <= new Date('2024-05-30')) {
        financialYear = '2020/2021';
      } else if (targetDate <= new Date('2099-05-30')) {
        financialYear = '2024/2025';
      }
    }
    let a = 0;
    let b = 0;
    if (financialYear === '2020/2021') {
      if (weeklyIncome < 359) { a = 0; b = 0; } else
      if (weeklyIncome < 438) { a = 0.19; b = 68.3462; } else
      if (weeklyIncome < 548) { a = 0.29; b = 112.1942; } else
      if (weeklyIncome < 721) { a = 0.21; b = 68.3465; } else
      if (weeklyIncome < 865) { a = 0.219; b = 74.8369; } else
      if (weeklyIncome < 1282) { a = 0.3477; b = 186.2119; } else
      if (weeklyIncome < 2307) { a = 0.345; b = 182.7504; } else
      if (weeklyIncome < 3461) { a = 0.39; b = 286.5965; } else { a = 0.47; b = 563.5196; }
    } else {
      if (weeklyIncome < 361) { a = 0; b = 0; } else
      if (weeklyIncome < 500) { a = 0.16; b = 57.8462; } else
      if (weeklyIncome < 625) { a = 0.26; b = 107.8462; } else
      if (weeklyIncome < 721) { a = 0.18; b = 57.8462; } else
      if (weeklyIncome < 865) { a = 0.189; b = 64.3365; } else
      if (weeklyIncome < 1282) { a = 0.3277; b = 180.0385; } else
      if (weeklyIncome < 2596) { a = 0.32; b = 176.5769; } else
      if (weeklyIncome < 3653) { a = 0.39; b = 358.3077; } else { a = 0.47; b = 650.6154; }
    }
    const weeklyTax = (a * weeklyIncome) - b;
    const monthlyTax = Math.round(weeklyTax * (13 / 3));
    return Math.max(0, Math.round(monthlyTax));
  }

  function renderAnnualViews() {
    if (!pageAnnualViews) return;

    // Get years based on current type
    const allYears = collectAllYears();
    const years = state.annualYearType === 'financial' ? allYears.financial : allYears.calendar;

    if (years.length === 0) {
      years.push(new Date().getFullYear());
    }

    if (!state.annualCurrentYear || !years.includes(state.annualCurrentYear)) {
      state.annualCurrentYear = years[0];
    }

    // Initialize year selector
    if (annualYearSelect) {
      const options = years.map(year => {
        const fy = financialYearLabel(year);
        return `<option value="${year}">${state.annualYearType === 'financial' ? fy : year}</option>`;
      }).join('');
      annualYearSelect.innerHTML = options;
      annualYearSelect.value = String(state.annualCurrentYear);
    }

    // Initialize year type toggle
    if (annualYearTypeToggle) {
      annualYearTypeToggle.checked = state.annualYearType === 'calendar';
    }
    if (annualYearTypeLabel) {
      annualYearTypeLabel.textContent = state.annualYearType === 'financial' ? 'Financial Year' : 'Calendar Year';
    }

    // Initialize contract filter
    renderAnnualContractFilter();

    // Load data
    // Always clear annual data when switching year/year type to avoid stale filters
    state.annualData = null;
    // Ensure filtered contracts reset to relevant set for this year
    state.annualFilteredContracts = [];
    console.log('[AnnualDebug] renderAnnualViews payload', {
      yearType: state.annualYearType,
      year: state.annualCurrentYear
    });
    loadAnnualData();
  }

  function renderAnnualContractFilter() {
    if (!annualContractFilterList) return;

    // Get year range based on year type
    let yearStart, yearEnd;
    if (state.annualYearType === 'financial') {
      yearStart = new Date(state.annualCurrentYear, 6, 1); // July 1st
      yearEnd = new Date(state.annualCurrentYear + 1, 5, 30, 23, 59, 59); // June 30th
    } else {
      yearStart = new Date(state.annualCurrentYear, 0, 1); // Jan 1st
      yearEnd = new Date(state.annualCurrentYear, 11, 31, 23, 59, 59); // Dec 31st
    }

    // Filter contracts that overlap with the selected year OR are referenced by entries in that range
    const entryContractIds = new Set();
    (state.entries || []).forEach((entry) => {
      if (!entry || !entry.contract_id || !entry.date) return;
      const entryDate = new Date(entry.date);
      if (entryDate >= yearStart && entryDate <= yearEnd) {
        entryContractIds.add(String(entry.contract_id));
      }
    });

    const relevantContracts = state.contracts.filter(c => {
      if (!c || !c.id || !c.name) return false;
      const contractStart = c.start_date ? new Date(c.start_date) : new Date(0);
      const contractEnd = c.end_date ? new Date(c.end_date) : new Date(9999, 11, 31);
      const overlaps = contractStart <= yearEnd && contractEnd >= yearStart;
      const referenced = entryContractIds.has(String(c.id));
      return overlaps || referenced;
    });

    if (relevantContracts.length <= 1) {
      if (annualContractFilterToggle) annualContractFilterToggle.style.display = 'none';
      if (annualContractFilterPanel) annualContractFilterPanel.style.display = 'none';
      state.annualFilteredContracts = relevantContracts.map(c => c.id);
      console.log('[AnnualDebug] Contract filter init (<=1 relevant)', {
        yearType: state.annualYearType,
        year: state.annualCurrentYear,
        relevantContracts: relevantContracts.map(c => ({ id: c.id, name: c.name }))
      });
      return;
    }

    // Show the filter toggle button
    if (annualContractFilterToggle) annualContractFilterToggle.style.display = 'block';

    // Panel starts hidden (user can click toggle to show)
    if (!annualContractFilterPanel.dataset.initialized) {
      if (annualContractFilterPanel) annualContractFilterPanel.style.display = 'none';
      if (annualContractFilterPanel) annualContractFilterPanel.dataset.initialized = 'true';
    }

    // Initialize with all relevant contracts if not set or if filtered contracts are not relevant
    const currentFilteredAreRelevant = state.annualFilteredContracts.every(id =>
      relevantContracts.some(c => c.id === id)
    );
    if (state.annualFilteredContracts.length === 0 || !currentFilteredAreRelevant) {
      state.annualFilteredContracts = relevantContracts.map(c => c.id);
    }
    console.log('[AnnualDebug] Contract filter state', {
      yearType: state.annualYearType,
      year: state.annualCurrentYear,
      relevantContracts: relevantContracts.map(c => ({ id: c.id, name: c.name })),
      filteredContracts: state.annualFilteredContracts.slice()
    });

    const html = relevantContracts.map(contract => {
      const isActive = state.annualFilteredContracts.includes(contract.id);
      return `
        <div class="ts-calendar-filter-item ${isActive ? 'active' : ''}" data-contract-id="${contract.id}">
          <input type="checkbox" class="ts-calendar-filter-checkbox" ${isActive ? 'checked' : ''} />
          <span class="ts-calendar-filter-name">${contract.name}</span>
        </div>
      `;
    }).join('');

    annualContractFilterList.innerHTML = html;

    // Add click handlers
    annualContractFilterList.querySelectorAll('.ts-calendar-filter-item').forEach(item => {
      item.addEventListener('click', () => {
        const contractId = item.dataset.contractId;
        const idx = state.annualFilteredContracts.indexOf(contractId);
        if (idx >= 0) {
          state.annualFilteredContracts.splice(idx, 1);
        } else {
          state.annualFilteredContracts.push(contractId);
        }
        if (!state.annualFilteredContracts.length) {
          state.annualFilteredContracts = relevantContracts.map(c => c.id);
        }
        saveCache();
        renderAnnualContractFilter();
        loadAnnualData();
      });
    });
  }

  function getAnnualCategoryKeys() {
    if (!state.annualData || !Array.isArray(state.annualData.monthlyData)) return [];
    const keys = new Set();
    state.annualData.monthlyData.forEach((month) => {
      if (!month || !month.categoryBreakdown || !Array.isArray(month.categoryBreakdown.categories)) return;
      month.categoryBreakdown.categories.forEach((entry) => {
        if (!entry) return;
        const id = entry.categoryId != null ? String(entry.categoryId) : '';
        keys.add(id);
      });
    });
    const result = Array.from(keys);
    result.sort((a, b) => {
      const metaA = getDeductionCategoryMeta(a);
      const metaB = getDeductionCategoryMeta(b);
      const isUncatA = (a || '') === '';
      const isUncatB = (b || '') === '';
      if (isUncatA && !isUncatB) return 1;
      if (isUncatB && !isUncatA) return -1;
      return metaA.name.localeCompare(metaB.name);
    });
    return result;
  }

  function ensureAnnualCategoryFilters(keys) {
    if (!keys.length) {
      state.annualCategoryFilters = [];
      state.annualCategoryExpansion = {};
      return;
    }
    const existing = Array.isArray(state.annualCategoryFilters) ? state.annualCategoryFilters.slice() : [];
    const valid = existing.filter((id) => keys.includes(id));
    const additions = keys.filter((id) => !valid.includes(id));
    state.annualCategoryFilters = valid.concat(additions);
    if (!state.annualCategoryExpansion || typeof state.annualCategoryExpansion !== 'object') {
      state.annualCategoryExpansion = {};
    }
    Object.keys(state.annualCategoryExpansion).forEach((key) => {
      if (!keys.includes(key)) {
        delete state.annualCategoryExpansion[key];
      }
    });
  }

  function renderAnnualCategorySection() {
    if (!annualCategorySection) return;
    if (!state.annualData || !getFeatureFlag('enable_deduction_categories')) {
      annualCategorySection.style.display = 'none';
      if (annualCategoryEmpty) annualCategoryEmpty.style.display = 'none';
      return;
    }
    const keys = getAnnualCategoryKeys();
    ensureAnnualCategoryFilters(keys);
    if (!keys.length) {
      annualCategorySection.style.display = 'none';
      if (annualCategoryEmpty) annualCategoryEmpty.style.display = 'none';
      return;
    }
    annualCategorySection.style.display = 'block';
    if (annualCategoryFilterWrapper) {
      annualCategoryFilterWrapper.style.display = keys.length > 0 ? 'block' : 'none';
    }
    renderAnnualCategoryFilters(keys);
    renderAnnualCategoryTable(keys);
  }

  function renderAnnualCategoryFilters(keys) {
    if (!annualCategoryFilterList) return;
    annualCategoryFilterList.innerHTML = '';
    if (!keys.length) return;

    keys.forEach((categoryId) => {
      const meta = getDeductionCategoryMeta(categoryId);
      const isActive = state.annualCategoryFilters.includes(categoryId);
      const item = document.createElement('div');
      item.className = 'ts-calendar-filter-item' + (isActive ? ' active' : '');
      item.dataset.categoryId = categoryId;
      item.style.display = 'inline-flex';
      item.style.alignItems = 'center';
      item.style.gap = '6px';

      const dot = document.createElement('span');
      dot.style.display = 'inline-block';
      dot.style.width = '10px';
      dot.style.height = '10px';
      dot.style.borderRadius = '50%';
      dot.style.backgroundColor = meta.color || '#6b7280';
      item.appendChild(dot);

      const label = document.createElement('span');
      label.className = 'ts-calendar-filter-name';
      label.textContent = meta.name;
      item.appendChild(label);

      item.addEventListener('click', () => {
        const index = state.annualCategoryFilters.indexOf(categoryId);
        if (index !== -1) {
          state.annualCategoryFilters.splice(index, 1);
        } else {
          state.annualCategoryFilters.push(categoryId);
        }
        saveCache();
        renderAnnualCategoryFilters(keys);
        renderAnnualCategoryTable(keys);
      });

      annualCategoryFilterList.appendChild(item);
    });
  }

  function getMonthlyCategoryEntry(month, categoryId) {
    if (!month || !month.categoryBreakdown || !Array.isArray(month.categoryBreakdown.categories)) return null;
    const target = categoryId != null ? String(categoryId) : '';
    const match = month.categoryBreakdown.categories.find((entry) => {
      if (!entry) return false;
      const entryId = entry.categoryId != null ? String(entry.categoryId) : '';
      return entryId === target;
    });
    return match || null;
  }

  function renderAnnualCategoryTable(keys) {
    if (!annualCategoryTableHead || !annualCategoryTableBody) return;
    annualCategoryTableHead.innerHTML = '';
    annualCategoryTableBody.innerHTML = '';

    if (!state.annualData) return;
    const visibleCategories = state.annualCategoryFilters.filter((id) => keys.includes(id));

    if (!visibleCategories.length) {
      if (annualCategoryEmpty) {
        if (annualCategoryEmptyText) annualCategoryEmptyText.textContent = 'Select at least one category to view the breakdown.';
        annualCategoryEmpty.style.display = 'block';
      }
      return;
    }

    if (annualCategoryEmpty) {
      annualCategoryEmpty.style.display = 'none';
    }

    const headRow = document.createElement('tr');
    const monthTh = document.createElement('th');
    monthTh.textContent = 'Month';
    monthTh.style.textAlign = 'left';
    monthTh.style.padding = '12px';
    headRow.appendChild(monthTh);

    visibleCategories.forEach((categoryId) => {
      const th = document.createElement('th');
      th.style.padding = '12px';
      th.style.textAlign = 'left';
      th.style.minWidth = '160px';
      const headerButton = document.createElement('button');
      headerButton.type = 'button';
      headerButton.style.display = 'flex';
      headerButton.style.alignItems = 'center';
      headerButton.style.justifyContent = 'space-between';
      headerButton.style.width = '100%';
      headerButton.style.gap = '8px';
      headerButton.style.background = 'none';
      headerButton.style.border = 'none';
      headerButton.style.padding = '0';
      headerButton.style.cursor = 'pointer';

      const left = document.createElement('span');
      left.style.display = 'inline-flex';
      left.style.alignItems = 'center';
      left.style.gap = '8px';

      const meta = getDeductionCategoryMeta(categoryId);
      const dot = document.createElement('span');
      dot.style.display = 'inline-block';
      dot.style.width = '10px';
      dot.style.height = '10px';
      dot.style.borderRadius = '50%';
      dot.style.backgroundColor = meta.color || '#6b7280';
      left.appendChild(dot);

      const nameSpan = document.createElement('span');
      nameSpan.textContent = meta.name;
      left.appendChild(nameSpan);

      headerButton.appendChild(left);

      const expanded = !!state.annualCategoryExpansion[categoryId];
      const arrow = document.createElement('span');
      arrow.textContent = expanded ? '' : '';
      headerButton.appendChild(arrow);

      headerButton.addEventListener('click', () => {
        state.annualCategoryExpansion[categoryId] = !expanded;
        saveCache();
        renderAnnualCategoryTable(keys);
      });

      th.appendChild(headerButton);
      headRow.appendChild(th);
    });

    annualCategoryTableHead.appendChild(headRow);

    const totalsByCategory = {};
    state.annualData.monthlyData.forEach((month) => {
      const row = document.createElement('tr');
      const monthCell = document.createElement('td');
      monthCell.textContent = month.label;
      monthCell.style.padding = '10px 12px';
      monthCell.style.fontWeight = '600';
      monthCell.style.whiteSpace = 'nowrap';
      row.appendChild(monthCell);

      visibleCategories.forEach((categoryId) => {
        const entry = getMonthlyCategoryEntry(month, categoryId);
        const totalValue = entry ? entry.total : 0;
        totalsByCategory[categoryId] = (totalsByCategory[categoryId] || 0) + totalValue;

        const cell = document.createElement('td');
        cell.style.padding = '10px 12px';
        const expanded = !!state.annualCategoryExpansion[categoryId];
        cell.style.textAlign = expanded ? 'left' : 'right';

        if (!entry || !entry.total) {
          cell.textContent = '';
          cell.style.color = 'var(--muted)';
        } else if (expanded) {
          cell.style.color = '';
          const totalEl = document.createElement('div');
          totalEl.style.fontWeight = '600';
          totalEl.style.marginBottom = '6px';
          totalEl.textContent = formatCurrency(entry.total);
          cell.appendChild(totalEl);

          const expandedItems = Array.isArray(entry.deductions) ? entry.deductions : [];
          expandedItems.forEach((deduction) => {
            const line = document.createElement('div');
            line.style.display = 'flex';
            line.style.justifyContent = 'space-between';
            line.style.gap = '12px';
            line.style.fontSize = '13px';
            const nameSpan = document.createElement('span');
            nameSpan.style.flex = '1';
            nameSpan.style.textAlign = 'left';
            nameSpan.textContent = deduction.name || 'Unnamed deduction';
            const amountSpan = document.createElement('span');
            amountSpan.textContent = formatCurrency(deduction.amount);
            amountSpan.style.textAlign = 'right';
            line.appendChild(nameSpan);
            line.appendChild(amountSpan);
            cell.appendChild(line);
          });
        } else {
          cell.style.color = '';
          cell.textContent = formatCurrency(entry.total);
        }

        row.appendChild(cell);
      });

      annualCategoryTableBody.appendChild(row);
    });

    const totalRow = document.createElement('tr');
    totalRow.style.fontWeight = '600';
    totalRow.style.borderTop = '2px solid var(--border)';
    const labelCell = document.createElement('td');
    labelCell.textContent = 'Total';
    labelCell.style.padding = '12px';
    totalRow.appendChild(labelCell);

    visibleCategories.forEach((categoryId) => {
      const totalCell = document.createElement('td');
      totalCell.style.padding = '12px';
      totalCell.style.textAlign = state.annualCategoryExpansion[categoryId] ? 'left' : 'right';
      const totalValue = Math.round((totalsByCategory[categoryId] || 0) * 100) / 100;
      if (totalValue) {
        totalCell.style.color = '';
        totalCell.textContent = formatCurrency(totalValue);
      } else {
        totalCell.textContent = '';
        totalCell.style.color = 'var(--muted)';
      }
      totalRow.appendChild(totalCell);
    });

    annualCategoryTableBody.appendChild(totalRow);
  }

  function collectAllYears() {
    // Get list of public holiday hour type IDs
    const publicHolidayHourTypeIds = state.hourTypes
      .filter(ht => ht.auto_populate_public_holidays === true || ht.auto_populate_public_holidays === 'TRUE')
      .map(ht => ht.id);

    // Group entries by year to check if year has non-public-holiday entries
    const calendarYearEntries = {};
    const financialYearEntries = {};

    state.entries.forEach(entry => {
      if (entry && entry.date) {
        const duration = entry.duration_minutes || 0;
        if (duration > 0) {
          const date = new Date(entry.date);
          const calendarYear = date.getFullYear();
          const fyStart = financialYearStartYear(date);
          const hourTypeId = entry.hour_type_id || '';
          const isPublicHoliday = publicHolidayHourTypeIds.includes(hourTypeId);

          // Track calendar year entries
          if (!calendarYearEntries[calendarYear]) {
            calendarYearEntries[calendarYear] = { total: 0, publicHolidays: 0 };
          }
          calendarYearEntries[calendarYear].total++;
          if (isPublicHoliday) {
            calendarYearEntries[calendarYear].publicHolidays++;
          }

          // Track financial year entries
          if (!financialYearEntries[fyStart]) {
            financialYearEntries[fyStart] = { total: 0, publicHolidays: 0 };
          }
          financialYearEntries[fyStart].total++;
          if (isPublicHoliday) {
            financialYearEntries[fyStart].publicHolidays++;
          }
        }
      }
    });

    // Only include years that have at least one non-public-holiday entry
    const calendarYears = Object.keys(calendarYearEntries)
      .filter(year => {
        const stats = calendarYearEntries[year];
        return stats.total > stats.publicHolidays; // Has at least one non-PH entry
      })
      .map(y => parseInt(y))
      .sort((a, b) => b - a);

    const financialYears = Object.keys(financialYearEntries)
      .filter(year => {
        const stats = financialYearEntries[year];
        return stats.total > stats.publicHolidays; // Has at least one non-PH entry
      })
      .map(y => parseInt(y))
      .sort((a, b) => b - a);

    return {
      calendar: calendarYears,
      financial: financialYears
    };
  }

  function getCorrespondingYear(year, fromType, toType) {
    if (fromType === toType) return year;

    if (fromType === 'financial' && toType === 'calendar') {
      // FY 2024 (Jul 2024 - Jun 2025) -> Calendar 2024
      return year;
    } else if (fromType === 'calendar' && toType === 'financial') {
      // Calendar 2024 -> FY 2024 (Jul 2024 - Jun 2025)
      return year;
    }
    return year;
  }

  function renderAnnualData() {
    if (!state.annualData) return;

    const data = state.annualData;
    const totals = data.yearTotals;

    // Update summary stats
    const grossEl = document.getElementById('annual-stat-gross');
    const superEl = document.getElementById('annual-stat-super');
    const taxEl = document.getElementById('annual-stat-tax');
    const netEl = document.getElementById('annual-stat-net');
    const hoursEl = document.getElementById('annual-stat-hours');
    const taxRateEl = document.getElementById('annual-stat-tax-rate');
    const avgMonthlyEl = document.getElementById('annual-stat-avg-monthly');
    const hourlyRateEl = document.getElementById('annual-stat-hourly-rate');

    if (grossEl) grossEl.textContent = formatCurrency(totals.grossIncome);
    if (superEl) superEl.textContent = formatCurrency(totals.superGuarantee + totals.extraSuper);
    if (taxEl) taxEl.textContent = formatCurrency(totals.tax);
    if (netEl) netEl.textContent = formatCurrency(totals.netIncome);
    if (hoursEl) hoursEl.textContent = totals.totalHours.toFixed(1) + ' hrs';

    // Calculate and display new metrics
    const effectiveTaxRate = totals.grossIncome > 0 ? (totals.tax / totals.grossIncome) * 100 : 0;
    const avgMonthlyIncome = totals.grossIncome / 12;
    // Use rateCalcHours if available and > 0, otherwise fall back to totalHours
    const hoursForRate = totals.rateCalcHours > 0 ? totals.rateCalcHours : totals.totalHours;
    const effectiveHourlyRate = hoursForRate > 0 ? totals.grossIncome / hoursForRate : 0;

    if (taxRateEl) taxRateEl.textContent = effectiveTaxRate.toFixed(1) + '%';
    if (avgMonthlyEl) avgMonthlyEl.textContent = formatCurrency(avgMonthlyIncome);
    if (hourlyRateEl) hourlyRateEl.textContent = formatCurrency(effectiveHourlyRate) + '/hr';

    // Update breakdown table
    updateAnnualBreakdownTable();

    // Render charts
    destroyAnnualCharts();
    renderAnnualIncomeChart();
    renderAnnualIncomePieChart();
    renderAnnualContractPieChart();
    renderAnnualHourTypesPieChart();
    renderAnnualTotalHoursPieChart();
    renderAnnualTotalHoursByTypePieChart();

    // Update tax analysis
    renderAnnualTaxAnalysis();
    renderAnnualCategorySection();

    // Show/hide empty state
    const hasData = data.monthlyData.some(m => m.grossIncome > 0 || m.totalHours > 0);
    if (annualEmpty) annualEmpty.style.display = hasData ? 'none' : 'block';
  }

  function updateAnnualBreakdownTable() {
    if (!state.annualData) return;
    const totals = state.annualData.yearTotals;
    const totalSuper = totals.superGuarantee + totals.extraSuper;
    const gross = totals.grossIncome;

    // Gross Income (always 100%)
    document.getElementById('annual-breakdown-gross').textContent = formatCurrency(gross);
    document.getElementById('annual-breakdown-gross-pct').textContent = '100%';
    document.getElementById('annual-breakdown-gross-bar').style.width = '100%';

    // Superannuation
    const superPct = gross > 0 ? (totalSuper / gross) * 100 : 0;
    document.getElementById('annual-breakdown-super').textContent = formatCurrency(totalSuper);
    document.getElementById('annual-breakdown-super-pct').textContent = superPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-super-bar').style.width = superPct.toFixed(1) + '%';

    // Superannuation Lost
    const superLostRow = document.getElementById('annual-breakdown-super-lost-row');
    if (totals.superLost > 0.01) {
      if (superLostRow) superLostRow.style.display = '';
      const superLostPct = gross > 0 ? (totals.superLost / gross) * 100 : 0;
      document.getElementById('annual-breakdown-super-lost').textContent = formatCurrency(totals.superLost);
      document.getElementById('annual-breakdown-super-lost-pct').textContent = superLostPct.toFixed(1) + '%';
      document.getElementById('annual-breakdown-super-lost-bar').style.width = superLostPct.toFixed(1) + '%';
    } else {
      if (superLostRow) superLostRow.style.display = 'none';
    }

    // Deductions
    const deductionsPct = gross > 0 ? (totals.otherDeductions / gross) * 100 : 0;
    document.getElementById('annual-breakdown-deductions').textContent = formatCurrency(totals.otherDeductions);
    document.getElementById('annual-breakdown-deductions-pct').textContent = deductionsPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-deductions-bar').style.width = deductionsPct.toFixed(1) + '%';

    // Tax
    const taxPct = gross > 0 ? (totals.tax / gross) * 100 : 0;
    document.getElementById('annual-breakdown-tax').textContent = formatCurrency(totals.tax);
    document.getElementById('annual-breakdown-tax-pct').textContent = taxPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-tax-bar').style.width = taxPct.toFixed(1) + '%';

    // Net Income
    const netPct = gross > 0 ? (totals.netIncome / gross) * 100 : 0;
    document.getElementById('annual-breakdown-net').textContent = formatCurrency(totals.netIncome);
    document.getElementById('annual-breakdown-net-pct').textContent = netPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-net-bar').style.width = netPct.toFixed(1) + '%';

    // Update table striping based on visible rows
    restripeTable('annual-income-breakdown-table');
  }

  // Chart.js plugin for center text in donut charts
  const centerTextPlugin = {
    id: 'centerText',
    beforeDraw: (chart) => {
      if (!chart.config.options.plugins.centerText) return;

      const { ctx, chartArea: { left, top, right, bottom, width, height } } = chart;
      const centerX = left + width / 2;
      const centerY = top + height / 2;

      ctx.save();

      const text = chart.config.options.plugins.centerText.text || '';
      const color = chart.config.options.plugins.centerText.color || '#ffffff';

      // Main text (large, centered)
      ctx.font = 'bold 26px Inter, system-ui, sans-serif';
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, centerX, centerY);

      ctx.restore();
    }
  };

  function renderAnnualIncomeChart() {
    const canvas = document.getElementById('annual-income-chart');
    if (!canvas || !state.annualData) return;

    const monthlyData = state.annualData.monthlyData;
    const labels = monthlyData.map(m => m.label);
    const colors = getThemeColors();

    // Create border arrays - show border for actual income months
    const borderWidths = monthlyData.map(m => m.hasActualIncome ? 2 : 0);
    const borderColors = monthlyData.map(m => m.hasActualIncome ? colors.text : 'transparent');

    const ctx = canvas.getContext('2d');
    state.annualCharts.income = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Tax',
            data: monthlyData.map(m => m.tax),
            backgroundColor: colors.danger,
            borderWidth: borderWidths,
            borderColor: borderColors
          },
          {
            label: 'Deductions',
            data: monthlyData.map(m => m.otherDeductions),
            backgroundColor: colors.warning,
            borderWidth: borderWidths,
            borderColor: borderColors
          },
          {
            label: 'Superannuation',
            data: monthlyData.map(m => m.superGuarantee + m.extraSuper),
            backgroundColor: colors.success,
            borderWidth: borderWidths,
            borderColor: borderColors
          },
          {
            label: 'Net Income',
            data: monthlyData.map(m => m.netIncome),
            backgroundColor: colors.primary,
            borderWidth: borderWidths,
            borderColor: borderColors
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'dataset',
          intersect: true
        },
        plugins: {
          datalabels: {
            color: '#fff',
            font: { size: 10, weight: '600' },
            formatter: (value) => {
              if (value < 500) return ''; // Hide labels for small segments
              return '$' + (value / 1000).toFixed(1) + 'k';
            },
            anchor: 'center',
            align: 'center'
          },
          legend: {
            position: 'top',
            align: 'start',
            labels: {
              color: colors.text,
              font: { size: 12, weight: '500' },
              padding: 16,
              usePointStyle: true,
              pointStyle: 'roundedRect'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            bodySpacing: 6,
            cornerRadius: 8,
            mode: 'index',
            intersect: false,
            callbacks: {
              label: (context) => {
                return '  ' + context.dataset.label + ': ' + formatCurrency(context.parsed.y);
              },
              footer: (items) => {
                const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                const monthIndex = items[0].dataIndex;
                const hasActual = monthlyData[monthIndex].hasActualIncome;
                const dataType = hasActual ? ' (Actual)' : ' (Estimated)';
                return '\n  Gross Total: ' + formatCurrency(total) + dataType;
              }
            }
          }
        },
        scales: {
          x: {
            stacked: true,
            grid: {
              display: false
            },
            ticks: {
              color: colors.muted,
              font: { size: 11 },
              padding: 8
            },
            border: {
              display: false
            }
          },
          y: {
            stacked: true,
            grid: {
              color: colors.border,
              drawBorder: false,
              lineWidth: 1
            },
            ticks: {
              color: colors.muted,
              font: { size: 11 },
              padding: 8,
              callback: (value) => '$' + (value / 1000).toFixed(0) + 'k'
            },
            border: {
              display: false
            }
          }
        },
        layout: {
          padding: {
            top: 10,
            right: 10,
            bottom: 0,
            left: 0
          }
        }
      }
    });
  }

  function renderAnnualIncomePieChart() {
    const canvas = document.getElementById('annual-income-pie-chart');
    if (!canvas || !state.annualData) return;

    const totals = state.annualData.yearTotals;
    const colors = getThemeColors();

    const grossIncome = totals.grossIncome;

    const ctx = canvas.getContext('2d');
    state.annualCharts.incomePie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: ['Net Income', 'Tax', 'Deductions', 'Superannuation'],
        datasets: [{
          data: [
            totals.netIncome,
            totals.tax,
            totals.otherDeductions,
            totals.superGuarantee + totals.extraSuper
          ],
          backgroundColor: [colors.primary, colors.danger, colors.warning, colors.success],
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: formatCurrency(grossIncome),
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'roundedRect'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const value = formatCurrency(context.parsed);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + value + ' (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function renderAnnualContractPieChart() {
    const container = document.getElementById('annual-contract-pie-container');
    const canvas = document.getElementById('annual-contract-pie-chart');
    if (!canvas || !state.annualData || !container) return;

    const contractBreakdown = state.annualData.contractBreakdown;
    if (contractBreakdown.length <= 1) {
      container.style.display = 'none';
      return;
    }

    container.style.display = 'block';
    const colors = getThemeColors();
    const chartColors = [colors.primary, colors.success, colors.warning, colors.danger, '#8b5cf6', '#ec4899', '#14b8a6', '#f59e0b'];

    const totalIncome = contractBreakdown.reduce((sum, c) => sum + c.grossIncome, 0);

    const ctx = canvas.getContext('2d');
    state.annualCharts.contractPie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: contractBreakdown.map(c => c.contractName),
        datasets: [{
          data: contractBreakdown.map(c => c.grossIncome),
          backgroundColor: chartColors.slice(0, contractBreakdown.length),
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: formatCurrency(totalIncome),
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'roundedRect'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const value = formatCurrency(context.parsed);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + value + ' (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function renderAnnualHourTypesPieChart() {
    const container = document.getElementById('annual-hour-types-pie-container');
    const canvas = document.getElementById('annual-hour-types-pie-chart');
    if (!canvas || !state.annualData || !container) return;

    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
    if (!hourTypesEnabled) {
      container.style.display = 'none';
      return;
    }

    const hourTypeBreakdown = state.annualData.hourTypeBreakdown;
    if (hourTypeBreakdown.length === 0) {
      container.style.display = 'none';
      return;
    }

    container.style.display = 'block';
    const colors = getThemeColors();

    const ctx = canvas.getContext('2d');
    state.annualCharts.hourTypesPie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: hourTypeBreakdown.map(ht => ht.hourTypeName),
        datasets: [{
          data: hourTypeBreakdown.map(ht => ht.hours),
          backgroundColor: hourTypeBreakdown.map(ht => ht.hourTypeColor || colors.muted),
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '45%',
        plugins: {
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'roundedRect'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const hours = context.parsed.toFixed(1);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + hours + ' hrs (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      }
    });
  }

  function renderAnnualTotalHoursPieChart() {
    const canvas = document.getElementById('annual-total-hours-pie-chart');
    if (!canvas || !state.annualData) return;

    const monthlyData = state.annualData.monthlyData;
    const labels = monthlyData.map(m => m.label);
    const hours = monthlyData.map(m => m.totalHours);
    const colors = getThemeColors();

    const totalHours = hours.reduce((sum, h) => sum + h, 0);

    // Use rainbow gradient for 12 months (ordered visually)
    const monthColors = hours.map((_, index) => {
      const hue = (index * 30) % 360; // 0, 30, 60, 90, 120... (full spectrum)
      return `hsl(${hue}, 70%, 60%)`;
    });

    const ctx = canvas.getContext('2d');
    state.annualCharts.totalHoursPie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: labels,
        datasets: [{
          data: hours,
          backgroundColor: monthColors,
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: totalHours.toFixed(1) + ' hrs',
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'roundedRect'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const hoursVal = context.parsed.toFixed(1);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + hoursVal + ' hrs (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function renderAnnualTotalHoursByTypePieChart() {
    const canvas = document.getElementById('annual-total-hours-by-type-pie-chart');
    if (!canvas || !state.annualData) return;

    const hourTypeBreakdown = state.annualData.hourTypeBreakdown;
    if (!hourTypeBreakdown || hourTypeBreakdown.length === 0) {
      return;
    }

    const labels = hourTypeBreakdown.map(ht => ht.hourTypeName);
    const hours = hourTypeBreakdown.map(ht => ht.hours);
    const hourColors = hourTypeBreakdown.map(ht => ht.hourTypeColor);
    const colors = getThemeColors();

    const totalHours = hours.reduce((sum, h) => sum + h, 0);

    const ctx = canvas.getContext('2d');
    state.annualCharts.totalHoursByTypePie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: labels,
        datasets: [{
          data: hours,
          backgroundColor: hourColors,
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: totalHours.toFixed(1) + ' hrs',
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const hoursVal = context.parsed.toFixed(1);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + hoursVal + ' hrs (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function calculateAustralianTax(annualTaxableIncome) {
    // Australian tax brackets 2024/2025
    let tax = 0;

    if (annualTaxableIncome <= 18200) {
      tax = 0;
    } else if (annualTaxableIncome <= 45000) {
      tax = (annualTaxableIncome - 18200) * 0.16;
    } else if (annualTaxableIncome <= 135000) {
      tax = 4288 + (annualTaxableIncome - 45000) * 0.30;
    } else if (annualTaxableIncome <= 190000) {
      tax = 31288 + (annualTaxableIncome - 135000) * 0.37;
    } else {
      tax = 51638 + (annualTaxableIncome - 190000) * 0.45;
    }

    // Add Medicare levy (2%)
    const medicareLevy = annualTaxableIncome * 0.02;

    return tax + medicareLevy;
  }

  function renderAnnualTaxAnalysis() {
    if (!state.annualData) return;

    const monthlyData = state.annualData.monthlyData;
    const totals = state.annualData.yearTotals;
    const paidTax = totals.tax;

    // Calculate annual taxable income by summing monthly taxable incomes
    const annualTaxableIncome = monthlyData.reduce((sum, m) => sum + m.taxableIncome, 0);

    // Calculate expected ATO tax with Medicare levy
    const expectedTax = calculateAustralianTax(annualTaxableIncome);
    const difference = paidTax - expectedTax;

    document.getElementById('annual-tax-paid').textContent = formatCurrency(paidTax);
    document.getElementById('annual-tax-expected').textContent = formatCurrency(expectedTax);

    const diffEl = document.getElementById('annual-tax-difference');
    if (diffEl) {
      diffEl.textContent = formatCurrency(Math.abs(difference));
      diffEl.style.color = difference > 0 ? 'var(--danger)' : 'var(--success)';
    }
  }

  // Event listeners for annual views
  if (annualYearTypeToggle) {
    annualYearTypeToggle.addEventListener('change', () => {
      const oldType = state.annualYearType;
      state.annualYearType = annualYearTypeToggle.checked ? 'calendar' : 'financial';

      if (annualYearTypeLabel) {
        annualYearTypeLabel.textContent = state.annualYearType === 'financial' ? 'Financial Year' : 'Calendar Year';
      }

      // Get corresponding year for new type
      const correspondingYear = getCorrespondingYear(state.annualCurrentYear, oldType, state.annualYearType);

      // Update year selector with new type's years
      const allYears = collectAllYears();
      const years = state.annualYearType === 'financial' ? allYears.financial : allYears.calendar;

      if (years.length === 0) {
        years.push(new Date().getFullYear());
      }

      // Set year to corresponding year if it exists, otherwise use first available
      if (years.includes(correspondingYear)) {
        state.annualCurrentYear = correspondingYear;
      } else {
        state.annualCurrentYear = years[0];
      }

      if (annualYearSelect) {
        const options = years.map(year => {
          const fy = financialYearLabel(year);
          return `<option value="${year}">${state.annualYearType === 'financial' ? fy : year}</option>`;
        }).join('');
        annualYearSelect.innerHTML = options;
        annualYearSelect.value = String(state.annualCurrentYear);
      }

      // Reset annual data and contract filter when toggling year type
      state.annualData = null;
      state.annualFilteredContracts = [];

      saveCache();
      renderAnnualContractFilter();
      loadAnnualData();
    });
  }

  if (annualYearSelect) {
    annualYearSelect.addEventListener('change', () => {
      state.annualCurrentYear = Number(annualYearSelect.value);
      // Reset annual data and contract filter when changing year
      state.annualData = null;
      state.annualFilteredContracts = [];
      saveCache();
      loadAnnualData();
    });
  }

  if (annualContractFilterToggle) {
    annualContractFilterToggle.addEventListener('click', () => {
      if (annualContractFilterPanel) {
        const isHidden = annualContractFilterPanel.style.display === 'none';
        annualContractFilterPanel.style.display = isHidden ? 'block' : 'none';
      }
    });
  }

  if (annualFilterSelectAll) {
    annualFilterSelectAll.addEventListener('click', () => {
      // Get year range based on year type
      let yearStart, yearEnd;
      if (state.annualYearType === 'financial') {
        yearStart = new Date(state.annualCurrentYear, 6, 1);
        yearEnd = new Date(state.annualCurrentYear + 1, 5, 30, 23, 59, 59);
      } else {
        yearStart = new Date(state.annualCurrentYear, 0, 1);
        yearEnd = new Date(state.annualCurrentYear, 11, 31, 23, 59, 59);
      }

      // Select only relevant contracts for this year
      const relevantContracts = state.contracts.filter(c => {
        if (!c || !c.id) return false;
        const contractStart = c.start_date ? new Date(c.start_date) : new Date(0);
        const contractEnd = c.end_date ? new Date(c.end_date) : new Date(9999, 11, 31);
        return contractStart <= yearEnd && contractEnd >= yearStart;
      });

      state.annualFilteredContracts = relevantContracts.map(c => c.id);
      saveCache();
      renderAnnualContractFilter();
      loadAnnualData();
    });
  }

  if (annualCategoryFilterSelectAll) {
    annualCategoryFilterSelectAll.addEventListener('click', (event) => {
      event.preventDefault();
      const keys = getAnnualCategoryKeys();
      state.annualCategoryFilters = keys.slice();
      saveCache();
      renderAnnualCategoryFilters(keys);
      renderAnnualCategoryTable(keys);
    });
  }

  if (annualCategoryFilterClear) {
    annualCategoryFilterClear.addEventListener('click', (event) => {
      event.preventDefault();
      state.annualCategoryFilters = [];
      saveCache();
      const keys = getAnnualCategoryKeys();
      renderAnnualCategoryFilters(keys);
      renderAnnualCategoryTable(keys);
    });
  }
function renderDeductionsList() {
    if (!deductionsListEl) return;
    const list = Array.isArray(state.deductions) ? [...state.deductions] : [];
    list.sort((a, b) => compareByDisplayOrder(a, b, { activeFirst: true }));
    const hasItems = list.length > 0;
    if (deductionsEmptyEl) {
      deductionsEmptyEl.style.display = hasItems ? 'none' : 'block';
    }

    const showReadonlyNote = !state.companyTrackingEnabled && list.some((item) => item.company_expense);
    if (deductionCompanyDisabledNote) {
      deductionCompanyDisabledNote.style.display = showReadonlyNote ? 'inline-flex' : 'none';
    }

    deductionsListEl.innerHTML = '';

    const categoriesEnabled = isDeductionCategoriesEnabled();
    const hasCustomCategories = categoriesEnabled && state.deductionCategories.length > 0;

    if (hasCustomCategories) {
      ensureDeductionCategoryCollapseState();

      const groups = {};
      list.forEach((deduction) => {
        const key = deduction.category_id && state.deductionCategoryMap[deduction.category_id]
          ? deduction.category_id
          : '__uncategorised__';
        if (!groups[key]) groups[key] = [];
        groups[key].push(deduction);
      });

      const groupEntries = Object.keys(groups).map((key) => {
        const items = groups[key].slice().sort((a, b) => compareByDisplayOrder(a, b, { activeFirst: true }));
        const meta = key === '__uncategorised__'
          ? { id: '__uncategorised__', name: 'Uncategorised', color: '#6b7280' }
          : getDeductionCategoryMeta(key);
        return { id: key, meta, items };
      });

      groupEntries.sort((a, b) => {
        if (a.id === '__uncategorised__') return 1;
        if (b.id === '__uncategorised__') return -1;
        return a.meta.name.localeCompare(b.meta.name);
      });

      groupEntries.forEach((group) => {
        const container = document.createElement('div');
        container.className = 'ts-deduction-category-group';

        const header = document.createElement('div');
        header.className = 'ts-item';
        header.style.display = 'flex';
        header.style.alignItems = 'center';
        header.style.justifyContent = 'space-between';
        header.style.cursor = 'pointer';

        const left = document.createElement('div');
        left.style.display = 'flex';
        left.style.alignItems = 'center';
        left.style.gap = '8px';

        const dot = document.createElement('span');
        dot.style.display = 'inline-block';
        dot.style.width = '10px';
        dot.style.height = '10px';
        dot.style.borderRadius = '50%';
        dot.style.backgroundColor = group.meta.color || '#6b7280';
        left.appendChild(dot);

        const title = document.createElement('span');
        title.style.fontWeight = '600';
        title.textContent = group.meta.name;
        left.appendChild(title);

        const count = document.createElement('span');
        count.className = 'ts-note';
        count.textContent = `${group.items.length} item${group.items.length === 1 ? '' : 's'}`;
        left.appendChild(count);

        header.appendChild(left);

        const arrow = document.createElement('span');
        const collapsed = !!state.deductionCategoryCollapse[group.id];
        arrow.textContent = collapsed ? '' : '';
        header.appendChild(arrow);

        header.addEventListener('click', () => {
          const current = !!state.deductionCategoryCollapse[group.id];
          state.deductionCategoryCollapse[group.id] = !current;
          saveCache();
          renderDeductionsList();
        });

        container.appendChild(header);

        const body = document.createElement('div');
        body.style.marginTop = '8px';
        body.style.display = collapsed ? 'none' : 'block';

        group.items.forEach((deduction) => {
          const card = createDeductionCard(deduction, { hideCategoryBadge: true });
          body.appendChild(card);
        });

        container.appendChild(body);
        deductionsListEl.appendChild(container);
      });
    } else {
      list.forEach((deduction) => {
        const card = createDeductionCard(deduction, { hideCategoryBadge: false });
        deductionsListEl.appendChild(card);
      });
    }

    if (deductionCategoryCollapseControls) {
      deductionCategoryCollapseControls.style.display = (hasCustomCategories && hasItems) ? 'flex' : 'none';
    }

    renderAnnualCategorySection();
  }

  function createDeductionCard(deduction, options = {}) {
    const hideCategoryBadge = !!options.hideCategoryBadge;
    const wrapper = document.createElement('div');
    wrapper.className = 'ts-deduction-card';
    if (!deduction.active || (deduction.company_expense && !state.companyTrackingEnabled)) {
      wrapper.classList.add('ts-deduction-readonly');
    }

    const details = document.createElement('div');
    details.className = 'ts-deduction-details';

    const header = document.createElement('div');
    header.className = 'ts-deduction-header';

    const title = document.createElement('div');
    title.style.fontWeight = '600';
    title.textContent = deduction.name || 'Untitled deduction';
    header.appendChild(title);

    if (!hideCategoryBadge && isDeductionCategoriesEnabled()) {
      const categoryMeta = getDeductionCategoryMeta(deduction.category_id);
      const categoryBadge = document.createElement('span');
      categoryBadge.className = 'ts-badge';
      categoryBadge.textContent = categoryMeta.name;
      categoryBadge.style.borderLeft = `4px solid ${categoryMeta.color || '#6b7280'}`;
      header.appendChild(categoryBadge);
    }

    const expenseBadge = document.createElement('span');
    expenseBadge.className = 'ts-badge';
    const isUnusedCompanyExpense = deduction.company_expense && !state.companyTrackingEnabled;
    expenseBadge.textContent = deduction.company_expense ? 'Company expense' : 'Salary sacrifice';
    header.appendChild(expenseBadge);

    // Add prominent warning indicator for unused company expenses
    if (isUnusedCompanyExpense) {
      const warningBadge = document.createElement('span');
      warningBadge.className = 'ts-badge';
      warningBadge.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align:middle;"><path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/></svg> Not used in calculations';
      warningBadge.style.cssText = 'background:var(--warning)20; color:var(--warning); border:1px solid var(--warning); font-weight:600;';
      warningBadge.title = 'Company expense tracking is disabled. This deduction is not included in any income calculations while the "Enable company income tracking" feature flag is disabled.';
      header.appendChild(warningBadge);
    }

    if (deduction.deduction_type === 'extra_super') {
      const typeBadge = document.createElement('span');
      typeBadge.className = 'ts-badge';
      typeBadge.textContent = 'Extra super';
      header.appendChild(typeBadge);
    }

    details.appendChild(header);

    const meta = document.createElement('div');
    meta.className = 'ts-deduction-meta';
    const amountSpan = document.createElement('span');
    amountSpan.textContent = formatDeductionAmount(deduction);
    if (deduction.company_expense && deduction.gst_inclusive && deduction.amount_type !== 'percent') {
      amountSpan.textContent += ' (GST excl.)';
      amountSpan.title = `Entered ${formatCurrency(deduction.amount_value)} incl. GST`;
    }
    meta.appendChild(amountSpan);

    const freqSpan = document.createElement('span');
    freqSpan.textContent = formatFrequencyLabel(deduction.frequency);
    meta.appendChild(freqSpan);

    const startSpan = document.createElement('span');
    startSpan.textContent = `Starts ${deduction.start_date ? DATE_FULL_FORMATTER.format(parseIsoDate(deduction.start_date)) : ''}`;
    meta.appendChild(startSpan);

    if (deduction.end_date) {
      const endSpan = document.createElement('span');
      endSpan.textContent = `Ends ${DATE_FULL_FORMATTER.format(parseIsoDate(deduction.end_date))}`;
      meta.appendChild(endSpan);
    }
    details.appendChild(meta);

    const upcomingDates = getUpcomingDeductionDates(deduction, 5);
    if (deduction.frequency !== 'once') {
      const occurrenceEl = document.createElement('span');
      occurrenceEl.className = 'ts-deduction-occurrences';
      if (upcomingDates.length) {
        occurrenceEl.textContent = `Next deduction on ${DATE_FULL_FORMATTER.format(parseIsoDate(upcomingDates[0]))}`;
      } else {
        occurrenceEl.textContent = 'No upcoming deductions scheduled.';
      }
      meta.appendChild(occurrenceEl);
    }

    if (deduction.notes) {
      const noteEl = document.createElement('div');
      noteEl.className = 'ts-deduction-note';
      noteEl.textContent = deduction.notes;
      details.appendChild(noteEl);
    }

    const actions = document.createElement('div');
    actions.className = 'ts-deduction-actions';

    const editBtn = document.createElement('button');
    editBtn.className = 'ghost small';
    editBtn.textContent = 'Edit';
    editBtn.addEventListener('click', () => openDeductionForm('edit', deduction));

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'ghost small danger';
    deleteBtn.textContent = 'Delete';
    deleteBtn.addEventListener('click', () => handleDeleteDeduction(deduction));

    const readOnly = (!deduction.active) || (deduction.company_expense && !state.companyTrackingEnabled);
    if (readOnly) {
      editBtn.disabled = true;
      deleteBtn.disabled = true;
      editBtn.title = 'Company tracking is disabled; this deduction is read-only.';
      deleteBtn.title = editBtn.title;
    }

    actions.appendChild(editBtn);
    actions.appendChild(deleteBtn);

    wrapper.appendChild(details);
    wrapper.appendChild(actions);
    return wrapper;
  }

  function resetDeductionForm() {
    if (!deductionNameInput) return;
    deductionFormState.mode = 'create';
    deductionFormState.editingId = null;
    deductionFormState.original = null;
    deductionNameInput.value = '';
    renderDeductionCategoryOptions('');
    if (deductionTypeSelect) deductionTypeSelect.value = 'standard';
    if (deductionAmountInput) deductionAmountInput.value = '';
    if (deductionPercentInput) deductionPercentInput.value = '';
    if (deductionAmountModeSelect) deductionAmountModeSelect.value = 'flat';
    if (deductionGstToggle) deductionGstToggle.checked = false;
    if (deductionCompanyToggle) deductionCompanyToggle.checked = false;
    if (deductionFrequencySelect) deductionFrequencySelect.value = 'once';
    if (deductionStartDateInput) deductionStartDateInput.value = todayIso();
    if (deductionEndDateInput) deductionEndDateInput.value = '';
    if (deductionNotesInput) deductionNotesInput.value = '';
    if (deductionOccurrencePreview) deductionOccurrencePreview.textContent = '';
    updateDeductionFormVisibility();
  }

  function closeDeductionForm() {
    deductionFormState.mode = 'create';
    deductionFormState.editingId = null;
    deductionFormState.original = null;
    hideModal(deductionFormModal);
  }

  function openDeductionForm(mode, deduction) {
    if (!deductionFormModal) return;
    if (mode === 'edit' && deduction && deduction.company_expense && !state.companyTrackingEnabled) {
      setStatus('Enable company tracking features to edit company deductions.', 'warn');
      return;
    }
    resetDeductionForm();
    deductionFormState.mode = mode;
    deductionFormState.editingId = deduction ? deduction.id : null;
    deductionFormState.original = deduction || null;
    if (deductionFormTitle) {
      deductionFormTitle.textContent = mode === 'edit' ? 'Edit deduction' : 'Add deduction';
    }
    if (mode === 'edit' && deduction) {
      if (deductionNameInput) deductionNameInput.value = deduction.name || '';
      renderDeductionCategoryOptions(deduction.category_id || '');
      if (deductionTypeSelect) deductionTypeSelect.value = deduction.deduction_type === 'extra_super' ? 'extra_super' : 'standard';
      if (deductionCompanyToggle) {
        deductionCompanyToggle.checked = !!(deduction.company_expense && state.companyTrackingEnabled && deduction.deduction_type !== 'extra_super');
      }
      const amountMode = deduction.amount_type === 'percent' ? 'percent' : 'flat';
      if (deductionAmountModeSelect) deductionAmountModeSelect.value = amountMode;
      if (amountMode === 'percent') {
        if (deductionPercentInput) {
          deductionPercentInput.value = Math.round((Number(deduction.amount_value) || 0) * 10000) / 100;
        }
      } else if (deductionAmountInput) {
        deductionAmountInput.value = Number(deduction.amount_value || 0).toFixed(2);
      }
      if (deductionGstToggle) deductionGstToggle.checked = !!deduction.gst_inclusive;
      if (deductionFrequencySelect) deductionFrequencySelect.value = deduction.frequency || 'once';
      if (deductionStartDateInput) deductionStartDateInput.value = deduction.start_date || '';
      if (deductionEndDateInput) deductionEndDateInput.value = deduction.end_date || '';
      if (deductionNotesInput) deductionNotesInput.value = deduction.notes || '';
    } else {
      renderDeductionCategoryOptions('');
    }
    updateDeductionFormVisibility();
    updateDeductionOccurrencePreview();
    showModal(deductionFormModal);
    if (deductionNameInput) deductionNameInput.focus();
  }

function updateDeductionFormVisibility() {
    if (!deductionTypeSelect) return;
    const type = deductionTypeSelect.value === 'extra_super' ? 'extra_super' : 'standard';
    const amountMode = type === 'extra_super' && deductionAmountModeSelect ? deductionAmountModeSelect.value : 'flat';
    const companyAllowed = state.companyTrackingEnabled;
    const companyExpense = companyAllowed && deductionCompanyToggle ? deductionCompanyToggle.checked : false;

    if (deductionCompanyWrapper) {
      deductionCompanyWrapper.style.display = companyAllowed ? 'flex' : 'none';
    }
    if (deductionCompanyToggle) {
      if (!companyAllowed) {
        deductionCompanyToggle.checked = false;
      }
      const shouldDisableCompanyToggle = !companyAllowed || type === 'extra_super';
      deductionCompanyToggle.disabled = shouldDisableCompanyToggle;
      if (shouldDisableCompanyToggle && deductionCompanyToggle.checked) {
        deductionCompanyToggle.checked = false;
      }
    }

    if (deductionAmountModeWrapper) {
      deductionAmountModeWrapper.style.display = type === 'extra_super' ? 'block' : 'none';
    }
    if (deductionPercentWrapper) {
      deductionPercentWrapper.style.display = type === 'extra_super' && amountMode === 'percent' ? 'block' : 'none';
    }
    if (deductionAmountWrapper) {
      deductionAmountWrapper.style.display = !(type === 'extra_super' && amountMode === 'percent') ? 'block' : 'none';
    }

    const showGstToggle = type === 'standard';
    if (deductionGstWrapper) {
      deductionGstWrapper.style.display = 'flex';
    }
    if (deductionGstToggle) {
      if (!showGstToggle) {
        deductionGstToggle.checked = false;
      }
      deductionGstToggle.disabled = !showGstToggle;
    }
    if (deductionCompanyGstNote) {
      if (companyExpense && showGstToggle) {
        deductionCompanyGstNote.style.display = 'block';
        deductionCompanyGstNote.textContent = 'GST component is tracked automatically when the amount includes GST.';
      } else {
        deductionCompanyGstNote.style.display = 'none';
      }
    }

    const restrictToMonthly = type === 'extra_super' && amountMode === 'percent';
    if (deductionFrequencySelect) {
      Array.from(deductionFrequencySelect.options).forEach((option) => {
        if (restrictToMonthly && option.value !== 'monthly') {
          option.disabled = true;
        } else {
          option.disabled = false;
        }
      });
      if (restrictToMonthly) {
        deductionFrequencySelect.value = 'monthly';
      }
    }

    if (deductionFrequencySelect && deductionFrequencySelect.value === 'once') {
      if (deductionEndDateWrapper) deductionEndDateWrapper.style.display = 'none';
      if (deductionEndDateInput) deductionEndDateInput.value = '';
    } else if (deductionEndDateWrapper) {
      deductionEndDateWrapper.style.display = 'block';
    }

    updateDeductionOccurrencePreview();
  }

  function updateDeductionOccurrencePreview() {
    if (!deductionOccurrencePreview || !deductionStartDateInput) return;
    const startDateValue = deductionStartDateInput.value;
    const frequency = deductionFrequencySelect ? deductionFrequencySelect.value : 'once';
    const endDateValue = deductionEndDateInput ? deductionEndDateInput.value : '';
    if (!startDateValue) {
      deductionOccurrencePreview.textContent = 'Select a start date to preview the schedule.';
      return;
    }
    const preview = {
      start_date: startDateValue,
      end_date: frequency === 'once' ? '' : endDateValue,
      frequency: frequency
    };
    const previewDates = getDeductionPreviewDates(preview, 5);
    if (!previewDates.length) {
      if (frequency === 'once') {
      deductionOccurrencePreview.textContent = `Occurs on ${DATE_FULL_FORMATTER.format(parseIsoDate(startDateValue))}.`;
      } else {
        deductionOccurrencePreview.textContent = 'No future occurrences within the configured range.';
      }
      return;
    }
    const labels = previewDates.map((iso) => DATE_FULL_FORMATTER.format(parseIsoDate(iso)));
    deductionOccurrencePreview.textContent = `Next ${labels.length > 1 ? labels.length : 1} deduction${labels.length > 1 ? 's' : ''}: ${labels.join(', ')}`;
  }

  function collectDeductionPayload() {
    if (!deductionNameInput) return null;
    const name = deductionNameInput.value.trim();
    if (!name) {
      setStatus('Deduction name is required.', 'warn');
      return null;
    }
    const type = deductionTypeSelect ? deductionTypeSelect.value : 'standard';
    const categoryId = (isDeductionCategoriesEnabled() && deductionCategorySelect) ? deductionCategorySelect.value : '';
    let companyExpense = state.companyTrackingEnabled && deductionCompanyToggle ? deductionCompanyToggle.checked : false;
    if (type === 'extra_super') {
      companyExpense = false;
    }
    const amountMode = type === 'extra_super' && deductionAmountModeSelect ? deductionAmountModeSelect.value : 'flat';
    let amountValue;
    if (amountMode === 'percent') {
      amountValue = Number(deductionPercentInput ? deductionPercentInput.value : '');
      if (!Number.isFinite(amountValue) || amountValue <= 0) {
        setStatus('Enter a valid percentage for the deduction.', 'warn');
        return null;
      }
      if (amountValue > 50) {
        setStatus('Percentage deductions must be 50% or less.', 'warn');
        return null;
      }
    } else {
      amountValue = Number(deductionAmountInput ? deductionAmountInput.value : '');
      if (!Number.isFinite(amountValue) || amountValue < 0) {
        setStatus('Enter a valid amount for the deduction.', 'warn');
        return null;
      }
    }
    const frequency = deductionFrequencySelect ? deductionFrequencySelect.value : 'once';
    const startDateValue = deductionStartDateInput ? deductionStartDateInput.value : '';
    if (!startDateValue) {
      setStatus('Select a start date for the deduction.', 'warn');
      return null;
    }
    let endDateValue = deductionEndDateInput ? deductionEndDateInput.value : '';
    if (frequency === 'once') {
      endDateValue = '';
    } else if (endDateValue && endDateValue < startDateValue) {
      setStatus('End date must be on or after the start date.', 'warn');
      return null;
    }
    const payload = {
      id: deductionFormState.mode === 'edit' ? deductionFormState.editingId : undefined,
      name,
      category_id: categoryId,
      company_expense: companyExpense,
      deduction_type: type,
      amount_type: amountMode,
      amount_value: amountValue,
      gst_inclusive: (type === 'standard' && companyExpense) ? (deductionGstToggle ? deductionGstToggle.checked : false) : false,
      frequency,
      start_date: startDateValue,
      end_date: endDateValue,
      notes: deductionNotesInput ? deductionNotesInput.value.trim() : '',
      active: true
    };
    if (payload.deduction_type === 'extra_super') {
      payload.company_expense = false;
      payload.gst_inclusive = false;
    }
    if (type === 'extra_super' && amountMode === 'percent') {
      payload.frequency = 'monthly';
    }
    return payload;
  }

  function buildOptimisticDeduction(payload, existing) {
    const nowIso = new Date().toISOString();
    const id = payload.id || `temp_${Date.now()}`;
    const amountDecimal = payload.amount_type === 'percent'
      ? (Number(payload.amount_value) / 100)
      : Number(payload.amount_value);
    const base = {
      id,
      name: payload.name,
      category_id: payload.category_id || '',
      company_expense: !!payload.company_expense,
      deduction_type: payload.deduction_type,
      amount_type: payload.amount_type,
      amount_value: payload.amount_type === 'percent' ? amountDecimal : amountDecimal,
      gst_inclusive: !!payload.gst_inclusive,
      gst_amount: payload.company_expense && payload.deduction_type === 'standard' && payload.gst_inclusive
        ? Math.round((Number(payload.amount_value) - (Number(payload.amount_value) / (1 + GST_RATE))) * 100) / 100
        : 0,
      frequency: payload.frequency,
      start_date: payload.start_date,
      end_date: payload.frequency === 'once' ? '' : payload.end_date,
      notes: payload.notes || '',
      active: true,
      created_at: existing && existing.created_at ? existing.created_at : nowIso,
      updated_at: nowIso
    };
    return sanitizeDeduction(base);
  }

  function deductionHasPastOccurrences(deduction) {
    if (!deduction || !deduction.start_date) return false;
    const today = startOfDay(new Date());
    const startDate = parseIsoDate(deduction.start_date);
    return startDate < today;
  }

  function findLastPastOccurrence(deduction) {
    if (!deduction || !deduction.start_date) return null;
    const today = startOfDay(new Date());
    const startDate = parseIsoDate(deduction.start_date);
    const endDate = deduction.end_date ? parseIsoDate(deduction.end_date) : null;

    if (startDate >= today) return null;

    const upperBound = endDate && endDate < today ? endDate : new Date(today.getTime() - 24 * 60 * 60 * 1000); // Yesterday

    if (deduction.frequency === 'once') {
      return startDate <= upperBound ? isoDate(startDate) : null;
    }

    let current = startOfDay(startDate);
    let lastPast = null;

    while (current && current <= upperBound) {
      lastPast = isoDate(current);
      current = nextOccurrenceDate(current, deduction.frequency);
      if (!current) break;
      if (endDate && current > endDate) break;
    }

    return lastPast;
  }

  function findNextFutureOccurrence(deduction) {
    if (!deduction || !deduction.start_date) return null;
    const today = startOfDay(new Date());
    const startDate = parseIsoDate(deduction.start_date);
    const endDate = deduction.end_date ? parseIsoDate(deduction.end_date) : null;

    if (startDate >= today) return isoDate(startDate);

    if (deduction.frequency === 'once') {
      return null; // One-time deduction in the past has no future occurrence
    }

    let current = startOfDay(startDate);

    while (current && current < today) {
      current = nextOccurrenceDate(current, deduction.frequency);
      if (!current) return null;
      if (endDate && current > endDate) return null;
    }

    return current ? isoDate(current) : null;
  }

  function performSplitDeduction(originalDeduction, newPayload) {
    const lastPastDate = findLastPastOccurrence(originalDeduction);
    const nextFutureDate = findNextFutureOccurrence(originalDeduction);

    if (!lastPastDate || !nextFutureDate) {
      // No split needed, just save normally
      saveDeductionDirectly(newPayload, originalDeduction);
      return;
    }

    // Step 1: Update original deduction with end date = last past occurrence
    const updatedOriginal = {
      ...originalDeduction,
      end_date: lastPastDate
    };

    // Step 2: Create new deduction with new settings starting from next future occurrence
    const newDeduction = {
      ...newPayload,
      id: undefined, // New UUID will be generated
      start_date: nextFutureDate
    };

    // Save both deductions
    setStatus('Splitting deduction...', 'warn');

    const previousList = state.deductions.slice();
    const revertOptimisticSplit = () => {
      state.deductions = previousList.slice();
      state.deductions = dedupeById(state.deductions);
      saveCache();
      renderDeductionsList();
      renderIncomeSummary();
      renderAnnualCategorySection();
    };

    const optimisticOriginal = sanitizeDeduction({ ...updatedOriginal });
    const optimisticNewId = `temp_split_${Date.now()}`;
    const optimisticNew = sanitizeDeduction({
      ...newDeduction,
      id: optimisticNewId
    });
    const exceptionsSnapshot = Array.isArray(state.deductionExceptions) ? state.deductionExceptions.slice() : [];
    const extraMonthKeys = [
      monthKeyFromDateIso(originalDeduction.start_date),
      monthKeyFromDateIso(originalDeduction.end_date),
      monthKeyFromDateIso(lastPastDate),
      monthKeyFromDateIso(nextFutureDate),
      monthKeyFromDateIso(newDeduction.start_date),
      monthKeyFromDateIso(newDeduction.end_date)
    ];

    const originalIndex = state.deductions.findIndex((item) => item.id === originalDeduction.id);
    if (originalIndex !== -1) {
      state.deductions.splice(originalIndex, 1, optimisticOriginal);
    } else {
      state.deductions.push(optimisticOriginal);
    }
    state.deductions.push(optimisticNew);
    state.deductions = dedupeById(state.deductions);
    markIncomeMonthsDirtyForDeductionChange(originalDeduction, optimisticOriginal, exceptionsSnapshot, exceptionsSnapshot, extraMonthKeys);
    markIncomeMonthsDirtyForDeductionChange(null, optimisticNew, exceptionsSnapshot, exceptionsSnapshot, extraMonthKeys);
    saveCache();
    renderDeductionsList();
    renderIncomeSummary();
    renderAnnualCategorySection();

    // First, update the original
    google.script.run
      .withSuccessHandler((res1) => {
        if (res1 && res1.success) {
          // Then create the new one
          google.script.run
            .withSuccessHandler((res2) => {
              if (res2 && res2.success) {
                // Reload deductions
                google.script.run
                  .withSuccessHandler((deductions) => {
                    const nextList = dedupeById((deductions || []).map(sanitizeDeduction));
                    const prevMap = new Map(previousList.map((d) => [d.id, d]));
                    const nextMap = new Map(nextList.map((d) => [d.id, d]));
                    const changedIds = new Set([originalDeduction.id]);
                    nextMap.forEach((val, id) => {
                      if (!prevMap.has(id)) changedIds.add(id);
                    });
                    changedIds.forEach((id) => {
                      markIncomeMonthsDirtyForDeductionChange(
                        prevMap.get(id),
                        nextMap.get(id),
                        exceptionsSnapshot,
                        exceptionsSnapshot,
                        extraMonthKeys
                      );
                    });
                    state.deductions = nextList;
                    saveCache();
                    renderDeductionsList();
                    renderIncomeSummary();
                    renderAnnualCategorySection();
                    if (state.annualData) {
                      loadAnnualData();
                    }
                    setStatus('Deduction split successfully', 'success');
                  })
                  .withFailureHandler(() => {
                    revertOptimisticSplit();
                    setStatus('Failed to reload deductions', 'error');
                  })
                  .api_getDeductions();
              } else {
                revertOptimisticSplit();
                setStatus('Failed to create future deduction', 'error');
              }
            })
            .withFailureHandler(() => {
              revertOptimisticSplit();
              setStatus('Failed to create future deduction', 'error');
            })
            .api_upsertDeduction(newDeduction);
        } else {
          revertOptimisticSplit();
          setStatus('Failed to update past deduction', 'error');
        }
      })
      .withFailureHandler(() => {
        revertOptimisticSplit();
        setStatus('Failed to update past deduction', 'error');
      })
      .api_upsertDeduction(updatedOriginal);
  }

  function performOverrideDeduction(payload, originalDeduction) {
    // Delete all exceptions for this deduction
    if (originalDeduction && originalDeduction.id) {
      google.script.run
        .withSuccessHandler(() => {
          // Remove exceptions from local state
          state.deductionExceptions = state.deductionExceptions.filter(
            ex => ex.deduction_id !== originalDeduction.id
          );
          saveCache();

          // Now save the deduction normally
          saveDeductionDirectly(payload, originalDeduction);
        })
        .withFailureHandler(() => {
          setStatus('Failed to delete exceptions', 'error');
        })
        .api_deleteExceptionsByDeductionId(originalDeduction.id);
    } else {
      saveDeductionDirectly(payload, originalDeduction);
    }
  }

  function saveDeductionDirectly(payload, existing) {
    const isEdit = !!existing;
    const previousList = state.deductions.slice();
    const exceptionsSnapshot = Array.isArray(state.deductionExceptions) ? state.deductionExceptions.slice() : [];
    const existingIndex = isEdit ? state.deductions.findIndex((item) => item.id === payload.id) : -1;
    const optimisticId = isEdit ? payload.id : `temp_${Date.now()}`;
    const optimisticDeduction = buildOptimisticDeduction({ ...payload, id: optimisticId }, existing);

    if (isEdit && existingIndex !== -1) {
      state.deductions.splice(existingIndex, 1, optimisticDeduction);
    } else {
      state.deductions.push(optimisticDeduction);
    }

    state.deductions = dedupeById(state.deductions);
    const extraMonthKeys = [
      monthKeyFromDateIso(payload.start_date),
      monthKeyFromDateIso(payload.end_date),
      monthKeyFromDateIso(existing ? existing.start_date : null),
      monthKeyFromDateIso(existing ? existing.end_date : null)
    ];
    markIncomeMonthsDirtyForDeductionChange(existing, optimisticDeduction, exceptionsSnapshot, exceptionsSnapshot, extraMonthKeys);
    saveCache();
    renderDeductionsList();
    renderIncomeSummary();
    renderAnnualCategorySection();
    setStatus('Saving deduction...', 'warn');

    const serverPayload = { ...payload };

    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success && res.deduction) {
          const updated = sanitizeDeduction(res.deduction);
          const matchIndex = state.deductions.findIndex((item) => item.id === optimisticId);
          if (matchIndex !== -1) {
            state.deductions.splice(matchIndex, 1, updated);
          } else if (isEdit) {
            const editIndex = state.deductions.findIndex((item) => item.id === payload.id);
            if (editIndex !== -1) state.deductions.splice(editIndex, 1, updated);
          } else {
            state.deductions.push(updated);
          }
          state.deductions = dedupeById(state.deductions);
          saveCache();
          renderDeductionsList();
          renderIncomeSummary();
          renderAnnualCategorySection();
          if (state.annualData) {
            loadAnnualData();
          }
          setStatus('Deduction saved', 'success');
          } else {
            state.deductions = previousList;
            state.deductions = dedupeById(state.deductions);
            saveCache();
            renderDeductionsList();
            renderIncomeSummary();
            renderAnnualCategorySection();
            setStatus('Deduction save failed', 'error');
        }
        })
        .withFailureHandler(() => {
          state.deductions = previousList;
          state.deductions = dedupeById(state.deductions);
          saveCache();
          renderDeductionsList();
          renderIncomeSummary();
          renderAnnualCategorySection();
          setStatus('Deduction save failed', 'error');
      })
      .api_upsertDeduction(serverPayload);
  }

  function handleSaveDeduction() {
    const payload = collectDeductionPayload();
    if (!payload) return;
    const isEdit = deductionFormState.mode === 'edit' && deductionFormState.editingId;
    if (isEdit) {
      payload.id = deductionFormState.editingId;
    }
    const previousList = state.deductions.slice();
    const existingIndex = isEdit ? state.deductions.findIndex((item) => item.id === payload.id) : -1;
    const existing = existingIndex !== -1 ? state.deductions[existingIndex] : null;

    // Check if we need to show the split dialog
    const categoryOnlyChange = isEdit && existing && Object.keys(payload).every((key) => {
      if (key === 'category_id') return true;
      return payload[key] === existing[key];
    });

    if (isEdit && existing && deductionHasPastOccurrences(existing) && !categoryOnlyChange) {
      // Store the payload and original for later
      pendingDeductionPayload = payload;
      originalDeductionForSplit = existing;

      // Close deduction form
      closeDeductionForm();

      // Show split decision modal
      showModal(modalSplitDeduction);
      return;
    }

    // No split needed, save normally
    closeDeductionForm();
    saveDeductionDirectly(payload, existing);
  }

  async function handleDeleteDeduction(deduction) {
    if (!deduction || !deduction.id) return;
    const confirmed = await customConfirm('Delete this deduction?', { danger: true });
    if (!confirmed) return;
    if (deduction.company_expense && !state.companyTrackingEnabled) {
      setStatus('Enable company tracking to modify company deductions.', 'warn');
      return;
    }
    const exceptionsSnapshot = Array.isArray(state.deductionExceptions) ? state.deductionExceptions.slice() : [];
    const extraMonthKeys = [
      monthKeyFromDateIso(deduction.start_date),
      monthKeyFromDateIso(deduction.end_date)
    ];
    markIncomeMonthsDirtyForDeductionChange(deduction, null, exceptionsSnapshot, exceptionsSnapshot, extraMonthKeys);
    const previousList = state.deductions.slice();
    state.deductions = state.deductions.filter((item) => item.id !== deduction.id);
    state.deductions = dedupeById(state.deductions);
    saveCache();
    renderDeductionsList();
    renderIncomeSummary();
    renderAnnualCategorySection();
    setStatus('Deleting deduction...', 'warn');
    google.script.run
      .withSuccessHandler(() => {
        if (state.annualData) {
          loadAnnualData();
        }
        setStatus('Deduction deleted', 'success');
      })
      .withFailureHandler(() => {
        state.deductions = previousList;
        state.deductions = dedupeById(state.deductions);
        saveCache();
        renderDeductionsList();
        renderIncomeSummary();
        renderAnnualCategorySection();
        setStatus('Failed to delete deduction', 'error');
      })
      .api_deleteDeduction(deduction.id);
  }

  function renderDeductionCategoryList() {
    if (!deductionCategoryList) return;
    const categories = [...state.deductionCategories].sort((a, b) => a.name.localeCompare(b.name));
    deductionCategoryList.innerHTML = '';
    if (!categories.length) {
      deductionCategoryDeleteId = null;
      if (deductionCategoryEmptyState) deductionCategoryEmptyState.style.display = 'block';
      return;
    }
    if (deductionCategoryEmptyState) deductionCategoryEmptyState.style.display = 'none';

    categories.forEach((category) => {
      const item = document.createElement('div');
      item.className = 'ts-item';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.justifyContent = 'space-between';

      const info = document.createElement('div');
      info.style.display = 'flex';
      info.style.alignItems = 'center';
      info.style.gap = '12px';

      const swatch = document.createElement('span');
      swatch.style.display = 'inline-block';
      swatch.style.width = '14px';
      swatch.style.height = '14px';
      swatch.style.borderRadius = '3px';
      swatch.style.backgroundColor = category.color || '#6b7280';
      info.appendChild(swatch);

      const name = document.createElement('span');
      name.textContent = category.name || 'Untitled category';
      info.appendChild(name);

      item.appendChild(info);

      const actions = document.createElement('div');
      actions.style.display = 'flex';
      actions.style.gap = '8px';

      if (deductionCategoryDeleteId === category.id) {
        const confirmText = document.createElement('span');
        confirmText.className = 'ts-note';
        confirmText.textContent = 'Delete this category?';
        actions.appendChild(confirmText);

        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'ghost small';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.addEventListener('click', () => {
          deductionCategoryDeleteId = null;
          renderDeductionCategoryList();
        });

        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'ghost small danger';
        confirmBtn.textContent = 'Delete';
        confirmBtn.addEventListener('click', () => confirmDeleteDeductionCategory(category));

        actions.appendChild(cancelBtn);
        actions.appendChild(confirmBtn);
      } else {
        const editBtn = document.createElement('button');
        editBtn.className = 'ghost small';
        editBtn.textContent = 'Edit';
        editBtn.addEventListener('click', () => {
          showDeductionCategoryForm('edit', category);
        });

        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'ghost small danger';
        deleteBtn.textContent = 'Delete';
        deleteBtn.addEventListener('click', () => {
          deductionCategoryDeleteId = category.id;
          renderDeductionCategoryList();
        });

        actions.appendChild(editBtn);
        actions.appendChild(deleteBtn);
      }

      item.appendChild(actions);

      deductionCategoryList.appendChild(item);
    });
  }

  function openDeductionCategoryModal() {
    if (!modalDeductionCategories) return;
    deductionCategoryFormState.mode = 'list';
    deductionCategoryFormState.editingId = null;
    if (deductionCategoryFormWrapper) deductionCategoryFormWrapper.style.display = 'none';
    if (deductionCategoryListWrapper) deductionCategoryListWrapper.style.display = 'block';
    if (deductionCategoryListFooter) deductionCategoryListFooter.style.display = 'flex';
    if (deductionCategoryFormFooter) deductionCategoryFormFooter.style.display = 'none';
    if (btnAddDeductionCategory) btnAddDeductionCategory.style.display = 'inline-flex';
    renderDeductionCategoryList();
    showModal(modalDeductionCategories);
  }

  function closeDeductionCategoryModal() {
    if (modalDeductionCategories) hideModal(modalDeductionCategories);
    hideDeductionCategoryForm();
    deductionCategoryDeleteId = null;
    renderDeductionCategoryList();
    renderAnnualCategorySection();
  }

  function showDeductionCategoryForm(mode, category) {
    deductionCategoryFormState.mode = mode;
    deductionCategoryFormState.editingId = category ? category.id : null;
    deductionCategoryDeleteId = null;
    if (deductionCategoryNameInput) deductionCategoryNameInput.value = category ? category.name : '';
    if (deductionCategoryColorInput) deductionCategoryColorInput.value = category ? category.color : '#6b7280';
    if (deductionCategoryFormWrapper) deductionCategoryFormWrapper.style.display = 'block';
    if (deductionCategoryListWrapper) deductionCategoryListWrapper.style.display = 'none';
    if (deductionCategoryListFooter) deductionCategoryListFooter.style.display = 'none';
    if (deductionCategoryFormFooter) deductionCategoryFormFooter.style.display = 'flex';
    if (btnAddDeductionCategory) btnAddDeductionCategory.style.display = 'none';
    if (deductionCategoryNameInput) deductionCategoryNameInput.focus();
  }

  function hideDeductionCategoryForm() {
    deductionCategoryFormState.mode = 'list';
    deductionCategoryFormState.editingId = null;
    if (deductionCategoryNameInput) deductionCategoryNameInput.value = '';
    if (deductionCategoryColorInput) deductionCategoryColorInput.value = '#6b7280';
    if (deductionCategoryFormWrapper) deductionCategoryFormWrapper.style.display = 'none';
    if (deductionCategoryListWrapper) deductionCategoryListWrapper.style.display = 'block';
    if (deductionCategoryListFooter) deductionCategoryListFooter.style.display = 'flex';
    if (deductionCategoryFormFooter) deductionCategoryFormFooter.style.display = 'none';
    if (btnAddDeductionCategory) btnAddDeductionCategory.style.display = 'inline-flex';
    deductionCategorySavePending = false;
    if (btnSaveDeductionCategory) {
      btnSaveDeductionCategory.disabled = false;
      btnSaveDeductionCategory.textContent = 'Save category';
    }
  }

  function handleSaveDeductionCategory(event) {
    if (event) event.preventDefault();
    if (!deductionCategoryNameInput || !deductionCategoryColorInput) return;
    const name = deductionCategoryNameInput.value.trim();
    if (!name) {
      setStatus('Category name is required.', 'warn');
      return;
    }
    const color = deductionCategoryColorInput.value || '#6b7280';
    const payload = {
      id: deductionCategoryFormState.mode === 'edit' ? deductionCategoryFormState.editingId : undefined,
      name,
      color
    };
    if (deductionCategorySavePending) return;
    deductionCategorySavePending = true;
    if (btnSaveDeductionCategory) {
      btnSaveDeductionCategory.disabled = true;
      btnSaveDeductionCategory.textContent = 'Saving...';
    }

    const nowIso = new Date().toISOString();
    const isEdit = deductionCategoryFormState.mode === 'edit' && deductionCategoryFormState.editingId;
    const previousCategories = state.deductionCategories.slice();
    const previousMap = { ...state.deductionCategoryMap };
    const previousFilters = state.annualCategoryFilters.slice();
    const previousExpansion = { ...state.annualCategoryExpansion };

    const tempId = isEdit ? payload.id : `temp_category_${Date.now()}`;
    const optimisticCategory = sanitizeDeductionCategory({
      id: tempId,
      name,
      color,
      created_at: nowIso,
      updated_at: nowIso
    });

    if (isEdit) {
      const index = state.deductionCategories.findIndex((item) => item.id === payload.id);
      if (index !== -1) {
        state.deductionCategories.splice(index, 1, optimisticCategory);
      } else {
        state.deductionCategories.push(optimisticCategory);
      }
    } else {
      state.deductionCategories.push(optimisticCategory);
    }

    state.deductionCategories = dedupeById(state.deductionCategories);
    updateDeductionCategoryMap();
    ensureDeductionCategoryCollapseState();
    renderDeductionCategoryOptions(optimisticCategory.id);
    renderDeductionCategoryList();
    renderDeductionsList();
    renderAnnualCategorySection();
    saveCache();
    setStatus('Saving category...', 'warn');

    google.script.run
      .withSuccessHandler((res) => {
        deductionCategorySavePending = false;
        if (btnSaveDeductionCategory) {
          btnSaveDeductionCategory.disabled = false;
          btnSaveDeductionCategory.textContent = 'Save category';
        }
        if (res && res.success && res.category) {
          const updated = sanitizeDeductionCategory(res.category);
          const tempIndex = state.deductionCategories.findIndex((item) => item.id === optimisticCategory.id);
          if (tempIndex !== -1) {
            state.deductionCategories.splice(tempIndex, 1, updated);
          } else {
            const existingIndex = state.deductionCategories.findIndex((item) => item.id === updated.id);
            if (existingIndex !== -1) {
              state.deductionCategories.splice(existingIndex, 1, updated);
            } else {
              state.deductionCategories.push(updated);
            }
          }
          state.deductionCategories = dedupeById(state.deductionCategories);
          updateDeductionCategoryMap();
          ensureDeductionCategoryCollapseState();
          renderDeductionCategoryOptions(updated.id);
          renderDeductionCategoryList();
          renderDeductionsList();
          renderAnnualCategorySection();
          saveCache();
          setStatus('Category saved', 'success');
          hideDeductionCategoryForm();
          deductionCategoryDeleteId = null;
        } else {
          state.deductionCategories = previousCategories;
          state.deductionCategoryMap = previousMap;
          state.annualCategoryFilters = previousFilters;
          state.annualCategoryExpansion = previousExpansion;
          ensureDeductionCategoryCollapseState();
          renderDeductionCategoryOptions(payload.id || '');
          renderDeductionCategoryList();
          renderDeductionsList();
          renderAnnualCategorySection();
          saveCache();
          setStatus('Failed to save category', 'error');
        }
      })
      .withFailureHandler(() => {
        deductionCategorySavePending = false;
        if (btnSaveDeductionCategory) {
          btnSaveDeductionCategory.disabled = false;
          btnSaveDeductionCategory.textContent = 'Save category';
        }
        state.deductionCategories = previousCategories;
        state.deductionCategoryMap = previousMap;
        state.annualCategoryFilters = previousFilters;
        state.annualCategoryExpansion = previousExpansion;
        ensureDeductionCategoryCollapseState();
        renderDeductionCategoryOptions(payload.id || '');
        renderDeductionCategoryList();
        renderDeductionsList();
        renderAnnualCategorySection();
        saveCache();
        setStatus('Failed to save category', 'error');
      })
      .api_upsertDeductionCategory(payload);
  }

  function confirmDeleteDeductionCategory(category) {
    if (!category || !category.id) return;
    deductionCategoryDeleteId = null;
    const previousCategories = state.deductionCategories.slice();
    const previousMap = { ...state.deductionCategoryMap };
    const previousFilters = state.annualCategoryFilters.slice();
    const previousExpansion = { ...state.annualCategoryExpansion };
    const previousDeductions = state.deductions.map((item) => ({ ...item }));

    state.deductionCategories = state.deductionCategories.filter((item) => item.id !== category.id);
    state.deductions.forEach((deduction) => {
      if (deduction.category_id === category.id) {
        deduction.category_id = '';
      }
    });
    state.deductions = dedupeById(state.deductions);
    state.annualCategoryFilters = state.annualCategoryFilters.filter((id) => id !== category.id);
    delete state.annualCategoryExpansion[category.id];

    updateDeductionCategoryMap();
    ensureDeductionCategoryCollapseState();
    renderDeductionCategoryOptions('');
    renderDeductionCategoryList();
    renderDeductionsList();
    renderAnnualCategorySection();
    renderIncomeSummary();
    saveCache();
    setStatus('Deleting category...', 'warn');

    google.script.run
      .withSuccessHandler(() => {
        setStatus('Category deleted', 'success');
        renderAnnualCategorySection();
      })
      .withFailureHandler(() => {
        state.deductionCategories = previousCategories;
        state.deductionCategoryMap = previousMap;
        state.annualCategoryFilters = previousFilters;
        state.annualCategoryExpansion = previousExpansion;
        state.deductions = dedupeById(previousDeductions.map((item) => ({ ...item })));
        updateDeductionCategoryMap();
        ensureDeductionCategoryCollapseState();
        renderDeductionCategoryOptions('');
        renderDeductionCategoryList();
        renderDeductionsList();
        renderAnnualCategorySection();
        renderIncomeSummary();
        saveCache();
        setStatus('Failed to delete category', 'error');
      })
      .api_deleteDeductionCategory(category.id);
  }

  function loadDeductionCategories() {
    if (!isDeductionCategoriesEnabled()) {
      state.deductionCategories = [];
      state.annualCategoryFilters = [];
      state.annualCategoryExpansion = {};
      deductionCategoryDeleteId = null;
      updateDeductionCategoryMap();
      ensureDeductionCategoryCollapseState();
      renderDeductionCategoryOptions('');
      renderDeductionCategoryList();
      renderDeductionsList();
      renderAnnualCategorySection();
      saveCache();
      return;
    }
    renderDeductionCategoryOptions(deductionCategorySelect ? deductionCategorySelect.value : '');
    if (loadingDeductionCategories) return;
    loadingDeductionCategories = true;
    google.script.run
      .withSuccessHandler((categories) => {
        loadingDeductionCategories = false;
        deductionCategoryDeleteId = null;
        state.deductionCategories = Array.isArray(categories) ? categories.map(sanitizeDeductionCategory) : [];
        updateDeductionCategoryMap();
        ensureDeductionCategoryCollapseState();
        const currentSelection = deductionCategorySelect ? deductionCategorySelect.value : '';
        renderDeductionCategoryOptions(currentSelection);
        renderDeductionCategoryList();
        renderDeductionsList();
        renderAnnualCategorySection();
        saveCache();
      })
      .withFailureHandler(() => {
        loadingDeductionCategories = false;
        setStatus('Failed to load categories', 'error');
      })
      .api_getDeductionCategories();
  }

  const FEATURE_FLAG_GROUPS = [
    { id: 'income', title: 'Income', order: 100 },
    { id: 'time_entries', title: 'Time Entries', order: 200 },
    { id: 'company', title: 'Company', order: 300 },
    { id: 'utilities', title: 'Utilities', order: 400 },
    { id: 'accessibility', title: 'Accessibility', order: 500 }
  ];

  const FEATURE_FLAG_GROUP_MAP = FEATURE_FLAG_GROUPS.reduce((acc, group) => {
    acc[group.id] = group;
    return acc;
  }, {});

  const DEFAULT_FEATURE_FLAGS = {
    enable_deduction_categories: {
      name: 'Enable deduction tracking',
      description: 'Adds category management for deductions and groups them on the deductions page and annual reports.',
      order: 110,
      group: 'income'
    },
    enable_actual_income: {
      name: 'Enable actual income tracking',
      description: 'Allows recording actual income so you can compare estimated versus received amounts with variance indicators.',
      order: 120,
      group: 'income'
    },
    expected_monthly_hours: {
      name: 'Enable expected monthly hours insights',
      description: 'Adds a calendar badge that projects contract hours for the month and shows whether you are ahead or behind.',
      order: 130,
      group: 'income'
    },
    contract_rate_preview: {
      name: 'Enable contract rate preview page',
      description: 'Unlocks the rate preview view to model hourly rate changes and see their impact across a contract.',
      order: 140,
      group: 'income'
    },
    no_lost_super_to_deductions: {
      name: 'Reclaim lost super to deductions',
      description: 'Recovers super guarantee lost to pre-tax deductions. Configure the recovery method on the Settings tab.',
      order: 150,
      group: 'income'
    },
    default_inputs: {
      name: 'Enable default hours for time entries',
      description: 'Allows saving reusable entry templates that can be applied when adding new time entries.',
      order: 210,
      group: 'time_entries'
    },
    hour_types: {
      name: 'Enable multiple hour types',
      description: 'Lets you categorise hours (work, annual, sick, training, etc.) and visualise their impact on income.',
      order: 220,
      group: 'time_entries'
    },
    recurring_time_entries: {
      name: 'Enable reoccurring time entries',
      description: 'Adds a scheduler to automatically create weekly or monthly entries that stay within active contract dates.',
      order: 225,
      group: 'time_entries'
    },
    bulk_time_entries: {
      name: 'Enable bulk time entries',
      description: 'Adds a tool to apply identical entries across a date range with weekend and public holiday filters.',
      order: 226,
      group: 'time_entries'
    },
    suggest_end_time: {
      name: 'Suggest exact end time',
      description: 'Uses your rounding rule and preferred finish time to recommend when to clock off for tidy totals.',
      order: 230,
      group: 'time_entries'
    },
    enable_public_holidays: {
      name: 'Enable automatic public holiday display',
      description: 'Automatically overlays Australian public holidays on the calendar view and keeps them in sync.',
      order: 240,
      group: 'time_entries'
    },
    xero_payroll_helper: {
      name: 'Enable Xero payroll helper',
      description: 'Adds a modal that slices the active month into Xero-aligned weekly ranges with cumulative hour totals.',
      order: 250,
      group: 'time_entries'
    },
    myob_payroll_helper: {
      name: 'Enable MYOB payroll helper',
      description: 'Adds a modal that groups the active month into MYOB-ready weekly totals with a monthly cross-check.',
      order: 260,
      group: 'time_entries'
    },
    enable_monthly_print_view: {
      name: 'Enable monthly hours print view',
      description: 'Adds a printable calendar showing hour breakdowns by type that fits on one A4 page for timesheets or records.',
      order: 270,
      group: 'time_entries'
    },
    enable_timesheet1_importer: {
      name: 'Enable Timesheet 1.0 importer',
      description: 'Adds an importer on the Time Entries page to pull legacy spreadsheet hours with mapping, contract checks, and duplicate detection.',
      order: 280,
      group: 'time_entries'
    },
    enable_company_tracking_features: {
      name: 'Enable company income tracking',
      description: 'Unlocks company-focused features including company deductions, BAS reporting, and invoice tooling.',
      order: 310,
      group: 'company'
    },
    enable_company_quarterly_bas: {
      name: 'Switch from monthly to quarterly BAS reporting',
      description: 'Shows BAS reporting in quarterly totals instead of monthly when company income tracking is enabled.',
      order: 320,
      group: 'company'
    },
    enable_invoices: {
      name: 'Enable invoices page',
      description: 'Enables invoice management, default line items, and Google Docs generation using your template.',
      order: 330,
      group: 'company'
    },
    enable_contract_line_item_templates: {
      name: 'Enable contract line item templates',
      description: 'Allows defining reusable line item templates with predefined descriptions and amounts on each contract.',
      order: 335,
      group: 'company'
    },
    is_sole_trader: {
      name: 'Enable sole trader mode',
      description: 'Indicates the business operates as a sole trader and adjusts PAYG income calculations accordingly.',
      order: 340,
      group: 'company'
    },
    remember_last_page: {
      name: 'Remember last page on refresh',
      description: 'When enabled, the app reopens on the most recently viewed page after a reload.',
      order: 410,
      group: 'utilities'
    },
    show_zero_hours: {
      name: 'Show zero hours on days with no time entered',
      description: 'Displays a 0 for days without logged time instead of leaving them blank on the calendar.',
      order: 420,
      group: 'utilities'
    },
    show_clear_cache: {
      name: 'Show clear cache button',
      description: 'Adds a button to wipe cached entries, settings, and remembered preferences from this browser.',
      order: 430,
      group: 'utilities'
    },
    custom_theme: {
      name: 'Enable custom theme',
      description: 'Adds a Custom theme option with configurable colours.',
      order: 510,
      group: 'accessibility'
    },
    enable_colorblind_themes: {
      name: 'Enable colour blind themes',
      description: 'Adds colour-blind friendly theme presets and warns about difficult hour type colour combinations.',
      order: 520,
      group: 'accessibility'
    }
  };

  const DEDUCTION_FREQUENCIES = ['once', 'weekly', 'fortnightly', 'monthly', 'quarterly', 'yearly'];

  const THEME_KEYS = ['dark', 'light', 'og', 'rose', 'sierra117', 'protanopia', 'deuteranopia', 'tritanopia', 'monochrome', 'custom'];

  const CUSTOM_THEME_DEFAULTS = {
    bg: '#0b1220',
    panel: '#111d33',
    text: '#e8edf7',
    muted: '#a4b5d6',
    primary: '#3b82f6',
    success: '#22c55e',
    warning: '#fbbf24',
    danger: '#ef4444'
  };

  function getCustomThemeFlag() {
    const fromState = state && state.featureFlags ? state.featureFlags.custom_theme : null;
    const fromDefaults = DEFAULT_FEATURE_FLAGS ? DEFAULT_FEATURE_FLAGS.custom_theme : null;
    return fromState || fromDefaults || { enabled: false };
  }

  function isCustomThemeEnabled() {
    const flag = getCustomThemeFlag();
    return !!(flag && flag.enabled);
  }

  function getLastNonCustomTheme() {
    if (state && state.settings && state.settings.last_non_custom_theme && state.settings.last_non_custom_theme !== 'custom') {
      return state.settings.last_non_custom_theme;
    }
    return 'dark';
  }

  function updateCustomThemeControls(activeTheme) {
    const themeSelectEl = document.getElementById('set-theme');
    const customThemeOption = document.querySelector('.ts-custom-theme');
    const configureButton = document.getElementById('btn-configure-theme');
    const customEnabled = isCustomThemeEnabled();
    const currentTheme = activeTheme || (themeSelectEl ? themeSelectEl.value : (state.settings && state.settings.theme) || 'dark');

    if (!customEnabled && currentTheme === 'custom') {
      const fallback = getLastNonCustomTheme();
      if (themeSelectEl) themeSelectEl.value = fallback;
      applyTheme(fallback);
      if (typeof checkSettingsDirty === 'function') {
        checkSettingsDirty();
      }
      return;
    }

    if (customThemeOption) {
      customThemeOption.style.display = customEnabled ? 'block' : 'none';
    }

    if (configureButton) {
      const effectiveTheme = themeSelectEl ? themeSelectEl.value : currentTheme;
      configureButton.style.display = customEnabled && effectiveTheme === 'custom'
        ? 'inline-block'
        : 'none';
    }
  }

  function applyTheme(theme) {
    const normalizedTheme = (typeof theme === 'string' ? theme.trim().toLowerCase() : '');
    const normalized = THEME_KEYS.includes(normalizedTheme) ? normalizedTheme : 'dark';
    const body = document.body;
    THEME_KEYS.forEach((key) => body.classList.remove('ts-theme-' + key));
    body.classList.add('ts-theme-' + normalized);
    state.settings = { ...state.settings, theme: normalized };
    if (normalized !== 'custom') {
      state.settings.last_non_custom_theme = normalized;
    }
    if (themeSelect) themeSelect.value = normalized;

    // Apply custom theme if selected
    if (normalized === 'custom') {
      applyCustomTheme();
    }

    if (state.annualData) {
      renderAnnualData();
    }

    if (contractBurndownEl && state.selectedContractId) {
      const activeContract = getContractById(state.selectedContractId);
      if (activeContract) {
        const usage = computeContractUsage(activeContract);
        renderContractBurndown(activeContract, usage);
        renderContractHoursBreakdown(activeContract, usage);
      }
    }

    updateCustomThemeControls(normalized);
  }

  function normalizeCustomThemeConfig(raw) {
    var base = { ...CUSTOM_THEME_DEFAULTS };
    if (raw && typeof raw === 'object') {
      Object.keys(raw).forEach(function(key) {
        if (raw[key]) {
          base[key] = raw[key];
        }
      });
    }

    if (!base.panel) {
      base.panel = isColorLight(base.bg) ? darken(base.bg, 0.12) : lighten(base.bg, 0.12);
    }
    if (!base.muted) {
      base.muted = mixColors(base.text, base.bg, 0.65);
    }
    if (!base.success) {
      base.success = CUSTOM_THEME_DEFAULTS.success;
    }
    if (!base.warning) {
      base.warning = adjustHue(base.primary, 35);
    }
    if (!base.danger) {
      base.danger = adjustHue(base.primary, -25);
    }

    return base;
  }

  // Color manipulation helpers
  function hexToRgb(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  function lighten(hex, amount) {
    var rgb = hexToRgb(hex);
    if (!rgb) return hex;
    var r = Math.min(255, Math.floor(rgb.r + (255 - rgb.r) * amount));
    var g = Math.min(255, Math.floor(rgb.g + (255 - rgb.g) * amount));
    var b = Math.min(255, Math.floor(rgb.b + (255 - rgb.b) * amount));
    return rgbToHex(r, g, b);
  }

  function darken(hex, amount) {
    var rgb = hexToRgb(hex);
    if (!rgb) return hex;
    var r = Math.floor(rgb.r * (1 - amount));
    var g = Math.floor(rgb.g * (1 - amount));
    var b = Math.floor(rgb.b * (1 - amount));
    return rgbToHex(r, g, b);
  }

  function adjustHue(hex, degrees) {
    var rgb = hexToRgb(hex);
    if (!rgb) return hex;

    // Convert to HSL
    var r = rgb.r / 255;
    var g = rgb.g / 255;
    var b = rgb.b / 255;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      if (max === r) h = (g - b) / d + (g < b ? 6 : 0);
      else if (max === g) h = (b - r) / d + 2;
      else h = (r - g) / d + 4;
      h /= 6;
    }

    // Adjust hue
    h = (h * 360 + degrees) % 360;
    if (h < 0) h += 360;
    h = h / 360;

    // Convert back to RGB
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);

    return rgbToHex(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255));
  }

  function withAlpha(hex, alpha) {
    var rgb = hexToRgb(hex);
    if (!rgb) return `rgba(15, 23, 42, ${alpha})`;
    return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
  }

  function clamp01(value) {
    if (value < 0) return 0;
    if (value > 1) return 1;
    return value;
  }

  function mixColors(hexA, hexB, weight) {
    var rgbA = hexToRgb(hexA);
    var rgbB = hexToRgb(hexB);
    var w = clamp01(typeof weight === 'number' ? weight : 0.5);

    if (!rgbA && !rgbB) return '#000000';
    if (!rgbA) return rgbToHex(rgbB.r, rgbB.g, rgbB.b);
    if (!rgbB) return rgbToHex(rgbA.r, rgbA.g, rgbA.b);

    var r = Math.round(rgbA.r * (1 - w) + rgbB.r * w);
    var g = Math.round(rgbA.g * (1 - w) + rgbB.g * w);
    var b = Math.round(rgbA.b * (1 - w) + rgbB.b * w);
    return rgbToHex(r, g, b);
  }

  function getLuminance(hex) {
    var rgb = hexToRgb(hex);
    if (!rgb) return 0;
    var channel = [rgb.r, rgb.g, rgb.b].map(function(component) {
      var c = component / 255;
      return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    });
    return 0.2126 * channel[0] + 0.7152 * channel[1] + 0.0722 * channel[2];
  }

  function getContrastRatio(hexA, hexB) {
    var lumA = getLuminance(hexA);
    var lumB = getLuminance(hexB);
    var lighter = Math.max(lumA, lumB);
    var darker = Math.min(lumA, lumB);
    if (!lighter && !darker) return 1;
    return (lighter + 0.05) / (darker + 0.05);
  }

  function formatContrast(value) {
    if (!value || !isFinite(value)) return '0.00';
    return (Math.round(value * 100) / 100).toFixed(2);
  }

  function isColorLight(hex) {
    return getLuminance(hex) > 0.6;
  }

  function generateCustomTheme(config) {
    var normalized = normalizeCustomThemeConfig(config);
    var bg = normalized.bg;
    var panel = normalized.panel;
    var text = normalized.text;
    var muted = normalized.muted;
    var primary = normalized.primary;
    var success = normalized.success;
    var warning = normalized.warning;
    var danger = normalized.danger;

    var bgIsLight = isColorLight(bg);
    var panelIsLight = isColorLight(panel);

    var border = mixColors(panel, bg, 0.35);
    var surfaceSubtle = bgIsLight ? darken(bg, 0.04) : lighten(bg, 0.04);
    var focusRing = withAlpha(primary, 0.55);
    var primaryDark = darken(primary, 0.16);

    var primarySoftBg = withAlpha(primary, 0.18);
    var primarySoftBorder = withAlpha(primary, 0.65);
    var primarySoftText = panelIsLight ? darken(primary, 0.25) : lighten(primary, 0.25);
    var primaryGlow = withAlpha(primary, 0.3);
    var primaryHintBg = withAlpha(primary, 0.16);
    var primaryHintBorder = withAlpha(primary, 0.55);
    var hoverBg = withAlpha(primary, 0.12);

    var successText = isColorLight(success) ? darken(success, 0.3) : lighten(success, 0.3);
    var warningText = isColorLight(warning) ? darken(warning, 0.35) : lighten(warning, 0.35);
    var dangerText = isColorLight(danger) ? darken(danger, 0.35) : lighten(danger, 0.35);

    var badgeSuccessBg = withAlpha(success, 0.18);
    var badgeSuccessBorder = withAlpha(success, 0.55);
    var badgeWarnBg = withAlpha(warning, 0.18);
    var badgeWarnBorder = withAlpha(warning, 0.55);
    var badgeErrorBg = withAlpha(danger, 0.2);
    var badgeErrorBorder = withAlpha(danger, 0.6);

    var holidayBg = withAlpha(success, 0.18);
    var holidayBorder = withAlpha(success, 0.5);
    var holidayHover = withAlpha(success, 0.75);

    var calendarGlow = withAlpha(primary, 0.36);
    var calendarBg = withAlpha(primary, 0.22);

    return {
      '--bg': bg,
      '--panel': panel,
      '--muted': muted,
      '--text': text,
      '--primary': primary,
      '--primary-600': primaryDark,
      '--danger': danger,
      '--warning': warning,
      '--success': success,
      '--border': border,
      '--badge-bg': panel,
      '--badge-border': border,
      '--badge-text': text,
      '--badge-success-bg': badgeSuccessBg,
      '--badge-success-border': badgeSuccessBorder,
      '--badge-success-text': successText,
      '--badge-warn-bg': badgeWarnBg,
      '--badge-warn-border': badgeWarnBorder,
      '--badge-warn-text': warningText,
      '--badge-error-bg': badgeErrorBg,
      '--badge-error-border': badgeErrorBorder,
      '--badge-error-text': dangerText,
      '--primary-soft-bg': primarySoftBg,
      '--primary-soft-border': primarySoftBorder,
      '--primary-soft-text': primarySoftText,
      '--primary-glow': primaryGlow,
      '--primary-hint-bg': primaryHintBg,
      '--primary-hint-border': primaryHintBorder,
      '--hover-bg': hoverBg,
      '--border-color': border,
      '--text-secondary': muted,
      '--surface-subtle': surfaceSubtle,
      '--focus-ring': focusRing,
      '--holiday-bg': holidayBg,
      '--holiday-border': holidayBorder,
      '--holiday-hover': holidayHover,
      '--calendar-selected-border': primary,
      '--calendar-selected-glow': calendarGlow,
      '--calendar-selected-bg': calendarBg
    };
  }

  function applyCustomTheme() {
    var customThemeConfig = normalizeCustomThemeConfig(state.settings.custom_theme_config);
    state.settings.custom_theme_config = customThemeConfig;

    var themeVars = generateCustomTheme(customThemeConfig);

    // Find or create style element for custom theme
    var styleId = 'custom-theme-style';
    var styleEl = document.getElementById(styleId);
    if (!styleEl) {
      styleEl = document.createElement('style');
      styleEl.id = styleId;
      document.head.appendChild(styleEl);
    }

    var css = '.ts-theme-custom {';
    Object.keys(themeVars).forEach(function(key) {
      css += key + ': ' + themeVars[key] + ';';
    });
    css += '}';
    styleEl.textContent = css;
  }

  const normalizeFeatureFlags = (raw) => {
    const out = {};
    const defaults = DEFAULT_FEATURE_FLAGS || {};
    const rawKeys = raw && typeof raw === 'object' ? Object.keys(raw) : [];
    const combinedKeys = Array.from(new Set([...Object.keys(defaults), ...rawKeys]));
    combinedKeys.forEach((key) => {
      const rawValue = raw && raw[key];
      const enabled = rawValue && typeof rawValue === 'object'
        ? !!rawValue.enabled
        : !!rawValue;
      const fallback = defaults[key] || { name: key, description: '' };
      out[key] = {
        enabled,
        name: fallback.name || key,
        description: fallback.description || ''
      };
    });
    return out;
  };

  function updateContractMap() {
    state.contractMap = state.contracts.reduce((map, contract) => {
      map[contract.id] = contract;
      return map;
    }, {});
  }

  function updateHourTypeMap() {
    state.hourTypeMap = state.hourTypes.reduce((map, hourType) => {
      map[hourType.id] = hourType;
      return map;
    }, {});
  }

  function updateDeductionCategoryMap() {
    const map = {};
    state.deductionCategories.forEach((category) => {
      if (!category || !category.id) return;
      map[category.id] = category;
    });
    state.deductionCategoryMap = map;
  }

  function getDeductionCategoryMeta(categoryId) {
    if (!categoryId) {
      return { id: '', name: 'Uncategorised', color: '#6b7280' };
    }
    return state.deductionCategoryMap[categoryId] || {
      id: categoryId,
      name: 'Unknown category',
      color: '#6b7280'
    };
  }

  function renderDeductionCategoryOptions(selectedId) {
    if (!deductionCategorySelect) return;
    const enabled = isDeductionCategoriesEnabled();
    const priorValue = selectedId !== undefined ? selectedId : deductionCategorySelect.value;

    deductionCategorySelect.innerHTML = '';
    const defaultOption = document.createElement('option');
    defaultOption.value = '';
    defaultOption.textContent = 'Uncategorised';
    deductionCategorySelect.appendChild(defaultOption);

    if (enabled) {
      const sorted = [...state.deductionCategories].sort((a, b) => a.name.localeCompare(b.name));
      sorted.forEach((category) => {
        if (!category.id) return;
        const option = document.createElement('option');
        option.value = category.id;
        option.textContent = category.name || 'Untitled category';
        deductionCategorySelect.appendChild(option);
      });
    }

    if (priorValue && (priorValue === '' || state.deductionCategoryMap[priorValue])) {
      deductionCategorySelect.value = priorValue;
    } else {
      deductionCategorySelect.value = '';
    }

    deductionCategorySelect.disabled = !enabled;

    if (deductionCategoryEmptyNote) {
      deductionCategoryEmptyNote.style.display = enabled && state.deductionCategories.length === 0 ? 'block' : 'none';
    }
    if (deductionCategoryColumn) {
      deductionCategoryColumn.style.display = enabled ? 'block' : 'none';
    }

    const nameCol = deductionNameInput ? deductionNameInput.closest('.ts-col') : null;
    const typeCol = deductionTypeSelect ? deductionTypeSelect.closest('.ts-col') : null;
    if (nameCol && typeCol) {
      if (enabled) {
        nameCol.style.flex = '';
        nameCol.style.maxWidth = '';
        typeCol.style.flex = '';
        typeCol.style.maxWidth = '220px';
      } else {
        nameCol.style.flex = '1';
        nameCol.style.maxWidth = '';
        typeCol.style.flex = '1';
        typeCol.style.maxWidth = '';
      }
    }
  }

  function ensureDeductionCategoryCollapseState() {
    if (!state.deductionCategoryCollapse) state.deductionCategoryCollapse = {};
    const collapse = state.deductionCategoryCollapse;
    const validIds = state.deductionCategories.map((category) => category.id);
    validIds.forEach((id) => {
      if (!collapse.hasOwnProperty(id)) {
        collapse[id] = true;
      }
    });
    if (!collapse.hasOwnProperty('__uncategorised__')) {
      collapse.__uncategorised__ = true;
    }
    Object.keys(collapse).forEach((key) => {
      if (key === '__uncategorised__') return;
      if (!validIds.includes(key)) {
        delete collapse[key];
      }
    });
  }

  function setAllDeductionCategoryCollapse(collapsed) {
    ensureDeductionCategoryCollapseState();
    Object.keys(state.deductionCategoryCollapse).forEach((key) => {
      state.deductionCategoryCollapse[key] = collapsed;
    });
    saveCache();
    renderDeductionsList();
  }

  function setAllFeatureFlagCollapse(collapsed) {
    if (!state.featureFlagCollapse || typeof state.featureFlagCollapse !== 'object') {
      state.featureFlagCollapse = {};
    }
    const groupIds = new Set();
    FEATURE_FLAG_GROUPS.forEach((group) => {
      if (group && group.id) groupIds.add(group.id);
    });
    Object.keys(DEFAULT_FEATURE_FLAGS).forEach((key) => {
      const cfg = DEFAULT_FEATURE_FLAGS[key];
      const groupId = (cfg && cfg.group) ? cfg.group : 'other';
      groupIds.add(groupId);
    });
    const rawFlags = state.featureFlags && typeof state.featureFlags === 'object' ? state.featureFlags : {};
    Object.keys(rawFlags).forEach((key) => {
      const cfg = DEFAULT_FEATURE_FLAGS[key];
      const groupId = cfg && cfg.group ? cfg.group : 'other';
      groupIds.add(groupId);
    });
    groupIds.add('other');
    groupIds.forEach((groupId) => {
      if (groupId) {
        state.featureFlagCollapse[groupId] = collapsed;
      }
    });
    saveCache();
    renderFeatureFlags();
  }

  function getSettingsSectionGroups() {
    const groups = {};
    Object.keys(SETTINGS_CONFIG).forEach((key) => {
      const config = SETTINGS_CONFIG[key];
      const sectionId = config && config.section ? config.section : 'core';
      if (!groups[sectionId]) groups[sectionId] = [];
      groups[sectionId].push(key);
    });
    return groups;
  }

  function ensureSettingsSectionCollapseState(sectionId) {
    if (!state.settingsSectionCollapse || typeof state.settingsSectionCollapse !== 'object') {
      state.settingsSectionCollapse = {};
    }
    if (!state.settingsSectionCollapse.hasOwnProperty(sectionId)) {
      state.settingsSectionCollapse[sectionId] = sectionId === 'core' ? false : true;
    }
  }

  function setAllSettingsSectionCollapse(collapsed) {
    if (!state.settingsSectionCollapse || typeof state.settingsSectionCollapse !== 'object') {
      state.settingsSectionCollapse = {};
    }
    const groups = getSettingsSectionGroups();
    Object.keys(groups).forEach((sectionId) => {
      state.settingsSectionCollapse[sectionId] = collapsed;
    });
    saveCache();
    renderSettingsSections();
  }

  function formatSettingsSectionTitle(sectionId) {
    if (sectionId === 'core') return 'Core';
    const meta = DEFAULT_FEATURE_FLAGS[sectionId];
    if (meta && meta.name) return meta.name;
    return sectionId.split('_').map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join(' ');
  }

  function renderSettingsSections() {
    if (!settingsSectionListEl) return;
    if (!state.settingsSectionCollapse || typeof state.settingsSectionCollapse !== 'object') {
      state.settingsSectionCollapse = {};
    }
    if (settingsFieldTemplates) {
      Object.keys(settingsFieldBlocks).forEach((key) => {
        const block = settingsFieldBlocks[key];
        if (block && block.parentElement !== settingsFieldTemplates) {
          settingsFieldTemplates.appendChild(block);
        }
      });
    }
    const groups = getSettingsSectionGroups();
    const sections = Object.keys(groups).map((sectionId) => {
      const items = groups[sectionId].slice().sort((a, b) => {
        const orderA = SETTINGS_CONFIG[a] && SETTINGS_CONFIG[a].order != null ? SETTINGS_CONFIG[a].order : 0;
        const orderB = SETTINGS_CONFIG[b] && SETTINGS_CONFIG[b].order != null ? SETTINGS_CONFIG[b].order : 0;
        if (orderA !== orderB) return orderA - orderB;
        return a.localeCompare(b);
      });
      const sectionOrder = items.reduce((min, key) => {
        const value = SETTINGS_CONFIG[key] && SETTINGS_CONFIG[key].order != null ? SETTINGS_CONFIG[key].order : min;
        return value < min ? value : min;
      }, Number.POSITIVE_INFINITY);
      return { id: sectionId, items, order: sectionOrder === Number.POSITIVE_INFINITY ? 0 : sectionOrder };
    }).sort((a, b) => {
      if (a.id === 'core') return -1;
      if (b.id === 'core') return 1;
      if (a.order !== b.order) return a.order - b.order;
      return formatSettingsSectionTitle(a.id).localeCompare(formatSettingsSectionTitle(b.id));
    });
    settingsSectionListEl.innerHTML = '';
    let visibleSections = 0;
    sections.forEach((section) => {
      const isCore = section.id === 'core';
      const featureMeta = !isCore ? (state.featureFlags[section.id] || DEFAULT_FEATURE_FLAGS[section.id] || {}) : null;
      const enabled = isCore ? true : !!featureMeta.enabled;
      if (!enabled) return;
      visibleSections += 1;
      ensureSettingsSectionCollapseState(section.id);
      const collapsed = !!state.settingsSectionCollapse[section.id];
      const container = document.createElement('div');
      container.className = 'ts-flag-group ts-settings-section';
      const header = document.createElement('div');
      header.className = 'ts-flag-group-header';
      header.setAttribute('role', 'button');
      header.setAttribute('tabindex', '0');
      header.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
      const titleWrapper = document.createElement('div');
      titleWrapper.className = 'ts-flag-group-header-title';
      const title = document.createElement('span');
      title.textContent = formatSettingsSectionTitle(section.id);
      titleWrapper.appendChild(title);
      const count = document.createElement('span');
      count.className = 'ts-flag-group-count';
      count.textContent = `${section.items.length} setting${section.items.length === 1 ? '' : 's'}`;
      titleWrapper.appendChild(count);
      const toggle = document.createElement('span');
      toggle.className = 'ts-flag-group-toggle';
      toggle.textContent = collapsed ? '' : '';
      header.appendChild(titleWrapper);
      header.appendChild(toggle);
      const bodyId = `settings-section-${section.id}`;
      header.setAttribute('aria-controls', bodyId);
      const toggleSection = () => {
        state.settingsSectionCollapse[section.id] = !state.settingsSectionCollapse[section.id];
        saveCache();
        renderSettingsSections();
      };
      header.addEventListener('click', toggleSection);
      header.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          toggleSection();
        }
      });
      container.appendChild(header);
      const body = document.createElement('div');
      body.className = 'ts-flag-group-body ts-settings-section-body';
      body.id = bodyId;
      body.style.display = collapsed ? 'none' : 'block';
      if (!isCore && featureMeta && featureMeta.description) {
        const desc = document.createElement('div');
        desc.className = 'ts-note';
        desc.style.marginBottom = '12px';
        desc.textContent = featureMeta.description;
        body.appendChild(desc);
      }
      const grid = document.createElement('div');
      grid.className = 'ts-settings-grid';
      section.items.forEach((key) => {
        const block = settingsFieldBlocks[key];
        if (!block) return;
        grid.appendChild(block);
      });
      body.appendChild(grid);
      container.appendChild(body);
      settingsSectionListEl.appendChild(container);
    });
    if (settingsSectionControls) {
      settingsSectionControls.style.display = visibleSections > 1 ? 'flex' : 'none';
    }
  }

  const contractIsValid = (contract, dateIso) => {
    if (!contract || !dateIso) return false;
    if (contract.start_date && contract.start_date > dateIso) return false;
    if (contract.end_date && contract.end_date !== '' && contract.end_date < dateIso) return false;
    return true;
  };

  function invoiceIsLocked() {
    const invoice = state.invoiceDetail && state.invoiceDetail.invoice;
    if (!invoice) return false;
    return String(invoice.status || 'draft').toLowerCase() === 'generated';
  }

  function validContractsForDate(dateIso) {
    if (!dateIso) return [];
    return state.contracts.filter((contract) => contractIsValid(contract, dateIso));
  }

  function getContractName(id) {
    if (!id) return '';
    const match = state.contractMap[id];
    if (match) return match.name;
    return '';
  }

  const contractBadge = (entry) => {
    const name = getContractName(entry.contract_id);
    if (name) return `<span class="ts-badge">${name}</span>`;
    if (entry.contract_id) return `<span class="ts-badge warn">Unknown contract</span>`;
    return `<span class="ts-badge warn">No contract</span>`;
  };

  function dedupeById(list) {
    if (!Array.isArray(list)) return [];
    const seen = new Set();
    const result = [];
    list.forEach((item) => {
      if (!item || !item.id) return;
      if (seen.has(item.id)) return;
      seen.add(item.id);
      result.push(item);
    });
    return result;
  }

  function loadCache() {
    try {
      const raw = localStorage.getItem(state.cacheKey);
      if (!raw) return;
      const obj = JSON.parse(raw);
      state.entries = Array.isArray(obj.entries) ? obj.entries.map(sanitizeEntry) : [];
      state.settings = obj.settings || {};
      state.contracts = Array.isArray(obj.contracts) ? obj.contracts.map(sanitizeContract) : [];
      state.hourTypes = Array.isArray(obj.hourTypes) ? obj.hourTypes.map(sanitizeHourType) : [];
      state.recurringTimeEntries = Array.isArray(obj.recurringTimeEntries)
        ? obj.recurringTimeEntries.map(sanitizeRecurringEntry).filter((item) => item)
        : [];
      state.recurringEntriesInitialized = state.recurringTimeEntries.length > 0;
      state.bulkEntries = Array.isArray(obj.bulkEntries)
        ? obj.bulkEntries.map(sanitizeBulkEntry).filter((item) => item)
        : [];
      state.bulkEntriesInitialized = state.bulkEntries.length > 0;
      state.deductions = Array.isArray(obj.deductions) ? dedupeById(obj.deductions.map(sanitizeDeduction)) : [];
      state.deductionCategories = Array.isArray(obj.deductionCategories) ? obj.deductionCategories.map(sanitizeDeductionCategory) : [];
      state.deductionCategoryCollapse = obj.deductionCategoryCollapse && typeof obj.deductionCategoryCollapse === 'object'
        ? { ...obj.deductionCategoryCollapse }
        : {};
      state.settingsSectionCollapse = obj.settingsSectionCollapse && typeof obj.settingsSectionCollapse === 'object'
        ? { ...obj.settingsSectionCollapse }
        : {};
      state.featureFlagCollapse = obj.featureFlagCollapse && typeof obj.featureFlagCollapse === 'object'
        ? { ...obj.featureFlagCollapse }
        : {};
      state.deductionExceptions = Array.isArray(obj.deductionExceptions) ? obj.deductionExceptions.map(sanitizeDeductionException) : [];
      if (obj.basCurrentFy != null) state.basCurrentFy = Number(obj.basCurrentFy);
      state.featureFlags = normalizeFeatureFlags(obj.featureFlags);
      state.publicHolidays = Array.isArray(obj.publicHolidays) ? obj.publicHolidays : [];
      state.actualIncome = Array.isArray(obj.actualIncome) ? obj.actualIncome : [];
      state.annualCategoryFilters = Array.isArray(obj.annualCategoryFilters) ? obj.annualCategoryFilters.slice() : [];
      state.annualCategoryExpansion = obj.annualCategoryExpansion && typeof obj.annualCategoryExpansion === 'object'
        ? { ...obj.annualCategoryExpansion }
        : {};
      state.invoices = Array.isArray(obj.invoices) ? obj.invoices.map((invoice) => ({ ...invoice })) : [];
      updateInvoiceMaps();
      state.invoiceDefaults = Array.isArray(obj.invoiceDefaults) ? obj.invoiceDefaults.map((item) => ({ ...item })) : [];
      state.invoiceDefaultMap = state.invoiceDefaults.reduce((acc, item) => {
        if (item && item.id) acc[item.id] = item;
        return acc;
      }, {});
      if (obj.invoiceFilters && typeof obj.invoiceFilters === 'object') {
        state.invoiceFilters = {
          year: obj.invoiceFilters.year != null ? String(obj.invoiceFilters.year) : '',
          month: obj.invoiceFilters.month != null ? String(obj.invoiceFilters.month) : ''
        };
      } else {
        state.invoiceFilters = { year: '', month: '' };
      }
      state.invoiceSelectedId = obj.invoiceSelectedId || '';
      if (obj.invoiceDetail && obj.invoiceDetail.invoice) {
        const detailLineItems = Array.isArray(obj.invoiceDetail.lineItems) ? obj.invoiceDetail.lineItems.map((item) => ({ ...item })) : [];
        const detailSummary = obj.invoiceDetail.summary || summarizeInvoiceLineItems(detailLineItems);
        state.invoiceDetail = {
          invoice: { ...obj.invoiceDetail.invoice },
          lineItems: detailLineItems,
          summary: detailSummary
        };
      } else {
        state.invoiceDetail = null;
      }
      state.invoiceDetailLoading = false;
      state.invoiceListLoading = false;
      state.invoicesInitialized = Array.isArray(state.invoices) && state.invoices.length > 0;
      if (obj.incomeSummaryCache && typeof obj.incomeSummaryCache === 'object') {
        state.incomeSummaryCache = deserializeIncomeSummaryCache(obj.incomeSummaryCache);
      } else {
        state.incomeSummaryCache = {};
      }
      if (obj.incomeCacheMetadata && typeof obj.incomeCacheMetadata === 'object') {
        state.incomeCacheMetadata = { ...obj.incomeCacheMetadata };
      } else {
        state.incomeCacheMetadata = {};
      }
      if (obj.potentialIncomeCache && typeof obj.potentialIncomeCache === 'object') {
        state.potentialIncomeCache = obj.potentialIncomeCache;
      } else {
        state.potentialIncomeCache = {};
      }
      state.dirtyIncomeMonths = new Set();
      updatePublicHolidayMap();
      refreshActualIncomeMap();
      updateDeductionCategoryMap();
      ensureDeductionCategoryCollapseState();
      ensureInvoiceFormOptions();
      initializeLazyLoadingState();
      hydrateLoadingTierCache(obj.loadingTiers);
      resetLazyLoadQueue();

      // Set initial tab based on today's entry type
      const today = todayIso();
      const todayEntry = state.entries.find(entry => entry.date === today);
      if (resolveEntryType(todayEntry) === 'advanced') {
        activateTab('punch');
        if (punchDate) punchDate.value = today;
        ensurePunchDraft(todayEntry.contract_id);
      }
      updateTabStates();
      updateContractMap();
      updateHourTypeMap();
      renderRecurringEntriesList();
      setRecurringFormDraft(state.recurringEntryForm.draft || defaultRecurringDraft());
      renderBulkEntriesList();
      setBulkFormDraft(state.bulkEntryForm.draft || defaultBulkDraft());
      applyTheme((state.settings && state.settings.theme) || 'dark');
      state.pendingEntryAdds = new Map();
      state.pendingEntryUpdates = new Map();
      state.pendingEntryDeletes = new Set();
    } catch (e) {}
  }
  function saveCache() {
    try {
      const invoicesForCache = Array.isArray(state.invoices) ? state.invoices.map((invoice) => ({ ...invoice })) : [];
      const invoiceDefaultsForCache = Array.isArray(state.invoiceDefaults) ? state.invoiceDefaults.map((item) => ({ ...item })) : [];
      const invoiceDetailForCache = (state.invoiceDetail && state.invoiceDetail.invoice)
        ? {
            invoice: { ...state.invoiceDetail.invoice },
            lineItems: Array.isArray(state.invoiceDetail.lineItems) ? state.invoiceDetail.lineItems.map((item) => ({ ...item })) : [],
            summary: state.invoiceDetail.summary ? { ...state.invoiceDetail.summary } : null
          }
        : null;
      const invoiceFiltersForCache = {
        year: state.invoiceFilters && state.invoiceFilters.year != null ? String(state.invoiceFilters.year) : '',
        month: state.invoiceFilters && state.invoiceFilters.month != null ? String(state.invoiceFilters.month) : ''
      };
      const payload = {
        entries: state.entries.map(sanitizeEntry),
        settings: state.settings,
        contracts: state.contracts.map(sanitizeContract),
        hourTypes: state.hourTypes.map(sanitizeHourType),
        recurringTimeEntries: state.recurringTimeEntries.map((item) => sanitizeRecurringEntry(item)),
        bulkEntries: state.bulkEntries.map((item) => sanitizeBulkEntry(item)),
        deductions: state.deductions.map(sanitizeDeduction),
        deductionCategories: state.deductionCategories.map(sanitizeDeductionCategory),
        deductionCategoryCollapse: state.deductionCategoryCollapse,
        settingsSectionCollapse: state.settingsSectionCollapse,
        featureFlagCollapse: state.featureFlagCollapse,
        deductionExceptions: state.deductionExceptions.map(sanitizeDeductionException),
        annualCategoryFilters: state.annualCategoryFilters,
        annualCategoryExpansion: state.annualCategoryExpansion,
        featureFlags: normalizeFeatureFlags(state.featureFlags),
        basCurrentFy: state.basCurrentFy,
        publicHolidays: state.publicHolidays,
        actualIncome: state.actualIncome,
        invoices: invoicesForCache,
        invoiceDefaults: invoiceDefaultsForCache,
        invoiceFilters: invoiceFiltersForCache,
        invoiceSelectedId: state.invoiceSelectedId,
        invoiceDetail: invoiceDetailForCache,
        incomeSummaryCache: serializeIncomeSummaryCache(),
        incomeCacheMetadata: state.incomeCacheMetadata,
        potentialIncomeCache: state.potentialIncomeCache,
        loadingTiers: serializeLoadingTierCache()
      };
      localStorage.setItem(state.cacheKey, JSON.stringify(payload));
    } catch (e) {}
  }

  // Tabs
  function activateTab(id) {
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;

    // With hour types enabled, allow switching between tabs to create entries for different hour types
    if (!hourTypesEnabled) {
      // Original validation logic when hour types are disabled
      const isEditingEntry = state.editingEntryId && state.currentTab !== id;
      const isEditingPunch = state.punchDraft && state.punchDraft.dirty && state.currentTab !== id;

      const isWrongEntryType = state.editingEntryId && (
        (state.editingEntryType === 'basic' && id === 'punch') ||
        (state.editingEntryType === 'advanced' && id === 'manual')
      );

      const hasConflictingData = (() => {
        if (!state.selectedCalendarDate) return false;
        const existingEntry = state.entries.find(entry => entry.date === state.selectedCalendarDate);
        if (!existingEntry) return false;

        const entryType = resolveEntryType(existingEntry);
        if (id === 'manual' && entryType === 'advanced') return true;
        if (id === 'punch' && entryType === 'basic') return true;

        return false;
      })();

      if (isEditingEntry || isEditingPunch || isWrongEntryType || hasConflictingData) {
        return;
      }
    } else {
      // With hour types enabled, only prevent switching if the current entry has unsaved changes
      const hasUnsavedChanges = state.punchDraft && state.punchDraft.dirty && state.currentTab !== id;
      if (hasUnsavedChanges) {
        return;
      }
    }
    
    // Update tab visual states
    $$('.ts-tab').forEach((tab) => {
      const target = tab.getAttribute('data-tab');
      tab.classList.toggle('active', target === id);
    });
    updateTabStates();
    ['manual', 'punch'].forEach((pane) => {
      const el = document.getElementById('tab-' + pane);
      if (el) el.style.display = pane === id ? 'block' : 'none';
    });

    const previousTab = state.currentTab;
    const switchingTabs = previousTab && previousTab !== id;

    // When switching tabs with hour types enabled, preserve hour type and date
    if (hourTypesEnabled && switchingTabs) {
      let currentDate = null;
      let currentHourType = null;

      // Get current values from the previous tab
      if (previousTab === 'manual' && manualDate && manualHourType) {
        currentDate = manualDate.value;
        currentHourType = manualHourType.value;
      } else if (previousTab === 'punch' && punchDate && punchHourType) {
        currentDate = punchDate.value;
        currentHourType = punchHourType.value;
      }

      // Apply to the new tab
      if (id === 'punch' && currentDate && currentHourType) {
        if (punchDate) punchDate.value = currentDate;
        if (punchHourType) punchHourType.value = currentHourType;

        // Check if there's ANY entry (basic or advanced) for this date + hour type
        const anyEntry = state.entries.find(e =>
          e.date === currentDate &&
          (e.hour_type_id || getDefaultHourTypeId()) === currentHourType
        );
        const anyEntryType = anyEntry ? resolveEntryType(anyEntry) : null;

        if (anyEntryType === 'basic') {
          // Hour type exists as basic entry - prevent switching to advanced
          // Switch back to the original tab
          state.currentTab = previousTab;
          $$('.ts-tab').forEach((tab) => {
            const target = tab.getAttribute('data-tab');
            tab.classList.toggle('active', target === previousTab);
          });
          ['manual', 'punch'].forEach((pane) => {
            const el = document.getElementById('tab-' + pane);
            if (el) el.style.display = pane === previousTab ? 'block' : 'none';
          });
          customAlert('This hour type already has a basic entry for this date. Please use the hour type dropdown to switch between different hour types.');
          return;
        }

        if (anyEntryType === 'advanced') {
          const existingEntry = anyEntry;
          // Load existing entry
          state.editingEntryId = existingEntry.id;
          state.editingEntryType = anyEntryType;
          updatePunchContractOptions(existingEntry.contract_id);
          if (punchContract) punchContract.value = existingEntry.contract_id || '';
          state.punchDraft = {
            entryId: existingEntry.id,
            contractId: existingEntry.contract_id || '',
            date: existingEntry.date,
            punches: clonePunches(existingEntry.punches || []),
            dirty: false
          };
          renderPunchDraft();
          updatePunchSummary();
        } else {
          // Create new entry
          state.editingEntryId = null;
          state.editingEntryType = null;
          updatePunchContractOptions();
          state.punchDraft = {
            entryId: null,
            contractId: punchContract ? punchContract.value : '',
            date: currentDate,
            punches: [{ in: '', out: '' }],
            dirty: false
          };
          renderPunchDraft();
          updatePunchSummary();
        }
        updatePunchContractVisibility();
      } else if (id === 'manual' && currentDate && currentHourType) {
        if (manualDate) manualDate.value = currentDate;
        if (manualHourType) manualHourType.value = currentHourType;

        // Check if there's ANY entry (basic or advanced) for this date + hour type
        const anyEntry = state.entries.find(e =>
          e.date === currentDate &&
          (e.hour_type_id || getDefaultHourTypeId()) === currentHourType
        );
        const anyEntryType = anyEntry ? resolveEntryType(anyEntry) : null;

        if (anyEntryType === 'advanced') {
          // Hour type exists as advanced entry - prevent switching to basic
          // Switch back to the original tab
          state.currentTab = previousTab;
          $$('.ts-tab').forEach((tab) => {
            const target = tab.getAttribute('data-tab');
            tab.classList.toggle('active', target === previousTab);
          });
          ['manual', 'punch'].forEach((pane) => {
            const el = document.getElementById('tab-' + pane);
            if (el) el.style.display = pane === previousTab ? 'block' : 'none';
          });
          customAlert('This hour type already has an advanced entry for this date. Please use the hour type dropdown to switch between different hour types.');
          return;
        }

        if (anyEntryType === 'basic') {
          // Load existing entry
          populateManualForm(anyEntry, true);
        } else {
          // Create new entry
          clearManualEditing();
          if (manualDate) manualDate.value = currentDate;
          if (manualHourType) manualHourType.value = currentHourType;
          updateManualContractVisibility();
        }
      }
    } else if (id === 'punch' && state.selectedCalendarDate && punchDate) {
      // Original behavior when hour types disabled
      punchDate.value = state.selectedCalendarDate;
      state.punchDraft = null;
      ensurePunchDraft();
    }

    state.currentTab = id;
  }
  $$('.ts-tab').forEach((tab) => {
    tab.addEventListener('click', () => {
      activateTab(tab.getAttribute('data-tab'));
      focusDefaultEntryField();
    });
  });

  // Function to update tab disabled states
  function updateTabStates() {
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;

    $$('.ts-tab').forEach((tab) => {
      const target = tab.getAttribute('data-tab');

      // Check if this tab should be disabled
      let isDisabled = false;
      let disabledReason = '';

      if (hourTypesEnabled && state.selectedCalendarDate) {
        // With hour types enabled, check if the CURRENT hour type has an entry in the opposite format
        const currentHourType = state.currentTab === 'manual'
          ? (manualHourType ? manualHourType.value : getDefaultHourTypeId())
          : (punchHourType ? punchHourType.value : getDefaultHourTypeId());

        const existingEntry = state.entries.find(entry =>
          entry.date === state.selectedCalendarDate &&
          (entry.hour_type_id || getDefaultHourTypeId()) === currentHourType
        );

        if (existingEntry) {
          const entryType = resolveEntryType(existingEntry);
          // Disable basic tab if current hour type has advanced entry
          if (target === 'manual' && entryType === 'advanced') {
            isDisabled = true;
            disabledReason = 'This hour type has an advanced entry for this date';
          }
          // Disable advanced tab if current hour type has basic entry
          if (target === 'punch' && entryType === 'basic') {
            isDisabled = true;
            disabledReason = 'This hour type has a basic entry for this date';
          }
        }
      } else if (!hourTypesEnabled && state.selectedCalendarDate) {
        // Original behavior when hour types disabled
        const existingEntry = state.entries.find(entry => entry.date === state.selectedCalendarDate);
        if (existingEntry) {
          const entryType = resolveEntryType(existingEntry);
          // Disable basic tab if date has advanced entry
          if (target === 'manual' && entryType === 'advanced') {
            isDisabled = true;
            disabledReason = 'This date already has an advanced entry';
          }
          // Disable advanced tab if date has basic entry
          if (target === 'punch' && entryType === 'basic') {
            isDisabled = true;
            disabledReason = 'This date already has a basic entry';
          }
        }
      }

      tab.style.opacity = isDisabled ? '0.4' : '1';
      tab.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
      tab.title = disabledReason;
    });
  }

  // Default to manual tab initially (will be updated after cache loads)
  activateTab('manual');

  // Punch controls
  const punchDate = document.getElementById('punch-date');
  const punchHourType = document.getElementById('punch-hour-type');
  const punchHourTypeCol = document.getElementById('punch-hour-type-col');
  const punchContract = document.getElementById('punch-contract');
  const punchContractWarning = document.getElementById('punch-contract-warning');
  const punchToggleBtn = document.getElementById('btn-punch-toggle');
  const punchSaveBtn = document.getElementById('btn-punch-save');
  const punchCancelBtn = document.getElementById('btn-punch-cancel');
  const punchDeleteBtn = document.getElementById('btn-delete-punch');
  const punchList = document.getElementById('punch-range-list');
  const punchOpenWarning = document.getElementById('punch-open-warning');
  const punchSummary = document.getElementById('punch-summary');
  const punchSuggestion = document.getElementById('punch-suggestion');

  function currentPunchDate() {
    return punchDate && punchDate.value ? punchDate.value : todayIso();
  }

  function updatePunchContractOptions(preferredContractId) {
    if (!punchContract) return '';
    const dateIso = currentPunchDate();
    const valid = validContractsForDate(dateIso);
    const currentValue = preferredContractId != null ? preferredContractId : punchContract.value;
    const options = [...valid];
    if (currentValue && !options.some((contract) => contract.id === currentValue)) {
      const fallback = state.contractMap[currentValue];
      if (fallback) options.push(fallback);
    }
    options.sort((a, b) => a.name.localeCompare(b.name));
    punchContract.innerHTML = '';
    if (!options.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts';
      punchContract.appendChild(placeholder);
      punchContract.value = '';
      punchContract.disabled = true;
      if (punchContractWarning) punchContractWarning.style.display = 'block';
      return '';
    }
    if (options.length > 1) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select contract';
      punchContract.appendChild(placeholder);
    }
    options.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      punchContract.appendChild(opt);
    });
    let selected = currentValue && options.some((contract) => contract.id === currentValue) ? currentValue : '';
    if (!selected && valid.length === 1) {
      selected = valid[0].id;
    }
    punchContract.value = selected;
    punchContract.disabled = valid.length === 1 && options.length === valid.length;
    if (punchContractWarning) punchContractWarning.style.display = selected ? 'none' : 'block';
    return punchContract.value;
  }

  function setPunchDate(dateIso, preferredContractId) {
    if (!punchDate) return;
    punchDate.value = dateIso || todayIso();
    updatePunchContractOptions(preferredContractId != null ? preferredContractId : (punchContract ? punchContract.value : ''));
  }

  function ensurePunchDraft(preferredContractId, entryOverride) {
    const preferred = preferredContractId != null ? preferredContractId : (entryOverride ? entryOverride.contract_id : undefined);
    const selected = updatePunchContractOptions(preferred);
    const contractId = selected || (preferred || '');
    const dateIso = currentPunchDate();
    
    // If we're switching dates and there's no contract selected, start fresh
    if (!contractId) {
      state.punchDraft = {
        entryId: null,
        contractId: '',
        date: dateIso,
        punches: [{ in: '', out: '' }],
        dirty: false
      };
      renderPunchDraft();
      return;
    }
    
    // Look for existing entry for this specific date/contract (prefer entryOverride match)
    var entry = null;
    if (entryOverride && entryOverride.date === dateIso && (entryOverride.contract_id || '') === contractId) {
      entry = entryOverride;
    } else {
      entry = state.entries.find((e) => e.date === dateIso && e.contract_id === contractId && (
        !entryOverride || e.hour_type_id === entryOverride.hour_type_id || e.id === entryOverride.id
      )) || state.entries.find((e) => e.date === dateIso && e.contract_id === contractId) || null;
    }
    state.punchDraft = {
      entryId: entry ? entry.id : null,
      contractId,
      date: dateIso,
      punches: entry ? clonePunches(entry.punches || []) : [{ in: '', out: '' }],
      dirty: false
    };

    // Set hour type if editing existing entry
    if (punchHourType && entry && entry.hour_type_id) {
      punchHourType.value = entry.hour_type_id;
      updatePunchContractVisibility();
    }

    renderPunchDraft();
    if (state.currentTab === 'punch') focusDefaultEntryField();
  }

  function setPunchDraftDirty() {
    if (!state.punchDraft) return;
    state.punchDraft.dirty = true;
  }

  function renderPunchDraft() {
    if (!punchList) return;
    punchList.innerHTML = '';
    const draft = state.punchDraft || { punches: [], contractId: '' };
    const punches = draft.punches || [];
    if (!draft.contractId) {
      const note = document.createElement('div');
      note.className = 'ts-note';
      note.textContent = 'Select a contract to view today\'s punches.';
      punchList.appendChild(note);
    } else if (!punches.length || (punches.length === 1 && !punches[0].in)) {
      // Show an empty range for new entries
      const emptyRange = document.createElement('div');
      emptyRange.className = 'ts-punch-row';
      const startInput = document.createElement('input');
      startInput.type = 'time';
      startInput.value = punches.length > 0 ? (punches[0].in || '') : '';
      startInput.className = 'ts-punch-input';
      startInput.dataset.punchIndex = '0';
      startInput.dataset.punchField = 'in';
      startInput.addEventListener('keydown', handlePunchInputEnter);
      startInput.onchange = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches[0].in = startInput.value;
        setPunchDraftDirty();
        updatePunchSummary();
      };
      const endInput = document.createElement('input');
      endInput.type = 'time';
      endInput.value = punches.length > 0 ? (punches[0].out || '') : '';
      endInput.className = 'ts-punch-input';
      endInput.dataset.punchIndex = '0';
      endInput.dataset.punchField = 'out';
      endInput.addEventListener('keydown', handlePunchInputEnter);
      endInput.onchange = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches[0].out = endInput.value;
        setPunchDraftDirty();
        updatePunchSummary();
      };
      const addBtn = document.createElement('button');
      addBtn.type = 'button';
      addBtn.className = 'ghost';
      addBtn.textContent = 'Add';
      addBtn.onclick = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches.push({ in: '', out: '' });
        setPunchDraftDirty();
        renderPunchDraft();
        // Focus on the new row's start input
        setTimeout(() => {
          const newRow = punchList.children[punchList.children.length - 1];
          const newStartInput = newRow.querySelector('input[type="time"]');
          if (newStartInput) newStartInput.focus();
        }, 0);
      };
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'ghost';
      removeBtn.textContent = 'Remove';
      removeBtn.onclick = () => {
        if (draft.punches.length) draft.punches.splice(0, 1);
        setPunchDraftDirty();
        renderPunchDraft();
      };
      emptyRange.appendChild(startInput);
      emptyRange.appendChild(document.createTextNode(' to '));
      emptyRange.appendChild(endInput);
      emptyRange.appendChild(addBtn);
      emptyRange.appendChild(removeBtn);
      punchList.appendChild(emptyRange);
    } else {
      punches.forEach((punch, index) => {
        const row = document.createElement('div');
        row.className = 'ts-punch-row';
        const startInput = document.createElement('input');
        startInput.type = 'time';
        startInput.value = punch.in || '';
        startInput.className = 'ts-punch-input';
        startInput.dataset.punchIndex = String(index);
        startInput.dataset.punchField = 'in';
        startInput.addEventListener('keydown', handlePunchInputEnter);
        startInput.onchange = () => {
          draft.punches[index].in = startInput.value;
          setPunchDraftDirty();
          updatePunchSummary();
        };
        const endInput = document.createElement('input');
        endInput.type = 'time';
        endInput.value = punch.out || '';
        endInput.className = 'ts-punch-input';
        endInput.dataset.punchIndex = String(index);
        endInput.dataset.punchField = 'out';
        endInput.addEventListener('keydown', handlePunchInputEnter);
        endInput.onchange = () => {
          draft.punches[index].out = endInput.value;
          setPunchDraftDirty();
          updatePunchSummary();
        };
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'ghost';
        addBtn.textContent = 'Add';
        addBtn.onclick = () => {
          // Insert new punch after current index
          draft.punches.splice(index + 1, 0, { in: '', out: '' });
          setPunchDraftDirty();
          renderPunchDraft();
          // Focus on the new row's start input
          setTimeout(() => {
            const allRows = punchList.children;
            const newRowIndex = index + 1;
            if (allRows[newRowIndex]) {
              const newStartInput = allRows[newRowIndex].querySelector('input[type="time"]');
              if (newStartInput) newStartInput.focus();
            }
          }, 0);
        };
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'ghost';
        removeBtn.textContent = 'Remove';
        removeBtn.onclick = () => {
          draft.punches.splice(index, 1);
          setPunchDraftDirty();
          renderPunchDraft();
        };
        row.appendChild(startInput);
        row.appendChild(document.createTextNode(' to '));
        row.appendChild(endInput);
        row.appendChild(addBtn);
        row.appendChild(removeBtn);
        punchList.appendChild(row);
      });
    }
    applyQueuedEntryFocus();
    updatePunchSummary();
    const hasContract = !!draft.contractId;
    const hasPunches = punches.length > 0;
    const openCount = summarizePunches(punches).openCount;
    if (punchToggleBtn) {
      punchToggleBtn.textContent = openCount > 0 ? 'Punch Out' : 'Punch In';
      punchToggleBtn.disabled = !hasContract;
    }
    if (punchSaveBtn) {
      punchSaveBtn.disabled = !hasContract || !hasPunches;
      punchSaveBtn.textContent = draft.entryId ? 'Update Entry' : 'Add Entry';
    }
    if (punchCancelBtn) {
      punchCancelBtn.disabled = !hasContract || !draft.dirty;
      punchCancelBtn.style.display = draft.dirty ? 'inline-flex' : 'none';
    }
    if (punchDeleteBtn) {
      punchDeleteBtn.style.display = draft.entryId ? 'inline-flex' : 'none';
    }
  }

  function calculateEndTimeSuggestion(punches, openPunch, roundingMinutes, minimumEndTime) {
    // Calculate total minutes from closed punches
    var closedMinutes = 0;
    for (var i = 0; i < punches.length; i++) {
      if (punches[i].in && punches[i].out) {
        var inParts = punches[i].in.split(':');
        var outParts = punches[i].out.split(':');
        var inMinutes = parseInt(inParts[0], 10) * 60 + parseInt(inParts[1], 10);
        var outMinutes = parseInt(outParts[0], 10) * 60 + parseInt(outParts[1], 10);
        closedMinutes += (outMinutes - inMinutes);
      }
    }

    // Calculate minutes from open punch to current time
    var inParts = openPunch.in.split(':');
    var inMinutes = parseInt(inParts[0], 10) * 60 + parseInt(inParts[1], 10);

    // Parse minimum end time
    var minEndParts = minimumEndTime.split(':');
    var minEndMinutes = parseInt(minEndParts[0], 10) * 60 + parseInt(minEndParts[1], 10);

    // Calculate current total if we were to clock out at minimum end time
    var currentTotal = closedMinutes + (minEndMinutes - inMinutes);

    // If the open punch hasn't reached minimum end time yet, no suggestion
    if (minEndMinutes < inMinutes) {
      return null;
    }

    // Calculate what the rounded total should be
    var roundedTotal = Math.ceil(currentTotal / roundingMinutes) * roundingMinutes;

    // Calculate suggested clock-out time
    var suggestedMinutes = inMinutes + (roundedTotal - closedMinutes);

    // Make sure it's within the valid range
    var maxEndMinutes = minEndMinutes + roundingMinutes;
    if (suggestedMinutes < minEndMinutes || suggestedMinutes > maxEndMinutes) {
      return null;
    }

    // Format the suggested time
    var suggestedHours = Math.floor(suggestedMinutes / 60);
    var suggestedMins = suggestedMinutes % 60;
    var suggestedTime = String(suggestedHours).padStart(2, '0') + ':' + String(suggestedMins).padStart(2, '0');

    // Format the total hours
    var totalHours = roundedTotal / 60;
    var formattedTotal = formatHours(roundedTotal);

    // Determine AM/PM
    var period = suggestedHours >= 12 ? 'pm' : 'am';
    var displayHours = suggestedHours > 12 ? suggestedHours - 12 : (suggestedHours === 0 ? 12 : suggestedHours);
    var displayTime = displayHours + ':' + String(suggestedMins).padStart(2, '0') + ' ' + period;

    return {
      time: suggestedTime,
      total: formattedTotal,
      message: 'Clock out at ' + displayTime + ' to round out your hours nicely to ' + formattedTotal
    };
  }

  function updatePunchSummary() {
    if (!punchSummary || !punchOpenWarning || !punchSuggestion) return;
    const draft = state.punchDraft || { punches: [] };
    const punches = normalizePunchList(draft.punches || []);
    const summary = summarizePunches(punches);
    if (punches.length) {
      const rounded = summary.totalMinutes > 0 ? roundDuration(summary.totalMinutes) : 0;
      punchSummary.textContent = `Recorded: ${formatHours(rounded)} hours`;
    } else {
      punchSummary.textContent = '';
    }
    if (summary.openCount > 0) {
      const lastOpen = punches.find((p) => !p.out);
      punchOpenWarning.textContent = lastOpen && lastOpen.in ? `Open punch since ${lastOpen.in}. Remember to punch out.` : 'Open punch detected. Please punch out when you finish.';
      punchOpenWarning.style.display = 'block';
    } else {
      punchOpenWarning.style.display = 'none';
    }

    // Calculate and display end time suggestion
    const suggestEndTimeEnabled = getFeatureFlag('suggest_end_time');
    if (suggestEndTimeEnabled && punches.length > 1 && summary.openCount > 0) {
      const lastOpen = punches.find((p) => !p.out);
      if (lastOpen && lastOpen.in) {
        const roundingMinutes = parseInt(state.settings.round_to_nearest, 10) || 0;
        const minimumEndTime = state.settings.minimum_end_time || '17:00';

        if (roundingMinutes > 0) {
          const suggestion = calculateEndTimeSuggestion(punches, lastOpen, roundingMinutes, minimumEndTime);
          if (suggestion) {
            punchSuggestion.textContent = suggestion.message;
            punchSuggestion.style.display = 'block';
          } else {
            punchSuggestion.style.display = 'none';
          }
        } else {
          punchSuggestion.style.display = 'none';
        }
      } else {
        punchSuggestion.style.display = 'none';
      }
    } else {
      punchSuggestion.style.display = 'none';
    }
  }

  function addPunchRow() {
    if (!state.punchDraft) return;
    state.punchDraft.punches.push({ in: '', out: '' });
    setPunchDraftDirty();
    renderPunchDraft();
  }

  function persistPunchDraft(options = {}) {
    const { requireClosed = false } = options;
    const draft = state.punchDraft;

    // Get hour type
    const hourTypeId = punchHourType ? punchHourType.value : getDefaultHourTypeId();
    const selectedHourType = state.hourTypeMap[hourTypeId];

    // Validate contract based on hour type
    if (selectedHourType && selectedHourType.requires_contract) {
      if (!draft || !draft.contractId) {
        customAlert('Select a contract before saving punches.');
        return;
      }
    }

    const punches = normalizePunchList(draft.punches || []);
    const validationError = validatePunches(punches, { allowOpen: !requireClosed, requireClosed });
    if (validationError) {
      customAlert(validationError);
      return;
    }
    const summary = summarizePunches(punches);
    const roundedMinutes = summary.totalMinutes > 0 ? roundDuration(summary.totalMinutes) : 0;
    const payload = {
      date: draft.date,
      contract_id: draft.contractId || '',
      hour_type_id: hourTypeId,
      punches,
      duration_minutes: roundedMinutes,
      round_interval: getRoundInterval(),
      entry_type: 'advanced'
    };
    if (draft.entryId) payload.id = draft.entryId;

    const lockResult = checkEntryDuplicateAndLock(payload, draft.entryId);
    if (lockResult.blocked) return;
    const inFlightKey = lockResult.key;
    const inFlightId = draft.entryId || payload.id || 'new';

    // Optimistic update
    let optimisticEntry = null;
    let optimisticBackup = null;
    const isUpdate = !!draft.entryId;
    if (isUpdate) {
      const idx = state.entries.findIndex((e) => e.id === draft.entryId);
      if (idx !== -1) {
        optimisticBackup = { ...state.entries[idx] };
        const optimisticUpdate = sanitizeEntry({ ...optimisticBackup, ...payload, id: draft.entryId });
        markIncomeSummaryDirtyForEntry(optimisticBackup);
        state.entries[idx] = optimisticEntry = optimisticUpdate;
        markIncomeSummaryDirtyForEntry(optimisticUpdate);
        recordPendingEntryUpdate(draft.entryId, optimisticUpdate);
        state.entries.sort(entrySort);
        saveCache();
        renderEntries();
      }
    } else {
      const pending = {
        id: 'temp_' + Date.now(),
        ...payload,
        created_at: isoDateTime(new Date())
      };
      optimisticEntry = sanitizeEntry(pending);
      state.entries.unshift(optimisticEntry);
      markIncomeSummaryDirtyForEntry(optimisticEntry);
      recordPendingEntryAdd(optimisticEntry);
      state.entries.sort(entrySort);
      saveCache();
      renderEntries();
    }

    setStatus('Saving punches...', 'warn');
    renderPunchDraft();

    const onSuccess = (res) => {
      if (handleDuplicateConflictResponse(res)) {
        if (optimisticEntry) {
          const dupIdx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
          if (dupIdx > -1) {
            if (isUpdate && optimisticBackup) {
              state.entries[dupIdx] = optimisticBackup;
              markIncomeSummaryDirtyForEntry(optimisticBackup);
            } else {
              state.entries.splice(dupIdx, 1);
              markIncomeSummaryDirtyForEntry(optimisticEntry);
            }
          }
          if (isUpdate) {
            resolvePendingEntryUpdate(draft.entryId);
          } else {
            resolvePendingEntryAdd(optimisticEntry.id);
          }
          saveCache();
          renderEntries();
        }
        renderPunchDraft();
        releaseEntryLock(inFlightKey, inFlightId);
        return;
      }
      if (res && res.success && res.entry) {
        const sanitized = sanitizeEntry(res.entry);
        if (optimisticEntry) {
          // Replace optimistic entry with real one
          const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
          if (idx > -1) {
            state.entries[idx] = sanitized;
            markIncomeSummaryDirtyForEntry(sanitized);
            if (isUpdate) {
              recordPendingEntryUpdate(sanitized.id, sanitized);
              if (!entriesSyncInFlight) resolvePendingEntryUpdate(sanitized.id);
            } else {
              updatePendingEntryAddId(optimisticEntry.id, sanitized);
              if (!entriesSyncInFlight) resolvePendingEntryAdd(sanitized.id);
            }
            state.entries.sort(entrySort);
          }
        } else {
          // Update existing entry
          const idx = state.entries.findIndex((e) => e.id === sanitized.id);
          if (idx > -1) {
            state.entries[idx] = sanitized;
            markIncomeSummaryDirtyForEntry(sanitized);
          } else {
            state.entries.push(sanitized);
            markIncomeSummaryDirtyForEntry(sanitized);
          }
          recordPendingEntryUpdate(sanitized.id, sanitized);
          if (!entriesSyncInFlight) resolvePendingEntryUpdate(sanitized.id);
          state.entries.sort(entrySort);
        }
        state.punchDraft = {
          entryId: sanitized.id,
          contractId: sanitized.contract_id,
          date: sanitized.date,
          punches: clonePunches(sanitized.punches || []),
          dirty: false
        };
        saveCache();
        renderEntries();
        setStatus('Punches saved', 'success');
        releaseEntryLock(inFlightKey, inFlightId);
      } else {
        // Remove optimistic entry on failure
        if (optimisticEntry) {
          const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
          if (idx > -1) {
            if (isUpdate && optimisticBackup) {
              state.entries[idx] = optimisticBackup;
              markIncomeSummaryDirtyForEntry(optimisticBackup);
            } else {
              state.entries.splice(idx, 1);
              markIncomeSummaryDirtyForEntry(optimisticEntry);
            }
            saveCache();
            renderEntries();
          }
          if (isUpdate) {
            resolvePendingEntryUpdate(draft.entryId);
          } else {
            resolvePendingEntryAdd(optimisticEntry.id);
          }
        }
        setStatus('Punch save failed', 'error');
        releaseEntryLock(inFlightKey, inFlightId);
      }
      renderPunchDraft();
    };

    const onFailure = () => {
      // Remove optimistic entry on failure
      if (optimisticEntry) {
        const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
        if (idx > -1) {
          if (isUpdate && optimisticBackup) {
            state.entries[idx] = optimisticBackup;
            markIncomeSummaryDirtyForEntry(optimisticBackup);
          } else {
            state.entries.splice(idx, 1);
            markIncomeSummaryDirtyForEntry(optimisticEntry);
          }
          saveCache();
          renderEntries();
        }
        if (isUpdate) {
          resolvePendingEntryUpdate(draft.entryId);
        } else {
          resolvePendingEntryAdd(optimisticEntry.id);
        }
      }
      setStatus('Punch save failed', 'error');
      renderPunchDraft();
      releaseEntryLock(inFlightKey, inFlightId);
    };

    if (draft.entryId) {
      google.script.run
        .withSuccessHandler(onSuccess)
        .withFailureHandler(onFailure)
        .api_updateEntry(payload);
    } else {
      google.script.run
        .withSuccessHandler(onSuccess)
        .withFailureHandler(onFailure)
        .api_addEntry(payload);
    }
  }

  function handlePunchToggle() {
    const draft = state.punchDraft;
    if (!draft || !draft.contractId) {
      customAlert('Select a contract before punching in.');
      return;
    }
    const now = new Date();
    const currentTime = now.toTimeString().slice(0, 5);
    const punches = draft.punches || [];
    
    // Look for an open punch (has in but no out)
    const openIndex = punches.findIndex((punch) => punch && punch.in && !punch.out);
    if (openIndex !== -1) {
      // Punch out - close the open punch
      draft.punches[openIndex].out = currentTime;
    } else {
      // Punch in - add a new punch or populate the first empty range
      if (punches.length === 0) {
        draft.punches.push({ in: currentTime, out: '' });
      } else {
        // Find the first empty range (no in time) and populate it
        const firstEmpty = punches.findIndex(punch => !punch.in);
        if (firstEmpty !== -1) {
          draft.punches[firstEmpty].in = currentTime;
        } else {
          draft.punches.push({ in: currentTime, out: '' });
        }
      }
    }
    setPunchDraftDirty();
    renderPunchDraft();
    persistPunchDraft({ requireClosed: false });
  }

  function handlePunchSave() {
    persistPunchDraft({ requireClosed: false });
  }

  function handlePunchDiscard() {
    if (!state.punchDraft) return;
    ensurePunchDraft(state.punchDraft.contractId);
  }

  async function handlePunchDelete() {
    if (!state.punchDraft || !state.punchDraft.entryId) return;

    const confirmed = await customConfirm(
      'Are you sure you want to delete this entry? This action cannot be undone.',
      { danger: true }
    );
    if (!confirmed) return;

    const entryId = state.punchDraft.entryId;
    const currentDate = state.punchDraft.date;

    // Optimistic delete: Remove from local state immediately
    const idx = state.entries.findIndex(e => e.id === entryId);
    if (idx === -1) {
      // If the entry isn't in local state (e.g. temp or already removed), just clear draft
      state.punchDraft = null;
      ensurePunchDraft();
      return;
    }

    const backup = state.entries[idx];
    state.entries.splice(idx, 1);
    markIncomeSummaryDirtyForEntry(backup);
    recordPendingEntryDelete(entryId);

    // Clear punch draft and start fresh
    state.punchDraft = null;
    if (punchDate) punchDate.value = currentDate;
    ensurePunchDraft();

    saveCache();
    renderEntries();
    updateTabStates();
    setStatus('Deleting entry...', 'warn');

    google.script.run
      .withSuccessHandler(() => {
        if (!entriesSyncInFlight) resolvePendingEntryDelete(entryId);
        setStatus('Entry deleted', 'success');
      })
      .withFailureHandler((error) => {
        console.error('Failed to delete punch entry', { entryId, error });
        const message = (error && error.message) ? String(error.message) : String(error || '');
        const notFound = /entry not found/i.test(message);
        if (notFound || entryId.startsWith('temp_')) {
          // Treat as already removed
          resolvePendingEntryDelete(entryId);
          saveCache();
          renderEntries();
          updateTabStates();
          setStatus('Entry already removed', 'success');
          return;
        }
        // Rollback: restore the entry
        state.entries.splice(idx, 0, backup);
        markIncomeSummaryDirtyForEntry(backup);
        resolvePendingEntryDelete(entryId);
        saveCache();
        renderEntries();
        updateTabStates();
        setStatus('Delete failed', 'error');
      })
      .api_deleteEntry(entryId);
  }

  if (punchToggleBtn) punchToggleBtn.onclick = handlePunchToggle;
  if (punchSaveBtn) punchSaveBtn.onclick = handlePunchSave;
  if (punchCancelBtn) punchCancelBtn.onclick = handlePunchDiscard;
  if (punchDeleteBtn) punchDeleteBtn.onclick = handlePunchDelete;
  if (punchDate) {
    punchDate.addEventListener('change', () => {
      state.selectedCalendarDate = punchDate.value;
      // Clear any existing draft when date changes
      state.punchDraft = null;
      updatePunchContractOptions();
      ensurePunchDraft();
    });
  }
  if (punchContract) {
    punchContract.addEventListener('change', () => {
      ensurePunchDraft(punchContract.value);
    });
  }

  // Manual form helpers
  const manualDate = document.getElementById('manual-date');
  const manualHourType = document.getElementById('manual-hour-type');
  const manualHourTypeCol = document.getElementById('manual-hour-type-col');
  const manualContract = document.getElementById('manual-contract');
  const manualContractWarning = document.getElementById('manual-contract-warning');
  const manualHoursInput = document.getElementById('manual-hours');
  const manualSaveBtn = document.getElementById('btn-add-manual');
  const manualCancelBtn = document.getElementById('btn-cancel-edit');
  const manualDeleteBtn = document.getElementById('btn-delete-manual');
  const recurringManageBtn = document.getElementById('btn-manage-recurring');
  const recurringModal = document.getElementById('modal-recurring-entries');
  const recurringList = document.getElementById('recurring-entry-list');
  const recurringEmpty = document.getElementById('recurring-entry-empty');
  const recurringNewBtn = document.getElementById('btn-recurring-new');
  const recurringForm = document.getElementById('recurring-entry-form');
  const recurringFormTitle = document.getElementById('recurring-form-title');
  const recurringFormSubtitle = document.getElementById('recurring-form-subtitle');
  const recurringFormWarning = document.getElementById('recurring-form-warning');
  const recurringFormError = document.getElementById('recurring-form-error');
  const recurringNameInput = document.getElementById('recurring-name');
  const recurringHoursInput = document.getElementById('recurring-hours');
  const recurringContractSelect = document.getElementById('recurring-contract');
  const recurringHourTypeRow = document.getElementById('recurring-hour-type-row');
  const recurringHourTypeSelect = document.getElementById('recurring-hour-type');
  const recurringStartDateInput = document.getElementById('recurring-start-date');
  const recurringEndDateInput = document.getElementById('recurring-end-date');
  const recurringFrequencySelect = document.getElementById('recurring-frequency');
  const recurringWeeklyFields = document.getElementById('recurring-weekly-fields');
  const recurringWeeklyIntervalInput = document.getElementById('recurring-weekly-interval');
  const recurringMonthlyFields = document.getElementById('recurring-monthly-fields');
  const recurringMonthlyIntervalInput = document.getElementById('recurring-monthly-interval');
  const recurringMonthlyModeSelect = document.getElementById('recurring-monthly-mode');
  const recurringMonthlyDayInput = document.getElementById('recurring-monthly-day');
  const recurringMonthlyWeekSelect = document.getElementById('recurring-monthly-week');
  const recurringMonthlyWeekdaySelect = document.getElementById('recurring-monthly-weekday');
  const recurringMonthlyDayWrapper = document.getElementById('recurring-monthly-day-wrapper');
  const recurringMonthlyWeekWrapper = document.getElementById('recurring-monthly-week-wrapper');
  const recurringMonthlyModeWrapper = document.getElementById('recurring-monthly-mode-wrapper');
  const recurringGeneratedSummary = document.getElementById('recurring-generated-summary');
  const recurringPreviewNote = document.getElementById('recurring-preview-note');
  const recurringPreviewList = document.getElementById('recurring-preview-list');
  const recurringCancelBtn = document.getElementById('btn-cancel-recurring');
  const recurringSaveBtn = document.getElementById('btn-save-recurring');
  const recurringDeleteBtn = document.getElementById('btn-delete-recurring');
  const recurringDeleteConfirm = document.getElementById('recurring-delete-confirm');
  const recurringDeleteCancelBtn = document.getElementById('btn-cancel-delete-recurring');
  const recurringDeleteConfirmBtn = document.getElementById('btn-confirm-delete-recurring');
  const bulkManageBtn = document.getElementById('btn-manage-bulk');
  const bulkModal = document.getElementById('modal-bulk-entries');
  const bulkList = document.getElementById('bulk-entry-list');
  const bulkEmpty = document.getElementById('bulk-entry-empty');
  const bulkNewBtn = document.getElementById('btn-bulk-new');
  const bulkForm = document.getElementById('bulk-entry-form');
  const bulkFormTitle = document.getElementById('bulk-form-title');
  const bulkFormSubtitle = document.getElementById('bulk-form-subtitle');
  const bulkFormWarning = document.getElementById('bulk-form-warning');
  const bulkFormError = document.getElementById('bulk-form-error');
  const bulkNameInput = document.getElementById('bulk-name');
  const bulkHoursModeSelect = document.getElementById('bulk-distribution-mode');
  const bulkHoursInput = document.getElementById('bulk-hours');
  const bulkHoursLabelText = document.getElementById('bulk-hours-label-text');
  const bulkContractSelect = document.getElementById('bulk-contract');
  const bulkHourTypeRow = document.getElementById('bulk-hour-type-row');
  const bulkHourTypeSelect = document.getElementById('bulk-hour-type');
  const bulkStartDateInput = document.getElementById('bulk-start-date');
  const bulkEndDateInput = document.getElementById('bulk-end-date');
  const bulkMonthWrapper = document.getElementById('bulk-month-wrapper');
  const bulkMonthInput = document.getElementById('bulk-month');
  const bulkMonthYearDisplay = document.getElementById('bulk-month-year');
  const bulkMonthPrevBtn = document.getElementById('bulk-month-year-prev');
  const bulkMonthNextBtn = document.getElementById('bulk-month-year-next');
  const bulkMonthGrid = document.getElementById('bulk-month-grid');
  const bulkMonthPickerState = { year: (new Date()).getFullYear() };
  const bulkDateRangeRow = document.getElementById('bulk-date-range-row');
  const bulkStartDateWrapper = document.getElementById('bulk-start-date-wrapper');
  const bulkEndDateWrapper = document.getElementById('bulk-end-date-wrapper');
  const bulkSkipWeekendsToggle = document.getElementById('bulk-skip-weekends');
  const bulkSkipHolidaysToggle = document.getElementById('bulk-skip-holidays');
  const bulkGeneratedSummary = document.getElementById('bulk-generated-summary');
  const bulkCancelBtn = document.getElementById('btn-cancel-bulk');
  const bulkSaveBtn = document.getElementById('btn-save-bulk');
  const bulkDeleteBtn = document.getElementById('btn-delete-bulk');
  const bulkDeleteConfirm = document.getElementById('bulk-delete-confirm');
  const bulkDeleteCancelBtn = document.getElementById('btn-cancel-delete-bulk');
  const bulkDeleteConfirmBtn = document.getElementById('btn-confirm-delete-bulk');

  let queuedEntryFocus = null;
  let queuedFocusTimer = null;
  let entryFieldFocusSuppressed = false;
  const entrySaveInFlight = new Map();
  let duplicateCleanupPromptShown = false;

  function withEntryFocusSuppressed(fn) {
    const previous = entryFieldFocusSuppressed;
    entryFieldFocusSuppressed = true;
    try {
      return fn();
    } finally {
      entryFieldFocusSuppressed = previous;
    }
  }

  function queueEntryFieldFocus(target) {
    if (entryFieldFocusSuppressed) return;
    queuedEntryFocus = target;
    if (queuedFocusTimer) clearTimeout(queuedFocusTimer);
    queuedFocusTimer = setTimeout(() => {
      queuedFocusTimer = null;
      applyQueuedEntryFocus();
    }, 0);
  }

  function applyQueuedEntryFocus() {
    if (!queuedEntryFocus) return;
    if (entryFieldFocusSuppressed) {
      queuedEntryFocus = null;
      return;
    }
    const target = queuedEntryFocus;
    queuedEntryFocus = null;
    if (target.mode === 'manual') {
      if (manualHoursInput) manualHoursInput.focus();
      return;
    }
    if (target.mode === 'punch') {
      if (!punchList) return;
      const selector = `[data-punch-index="${target.index}"][data-punch-field="${target.field}"]`;
      const punchInput = punchList.querySelector(selector) || punchList.querySelector('input[type="time"]');
      if (punchInput) punchInput.focus();
    }
  }

  function entryCompositeKey(dateIso, hourTypeId, contractId) {
    const typeId = hourTypeId || getDefaultHourTypeId() || '';
    return [dateIso || '', String(typeId || ''), contractId || ''].join('|');
  }

  function findDuplicateEntryInState(dateIso, hourTypeId, contractId, excludeId) {
    const targetKey = entryCompositeKey(dateIso, hourTypeId, contractId);
    return state.entries.find((entry) => {
      if (!entry || entry.id === excludeId) return false;
      const key = entryCompositeKey(entry.date, entry.hour_type_id || getDefaultHourTypeId(), entry.contract_id || '');
      return key === targetKey;
    }) || null;
  }

  function findDuplicateGroups(entries) {
    const map = new Map();
    (entries || []).forEach((entry) => {
      if (!entry || !entry.date) return;
      const key = entryCompositeKey(entry.date, entry.hour_type_id || getDefaultHourTypeId(), entry.contract_id || '');
      if (!map.has(key)) map.set(key, []);
      map.get(key).push(entry);
    });
    return Array.from(map.entries()).map(([key, list]) => ({ key, entries: list })).filter((g) => g.entries.length > 1);
  }

  function openExistingEntry(entry) {
    if (!entry) return;
    const entryType = resolveEntryType(entry);
    if (entryType === 'basic') {
      populateManualForm(entry, true);
    } else {
      state.currentTab = 'punch';
      state.editingEntryType = entryType;
      activateTab('punch');
      if (punchDate) punchDate.value = entry.date;
      ensurePunchDraft(entry.contract_id, entry);
      if (state.punchDraft) {
        state.punchDraft.entryId = entry.id;
        state.punchDraft.contractId = entry.contract_id;
        state.punchDraft.date = entry.date;
        state.punchDraft.punches = clonePunches(entry.punches || []);
        state.punchDraft.dirty = false;
        if (punchHourType && entry.hour_type_id) {
          punchHourType.value = entry.hour_type_id;
          updatePunchContractVisibility();
        }
        renderPunchDraft();
      }
    }
  }

  function checkEntryDuplicateAndLock(payload, editingId) {
    const key = entryCompositeKey(payload.date, payload.hour_type_id, payload.contract_id);
    const duplicate = findDuplicateEntryInState(payload.date, payload.hour_type_id, payload.contract_id, editingId);
    if (duplicate) {
      const hourTypeName = (state.hourTypeMap[payload.hour_type_id] || {}).name || 'Work';
      setStatus(`An entry for ${hourTypeName} already exists on ${payload.date}.`, 'error');
      openExistingEntry(duplicate);
      return { blocked: true };
    }
    const currentId = editingId || payload.id || 'new';
    const existingLock = entrySaveInFlight.get(key);
    if (existingLock && existingLock !== currentId) {
      setStatus('Another save for this date and hour type is in progress. Please wait.', 'warn');
      return { blocked: true };
    }
    entrySaveInFlight.set(key, currentId);
    return { blocked: false, key };
  }

  function releaseEntryLock(key, currentId) {
    if (!key) return;
    const existing = entrySaveInFlight.get(key);
    if (!existing || (currentId && existing !== currentId)) return;
    entrySaveInFlight.delete(key);
  }

  function handleDuplicateConflictResponse(res) {
    if (res && res.error === 'duplicate_entry') {
      setStatus('An entry already exists for this date and hour type.', 'error');
      if (res.entry) {
        openExistingEntry(sanitizeEntry(res.entry));
      }
      return true;
    }
    return false;
  }

  function buildDuplicateCleanupModal() {
    let modal = document.getElementById('duplicate-cleanup-modal');
    if (modal) return modal;
    modal = document.createElement('div');
    modal.id = 'duplicate-cleanup-modal';
    modal.className = 'ts-modal';
    modal.style.display = 'none';
    modal.innerHTML = `
      <div class="ts-modal-content" style="max-width:680px;">
        <div class="ts-modal-header">
          <h3>Resolve duplicate entries</h3>
          <button class="ts-modal-close">&times;</button>
        </div>
        <div class="ts-modal-body">
          <p id="duplicate-cleanup-summary" style="margin-top:0;"></p>
          <div id="duplicate-cleanup-list" class="ts-list" style="max-height:240px; overflow:auto;"></div>
          <p class="ts-note" style="margin-top:12px;">Select the entry to keep. All other entries for this date and hour type will be deleted.</p>
          <p id="duplicate-cleanup-progress" class="ts-note duplicate-cleanup-progress">Deleting duplicates...</p>
        </div>
        <div class="ts-modal-footer">
          <button class="ghost" id="duplicate-cleanup-cancel">Cancel</button>
          <button id="duplicate-cleanup-confirm">Keep selected &amp; delete others</button>
        </div>
      </div>
    `;
    document.body.appendChild(modal);
    const closeBtn = modal.querySelector('.ts-modal-close');
    if (closeBtn) closeBtn.onclick = () => hideModal(modal);
    const cancelBtn = modal.querySelector('#duplicate-cleanup-cancel');
    if (cancelBtn) cancelBtn.onclick = () => hideModal(modal);
    return modal;
  }

  function populateDuplicateCleanupModal(group) {
    const modal = buildDuplicateCleanupModal();
    const summary = modal.querySelector('#duplicate-cleanup-summary');
    const listEl = modal.querySelector('#duplicate-cleanup-list');
    const confirmBtn = modal.querySelector('#duplicate-cleanup-confirm');
    const progressEl = modal.querySelector('#duplicate-cleanup-progress');
    if (!listEl || !confirmBtn || !summary) return null;
    if (!confirmBtn.dataset.defaultText) {
      confirmBtn.dataset.defaultText = confirmBtn.textContent || 'Keep selected & delete others';
    }
    confirmBtn.disabled = false;
    confirmBtn.textContent = confirmBtn.dataset.defaultText;
    confirmBtn.dataset.busy = 'false';
    modal.classList.remove('duplicate-cleanup-busy');
    if (progressEl) progressEl.textContent = 'Deleting duplicates...';
    const sample = group.entries[0] || {};
    const hourType = state.hourTypeMap[sample.hour_type_id || getDefaultHourTypeId()];
    const contractName = sample.contract_id ? (state.contractMap[sample.contract_id]?.name || 'Unknown contract') : 'No contract';
    summary.textContent = `Date: ${sample.date}  Hour type: ${hourType ? hourType.name : 'Default'}  Contract: ${contractName}`;
    listEl.innerHTML = '';
    group.entries.forEach((entry, idx) => {
      const item = document.createElement('label');
      item.className = 'ts-list-item';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.justifyContent = 'space-between';
      item.style.gap = '16px';
      item.innerHTML = `
        <div style="flex:1; display:flex; flex-direction:column; gap:4px;">
          <div style="font-size:16px;"><strong>${entry.duration_minutes || 0} min</strong> <span style="color:var(--muted);">(${entry.entry_type || 'basic'})</span></div>
          <div style="color:var(--muted); font-size:12px;">Created: ${entry.created_at || ''}</div>
          <div style="color:var(--muted); font-size:12px; word-break:break-all;">Id: ${entry.id}</div>
        </div>
        <input type="radio" name="duplicate-keep" value="${entry.id}" ${idx === 0 ? 'checked' : ''} style="width:auto; flex-shrink:0;" />
      `;
      listEl.appendChild(item);
    });
    return { modal, confirmBtn };
  }

  function deleteEntriesById(ids) {
    const results = [];
    const run = (id) => new Promise((resolve) => {
      google.script.run
        .withSuccessHandler(() => resolve({ id, success: true }))
        .withFailureHandler((error) => {
          const message = (error && error.message) ? String(error.message) : String(error || '');
          const notFound = /entry not found/i.test(message);
          if (notFound || (id && String(id).startsWith('temp_'))) {
            resolve({ id, success: true, warning: 'not_found' });
            return;
          }
          resolve({ id, success: false, error });
        })
        .api_deleteEntry(id);
    });
    const seq = async () => {
      for (const id of ids) {
        // Remove locally optimistically; rollback handled by refresh on failure
        const idx = state.entries.findIndex((e) => e.id === id);
        if (idx > -1) {
          const removed = state.entries.splice(idx, 1)[0];
          markIncomeSummaryDirtyForEntry(removed);
        }
        const res = await run(id);
        results.push(res);
      }
      return results;
    };
    return seq();
  }

  function promptDuplicateCleanup(group) {
    const populated = populateDuplicateCleanupModal(group);
    if (!populated) return;
    const { modal, confirmBtn } = populated;
    const listEl = modal.querySelector('#duplicate-cleanup-list');
    const progressEl = modal.querySelector('#duplicate-cleanup-progress');
    const onConfirm = async () => {
      if (!listEl) return;
      if (confirmBtn.dataset.busy === 'true') return;
      const selected = listEl.querySelector('input[name="duplicate-keep"]:checked');
      const keepId = selected ? selected.value : null;
      if (!keepId) {
        setStatus('Select an entry to keep.', 'warn');
        return;
      }
      const toDelete = group.entries.map((e) => e.id).filter((id) => id !== keepId);
      if (!toDelete.length) {
        hideModal(modal);
        return;
      }
      const defaultText = confirmBtn.dataset.defaultText || confirmBtn.textContent || 'Keep selected & delete others';
      confirmBtn.dataset.busy = 'true';
      confirmBtn.disabled = true;
      confirmBtn.textContent = 'Deleting duplicates...';
      modal.classList.add('duplicate-cleanup-busy');
      if (progressEl) progressEl.textContent = 'Deleting duplicates...';
      try {
        setStatus('Deleting duplicate entries...', 'warn');
        const results = await deleteEntriesById(toDelete);
        const failed = results.filter((r) => !r.success);
        if (failed.length) {
          console.error('Failed to delete some duplicates', failed);
          setStatus(`Failed to delete ${failed.length} duplicate(s).`, 'error');
        } else {
          setStatus('Duplicates deleted', 'success');
        }
        saveCache();
        renderEntries();
        renderCalendar();
        hideModal(modal);
      } finally {
        confirmBtn.disabled = false;
        confirmBtn.textContent = defaultText;
        confirmBtn.dataset.busy = 'false';
        modal.classList.remove('duplicate-cleanup-busy');
      }
    };
    confirmBtn.onclick = onConfirm;
    showModal(modal);
  }

  function maybePromptDuplicateCleanup() {
    if (duplicateCleanupPromptShown) return;
    const groups = findDuplicateGroups(state.entries);
    if (!groups.length) return;
    duplicateCleanupPromptShown = true;
    promptDuplicateCleanup(groups[0]);
  }

  function determinePunchFocusTarget(punches) {
    if (!Array.isArray(punches) || !punches.length) {
      return { index: 0, field: 'in' };
    }
    for (let i = 0; i < punches.length; i++) {
      const punch = punches[i] || {};
      if (!punch.in) return { index: i, field: 'in' };
      if (punch.in && !punch.out) return { index: i, field: 'out' };
    }
    return { index: 0, field: 'in' };
  }

  function focusDefaultEntryField() {
    if (entryFieldFocusSuppressed) return;
    if (state.currentTab === 'manual') {
      if (manualHoursInput) queueEntryFieldFocus({ mode: 'manual' });
      return;
    }
    if (state.currentTab === 'punch') {
      const draft = state.punchDraft || {};
      const target = determinePunchFocusTarget(draft.punches || []);
      queueEntryFieldFocus({ mode: 'punch', index: target.index, field: target.field });
    }
  }

  function handleManualHoursEnter(event) {
    if (event.key !== 'Enter') return;
    event.preventDefault();
    if (manualSaveBtn && !manualSaveBtn.disabled) {
      manualSaveBtn.click();
    }
  }

  function handlePunchInputEnter(event) {
    if (event.key !== 'Enter') return;
    event.preventDefault();

    // Force update draft from current input values before saving
    // This prevents race condition where onchange hasn't fired yet
    if (punchList && state.punchDraft) {
      const punchInputs = punchList.querySelectorAll('input.ts-punch-input');
      punchInputs.forEach(input => {
        const index = parseInt(input.dataset.punchIndex, 10);
        const field = input.dataset.punchField;
        if (state.punchDraft.punches[index]) {
          state.punchDraft.punches[index][field] = input.value;
        }
      });
      setPunchDraftDirty();
    }

    if (punchSaveBtn && !punchSaveBtn.disabled) {
      punchSaveBtn.click();
    }
  }

  function updateBasicSaveEnabled() {
    if (!manualSaveBtn) return;

    const hours = Number(manualHoursInput ? manualHoursInput.value : '');
    const validHours = Number.isFinite(hours) && hours > 0;

    // Check if contract is required based on hour type
    let contractValid = true;
    if (manualHourType && manualHourType.value) {
      const selectedHourType = state.hourTypeMap[manualHourType.value];
      if (selectedHourType && selectedHourType.requires_contract) {
        contractValid = !!(manualContract && manualContract.value);
      }
    } else {
      // Default behavior when no hour type selected or feature disabled
      contractValid = !!(manualContract && manualContract.value);
    }

    manualSaveBtn.disabled = !(contractValid && validHours);
  }

  function updateManualContractOptions(preferredContractId) {
    if (!manualContract) return '';
    const dateIso = manualDate && manualDate.value ? manualDate.value : todayIso();
    const valid = validContractsForDate(dateIso);
    const currentValue = preferredContractId != null ? preferredContractId : manualContract.value;
    const options = [...valid];
    if (currentValue && !options.some((contract) => contract.id === currentValue)) {
      const fallback = state.contractMap[currentValue];
      if (fallback) options.push(fallback);
    }
    options.sort((a, b) => a.name.localeCompare(b.name));
    manualContract.innerHTML = '';
    if (!options.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts';
      manualContract.appendChild(placeholder);
      manualContract.value = '';
      manualContract.disabled = true;
      if (manualContractWarning) manualContractWarning.style.display = 'block';
      updateBasicSaveEnabled();
      return '';
    }
    if (options.length > 1) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select contract';
      manualContract.appendChild(placeholder);
    }
    options.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      manualContract.appendChild(opt);
    });
    let selected = currentValue && options.some((contract) => contract.id === currentValue) ? currentValue : '';
    if (!selected && valid.length === 1) {
      selected = valid[0].id;
    }
    manualContract.value = selected;
    manualContract.disabled = valid.length === 1 && options.length === valid.length;
    if (manualContractWarning) manualContractWarning.style.display = manualContract.value ? 'none' : 'block';
    updateBasicSaveEnabled();
    return manualContract.value;
  }

  function refreshContractBindings(preferredManualContractId, preferredPunchContractId) {
    updateContractMap();
    const manualDateIso = manualDate && manualDate.value ? manualDate.value : todayIso();
    const manualPreferred = preferredManualContractId && contractIsValid(state.contractMap[preferredManualContractId], manualDateIso)
      ? preferredManualContractId
      : undefined;
    const punchPreferred = preferredPunchContractId && contractIsValid(state.contractMap[preferredPunchContractId], currentPunchDate())
      ? preferredPunchContractId
      : undefined;
    updateManualContractOptions(manualPreferred);
    ensurePunchDraft(punchPreferred);
    renderContractsUI();
  }

  function setManualDate(dateIso, preferredContractId) {
    if (!manualDate) return;
    manualDate.value = dateIso || todayIso();
    updateManualContractOptions(preferredContractId != null ? preferredContractId : (manualContract ? manualContract.value : ''));
  }

  function setManualMode(isEdit) {
    if (manualSaveBtn) manualSaveBtn.textContent = isEdit ? 'Update Entry' : 'Add Entry';
    if (manualCancelBtn) manualCancelBtn.style.display = isEdit ? 'inline-flex' : 'none';
    if (manualDeleteBtn) manualDeleteBtn.style.display = isEdit ? 'inline-flex' : 'none';
  }

  function populateManualForm(entry, isEdit) {
    showPage('time');
    state.currentTab = 'manual';
    activateTab('manual');
    const preferredDate = entry.date || todayIso();
    const preferredContractId = entry.contract_id || '';
    setManualDate(preferredDate, preferredContractId);
    const punches = entryPunches(entry);
    let totalMinutes = punches.reduce((acc, punch) => {
      const start = timeToMinutes(punch.in);
      const end = timeToMinutes(punch.out);
      if (start === null || end === null || end <= start) return acc;
      return acc + (end - start);
    }, 0);
    if (!totalMinutes && entry.duration_minutes != null) {
      totalMinutes = Number(entry.duration_minutes);
    }
    if (manualHoursInput) {
      const hoursValue = totalMinutes > 0 ? formatDecimalHours(totalMinutes / 60) : '';
      manualHoursInput.value = hoursValue ? hoursValue : '';
    }
    // Set hour type
    if (manualHourType && entry.hour_type_id) {
      manualHourType.value = entry.hour_type_id;
      updateManualContractVisibility();
    }

    state.editingEntryId = isEdit ? entry.id : null;
    state.editingEntryType = isEdit ? (entry.entry_type || 'basic') : null;
    setManualMode(!!isEdit);
    updateBasicSaveEnabled();
    focusDefaultEntryField();
  }

  function clearManualEditing() {
    state.editingEntryId = null;
    state.editingEntryType = null;
    state.currentTab = 'manual';
    setManualMode(false);
    if (manualHoursInput) manualHoursInput.value = '';
    updateManualContractOptions();
    updateBasicSaveEnabled();
    focusDefaultEntryField();
  }

  function getManualPayload() {
    const date = manualDate.value || todayIso();
    if (!date) {
      customAlert('Date is required.');
      return null;
    }
    const hoursRaw = manualHoursInput ? manualHoursInput.value.trim() : '';
    const totalHours = Number(hoursRaw);
    if (!Number.isFinite(totalHours) || totalHours <= 0) {
      customAlert('Enter the total number of hours worked.');
      return null;
    }
    const totalMinutes = Math.round(totalHours * 60);
    if (totalMinutes > 24 * 60) {
      customAlert('Total hours must be within a single day (24 hours or less).');
      return null;
    }
    if (totalMinutes <= 0) {
      customAlert('Total hours must be greater than zero.');
      return null;
    }
    // Get hour type
    const hourTypeId = manualHourType ? manualHourType.value : getDefaultHourTypeId();
    const selectedHourType = state.hourTypeMap[hourTypeId];

    // Validate contract based on hour type
    const contractId = manualContract ? manualContract.value : '';
    if (selectedHourType && selectedHourType.requires_contract) {
      if (!contractId) {
        customAlert('Select a contract for this date.');
        return null;
      }
      const contract = state.contractMap[contractId];
      if (!contract) {
        customAlert('Selected contract is no longer available.');
        return null;
      }
      if (!contractIsValid(contract, date) && !state.editingEntryId) {
        customAlert('Selected contract is not valid for this date.');
        return null;
      }
    }

    const punches = [{ in: '00:00', out: minutesToTime(totalMinutes) }];
    const roundedMinutes = roundDuration(totalMinutes);
    return {
      date,
      punches,
      duration_minutes: roundedMinutes,
      contract_id: contractId,
      hour_type_id: hourTypeId,
      round_interval: getRoundInterval(),
      entry_type: 'basic'
    };
  }

  manualSaveBtn.onclick = function () {
    const payload = getManualPayload();
    if (!payload) return;
    const lockResult = checkEntryDuplicateAndLock(payload, state.editingEntryId);
    if (lockResult.blocked) return;
    const inFlightKey = lockResult.key;
    const inFlightId = state.editingEntryId || payload.id || 'new';
    if (state.editingEntryId) {
      const idx = state.entries.findIndex((e) => e.id === state.editingEntryId);
      if (idx === -1) {
        releaseEntryLock(inFlightKey, inFlightId);
        return;
      }
      const backup = { ...state.entries[idx] };
      const update = { id: state.editingEntryId, ...payload };
      const optimisticUpdate = sanitizeEntry({ ...backup, ...update });
      markIncomeSummaryDirtyForEntry(backup);
      state.entries[idx] = optimisticUpdate;
      markIncomeSummaryDirtyForEntry(optimisticUpdate);
      recordPendingEntryUpdate(state.editingEntryId, optimisticUpdate);
      saveCache();
      renderEntries();
      setStatus('Saving...', 'warn');
      google.script.run
        .withSuccessHandler((res) => {
          if (handleDuplicateConflictResponse(res)) {
            state.entries[idx] = backup;
            markIncomeSummaryDirtyForEntry(backup);
            resolvePendingEntryUpdate(state.editingEntryId);
            saveCache();
            renderEntries();
            releaseEntryLock(inFlightKey, inFlightId);
            return;
          }
          if (res && res.success) {
            const confirmed = sanitizeEntry(res.entry);
            state.entries[idx] = confirmed;
            markIncomeSummaryDirtyForEntry(confirmed);
            recordPendingEntryUpdate(confirmed.id, confirmed);
            if (!entriesSyncInFlight) resolvePendingEntryUpdate(confirmed.id);
            state.entries.sort(entrySort);
            clearManualEditing();
            saveCache();
            renderEntries();
            ensurePunchDraft(payload.contract_id);
            setStatus('Saved', 'success');
          } else {
            state.entries[idx] = backup;
            markIncomeSummaryDirtyForEntry(backup);
            resolvePendingEntryUpdate(state.editingEntryId);
            saveCache();
            renderEntries();
            setStatus('Save failed', 'error');
          }
          releaseEntryLock(inFlightKey, inFlightId);
        })
        .withFailureHandler(() => {
          state.entries[idx] = backup;
          markIncomeSummaryDirtyForEntry(backup);
          resolvePendingEntryUpdate(state.editingEntryId);
          saveCache();
          renderEntries();
          setStatus('Save failed', 'error');
          releaseEntryLock(inFlightKey, inFlightId);
        })
        .api_updateEntry(update);
    } else {
      const now = new Date();
      const entry = {
        id: 'temp_' + Date.now(),
        ...payload,
        created_at: isoDateTime(now)
      };
      const optimisticEntry = sanitizeEntry(entry);
      state.entries.unshift(optimisticEntry);
      markIncomeSummaryDirtyForEntry(optimisticEntry);
      recordPendingEntryAdd(optimisticEntry);
      state.entries.sort(entrySort);
      saveCache();
      renderEntries();
      clearManualEditing();
      setStatus('Saving...', 'warn');
      google.script.run
        .withSuccessHandler((res) => {
          if (handleDuplicateConflictResponse(res)) {
            resolvePendingEntryAdd(optimisticEntry.id);
            // Remove optimistic entry since it conflicts
            const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
            if (idx > -1) {
              state.entries.splice(idx, 1);
              saveCache();
              renderEntries();
            }
            releaseEntryLock(inFlightKey, inFlightId);
            return;
          }
          if (res && res.success) {
            const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
            if (idx > -1) {
              const confirmed = sanitizeEntry(res.entry);
              state.entries[idx] = confirmed;
              markIncomeSummaryDirtyForEntry(confirmed);
              updatePendingEntryAddId(optimisticEntry.id, confirmed);
              if (!entriesSyncInFlight) resolvePendingEntryAdd(confirmed.id);
              state.entries.sort(entrySort);
            }
            saveCache();
            renderEntries();
            ensurePunchDraft(payload.contract_id);
            setStatus('Saved', 'success');
          } else {
            resolvePendingEntryAdd(optimisticEntry.id);
            setStatus('Save failed', 'error');
            const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
            if (idx > -1) {
              state.entries.splice(idx, 1);
              saveCache();
              renderEntries();
            }
          }
          releaseEntryLock(inFlightKey, inFlightId);
        })
        .withFailureHandler(() => {
          resolvePendingEntryAdd(optimisticEntry.id);
          markIncomeSummaryDirtyForEntry(optimisticEntry);
          setStatus('Save failed (offline?)', 'error');
          const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
          if (idx > -1) {
            state.entries.splice(idx, 1);
            saveCache();
            renderEntries();
          }
          releaseEntryLock(inFlightKey, inFlightId);
        })
        .api_addEntry(entry);
    }
    state.selectedCalendarDate = payload.date;
    setManualDate(state.selectedCalendarDate, payload.contract_id);
    renderCalendar();
  };
  manualCancelBtn.onclick = function () {
    clearManualEditing();
    activateTab('manual');
  };

  if (manualDeleteBtn) {
    manualDeleteBtn.onclick = async function () {
      if (!state.editingEntryId) return;

      const confirmed = await customConfirm(
        'Are you sure you want to delete this entry? This action cannot be undone.',
        { danger: true }
      );
      if (!confirmed) return;

      const entryId = state.editingEntryId;
      const currentDate = manualDate ? manualDate.value : todayIso();

      // Optimistic delete: Remove from local state immediately
      const idx = state.entries.findIndex(e => e.id === entryId);
      if (idx === -1) {
        // If it's already gone locally, skip server delete
        resolvePendingEntryDelete(entryId);
        setStatus('Entry already removed', 'success');
        return;
      }

      const backup = state.entries[idx];
      state.entries.splice(idx, 1);
      markIncomeSummaryDirtyForEntry(backup);
      recordPendingEntryDelete(entryId);

      // Clear editing state and reset form
      clearManualEditing();
      setManualDate(currentDate);

      saveCache();
      renderEntries();
      updateTabStates();
      setStatus('Deleting entry...', 'warn');

      google.script.run
        .withSuccessHandler(() => {
          if (!entriesSyncInFlight) resolvePendingEntryDelete(entryId);
          setStatus('Entry deleted', 'success');
        })
        .withFailureHandler((error) => {
          console.error('Failed to delete manual entry', { entryId, error });
          const message = (error && error.message) ? String(error.message) : String(error || '');
          const notFound = /entry not found/i.test(message);
          if (notFound || entryId.startsWith('temp_')) {
            resolvePendingEntryDelete(entryId);
            setStatus('Entry already removed', 'success');
            saveCache();
            renderEntries();
            updateTabStates();
            return;
          }
          // Rollback: restore the entry
          state.entries.splice(idx, 0, backup);
          markIncomeSummaryDirtyForEntry(backup);
          resolvePendingEntryDelete(entryId);
          saveCache();
          renderEntries();
          updateTabStates();
          setStatus('Delete failed', 'error');
        })
        .api_deleteEntry(entryId);
    };
  }

  if (manualDate) {
    manualDate.addEventListener('change', () => {
      const newDate = manualDate.value;
      const oldDate = state.selectedCalendarDate;
      
      // If we're editing an entry and the date changed, assume changes were discarded
      if (state.editingEntryId && newDate !== oldDate) {
        clearManualEditing();
        state.selectedCalendarDate = newDate;
        setManualDate(newDate);
        updateManualContractOptions();
        renderCalendar();
        return;
      }
      
      state.selectedCalendarDate = newDate;
      updateManualContractOptions();
      renderCalendar();
    });
  }

  if (manualContract) {
    manualContract.addEventListener('change', updateBasicSaveEnabled);
  }

  if (manualHoursInput) {
    manualHoursInput.addEventListener('input', updateBasicSaveEnabled);
    manualHoursInput.addEventListener('keydown', handleManualHoursEnter);
  }

  // Recurring entry events
 if (recurringManageBtn) {
   recurringManageBtn.addEventListener('click', () => {
     const draft = state.recurringEntryForm.draft || defaultRecurringDraft();
     setRecurringFormDraft(draft);
     openRecurringModal();
   });
 }
 if (recurringNewBtn) {
   recurringNewBtn.addEventListener('click', () => {
     setRecurringFormDraft(defaultRecurringDraft());
   });
 }
  if (recurringCancelBtn) {
    recurringCancelBtn.addEventListener('click', () => closeRecurringModal());
  }
  if (recurringSaveBtn) {
    recurringSaveBtn.addEventListener('click', handleRecurringSave);
  }
  if (recurringDeleteBtn) {
    recurringDeleteBtn.addEventListener('click', () => toggleRecurringDeleteConfirm(true));
  }
  if (recurringDeleteCancelBtn) {
    recurringDeleteCancelBtn.addEventListener('click', () => toggleRecurringDeleteConfirm(false));
  }
  if (recurringDeleteConfirmBtn) {
    recurringDeleteConfirmBtn.addEventListener('click', handleRecurringDelete);
  }
  if (recurringFrequencySelect) {
    recurringFrequencySelect.addEventListener('change', () => {
      updateRecurringFrequencyVisibility();
      updateRecurringFormFromInputs();
    });
  }
  [
    recurringNameInput,
    recurringHoursInput,
    recurringContractSelect,
    recurringHourTypeSelect,
    recurringStartDateInput,
    recurringEndDateInput,
    recurringWeeklyIntervalInput,
    recurringMonthlyIntervalInput,
    recurringMonthlyDayInput,
    recurringMonthlyWeekSelect,
    recurringMonthlyWeekdaySelect
  ].forEach((input) => {
    if (!input) return;
    const eventName = input === recurringHoursInput ? 'input' : 'change';
    input.addEventListener(eventName, updateRecurringFormFromInputs);
  });
  if (recurringMonthlyModeSelect) {
    recurringMonthlyModeSelect.addEventListener('change', () => {
      updateRecurringMonthlyModeVisibility();
      updateRecurringFormFromInputs();
    });
  }

  if (bulkHoursModeSelect) {
    bulkHoursModeSelect.addEventListener('change', () => {
      const draft = state.bulkEntryForm.draft || defaultBulkDraft();
      const mode = bulkHoursModeSelect.value || 'daily';
      draft.distribution_mode = mode;
      if (mode === 'monthly') {
        draft.monthly_total_minutes = BULK_DEFAULT_MONTHLY_MINUTES;
        draft.duration_minutes = 0;
        if (bulkHoursInput) bulkHoursInput.value = formatDecimalHours(BULK_DEFAULT_MONTHLY_HOURS);
        const defaultMonth = getDefaultBulkMonthValue(draft);
        applyBulkMonthSelection(defaultMonth, true);
      } else {
        draft.duration_minutes = BULK_DEFAULT_DAILY_MINUTES;
        draft.monthly_total_minutes = 0;
        if (bulkHoursInput) bulkHoursInput.value = formatDecimalHours(BULK_DEFAULT_DAILY_HOURS);
      }
      updateBulkDistributionUI(draft);
    });
  }
  if (bulkMonthPrevBtn) {
    bulkMonthPrevBtn.addEventListener('click', () => {
      bulkMonthPickerState.year -= 1;
      renderBulkMonthPicker(bulkMonthInput ? bulkMonthInput.value : '');
    });
  }
  if (bulkMonthNextBtn) {
    bulkMonthNextBtn.addEventListener('click', () => {
      bulkMonthPickerState.year += 1;
      renderBulkMonthPicker(bulkMonthInput ? bulkMonthInput.value : '');
    });
  }
  if (bulkManageBtn) {
    bulkManageBtn.addEventListener('click', () => {
      const draft = state.bulkEntryForm.draft || defaultBulkDraft();
      setBulkFormDraft(draft);
      openBulkModal();
    });
  }
  if (bulkNewBtn) {
    bulkNewBtn.addEventListener('click', () => {
      setBulkFormDraft(defaultBulkDraft());
    });
  }
  if (bulkStartDateInput) {
    bulkStartDateInput.addEventListener('change', () => {
      handleBulkRangeChange();
    });
  }
  if (bulkEndDateInput) {
    bulkEndDateInput.addEventListener('change', () => {
      handleBulkRangeChange();
    });
  }
  if (bulkCancelBtn) {
    bulkCancelBtn.addEventListener('click', () => closeBulkModal());
  }
  if (bulkSaveBtn) {
    bulkSaveBtn.addEventListener('click', handleBulkSave);
  }
  if (bulkDeleteBtn) {
    bulkDeleteBtn.addEventListener('click', () => toggleBulkDeleteConfirm(true));
  }
  if (bulkDeleteCancelBtn) {
    bulkDeleteCancelBtn.addEventListener('click', () => toggleBulkDeleteConfirm(false));
  }
  if (bulkDeleteConfirmBtn) {
    bulkDeleteConfirmBtn.addEventListener('click', handleBulkDelete);
  }
  if (bulkMonthInput) {
    bulkMonthInput.addEventListener('change', () => {
      applyBulkMonthSelection(bulkMonthInput.value, true);
    });
  }
  if (bulkContractSelect) {
    bulkContractSelect.addEventListener('change', () => {
      if (state.bulkEntryForm.draft) {
        state.bulkEntryForm.draft.contract_id = bulkContractSelect.value || '';
      }
      evaluateBulkContractWarning();
    });
  }

  if (manualHourType) {
    manualHourType.addEventListener('change', updateBasicSaveEnabled);
  }

  if (manualHoursInput) manualHoursInput.value = '';
  updateBasicSaveEnabled();
  setManualDate(todayIso());
  focusDefaultEntryField();

  const incomeNetBadge = document.getElementById('calendar-net-income');
  const incomeToggleBtn = incomeNetBadge;
  const incomeBreakdownEl = document.getElementById('income-breakdown');
  const incomeInvoiceTotalRow = document.getElementById('income-invoice-total-row');
  const incomeInvoiceTotalEl = document.getElementById('income-invoice-total');
  const incomeCompanyIncomeRow = document.getElementById('income-company-income-row');
  const incomeCompanyIncomeEl = document.getElementById('income-company-income');
  const incomeCompanyExpensesRow = document.getElementById('income-company-expenses-row');
  const incomeCompanyExpensesEl = document.getElementById('income-company-expenses');
  const incomeGrossEl = document.getElementById('income-gross');
  const incomeSuperGuaranteeEl = document.getElementById('income-super-guarantee');
  const incomeSuperLostRow = document.getElementById('income-super-lost-row');
  const incomeSuperLostEl = document.getElementById('income-super-lost');
  const incomeExtraSuperEl = document.getElementById('income-extra-super');
  const incomeSuperTotalEl = document.getElementById('income-super-total');
  const incomeOtherDeductionsEl = document.getElementById('income-other-deductions');
  const incomeTaxableEl = document.getElementById('income-taxable');
  const incomeTaxEl = document.getElementById('income-tax');
  const incomeNetDetailEl = document.getElementById('income-net');
  const incomeActualGrossValueEl = document.getElementById('income-actual-gross-value');
  const incomeActualSuperValueEl = document.getElementById('income-actual-super-value');
  const incomeActualTaxValueEl = document.getElementById('income-actual-tax-value');
  const incomeActualNetValueEl = document.getElementById('income-actual-net-value');
  const potentialNetDivider = document.getElementById('potential-net-divider');
  const incomeProjectionsHeader = document.getElementById('income-projections-header');
  const incomePotentialNetRow = document.getElementById('income-potential-net-row');
  const incomeEstimatedStandardRow = document.getElementById('income-estimated-standard-row');
  const incomeEstimatedProjectedRow = document.getElementById('income-estimated-projected-row');
  const incomePotentialNetEl = document.getElementById('income-potential-net');
  const incomeEstimatedStandardNetEl = document.getElementById('income-estimated-standard-net');
  const incomeEstimatedProjectedNetEl = document.getElementById('income-estimated-projected-net');
  const incomeEstimatedStandardInfo = document.getElementById('income-estimated-standard-info');
  const incomeEstimatedProjectedInfo = document.getElementById('income-estimated-projected-info');
  const btnCompanyExpensesDetails = document.getElementById('btn-company-expenses-details');
  const btnDeductionsDetails = document.getElementById('btn-deductions-details');
  const modalMonthlyDeductions = document.getElementById('modal-monthly-deductions');
  const monthlyDeductionsTitle = document.getElementById('monthly-deductions-title');
  const monthlyDeductionsContent = document.getElementById('monthly-deductions-content');
  const btnCloseMonthlyDeductions = document.getElementById('btn-close-monthly-deductions');
  const modalAdjustOccurrence = document.getElementById('modal-adjust-occurrence');
  const adjustDeductionName = document.getElementById('adjust-deduction-name');
  const adjustOriginalDate = document.getElementById('adjust-original-date');
  const adjustOriginalAmount = document.getElementById('adjust-original-amount');
  const adjustNewDate = document.getElementById('adjust-new-date');
  const adjustNewAmount = document.getElementById('adjust-new-amount');
  const adjustNotes = document.getElementById('adjust-notes');
  const btnCancelAdjust = document.getElementById('btn-cancel-adjust');
  const btnSaveException = document.getElementById('btn-save-exception');
  const btnDeleteException = document.getElementById('btn-delete-exception');
  let adjustingDeduction = null;
  let adjustingOriginalDate = null;
  let adjustingType = null;
  let incomeBreakdownExpanded = false;
  if (incomeToggleBtn) {
    incomeToggleBtn.addEventListener('click', () => {
      incomeBreakdownExpanded = !incomeBreakdownExpanded;
      applyIncomeBreakdownVisibility();
    });
  }
  applyIncomeBreakdownVisibility();

  // Hour types breakdown toggle
  const hourTypesToggleBtn = document.getElementById('calendar-month-total');
  const hourTypesBreakdownEl = document.getElementById('hour-types-breakdown');
  const hourTypesBreakdownListEl = document.getElementById('hour-types-breakdown-list');
  let hourTypesBreakdownExpanded = false;

  function applyHourTypesBreakdownVisibility() {
    if (!hourTypesBreakdownEl || !hourTypesToggleBtn) return;

    if (hourTypesBreakdownExpanded) {
      hourTypesBreakdownEl.hidden = false;
      hourTypesToggleBtn.setAttribute('data-expanded', 'true');
      hourTypesToggleBtn.setAttribute('aria-expanded', 'true');
    } else {
      hourTypesBreakdownEl.hidden = true;
      hourTypesToggleBtn.setAttribute('data-expanded', 'false');
      hourTypesToggleBtn.setAttribute('aria-expanded', 'false');
    }
  }

  if (hourTypesToggleBtn) {
    hourTypesToggleBtn.addEventListener('click', () => {
      hourTypesBreakdownExpanded = !hourTypesBreakdownExpanded;
      applyHourTypesBreakdownVisibility();
    });
  }
  applyHourTypesBreakdownVisibility();

  const expectedHoursBadge = document.getElementById('calendar-expected-hours');
  const expectedHoursBreakdownEl = document.getElementById('expected-hours-breakdown');
  const expectedHoursContentEl = document.getElementById('expected-hours-content');
  let expectedHoursExpanded = false;

  function applyExpectedHoursVisibility() {
    if (!expectedHoursBadge || !expectedHoursBreakdownEl) return;
    expectedHoursBadge.setAttribute('data-expanded', expectedHoursExpanded ? 'true' : 'false');
    expectedHoursBadge.setAttribute('aria-expanded', expectedHoursExpanded ? 'true' : 'false');
    expectedHoursBreakdownEl.hidden = !expectedHoursExpanded;
  }

  if (expectedHoursBadge) {
    expectedHoursBadge.addEventListener('click', () => {
      expectedHoursExpanded = !expectedHoursExpanded;
      renderExpectedHoursSummary();
    });
  }
  applyExpectedHoursVisibility();

  const featureFlagCollapseControls = document.getElementById('feature-flag-collapse-controls');
  const btnExpandAllFeatureFlags = document.getElementById('btn-expand-all-feature-flags');
  const btnCollapseAllFeatureFlags = document.getElementById('btn-collapse-all-feature-flags');
  const featureFlagsListEl = document.getElementById('feature-flags-list');
  const settingsSectionControls = document.getElementById('settings-section-collapse-controls');
  const btnExpandAllSettingsSections = document.getElementById('btn-expand-all-settings-sections');
  const btnCollapseAllSettingsSections = document.getElementById('btn-collapse-all-settings-sections');
  const settingsSectionListEl = document.getElementById('settings-section-list');
  const settingsFieldTemplates = document.getElementById('settings-field-templates');
  const settingsFieldBlocks = {};
  if (settingsFieldTemplates) {
    settingsFieldTemplates.querySelectorAll('[data-setting-key]').forEach((node) => {
      const key = node.getAttribute('data-setting-key');
      if (key) {
        settingsFieldBlocks[key] = node;
      }
    });
  }
  const roundInput = document.getElementById('set-round');
  const themeSelect = document.getElementById('set-theme');
  const statusNotificationSelect = document.getElementById('set-status-notifications');
  const paygRateInput = document.getElementById('set-payg-rate');
  const publicHolidayStateSelect = document.getElementById('set-public-holiday-state');
  const minimumEndTimeInput = document.getElementById('set-minimum-end-time');
  const monthlyInsightsTrendMethodSelect = document.getElementById('set-monthly-insights-trend-method');
  const projectionsVarianceValueSelect = document.getElementById('set-projections-variance-value');
  const lostSuperRecoveryModeSelect = document.getElementById('set-lost-super-recovery-mode');
  const saveSettingsBtn = document.getElementById('btn-save-settings');
  const discardSettingsBtn = document.getElementById('btn-discard-settings');
  if (btnExpandAllFeatureFlags) {
    btnExpandAllFeatureFlags.addEventListener('click', () => setAllFeatureFlagCollapse(false));
  }
  if (btnCollapseAllFeatureFlags) {
    btnCollapseAllFeatureFlags.addEventListener('click', () => setAllFeatureFlagCollapse(true));
  }
  if (btnExpandAllSettingsSections) {
    btnExpandAllSettingsSections.addEventListener('click', () => setAllSettingsSectionCollapse(false));
  }
  if (btnCollapseAllSettingsSections) {
    btnCollapseAllSettingsSections.addEventListener('click', () => setAllSettingsSectionCollapse(true));
  }
  if (statusNotificationSelect) {
    statusNotificationSelect.addEventListener('change', applyStatusDisplay);
  }

  const contractNameInput = document.getElementById('contract-name');
  const contractStartInput = document.getElementById('contract-start');
  const contractEndInput = document.getElementById('contract-end');
  const contractRateInput = document.getElementById('contract-rate');
  const contractTotalHoursInput = document.getElementById('contract-total-hours');
  const contractStandardHoursInput = document.getElementById('contract-standard-hours');
  const contractIncludeWeekendsRow = document.getElementById('contract-weekends-row');
  const contractIncludeWeekendsInput = document.getElementById('contract-include-weekends');
  const contractSaveBtn = document.getElementById('contract-save');
  const contractCancelBtn = document.getElementById('contract-cancel');
  const contractAddToggle = document.getElementById('contract-toggle-add');
  const contractFormContainer = document.getElementById('contract-form-container');
  const contractSelector = document.getElementById('contract-selector');
  const contractDetailEl = document.getElementById('contract-detail');
  const contractBurndownEl = document.getElementById('contract-burndown');
  const contractHoursBreakdownEl = document.getElementById('contract-hours-breakdown');
  const contractUnlimitedNote = document.getElementById('contract-unlimited-note');
  const contractFormDefaultParent = contractFormContainer ? contractFormContainer.parentElement : null;
  const contractFormPlaceholder = contractFormContainer && contractFormDefaultParent
    ? (function () {
        const placeholder = document.createComment('contract-form-home');
        contractFormDefaultParent.insertBefore(placeholder, contractFormContainer.nextSibling);
        return placeholder;
      })()
    : null;
  const contractTemplatesSection = document.getElementById('contract-line-item-templates-section');
  const contractTemplateList = document.getElementById('contract-template-list');
  const contractTemplateEmpty = document.getElementById('contract-template-empty');
  const contractTemplateForm = document.getElementById('contract-template-form');
  const contractTemplateLabelInput = document.getElementById('contract-template-label');
  const contractTemplateDescriptionInput = document.getElementById('contract-template-description');
  const contractTemplateAmountInput = document.getElementById('contract-template-amount');
  const btnContractTemplateNew = document.getElementById('btn-contract-template-new');
  const btnContractTemplateCancel = document.getElementById('btn-contract-template-cancel');
  const btnContractTemplateSave = document.getElementById('btn-contract-template-save');
  const clearCacheWrapper = document.getElementById('clear-cache-wrapper');
  const clearCacheBtn = document.getElementById('btn-clear-cache');
  const payrollXeroBtn = document.getElementById('calendar-xero-helper');
  const payrollMyobBtn = document.getElementById('calendar-myob-helper');
  const xeroHelperModal = document.getElementById('modal-xero-helper');
  const myobHelperModal = document.getElementById('modal-myob-helper');
  const xeroHelperContent = document.getElementById('xero-helper-content');
  const myobHelperContent = document.getElementById('myob-helper-content');
  const actualIncomeBtn = document.getElementById('calendar-actual-income-btn');
  const actualIncomeModal = document.getElementById('modal-actual-income');
  const actualIncomeTitle = document.getElementById('actual-income-title');
  const actualIncomeMonthInput = document.getElementById('actual-income-month');
  const actualIncomeMonthDisplay = document.getElementById('actual-income-month-display');
  const actualIncomeGrossInput = document.getElementById('actual-income-gross');
  const actualIncomeSuperInput = document.getElementById('actual-income-super');
  const actualIncomeTaxInput = document.getElementById('actual-income-tax');
  const actualIncomeNetInput = document.getElementById('actual-income-net');
  const btnSaveActualIncome = document.getElementById('btn-save-actual-income');
  const btnCancelActualIncome = document.getElementById('btn-cancel-actual-income');
  const btnDeleteActualIncome = document.getElementById('btn-delete-actual-income');
  const printMonthlyBtn = document.getElementById('calendar-print-monthly-btn');
  const printViewConfigModal = document.getElementById('modal-print-view-config');
  const printViewIncomeList = document.getElementById('print-view-income-list');
  const printViewOtherList = document.getElementById('print-view-other-list');
  const printViewWarning = document.getElementById('print-view-warning');
  const printViewWarningText = document.getElementById('print-view-warning-text');
  const btnCancelPrintView = document.getElementById('btn-cancel-print-view');
  const btnGeneratePrintView = document.getElementById('btn-generate-print-view');
  const btnUnselectAllOther = document.getElementById('btn-unselect-all-other');
  const timesheet1Btn = document.getElementById('btn-timesheet1-importer');
  const timesheet1Modal = document.getElementById('modal-timesheet1-importer');
  const timesheet1FileInput = document.getElementById('timesheet1-file-id');
  const timesheet1Status = document.getElementById('timesheet1-status');
  const timesheet1PreviewBtn = document.getElementById('btn-timesheet1-preview');
  const timesheet1RunBtn = document.getElementById('btn-timesheet1-run');
  const timesheet1CancelBtn = document.getElementById('btn-timesheet1-cancel');
  const timesheet1SkipHolidaysToggle = document.getElementById('timesheet1-skip-holidays');
  const timesheet1MappingSection = document.getElementById('timesheet1-mapping-section');
  const timesheet1MappingList = document.getElementById('timesheet1-mapping-list');
  const timesheet1ContractSection = document.getElementById('timesheet1-contract-section');
  const timesheet1ContractList = document.getElementById('timesheet1-contract-list');
  const timesheet1PreviewSection = document.getElementById('timesheet1-preview-section');
  const timesheet1PreviewSummary = document.getElementById('timesheet1-preview-summary');
  const timesheet1ImportSummary = document.getElementById('timesheet1-import-summary');

  const DECIMAL_HOURS_FORMATTER = new Intl.NumberFormat(undefined, {
    minimumFractionDigits: 0,
    maximumFractionDigits: 2
  });
  const MONTH_DAY_FORMATTER = new Intl.DateTimeFormat(undefined, {
    month: 'short',
    day: 'numeric'
  });
  const DATE_FULL_FORMATTER = new Intl.DateTimeFormat(undefined, {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
  const MONTH_YEAR_FORMATTER = new Intl.DateTimeFormat(undefined, {
    month: 'short',
    year: 'numeric'
  });
  const FINANCIAL_YEAR_START_MONTH = 6; // July (0-indexed)
  const MONTH_ORDER = ['january','february','march','april','may','june','july','august','september','october','november','december'];
  let timesheet1State = {
    mapping: {},
    contractSelections: {},
    preview: null,
    skipPublicHolidays: true
  };

  function financialYearLabel(startYear) {
    const endYear = startYear + 1;
    return `FY ${startYear}-${String(endYear).slice(-2)}`;
  }

  function financialYearStartYear(date) {
    if (!(date instanceof Date) || Number.isNaN(date.getTime())) return new Date().getFullYear();
    return date.getMonth() >= FINANCIAL_YEAR_START_MONTH ? date.getFullYear() : date.getFullYear() - 1;
  }

  function getFinancialYearMonths(startYear) {
    const months = [];
    for (let i = 0; i < 12; i += 1) {
      const monthIndex = (FINANCIAL_YEAR_START_MONTH + i) % 12;
      const yearOffset = Math.floor((FINANCIAL_YEAR_START_MONTH + i) / 12);
      months.push({ year: startYear + yearOffset, month: monthIndex });
    }
    return months;
  }

  function getCalendarYearMonths(year) {
    const months = [];
    for (let month = 0; month < 12; month += 1) {
      months.push({ year, month });
    }
    return months;
  }

  function startOfFinancialYear(startYear) {
    return startOfDay(new Date(startYear, FINANCIAL_YEAR_START_MONTH, 1));
  }
  const WEEKDAY_FORMATTER = new Intl.DateTimeFormat(undefined, {
    weekday: 'short'
  });

  function formatDecimalHours(value) {
    return DECIMAL_HOURS_FORMATTER.format(Math.max(0, Math.round((Number(value) || 0) * 100) / 100));
  }

  function formatSignedHours(value) {
    const num = Math.round((Number(value) || 0) * 100) / 100;
    if (num === 0) return '0';
    const prefix = num > 0 ? '+' : '-';
    return prefix + DECIMAL_HOURS_FORMATTER.format(Math.abs(num));
  }

  function resetContractFormFields() {
    if (contractNameInput) contractNameInput.value = '';
    if (contractStartInput) contractStartInput.value = '';
    if (contractEndInput) contractEndInput.value = '';
    if (contractRateInput) contractRateInput.value = '';
    if (contractTotalHoursInput) contractTotalHoursInput.value = '';
    if (contractIncludeWeekendsInput) contractIncludeWeekendsInput.checked = false;
  }

  function placeContractFormAtDefault() {
    if (!contractFormContainer || !contractFormPlaceholder || !contractFormPlaceholder.parentNode) return;
    if (contractFormContainer.parentElement !== contractFormPlaceholder.parentNode) {
      contractFormPlaceholder.parentNode.insertBefore(contractFormContainer, contractFormPlaceholder);
    }
  }

  function placeContractFormInDetail() {
    if (!contractFormContainer || !contractDetailEl) return;
    if (contractFormContainer.parentElement !== contractDetailEl) {
      contractDetailEl.appendChild(contractFormContainer);
    }
  }

  function setContractFormMode(mode) {
    state.contractFormMode = mode;
    const visible = mode === 'create' || mode === 'edit';
    if (contractFormContainer) contractFormContainer.style.display = visible ? 'block' : 'none';
    if (contractSaveBtn) contractSaveBtn.textContent = mode === 'edit' ? 'Save Changes' : 'Save';
    if (contractCancelBtn) contractCancelBtn.style.display = visible ? 'inline-flex' : 'none';
    updateContractTemplatesSectionVisibility();
  }

  function showContractForm(mode) {
    if (mode === 'create') {
      state.editingContractId = null;
      state.contractDraft = {};
      resetContractFormFields();
      placeContractFormInDetail();
      if (contractAddToggle) contractAddToggle.textContent = 'Close';
    }
    state.contractTemplateForm = { mode: 'hidden', editingIndex: null, draft: {} };
    renderContractTemplateList();
    renderContractTemplateForm();
    updateContractTemplatesSectionVisibility();
    setContractFormMode(mode);
    if (mode === 'create' && contractNameInput) contractNameInput.focus();
    renderContractDetail();
  }

  function hideContractForm() {
    resetContractFormFields();
    state.editingContractId = null;
    setContractFormMode('hidden');
    placeContractFormAtDefault();
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
  }

  function getContractFormPayload() {
    const name = contractNameInput ? contractNameInput.value.trim() : '';
    const startDate = contractStartInput ? contractStartInput.value : '';
    const endDate = contractEndInput ? contractEndInput.value : '';
    const hourlyRateRaw = contractRateInput ? contractRateInput.value : '';
    const hourlyRate = Number(hourlyRateRaw || 0);
    const totalHoursRaw = contractTotalHoursInput ? contractTotalHoursInput.value : '';
    const totalHoursValue = totalHoursRaw === '' ? 0 : Number(totalHoursRaw);
    if (!name) {
      customAlert('Contract name is required.');
      return null;
    }
    if (!startDate) {
      customAlert('Contract start date is required.');
      return null;
    }
    if (endDate && endDate < startDate) {
      customAlert('End date must be on or after the start date.');
      return null;
    }
    if (hourlyRate < 0) {
      customAlert('Hourly rate must be zero or greater.');
      return null;
    }
    if (Number.isNaN(totalHoursValue) || totalHoursValue < 0) {
      customAlert('Total hours must be zero or greater.');
      return null;
    }
    const totalHours = Math.round(Number(totalHoursValue || 0) * 100) / 100;
    const standardHoursRaw = contractStandardHoursInput ? contractStandardHoursInput.value : '';
    const standardHoursValue = standardHoursRaw === '' ? 7.5 : Number(standardHoursRaw);
    const standardHours = standardHoursValue > 0 ? Math.round(standardHoursValue * 10) / 10 : 7.5;
    const includeWeekends = contractIncludeWeekendsInput ? contractIncludeWeekendsInput.checked : false;
    const contract = getEditingContract();
    const lineItemTemplatesJson = contract ? (contract.line_item_templates_json || '') : '';
    return {
      name,
      start_date: startDate,
      end_date: endDate,
      hourly_rate: Math.round(hourlyRate * 100) / 100,
      total_hours: totalHours,
      standard_hours_per_day: standardHours,
      include_weekends: includeWeekends,
      line_item_templates_json: lineItemTemplatesJson
    };
  }

  function populateContractForm(contract) {
    state.editingContractId = contract.id;
    if (contractNameInput) contractNameInput.value = contract.name || '';
    if (contractStartInput) contractStartInput.value = contract.start_date || '';
    if (contractEndInput) contractEndInput.value = contract.end_date || '';
    if (contractRateInput) contractRateInput.value = contract.hourly_rate != null ? Number(contract.hourly_rate).toFixed(2) : '';
    if (contractTotalHoursInput) {
      const totalHours = Number(contract.total_hours || 0);
      contractTotalHoursInput.value = totalHours > 0 ? String(totalHours) : '';
    }
    if (contractStandardHoursInput) {
      const standardHours = Number(contract.standard_hours_per_day || 7.5);
      contractStandardHoursInput.value = String(standardHours);
    }
    if (contractIncludeWeekendsInput) contractIncludeWeekendsInput.checked = !!contract.include_weekends;
    state.contractTemplateForm = { mode: 'hidden', editingIndex: null, draft: {} };
    renderContractTemplateList();
    renderContractTemplateForm();
    updateContractTemplatesSectionVisibility();
    placeContractFormInDetail();
    setContractFormMode('edit');
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
    if (contractNameInput) contractNameInput.focus();
    renderContractDetail();
  }

  function getContractById(id) {
    return id ? state.contractMap[id] : undefined;
  }

  function contractEndSortValue(contract) {
    return contract.end_date && contract.end_date !== '' ? contract.end_date : '9999-12-31';
  }

  function renderContractSelectorOptions() {
    if (!contractSelector) return;
    const previousSelection = state.selectedContractId;
    contractSelector.innerHTML = '';
    if (!state.contracts.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts yet';
      contractSelector.appendChild(placeholder);
      contractSelector.disabled = true;
      state.selectedContractId = '';
      return;
    }
    contractSelector.disabled = false;
    const sorted = [...state.contracts].sort((a, b) => {
      const endA = contractEndSortValue(a);
      const endB = contractEndSortValue(b);
      if (endA !== endB) return endB.localeCompare(endA);
      const startA = a.start_date || '';
      const startB = b.start_date || '';
      if (startA !== startB) return startB.localeCompare(startA);
      return a.name.localeCompare(b.name);
    });
    const todayContracts = validContractsForDate(todayIso());
    const soleCurrentContractId = (!state.editingContractId && todayContracts.length === 1)
      ? todayContracts[0].id
      : '';
    if (!state.selectedContractId || !getContractById(state.selectedContractId)) {
      state.selectedContractId = soleCurrentContractId
        || (previousSelection && getContractById(previousSelection) ? previousSelection : '')
        || (sorted.length ? sorted[0].id : '');
    }
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select a contract...';
    contractSelector.appendChild(placeholder);
    sorted.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name || 'Untitled contract';
      contractSelector.appendChild(opt);
    });
    contractSelector.value = state.selectedContractId || '';
  }

  function computeContractUsage(contract) {
    const incomeMonthlyHours = {};
    const nonIncomeMonthlyHours = {};
    const allMonthlyHours = {};
    const hourTypeTotals = {};
    let incomeTotal = 0;
    let allTotal = 0;
    if (contract) {
      state.entries.forEach((entry) => {
        if (entry.contract_id !== contract.id || !entry.date) return;
        const monthKey = entry.date.slice(0, 7);
        const hours = (Number(entry.duration_minutes) || 0) / 60;
        const contributes = entryContributesToIncome(entry);
        const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
        if (!hourTypeTotals[hourTypeId]) {
          const hourType = state.hourTypeMap ? state.hourTypeMap[hourTypeId] : null;
          hourTypeTotals[hourTypeId] = {
            hourTypeId,
            name: hourType ? hourType.name : 'Unknown',
            color: hourType ? (hourType.color || '#94a3b8') : '#94a3b8',
            contributesToIncome: contributes,
            totalHours: 0,
            incomeHours: 0,
            nonIncomeHours: 0,
            monthlyHours: {},
            monthlyIncomeHours: {},
            monthlyNonIncomeHours: {}
          };
        }
        allTotal += hours;
        allMonthlyHours[monthKey] = (allMonthlyHours[monthKey] || 0) + hours;
        if (contributes) {
          incomeTotal += hours;
          incomeMonthlyHours[monthKey] = (incomeMonthlyHours[monthKey] || 0) + hours;
          hourTypeTotals[hourTypeId].incomeHours += hours;
          hourTypeTotals[hourTypeId].monthlyIncomeHours[monthKey] = (hourTypeTotals[hourTypeId].monthlyIncomeHours[monthKey] || 0) + hours;
        } else {
          nonIncomeMonthlyHours[monthKey] = (nonIncomeMonthlyHours[monthKey] || 0) + hours;
          hourTypeTotals[hourTypeId].nonIncomeHours += hours;
          hourTypeTotals[hourTypeId].monthlyNonIncomeHours[monthKey] = (hourTypeTotals[hourTypeId].monthlyNonIncomeHours[monthKey] || 0) + hours;
        }
        hourTypeTotals[hourTypeId].totalHours += hours;
        hourTypeTotals[hourTypeId].monthlyHours[monthKey] = (hourTypeTotals[hourTypeId].monthlyHours[monthKey] || 0) + hours;
      });
    }
    const nonIncomeTotal = Math.max(0, allTotal - incomeTotal);
    const hourTypes = Object.keys(hourTypeTotals).reduce((acc, key) => {
      const ht = hourTypeTotals[key];
      const hourType = state.hourTypeMap ? state.hourTypeMap[key] : null;
      acc[key] = {
        ...ht,
        name: hourType ? hourType.name : ht.name,
        color: hourType && hourType.color ? hourType.color : ht.color,
        contributesToIncome: hourType && Object.prototype.hasOwnProperty.call(hourType, 'contributes_to_income')
          ? !!hourType.contributes_to_income
          : ht.contributesToIncome
      };
      return acc;
    }, {});
    return {
      totalHours: incomeTotal,
      monthlyHours: incomeMonthlyHours,
      breakdown: {
        income: { totalHours: incomeTotal, monthlyHours: incomeMonthlyHours },
        nonIncome: { totalHours: nonIncomeTotal, monthlyHours: nonIncomeMonthlyHours },
        all: { totalHours: allTotal, monthlyHours: allMonthlyHours },
        hourTypes
      }
    };
  }

  function contractMonthRange(contract) {
    if (!contract) return [];
    const startDate = contract.start_date ? parseIsoDate(contract.start_date) : parseIsoDate(todayIso());
    if (!startDate || Number.isNaN(startDate.getTime())) return [];
    const start = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
    const today = new Date();
    const endSource = contract.end_date ? parseIsoDate(contract.end_date) : today;
    const effectiveEndDate = (!endSource || Number.isNaN(endSource.getTime())) ? today : endSource;
    const end = new Date(effectiveEndDate.getFullYear(), effectiveEndDate.getMonth(), 1);
    const months = [];
    const cursor = new Date(start.getFullYear(), start.getMonth(), 1);
    if (cursor > end) {
      months.push(new Date(cursor));
      return months;
    }
    while (cursor <= end) {
      months.push(new Date(cursor));
      cursor.setMonth(cursor.getMonth() + 1);
    }
    if (!months.length) months.push(new Date(start));
    return months;
  }

  function renderContractDetail() {
    if (!contractDetailEl) return;
    updatePotentialIncomeSection(state.incomeSummary);
    contractDetailEl.innerHTML = '';
    if (contractHoursBreakdownEl) contractHoursBreakdownEl.innerHTML = '';
    if (state.contractFormMode === 'create') {
      if (contractSelector) contractSelector.value = '';
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (contractAddToggle) contractAddToggle.textContent = 'Close';
      const heading = document.createElement('div');
      heading.className = 'ts-note';
      heading.textContent = 'Creating new contract';
      contractDetailEl.appendChild(heading);
      placeContractFormInDetail();
      return;
    }
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
    if (contractSelector) contractSelector.value = state.selectedContractId || '';
    if (!state.selectedContractId) {
      const note = document.createElement('div');
      note.className = 'ts-note';
      note.textContent = state.contracts.length ? 'Select a contract to see its detail and burndown.' : 'Add a contract to get started.';
      contractDetailEl.appendChild(note);
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (!state.editingContractId) placeContractFormAtDefault();
      return;
    }
    const contract = getContractById(state.selectedContractId);
    if (!contract) {
      state.selectedContractId = '';
      if (contractSelector) contractSelector.value = '';
      renderContractDetail();
      return;
    }
    const isEditing = state.editingContractId === contract.id;
    if (!isEditing) {
      placeContractFormAtDefault();
      if (contractFormContainer && contractFormContainer.style.display === 'block' && !state.editingContractId) {
        // create mode already visible in default location
      }
    }
    const usage = computeContractUsage(contract);
    if (isEditing) {
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      placeContractFormInDetail();
      setContractFormMode('edit');
      const heading = document.createElement('div');
      heading.className = 'ts-note';
      heading.textContent = 'Editing contract';
      contractDetailEl.appendChild(heading);
      contractDetailEl.appendChild(contractFormContainer);
      renderContractBurndown(contract, usage);
      renderContractHoursBreakdown(contract, usage);
      return;
    }

    const grid = document.createElement('div');
    grid.className = 'contract-detail-grid';

    const addDetail = (label, value) => {
      const item = document.createElement('div');
      item.className = 'contract-detail-item';
      const labelEl = document.createElement('div');
      labelEl.className = 'contract-detail-label';
      labelEl.textContent = label;
      const valueEl = document.createElement('div');
      valueEl.className = 'contract-detail-value';
      valueEl.textContent = value || '';
      item.append(labelEl, valueEl);
      grid.appendChild(item);
    };

    const rangeLabel = contract.end_date
      ? `${contract.start_date || ''}  ${contract.end_date}`
      : `${contract.start_date || ''}  Present`;
    const totalHoursValue = Number(contract.total_hours || 0);
    addDetail('Contract name', contract.name || 'Untitled contract');
    addDetail('Date range', rangeLabel);
    addDetail('Hourly rate', `${Number(contract.hourly_rate || 0).toFixed(2)} / hr`);
    addDetail('Total hours', totalHoursValue > 0 ? `${formatDecimalHours(totalHoursValue)} hrs` : 'Unlimited');
    addDetail('Weekends counted', contract.include_weekends ? 'Yes (all days)' : 'No (Mon-Fri)');
    addDetail('Income hours logged', `${formatDecimalHours(usage.totalHours)} hrs`);

    contractDetailEl.appendChild(grid);

    const actions = document.createElement('div');
    actions.className = 'contract-detail-actions';
    const editBtn = document.createElement('button');
    editBtn.textContent = 'Edit';
    editBtn.className = 'ghost';
    editBtn.onclick = () => handleContractEdit(contract.id);
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    deleteBtn.className = 'danger';
    deleteBtn.onclick = () => handleContractDelete(contract.id);
    actions.append(editBtn, deleteBtn);
    contractDetailEl.appendChild(actions);

    renderContractBurndown(contract, usage);
    renderContractHoursBreakdown(contract, usage);
  }

  function renderContractBurndown(contract, usage) {
    if (!contractBurndownEl) return;
    contractBurndownEl.innerHTML = '';
    if (state.contractCharts && state.contractCharts.monthlyHours) {
      state.contractCharts.monthlyHours.destroy();
      state.contractCharts.monthlyHours = null;
    }
    const totalHours = Number(contract.total_hours || 0);
    if (!usage) usage = computeContractUsage(contract);
    if (totalHours <= 0) {
      if (contractUnlimitedNote) {
        contractUnlimitedNote.style.display = 'block';
        contractUnlimitedNote.textContent = `This contract is unlimited. Income-generating hours logged so far: ${formatDecimalHours(usage.totalHours)} hrs. Burndown charts require a total hour cap.`;
      }
      const monthsEntries = Object.keys(usage.monthlyHours).sort();
      if (usage.totalHours > 0 && monthsEntries.length) {
        const heading = document.createElement('div');
        heading.className = 'ts-note';
        heading.textContent = 'Monthly income hours logged';
        contractBurndownEl.appendChild(heading);
        const table = document.createElement('table');
        table.className = 'contract-burndown-table contract-hours-table';
        table.innerHTML = '<thead><tr><th>Month</th><th>Income hours logged</th></tr></thead>';
        const tbody = document.createElement('tbody');
        monthsEntries.forEach((monthKey) => {
          const tr = document.createElement('tr');
          const monthCell = document.createElement('td');
          const parts = monthKey.split('-');
          const dateObj = new Date(Number(parts[0]), Number(parts[1]) - 1, 1);
          monthCell.textContent = formatMonthShortYear(dateObj);
          const valueCell = document.createElement('td');
          valueCell.textContent = `${formatDecimalHours(usage.monthlyHours[monthKey])} hrs`;
          tr.append(monthCell, valueCell);
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        contractBurndownEl.appendChild(table);
      } else {
        const empty = document.createElement('div');
        empty.className = 'contract-burndown-empty';
        empty.textContent = 'No time has been logged for this contract yet.';
        contractBurndownEl.appendChild(empty);
      }
      return;
    }
    if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';

    const months = contractMonthRange(contract);
    if (!months.length) {
      const empty = document.createElement('div');
      empty.className = 'contract-burndown-empty';
      empty.textContent = 'Not enough data to build a burndown chart.';
      contractBurndownEl.appendChild(empty);
      return;
    }

    // Calculate pro-rated months for average burn rate
    const contractStartDate = contract.start_date ? parseIsoDate(contract.start_date) : null;
    const contractEndDate = contract.end_date ? parseIsoDate(contract.end_date) : null;
    const proRatedMonths = (contractStartDate && contractEndDate)
      ? calculateProRatedMonths(contractStartDate, contractEndDate)
      : months.length;
    const avgBurn = proRatedMonths > 0 ? totalHours / proRatedMonths : 0;
    const expectedPoints = [{ label: 'Start', value: totalHours }];
    const actualPathPoints = [{ label: 'Start', value: totalHours }];
    const tableRows = [];
    const today = new Date();
    const todayIsoString = todayIso();
    const contractStarted = !contract.start_date || contract.start_date <= todayIsoString;
    const contractActive = contractStarted && (!contract.end_date || contract.end_date >= todayIsoString);
    const currentMonthKey = monthKeyFor(today.getFullYear(), today.getMonth());
    const currentIdx = months.findIndex((monthDate) => monthKeyFor(monthDate.getFullYear(), monthDate.getMonth()) === currentMonthKey);
    let latestDataIdx = -1;
    months.forEach((monthDate, idx) => {
      const key = monthKeyFor(monthDate.getFullYear(), monthDate.getMonth());
      if ((usage.monthlyHours[key] || 0) > 0) latestDataIdx = idx;
    });
    let actualEndIndex = months.length - 1;
    if (contractActive && currentIdx !== -1) {
      actualEndIndex = Math.max(latestDataIdx, currentIdx);
      if (actualEndIndex < 0) actualEndIndex = currentIdx;
      actualEndIndex = Math.min(actualEndIndex, months.length - 1);
    }
    if (actualEndIndex < 0) actualEndIndex = months.length - 1;

    const monthContributions = months.map((monthDate, idx) => {
      if (idx === currentIdx && contractActive && latestDataIdx <= currentIdx) {
        const daysInMonth = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0).getDate();
        const daysElapsed = Math.min(daysInMonth, Math.max(1, today.getDate()));
        return Math.min(1, daysElapsed / daysInMonth);
      }
      return 1;
    });
    const projectionContributions = monthContributions.map((value, idx) => {
      if (contractActive && idx === currentIdx) return 1;
      return value;
    });

    let actualConsumedForAverage = 0;
    let monthsContributionUsed = 0;
    let cumulativeConsumed = 0;
    months.forEach((monthDate, idx) => {
      const key = monthKeyFor(monthDate.getFullYear(), monthDate.getMonth());
      const expectedRemaining = Math.max(0, totalHours - avgBurn * (idx + 1));
      const hoursThisMonth = usage.monthlyHours[key] || 0;
      cumulativeConsumed += hoursThisMonth;
      const actualRemaining = Math.max(0, totalHours - cumulativeConsumed);
      expectedPoints.push({ label: monthDate, value: expectedRemaining });
      if (idx <= actualEndIndex) {
        actualPathPoints.push({ label: monthDate, value: actualRemaining });
        actualConsumedForAverage += hoursThisMonth;
        monthsContributionUsed += monthContributions[idx];
      }
      tableRows.push({
        monthLabel: formatMonthShortYear(monthDate),
        hoursLogged: hoursThisMonth,
        expectedRemaining,
        actualRemaining
      });
    });

    const avgActualMonthlyBurn = monthsContributionUsed > 0 ? actualConsumedForAverage / monthsContributionUsed : 0;
    const totalContribution = projectionContributions.reduce((sum, value) => sum + value, 0);
    const actualAveragePoints = [{ label: 'Start', value: totalHours }];
    if (avgActualMonthlyBurn > 0) {
      let cumulativeContribution = 0;
      months.forEach((monthDate, idx) => {
        cumulativeContribution += projectionContributions[idx];
        const projectedRemaining = totalHours - avgActualMonthlyBurn * cumulativeContribution;
        actualAveragePoints.push({ label: monthDate, value: projectedRemaining });
      });
    }

    const pointGroups = [expectedPoints, actualPathPoints];
    if (actualAveragePoints.length > 1) pointGroups.push(actualAveragePoints);
    const values = pointGroups.flat().map((p) => p.value);
    const maxValue = Math.max(totalHours, ...values, 0);
    const minValue = Math.min(0, ...values);
    const containerRect = contractBurndownEl.getBoundingClientRect();
    const detailRect = contractDetailEl ? contractDetailEl.getBoundingClientRect() : null;
    const measuredWidth = containerRect.width || (detailRect && detailRect.width) || 720;
    const width = Math.max(480, Math.floor(measuredWidth));
    const height = 480;
    const margin = { top: 20, right: 28, bottom: 44, left: 72 };
    const plotWidth = width - margin.left - margin.right;
    const plotHeight = height - margin.top - margin.bottom;
    const stepX = expectedPoints.length > 1 ? plotWidth / (expectedPoints.length - 1) : 0;
    const scaleX = (index) => margin.left + stepX * index;
    const scaleY = (value) => {
      if (maxValue === minValue) return margin.top + plotHeight;
      const ratio = (value - minValue) / (maxValue - minValue);
      return margin.top + plotHeight - ratio * plotHeight;
    };
    const tickStep = (function buildTickStep(min, max) {
      const span = max - min || 1;
      const rough = span / 5;
      const pow10 = Math.pow(10, Math.floor(Math.log10(rough)));
      const niceSteps = [1, 2, 2.5, 5, 10].map((m) => m * pow10);
      return niceSteps.find((s) => rough <= s) || niceSteps[niceSteps.length - 1];
    })(minValue, maxValue);
    const tickStart = Math.floor(minValue / tickStep) * tickStep;
    const tickEnd = Math.ceil(maxValue / tickStep) * tickStep;
    const ticks = [];
    for (let v = tickStart; v <= tickEnd + tickStep / 2; v += tickStep) {
      ticks.push(Math.round(v * 1000) / 1000);
    }
    const buildPath = (points) => points.map((point, idx) => {
      const x = scaleX(idx).toFixed(2);
      const y = scaleY(point.value).toFixed(2);
      return `${idx === 0 ? 'M' : 'L'}${x},${y}`;
    }).join(' ');

    const styles = getComputedStyle(document.body);
    const borderColor = (styles.getPropertyValue('--border') || '#1e293b').trim();
    const mutedColor = (styles.getPropertyValue('--muted') || '#94a3b8').trim();
    const primaryColor = (styles.getPropertyValue('--primary') || '#3b82f6').trim();
    const successColor = (styles.getPropertyValue('--success') || '#10b981').trim();
    const textColor = mutedColor || '#94a3b8';

    const expectedPath = buildPath(expectedPoints);
    const actualPath = buildPath(actualPathPoints);
    const actualAveragePath = actualAveragePoints.length > 1 ? buildPath(actualAveragePoints) : '';
    const xAxisY = scaleY(0);
    const svgParts = [];
    svgParts.push(`<path d="M${margin.left},${xAxisY} L${margin.left + plotWidth},${xAxisY}" stroke="${borderColor}" stroke-width="1" fill="none" />`);
    svgParts.push(`<path d="M${margin.left},${margin.top} L${margin.left},${margin.top + plotHeight}" stroke="${borderColor}" stroke-width="1" fill="none" />`);
    ticks.forEach((tick) => {
      const y = scaleY(tick);
      svgParts.push(`<path d="M${margin.left - 6},${y} L${margin.left},${y}" stroke="${borderColor}" stroke-width="1" />`);
      svgParts.push(`<text x="${margin.left - 10}" y="${y + 4}" text-anchor="end" font-size="11" fill="${textColor}">${formatDecimalHours(tick)}</text>`);
    });
    svgParts.push(`<path d="${expectedPath}" stroke="${mutedColor}" stroke-width="2" fill="none" />`);
    svgParts.push(`<path d="${actualPath}" stroke="${primaryColor}" stroke-width="2" fill="none" />`);
    if (actualAveragePath) svgParts.push(`<path d="${actualAveragePath}" stroke="${successColor}" stroke-width="2" fill="none" stroke-dasharray="6 4" />`);

    expectedPoints.forEach((point, idx) => {
      const x = scaleX(idx);
      const y = scaleY(point.value);
      svgParts.push(`<circle data-series="expected" data-label="${typeof point.label === 'string' ? point.label : formatMonthShortYear(point.label)}" data-value="${formatDecimalHours(point.value)}" cx="${x}" cy="${y}" r="3" fill="${mutedColor}" />`);
    });
    actualPathPoints.forEach((point, idx) => {
      const x = scaleX(idx);
      const y = scaleY(point.value);
      const label = typeof point.label === 'string' ? point.label : formatMonthShortYear(point.label);
      svgParts.push(`<circle data-series="actual" data-label="${label}" data-value="${formatDecimalHours(point.value)}" cx="${x}" cy="${y}" r="3" fill="${primaryColor}" />`);
    });
    if (actualAveragePath) {
      actualAveragePoints.forEach((point, idx) => {
        const x = scaleX(idx);
        const y = scaleY(point.value);
        const label = typeof point.label === 'string' ? point.label : formatMonthShortYear(point.label);
        svgParts.push(`<circle data-series="projection" data-label="${label}" data-value="${formatSignedHours(point.value)}" cx="${x}" cy="${y}" r="3" fill="${successColor}" />`);
      });
    }

    const labelGroup = months.map((monthDate, idx) => {
      const x = scaleX(idx + 1);
      const label = formatMonthShortYear(monthDate);
      return `<text x="${x}" y="${xAxisY + 18}" text-anchor="middle" font-size="11" fill="${textColor}">${label}</text>`;
    }).join('');

    const yLabelX = margin.left - 46;
    const yLabelY = margin.top + plotHeight / 2;
    svgParts.push(`<text x="${yLabelX}" y="${yLabelY}" text-anchor="middle" font-size="11" fill="${textColor}" transform="rotate(-90 ${yLabelX} ${yLabelY})">Hours remaining (income)</text>`);

    const svg = `<svg viewBox="0 0 ${width} ${height}" role="img" aria-label="Contract burndown chart with projection"><g>${svgParts.join('')} ${labelGroup}</g></svg>`;

    const avgSummary = document.createElement('div');
    avgSummary.className = 'ts-note contract-burndown-summary';
    const summaryParts = [`Average burn required (income hours): ${formatDecimalHours(avgBurn)} hrs/month.`];
    if (avgActualMonthlyBurn > 0) {
      summaryParts.push(`Actual average to date (income hours): ${formatDecimalHours(avgActualMonthlyBurn)} hrs/month (${monthsContributionUsed.toFixed(2)} months measured).`);
    }
    avgSummary.textContent = summaryParts.join(' ');
    contractBurndownEl.appendChild(avgSummary);

    if (contractActive && avgActualMonthlyBurn > avgBurn + 0.01 && monthsContributionUsed > 0) {
      const projectedTotalUsage = avgActualMonthlyBurn * totalContribution;
      const overageHours = projectedTotalUsage - totalHours;
      if (overageHours > 0.5) {
        const warning = document.createElement('div');
        warning.className = 'ts-warning contract-burndown-warning';
        warning.textContent = `At the current pace you're on track to exceed this contract by approximately ${formatDecimalHours(overageHours)} hrs.`;
        contractBurndownEl.appendChild(warning);
      }
    }

    const plotWrapper = document.createElement('div');
    plotWrapper.className = 'contract-burndown-plot';
    plotWrapper.innerHTML = svg;
    contractBurndownEl.appendChild(plotWrapper);
    const tooltip = document.createElement('div');
    tooltip.style.position = 'absolute';
    tooltip.style.pointerEvents = 'none';
    tooltip.style.background = 'var(--panel)';
    tooltip.style.border = '1px solid var(--border)';
    tooltip.style.borderRadius = '8px';
    tooltip.style.padding = '8px 10px';
    tooltip.style.fontSize = '12px';
    tooltip.style.boxShadow = '0 8px 20px rgba(0,0,0,0.25)';
    tooltip.style.display = 'none';
    plotWrapper.style.position = 'relative';
    plotWrapper.appendChild(tooltip);
    const circles = plotWrapper.querySelectorAll('circle[data-label]');
    if (circles && circles.length) {
      const circleMeta = Array.from(circles).map((circle) => {
        return {
          el: circle,
          x: Number(circle.getAttribute('cx')),
          y: Number(circle.getAttribute('cy')),
          label: circle.getAttribute('data-label') || '',
          value: circle.getAttribute('data-value') || '',
          series: circle.getAttribute('data-series') || ''
        };
      });
      const seriesLabel = {
        expected: 'Expected remaining',
        actual: 'Actual remaining',
        projection: 'Projected remaining'
      };
      const buildTooltipContent = (label) => {
        const items = circleMeta.filter((meta) => meta.label === label);
        const rows = items.map((item) => {
          return `<div style="display:flex; justify-content:space-between; gap:8px;"><span>${seriesLabel[item.series] || 'Value'}</span><strong>${item.value} hrs</strong></div>`;
        }).join('');
        return `<div style="font-weight:700; margin-bottom:4px;">${label}</div>${rows}`;
      };
      const handleMove = (evt) => {
        const rect = plotWrapper.getBoundingClientRect();
        const mouseX = evt.clientX - rect.left;
        const mouseY = evt.clientY - rect.top;
        let closest = null;
        let minDist = 18;
        circleMeta.forEach((meta) => {
          const dx = meta.x - mouseX;
          const dy = meta.y - mouseY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < minDist) {
            minDist = dist;
            closest = meta;
          }
        });
        if (!closest) {
          tooltip.style.display = 'none';
          return;
        }
        tooltip.style.display = 'block';
        tooltip.innerHTML = buildTooltipContent(closest.label);
        const tooltipRect = tooltip.getBoundingClientRect();
        const wrapperRect = plotWrapper.getBoundingClientRect();
        let left = closest.x + 12;
        let top = closest.y - tooltipRect.height - 8;
        if (left + tooltipRect.width > wrapperRect.width) {
          left = closest.x - tooltipRect.width - 12;
        }
        if (left < 0) left = 4;
        if (top < 0) top = closest.y + 12;
        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
      };
      plotWrapper.addEventListener('mousemove', handleMove);
      plotWrapper.addEventListener('mouseleave', () => { tooltip.style.display = 'none'; });
    }

    const legend = document.createElement('div');
    legend.className = 'contract-burndown-legend';
    legend.innerHTML = `<span><span class="line" style="background:${mutedColor};"></span>Expected remaining</span><span><span class="line" style="background:${primaryColor};"></span>Actual remaining</span>${actualAveragePath ? `<span><span class="line" style="background:transparent; border-bottom:2px dashed ${successColor}; height:0;"></span>Actual average (projection)</span>` : ''}`;
    contractBurndownEl.appendChild(legend);

    const chartLabels = months.map((monthDate) => formatMonthShortYear(monthDate));
    const monthlyHoursData = months.map((monthDate) => {
      const key = monthKeyFor(monthDate.getFullYear(), monthDate.getMonth());
      return Number(usage.monthlyHours[key] || 0);
    });

    if (chartLabels.length) {
      const chartWrapper = document.createElement('div');
      chartWrapper.className = 'contract-monthly-chart';
      const chartCanvas = document.createElement('canvas');
      chartWrapper.appendChild(chartCanvas);
      contractBurndownEl.appendChild(chartWrapper);

      const colors = getThemeColors();
      const datasets = [
        {
          type: 'bar',
          label: 'Income hours logged',
          data: monthlyHoursData,
          backgroundColor: colors.primary || '#3b82f6',
          borderColor: colors.primary || '#3b82f6',
          borderWidth: 0,
          borderRadius: 6,
          maxBarThickness: 42,
          order: 2
        }
      ];

      if (avgBurn > 0) {
        datasets.push({
          type: 'line',
          label: 'Expected monthly average',
          data: chartLabels.map(() => avgBurn),
          borderColor: colors.warning || '#facc15',
          backgroundColor: 'transparent',
          borderWidth: 2,
          borderDash: [6, 4],
          pointRadius: 0,
          pointHoverRadius: 4,
          tension: 0,
          order: 0
        });
      }

      if (avgActualMonthlyBurn > 0) {
        datasets.push({
          type: 'line',
          label: 'Actual average to date',
          data: chartLabels.map(() => avgActualMonthlyBurn),
          borderColor: colors.success || '#10b981',
          backgroundColor: 'transparent',
          borderWidth: 2,
          pointRadius: 0,
          pointHoverRadius: 4,
          tension: 0,
          order: 1
        });
      }

      const ctx = chartCanvas.getContext('2d');
      const textColor = colors.text || '#f5f9ff';
      const mutedColor = colors.muted || '#94a3b8';
      const gridColor = colors.border || 'rgba(148,163,184,0.35)';

      if (state.contractCharts.monthlyHours) {
        state.contractCharts.monthlyHours.destroy();
      }

      state.contractCharts.monthlyHours = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: chartLabels,
          datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          plugins: {
            legend: {
              position: 'top',
            labels: {
              color: textColor,
              usePointStyle: true,
              pointStyle: 'roundedRect',
              padding: 12
            }
            },
            tooltip: {
              callbacks: {
                label(context) {
                  const value = typeof context.parsed === 'number' ? context.parsed : context.parsed.y;
                  return `${context.dataset.label}: ${formatDecimalHours(value || 0)} hrs`;
                }
              }
            }
          },
          scales: {
            x: {
              grid: { display: false },
              ticks: {
                color: mutedColor
              }
            },
            y: {
              beginAtZero: true,
              grid: { color: gridColor },
              ticks: {
                color: mutedColor,
                callback(value) {
                  return `${formatDecimalHours(Number(value) || 0)} hrs`;
                }
              }
            }
          }
        }
      });
    }

    const table = document.createElement('table');
    table.className = 'contract-burndown-table';
    table.innerHTML = '<thead><tr><th>Month</th><th>Income hours logged</th><th>Expected remaining</th><th>Actual remaining</th><th>Hours balance</th></tr></thead>';
    const tbody = document.createElement('tbody');
    tableRows.forEach((row) => {
      const tr = document.createElement('tr');
      const monthCell = document.createElement('td');
      monthCell.textContent = row.monthLabel;
      const loggedCell = document.createElement('td');
      loggedCell.textContent = `${formatDecimalHours(row.hoursLogged)} hrs`;
      const expectedCell = document.createElement('td');
      expectedCell.textContent = `${formatDecimalHours(row.expectedRemaining)} hrs`;
      const actualCell = document.createElement('td');
      actualCell.textContent = `${formatDecimalHours(row.actualRemaining)} hrs`;
      const balanceCell = document.createElement('td');
      const balance = row.actualRemaining - row.expectedRemaining;
      if (row.hoursLogged <= 0) {
        balanceCell.textContent = '';
      } else {
        balanceCell.textContent = `${formatSignedHours(balance)} hrs`;
      }
      tr.append(monthCell, loggedCell, expectedCell, actualCell, balanceCell);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    contractBurndownEl.appendChild(table);
  }

  function renderContractHoursBreakdown(contract, usage) {
    if (!contractHoursBreakdownEl) return;
    contractHoursBreakdownEl.innerHTML = '';
    if (!contract || !usage || !usage.breakdown) return;

    const hourTypesMap = usage.breakdown.hourTypes || {};
    const hourTypes = Object.values(hourTypesMap).filter((ht) => ht && ht.totalHours > 0);
    const filterKey = contract && contract.id ? contract.id : '_contract';
    if (!state.contractHourTypeFilters) state.contractHourTypeFilters = {};
    if (!state.contractHourTypeFilters[filterKey]) state.contractHourTypeFilters[filterKey] = new Set();
    const selected = state.contractHourTypeFilters[filterKey];
    const availableIds = new Set(hourTypes.map((ht) => ht.hourTypeId));
    Array.from(selected).forEach((id) => { if (!availableIds.has(id)) selected.delete(id); });
    if (!selected.size && hourTypes.length) {
      hourTypes.forEach((ht) => selected.add(ht.hourTypeId));
    }
    const isIncluded = (ht) => !selected.size || selected.has(ht.hourTypeId);
    const filteredHourTypes = hourTypes.filter(isIncluded);

    const aggregated = filteredHourTypes.reduce((acc, ht) => {
      acc.income += ht.incomeHours || 0;
      acc.nonIncome += ht.nonIncomeHours || 0;
      acc.all += ht.totalHours || 0;
      Object.keys(ht.monthlyIncomeHours || {}).forEach((key) => {
        acc.monthlyIncome[key] = (acc.monthlyIncome[key] || 0) + ht.monthlyIncomeHours[key];
      });
      Object.keys(ht.monthlyNonIncomeHours || {}).forEach((key) => {
        acc.monthlyNonIncome[key] = (acc.monthlyNonIncome[key] || 0) + ht.monthlyNonIncomeHours[key];
      });
      Object.keys(ht.monthlyHours || {}).forEach((key) => {
        acc.monthlyAll[key] = (acc.monthlyAll[key] || 0) + ht.monthlyHours[key];
      });
      return acc;
    }, { income: 0, nonIncome: 0, all: 0, monthlyIncome: {}, monthlyNonIncome: {}, monthlyAll: {} });

    const monthKeys = Object.keys(aggregated.monthlyAll).sort();
    const hasEntries = Number(aggregated.all || 0) > 0;

    const header = document.createElement('div');
    header.className = 'contract-hours-breakdown-header';
    const title = document.createElement('div');
    title.className = 'contract-hours-breakdown-title';
    title.textContent = 'All logged hours (informational)';
    const note = document.createElement('div');
    note.className = 'contract-hours-breakdown-note';
    note.textContent = 'Income-generating hours drive the calculations above; non-income hours are shown here for visibility only. Use the filters to hide hour typestotals update to match.';
    header.append(title);

    const filterPanel = document.createElement('div');
    filterPanel.className = 'contract-hours-filter-panel';
    const filterHeader = document.createElement('div');
    filterHeader.className = 'ts-flex-between ts-flex-wrap';
    filterHeader.style.marginBottom = '8px';
    const filterLabel = document.createElement('span');
    filterLabel.style.fontSize = '13px';
    filterLabel.style.fontWeight = '600';
    filterLabel.textContent = 'Filter hour types';
    const filterActions = document.createElement('div');
    filterActions.className = 'contract-hours-filter-actions';
    const btnSelectAll = document.createElement('button');
    btnSelectAll.className = 'ghost small';
    btnSelectAll.textContent = 'Select all';
    btnSelectAll.onclick = () => {
      selected.clear();
      hourTypes.forEach((ht) => selected.add(ht.hourTypeId));
      renderContractHoursBreakdown(contract, usage);
    };
    const btnClear = document.createElement('button');
    btnClear.className = 'ghost small';
    btnClear.textContent = 'Clear';
    btnClear.onclick = () => {
      selected.clear();
      renderContractHoursBreakdown(contract, usage);
    };
    filterActions.append(btnSelectAll, btnClear);
    filterHeader.append(filterLabel, filterActions);

    const filterList = document.createElement('div');
    filterList.className = 'contract-hours-filter-list';
    if (!hourTypes.length) {
      const empty = document.createElement('div');
      empty.className = 'ts-note';
      empty.textContent = 'No hour types logged yet.';
      filterPanel.append(filterHeader, empty);
    } else {
      hourTypes
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach((ht) => {
          const row = document.createElement('label');
          row.className = 'contract-hours-filter-item';
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = selected.has(ht.hourTypeId);
          checkbox.onchange = () => {
            if (checkbox.checked) {
              selected.add(ht.hourTypeId);
            } else {
              selected.delete(ht.hourTypeId);
            }
            renderContractHoursBreakdown(contract, usage);
          };
          const content = document.createElement('div');
          content.className = 'content';
          const swatch = document.createElement('span');
          swatch.className = 'swatch';
          swatch.style.backgroundColor = ht.color || '#94a3b8';
          const textWrap = document.createElement('div');
          textWrap.className = 'text';
          const labelText = document.createElement('span');
          labelText.className = 'label';
          labelText.textContent = ht.name || 'Unknown';
          const meta = document.createElement('span');
          meta.className = 'meta';
          meta.textContent = ht.contributesToIncome ? 'Income' : 'Non-income';
          textWrap.append(labelText, meta);
          content.append(swatch, textWrap);
          row.append(checkbox, content);
          filterList.appendChild(row);
        });
      filterPanel.append(filterHeader, filterList);
    }

    const cards = document.createElement('div');
    cards.className = 'contract-hours-breakdown-cards';
    const addCard = (label, value) => {
      const card = document.createElement('div');
      card.className = 'contract-hours-breakdown-card';
      const labelEl = document.createElement('div');
      labelEl.className = 'label';
      labelEl.textContent = label;
      const valueEl = document.createElement('div');
      valueEl.className = 'value';
      valueEl.textContent = `${formatDecimalHours(value)} hrs`;
      card.append(labelEl, valueEl);
      cards.appendChild(card);
    };
    addCard('Income hours (used in calculations)', aggregated.income);
    addCard('Non-income hours', aggregated.nonIncome);
    addCard('All hours logged', aggregated.all);

    contractHoursBreakdownEl.append(header, note, filterPanel, cards);

    if (!hasEntries) {
      const empty = document.createElement('div');
      empty.className = 'contract-burndown-empty';
      empty.textContent = 'No time has been logged for this contract yet or no hour types are selected.';
      contractHoursBreakdownEl.appendChild(empty);
      return;
    }

    const typeTable = document.createElement('table');
    typeTable.className = 'contract-burndown-table contract-hours-table';
    typeTable.innerHTML = '<thead><tr><th>Hour type</th><th>Income?</th><th style="text-align:right;">Hours</th><th style="text-align:right;">Share</th></tr></thead>';
    const typeBody = document.createElement('tbody');
    if (!filteredHourTypes.length) {
      const emptyRow = document.createElement('tr');
      const cell = document.createElement('td');
      cell.colSpan = 4;
      cell.style.textAlign = 'center';
      cell.textContent = 'Select at least one hour type to see the breakdown.';
      emptyRow.appendChild(cell);
      typeBody.appendChild(emptyRow);
    } else {
      filteredHourTypes
        .sort((a, b) => b.totalHours - a.totalHours)
        .forEach((ht) => {
          const tr = document.createElement('tr');
          const nameCell = document.createElement('td');
          nameCell.style.display = 'flex';
          nameCell.style.alignItems = 'center';
          nameCell.style.gap = '8px';
          const swatch = document.createElement('span');
          swatch.style.display = 'inline-block';
          swatch.style.width = '10px';
          swatch.style.height = '10px';
          swatch.style.borderRadius = '999px';
          swatch.style.backgroundColor = ht.color || '#94a3b8';
          nameCell.append(swatch, document.createTextNode(ht.name || 'Unknown'));
          const incomeCell = document.createElement('td');
          incomeCell.textContent = ht.contributesToIncome ? 'Income' : 'Non-income';
          const valueCell = document.createElement('td');
          valueCell.textContent = `${formatDecimalHours(ht.totalHours)} hrs`;
          valueCell.style.textAlign = 'right';
          const shareCell = document.createElement('td');
          shareCell.style.textAlign = 'right';
          const share = aggregated.all > 0 ? (ht.totalHours / aggregated.all) * 100 : null;
          shareCell.textContent = share !== null ? `${share.toFixed(1)}%` : '--';
          tr.append(nameCell, incomeCell, valueCell, shareCell);
          typeBody.appendChild(tr);
        });
      const totalRow = document.createElement('tr');
      const totalLabelCell = document.createElement('td');
      totalLabelCell.textContent = 'Total (filtered)';
      const totalIncomeCell = document.createElement('td');
      totalIncomeCell.textContent = '';
      const totalHoursCell = document.createElement('td');
      totalHoursCell.style.textAlign = 'right';
      totalHoursCell.textContent = `${formatDecimalHours(aggregated.all)} hrs`;
      const totalShareCell = document.createElement('td');
      totalShareCell.style.textAlign = 'right';
      totalShareCell.textContent = aggregated.all > 0 ? '100%' : '--';
      totalRow.append(totalLabelCell, totalIncomeCell, totalHoursCell, totalShareCell);
      typeBody.appendChild(totalRow);
    }
    typeTable.appendChild(typeBody);

    const monthTable = document.createElement('table');
    monthTable.className = 'contract-burndown-table contract-hours-table';
    monthTable.innerHTML = '<thead><tr><th>Month</th><th>Income hours</th><th>Non-income hours</th><th>All hours</th></tr></thead>';
    const monthBody = document.createElement('tbody');
    monthKeys.forEach((monthKey) => {
      const parts = monthKey.split('-');
      const dateObj = parts.length === 2 ? new Date(Number(parts[0]), Number(parts[1]) - 1, 1) : null;
      const monthLabel = dateObj && !Number.isNaN(dateObj.getTime()) ? formatMonthShortYear(dateObj) : monthKey;
      const incomeHours = aggregated.monthlyIncome[monthKey] || 0;
      const nonIncomeHours = aggregated.monthlyNonIncome[monthKey] || 0;
      const totalHours = aggregated.monthlyAll[monthKey] || 0;
      const tr = document.createElement('tr');
      const monthCell = document.createElement('td');
      monthCell.textContent = monthLabel;
      const incomeCell = document.createElement('td');
      incomeCell.textContent = `${formatDecimalHours(incomeHours)} hrs`;
      const nonIncomeCell = document.createElement('td');
      nonIncomeCell.textContent = `${formatDecimalHours(nonIncomeHours)} hrs`;
      const totalCell = document.createElement('td');
      totalCell.textContent = `${formatDecimalHours(totalHours)} hrs`;
      tr.append(monthCell, incomeCell, nonIncomeCell, totalCell);
      monthBody.appendChild(tr);
    });
    const totalRow = document.createElement('tr');
    const totalLabelCell = document.createElement('td');
    totalLabelCell.textContent = 'Total (filtered)';
    const totalIncomeCell = document.createElement('td');
    totalIncomeCell.textContent = `${formatDecimalHours(aggregated.income)} hrs`;
    const totalNonIncomeCell = document.createElement('td');
    totalNonIncomeCell.textContent = `${formatDecimalHours(aggregated.nonIncome)} hrs`;
    const totalAllCell = document.createElement('td');
    totalAllCell.textContent = `${formatDecimalHours(aggregated.all)} hrs`;
    totalRow.append(totalLabelCell, totalIncomeCell, totalNonIncomeCell, totalAllCell);
    monthBody.appendChild(totalRow);
    monthTable.appendChild(monthBody);

    contractHoursBreakdownEl.append(typeTable, monthTable);
  }

  function isRatePreviewEnabled() {
    const flag = state.featureFlags.contract_rate_preview || DEFAULT_FEATURE_FLAGS.contract_rate_preview || { enabled: false };
    return !!flag.enabled;
  }

  function normalizeRateValue(value) {
    const num = Number(value);
    if (!Number.isFinite(num) || num < 0) return 0;
    return Math.round(num * 100) / 100;
  }

  function normalizePercentValue(value) {
    const num = Number(value);
    if (!Number.isFinite(num)) return null;
    return Math.round(num * 100) / 100;
  }

  function formatPercentInputValue(value) {
    const normalized = normalizePercentValue(value);
    if (normalized === null) return '';
    const abs = Math.abs(normalized).toFixed(2).replace(/\.00$/, '').replace(/(\.\d*?)0+$/, '$1');
    return normalized < 0 ? `-${abs}` : abs;
  }

  function resetRatePreviewState() {
    state.ratePreview.selectedContractId = '';
    state.ratePreview.data = null;
    state.ratePreview.loading = false;
    state.ratePreview.requestToken = 0;
    state.ratePreview.inputs = { percentChange: null, newRate: null };
    if (ratePreviewContractSelect) ratePreviewContractSelect.value = '';
    if (ratePreviewPercentInput) {
      ratePreviewPercentInput.value = '';
      ratePreviewPercentInput.disabled = false;
      ratePreviewPercentInput.placeholder = 'e.g. 5';
    }
    if (ratePreviewRateInput) ratePreviewRateInput.value = '';
    hideRatePreviewLoading();
    clearRatePreviewContent();
    updateRatePreviewEmptyState();
  }

  function clearRatePreviewContent() {
    if (ratePreviewAdjustedRateEl) ratePreviewAdjustedRateEl.textContent = '--';
    if (ratePreviewCurrentRateEl) ratePreviewCurrentRateEl.textContent = '--';
    if (ratePreviewRateDeltaEl) {
      ratePreviewRateDeltaEl.textContent = '--';
      applyRatePreviewVariance(ratePreviewRateDeltaEl, null);
    }
    if (ratePreviewTotalHoursEl) ratePreviewTotalHoursEl.textContent = '--';
    if (ratePreviewTotalEarnScenarioEl) ratePreviewTotalEarnScenarioEl.textContent = '--';
    if (ratePreviewTotalEarnCurrentEl) ratePreviewTotalEarnCurrentEl.textContent = '--';
    if (ratePreviewTotalEarnVarianceEl) {
      ratePreviewTotalEarnVarianceEl.textContent = '--';
      applyRatePreviewVariance(ratePreviewTotalEarnVarianceEl, null);
    }
    setRatePreviewMetric(ratePreviewTotalSuperScenarioEl, ratePreviewTotalSuperCurrentEl, ratePreviewTotalSuperVarianceEl, null, null, null, null);
    setRatePreviewMetric(ratePreviewTotalTaxScenarioEl, ratePreviewTotalTaxCurrentEl, ratePreviewTotalTaxVarianceEl, null, null, null, null, true);
    setRatePreviewMetric(ratePreviewTotalNetScenarioEl, ratePreviewTotalNetCurrentEl, ratePreviewTotalNetVarianceEl, null, null, null, null);
    if (ratePreviewRemainingScenarioEl) ratePreviewRemainingScenarioEl.textContent = '--';
    if (ratePreviewRemainingCurrentEl) ratePreviewRemainingCurrentEl.textContent = '--';
    if (ratePreviewContractHoursEl) ratePreviewContractHoursEl.textContent = '--';
    if (ratePreviewRemainingVarianceEl) {
      ratePreviewRemainingVarianceEl.textContent = '--';
      applyRatePreviewVariance(ratePreviewRemainingVarianceEl, null);
    }
    setRatePreviewMetric(ratePreviewRemainingSuperScenarioEl, ratePreviewRemainingSuperCurrentEl, ratePreviewRemainingSuperVarianceEl, null, null, null, null);
    setRatePreviewMetric(ratePreviewRemainingTaxScenarioEl, ratePreviewRemainingTaxCurrentEl, ratePreviewRemainingTaxVarianceEl, null, null, null, null, true);
    setRatePreviewMetric(ratePreviewRemainingNetScenarioEl, ratePreviewRemainingNetCurrentEl, ratePreviewRemainingNetVarianceEl, null, null, null, null);
    if (ratePreviewRemainingCard) ratePreviewRemainingCard.style.display = 'none';
    if (ratePreviewSummaryFootnote) ratePreviewSummaryFootnote.textContent = '--';
    if (ratePreviewNoEntriesNote) ratePreviewNoEntriesNote.style.display = 'none';
    if (ratePreviewMonthlyBody) ratePreviewMonthlyBody.innerHTML = '';
    if (ratePreviewContent) ratePreviewContent.style.display = 'none';
  }

  function updateRatePreviewEmptyState() {
    if (!ratePreviewEmpty || !ratePreviewContent) return;
    const contractId = state.ratePreview.selectedContractId;
    const hasSelection = contractId && state.contractMap[contractId];
    if (!hasSelection) {
      ratePreviewEmpty.style.display = 'block';
      ratePreviewContent.style.display = 'none';
      return;
    }
    ratePreviewEmpty.style.display = 'none';
    if (state.ratePreview.data) {
      ratePreviewContent.style.display = 'block';
    }
  }

  function renderRatePreviewContractOptions() {
    if (!ratePreviewContractSelect) return;
    const selectedId = state.ratePreview.selectedContractId;
    ratePreviewContractSelect.innerHTML = '';
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select a contract...';
    ratePreviewContractSelect.appendChild(placeholder);
    state.contracts.forEach((contract) => {
      if (!contract) return;
      const option = document.createElement('option');
      option.value = contract.id;
      option.textContent = contract.name || 'Untitled contract';
      ratePreviewContractSelect.appendChild(option);
    });
    if (selectedId && state.contractMap[selectedId]) {
      ratePreviewContractSelect.value = selectedId;
    } else {
      ratePreviewContractSelect.value = '';
      if (selectedId) {
        state.ratePreview.selectedContractId = '';
        state.ratePreview.data = null;
        clearRatePreviewContent();
      }
    }
  }

  function applyRatePreviewVariance(element, value) {
    if (!element) return;
    element.classList.remove('rate-preview-metric-positive', 'rate-preview-metric-negative');
    const num = Number(value);
    if (!Number.isFinite(num) || num === 0) return;
    element.classList.add(num > 0 ? 'rate-preview-metric-positive' : 'rate-preview-metric-negative');
  }

  function setRatePreviewMetric(scenarioEl, currentEl, varianceEl, scenarioValue, currentValue, varianceValue, variancePercent, invertTrend) {
    if (scenarioEl) {
      if (scenarioValue === null || scenarioValue === undefined) {
        scenarioEl.textContent = '--';
      } else {
        scenarioEl.textContent = formatCurrency(scenarioValue);
      }
    }
    if (currentEl) {
      if (currentValue === null || currentValue === undefined) {
        currentEl.textContent = '--';
      } else {
        currentEl.textContent = formatCurrency(currentValue);
      }
    }
    if (varianceEl) {
      if (varianceValue === null || varianceValue === undefined) {
        varianceEl.textContent = '--';
        applyRatePreviewVariance(varianceEl, null);
      } else {
        const varianceText = formatSignedCurrency(varianceValue);
        const percentText = Number.isFinite(Number(variancePercent)) ? ` (${formatPercentValue(variancePercent)})` : '';
        varianceEl.textContent = varianceText + percentText;
        const varianceForColor = invertTrend ? -varianceValue : varianceValue;
        applyRatePreviewVariance(varianceEl, varianceForColor);
      }
    }
  }

  function showRatePreviewLoading(message) {
    if (!ratePreviewLoadingOverlay || !pageRatePreview) return;
    pageRatePreview.style.position = pageRatePreview.style.position || 'relative';
    ratePreviewLoadingOverlay.textContent = message || 'Calculating scenario...';
    ratePreviewLoadingOverlay.style.display = 'flex';
  }

  function hideRatePreviewLoading() {
    if (ratePreviewLoadingOverlay) {
      ratePreviewLoadingOverlay.style.display = 'none';
    }
  }

  function scheduleRatePreviewFetch(immediate) {
    if (!isRatePreviewEnabled()) return;
    if (!state.ratePreview.selectedContractId) return;
    if (ratePreviewDebounceTimer) {
      clearTimeout(ratePreviewDebounceTimer);
      ratePreviewDebounceTimer = null;
    }
    if (immediate) {
      fetchRatePreviewData();
      return;
    }
    ratePreviewDebounceTimer = setTimeout(() => {
      fetchRatePreviewData();
    }, RATE_PREVIEW_DEBOUNCE_MS);
  }

  function fetchRatePreviewData() {
    if (!isRatePreviewEnabled()) return;
    const contractId = state.ratePreview.selectedContractId;
    if (!contractId || !state.contractMap[contractId]) {
      updateRatePreviewEmptyState();
      return;
    }
    const percent = normalizePercentValue(state.ratePreview.inputs.percentChange);
    const rate = state.ratePreview.inputs.newRate != null ? normalizeRateValue(state.ratePreview.inputs.newRate) : null;
    const payload = {
      contractId,
      percentChange: percent != null ? percent : null,
      newRate: rate != null ? rate : null
    };
    state.ratePreview.loading = true;
    const requestId = state.ratePreview.requestToken + 1;
    state.ratePreview.requestToken = requestId;
    showRatePreviewLoading('Calculating scenario...');
    setStatus('Calculating rate preview...', 'info');
    google.script.run
      .withSuccessHandler((data) => {
        if (state.ratePreview.requestToken !== requestId) return;
        state.ratePreview.loading = false;
        hideRatePreviewLoading();
        if (data && data.contract && data.contract.id === state.ratePreview.selectedContractId) {
          state.ratePreview.data = data;
          applyRatePreviewData(data);
          setStatus('Ready', 'success');
        } else {
          setStatus('Rate preview updated', 'success');
        }
      })
      .withFailureHandler((error) => {
        if (state.ratePreview.requestToken !== requestId) return;
        state.ratePreview.loading = false;
        hideRatePreviewLoading();
        console.error('Failed to calculate rate preview', error);
        setStatus('Failed to calculate rate preview', 'error');
      })
      .api_getContractRatePreview(payload);
  }

  function applyRatePreviewData(data) {
    if (!data) return;
    const contractId = state.ratePreview.selectedContractId;
    if (!contractId || !state.contractMap[contractId]) return;
    const baseRate = normalizeRateValue(data.current && data.current.hourlyRate);
    if (ratePreviewPercentInput) {
      if (baseRate === 0) {
        ratePreviewPercentInput.disabled = true;
        ratePreviewPercentInput.placeholder = 'Unavailable for $0 rates';
      } else {
        ratePreviewPercentInput.disabled = false;
        ratePreviewPercentInput.placeholder = 'e.g. 5';
      }
    }
    if (ratePreviewAdjustedRateEl) ratePreviewAdjustedRateEl.textContent = `${formatCurrency(normalizeRateValue(data.scenario && data.scenario.hourlyRate))} / hr`;
    if (ratePreviewCurrentRateEl) ratePreviewCurrentRateEl.textContent = `${formatCurrency(baseRate)} / hr`;
    if (ratePreviewRateDeltaEl) {
      const delta = Number(data.variance && data.variance.hourlyRateDelta) || 0;
      ratePreviewRateDeltaEl.textContent = `${formatSignedCurrency(delta)} / hr`;
      applyRatePreviewVariance(ratePreviewRateDeltaEl, delta);
    }
    if (ratePreviewTotalHoursEl) ratePreviewTotalHoursEl.textContent = `${formatDecimalHours(data.current && data.current.totalHours)} hrs`;
    if (ratePreviewTotalEarnScenarioEl) ratePreviewTotalEarnScenarioEl.textContent = formatCurrency(data.scenario && data.scenario.totalEarnings);
    if (ratePreviewTotalEarnCurrentEl) ratePreviewTotalEarnCurrentEl.textContent = formatCurrency(data.current && data.current.totalEarnings);
    if (ratePreviewTotalEarnVarianceEl) {
      const totalVariance = Number(data.variance && data.variance.totalEarnings) || 0;
      const totalVarianceText = formatSignedCurrency(totalVariance);
      const totalVariancePercent = Number.isFinite(Number(data.variance && data.variance.totalEarningsPercent))
        ? ` (${formatPercentValue(data.variance.totalEarningsPercent)})`
        : '';
      ratePreviewTotalEarnVarianceEl.textContent = totalVarianceText + totalVariancePercent;
      applyRatePreviewVariance(ratePreviewTotalEarnVarianceEl, totalVariance);
    }
    setRatePreviewMetric(
      ratePreviewTotalSuperScenarioEl,
      ratePreviewTotalSuperCurrentEl,
      ratePreviewTotalSuperVarianceEl,
      data.scenario && data.scenario.super,
      data.current && data.current.super,
      data.variance && data.variance.super,
      data.variance && data.variance.superPercent
    );
    setRatePreviewMetric(
      ratePreviewTotalTaxScenarioEl,
      ratePreviewTotalTaxCurrentEl,
      ratePreviewTotalTaxVarianceEl,
      data.scenario && data.scenario.tax,
      data.current && data.current.tax,
      data.variance && data.variance.tax,
      data.variance && data.variance.taxPercent,
      true
    );
    setRatePreviewMetric(
      ratePreviewTotalNetScenarioEl,
      ratePreviewTotalNetCurrentEl,
      ratePreviewTotalNetVarianceEl,
      data.scenario && data.scenario.net,
      data.current && data.current.net,
      data.variance && data.variance.net,
      data.variance && data.variance.netPercent
    );
    const hasContractCap = Number(data.current && data.current.remainingHours) > 0;
    if (ratePreviewRemainingCard) {
      ratePreviewRemainingCard.style.display = hasContractCap ? 'flex' : 'none';
    }
    if (hasContractCap) {
      if (ratePreviewRemainingScenarioEl) ratePreviewRemainingScenarioEl.textContent = formatCurrency(data.scenario && data.scenario.remainingEarnings);
      if (ratePreviewRemainingCurrentEl) ratePreviewRemainingCurrentEl.textContent = formatCurrency(data.current && data.current.remainingEarnings);
      if (ratePreviewContractHoursEl) {
        const hoursValue = Number(data.current && data.current.remainingHours) || 0;
        ratePreviewContractHoursEl.textContent = `${formatDecimalHours(hoursValue)} hrs`;
      }
      if (ratePreviewRemainingVarianceEl) {
        const remainingVariance = Number(data.variance && data.variance.remainingEarnings) || 0;
        const remainingVarianceText = formatSignedCurrency(remainingVariance);
        const remainingVariancePercent = Number.isFinite(Number(data.variance && data.variance.remainingEarningsPercent))
          ? ` (${formatPercentValue(data.variance.remainingEarningsPercent)})`
          : '';
        ratePreviewRemainingVarianceEl.textContent = remainingVarianceText + remainingVariancePercent;
        applyRatePreviewVariance(ratePreviewRemainingVarianceEl, remainingVariance);
      }
      setRatePreviewMetric(
        ratePreviewRemainingSuperScenarioEl,
        ratePreviewRemainingSuperCurrentEl,
        ratePreviewRemainingSuperVarianceEl,
        data.scenario && data.scenario.remainingSuper,
        data.current && data.current.remainingSuper,
        data.variance && data.variance.remainingSuper,
        data.variance && data.variance.remainingSuperPercent
      );
      setRatePreviewMetric(
        ratePreviewRemainingTaxScenarioEl,
        ratePreviewRemainingTaxCurrentEl,
        ratePreviewRemainingTaxVarianceEl,
        data.scenario && data.scenario.remainingTax,
        data.current && data.current.remainingTax,
        data.variance && data.variance.remainingTax,
        data.variance && data.variance.remainingTaxPercent,
        true
      );
      setRatePreviewMetric(
        ratePreviewRemainingNetScenarioEl,
        ratePreviewRemainingNetCurrentEl,
        ratePreviewRemainingNetVarianceEl,
        data.scenario && data.scenario.remainingNet,
        data.current && data.current.remainingNet,
        data.variance && data.variance.remainingNet,
        data.variance && data.variance.remainingNetPercent
      );
    }
    if (!hasContractCap) {
      if (ratePreviewRemainingScenarioEl) ratePreviewRemainingScenarioEl.textContent = formatCurrency(data.scenario && data.scenario.remainingEarnings);
      if (ratePreviewRemainingCurrentEl) ratePreviewRemainingCurrentEl.textContent = formatCurrency(data.current && data.current.remainingEarnings);
      if (ratePreviewContractHoursEl) ratePreviewContractHoursEl.textContent = '--';
      if (ratePreviewRemainingVarianceEl) {
        ratePreviewRemainingVarianceEl.textContent = '--';
        applyRatePreviewVariance(ratePreviewRemainingVarianceEl, null);
      }
      setRatePreviewMetric(ratePreviewRemainingSuperScenarioEl, ratePreviewRemainingSuperCurrentEl, ratePreviewRemainingSuperVarianceEl, null, null, null, null);
      setRatePreviewMetric(ratePreviewRemainingTaxScenarioEl, ratePreviewRemainingTaxCurrentEl, ratePreviewRemainingTaxVarianceEl, null, null, null, null, true);
      setRatePreviewMetric(ratePreviewRemainingNetScenarioEl, ratePreviewRemainingNetCurrentEl, ratePreviewRemainingNetVarianceEl, null, null, null, null);
    }
    if (ratePreviewSummaryFootnote) {
      const entryCount = Number(data.metadata && data.metadata.entryCount) || 0;
      const monthCount = Number(data.metadata && data.metadata.monthCount) || 0;
      if (entryCount === 0) {
        ratePreviewSummaryFootnote.textContent = 'No entries logged yetfuture time entries will update this preview automatically.';
      } else {
        const entryLabel = entryCount === 1 ? '1 entry' : `${entryCount} entries`;
        const monthLabel = monthCount === 1 ? '1 month' : `${monthCount} months`;
        ratePreviewSummaryFootnote.textContent = `Based on ${entryLabel} across ${monthLabel}.`;
      }
    }
    if (ratePreviewNoEntriesNote) {
      const entryCount = Number(data.metadata && data.metadata.entryCount) || 0;
      ratePreviewNoEntriesNote.style.display = entryCount === 0 ? 'block' : 'none';
    }
    renderRatePreviewMonthlyRows(Array.isArray(data.monthly) ? data.monthly : []);
    if (ratePreviewContent) ratePreviewContent.style.display = 'block';
    updateRatePreviewEmptyState();
    ratePreviewInputSyncing = true;
    const scenarioRate = normalizeRateValue(data.scenario && data.scenario.hourlyRate);
    if (ratePreviewRateInput) ratePreviewRateInput.value = scenarioRate.toFixed(2);
    if (ratePreviewPercentInput) {
      if (Number.isFinite(Number(data.scenario && data.scenario.percentChange))) {
        ratePreviewPercentInput.value = formatPercentInputValue(data.scenario.percentChange);
      } else {
        ratePreviewPercentInput.value = '';
      }
    }
    ratePreviewInputSyncing = false;
    state.ratePreview.inputs.newRate = scenarioRate;
    state.ratePreview.inputs.percentChange = Number.isFinite(Number(data.scenario && data.scenario.percentChange))
      ? normalizePercentValue(data.scenario.percentChange)
      : null;
  }

  function appendRatePreviewMetricCell(rowEl, scenarioValue, currentValue, varianceValue, variancePercent, invertTrend) {
    const cell = document.createElement('td');
    cell.className = 'rate-preview-metric-cell';
    const scenarioDiv = document.createElement('div');
    scenarioDiv.className = 'rate-preview-metric-cell-main';
    if (scenarioValue === null || scenarioValue === undefined) {
      scenarioDiv.textContent = '--';
    } else {
      scenarioDiv.textContent = formatCurrency(scenarioValue);
    }
    const varianceDiv = document.createElement('div');
    varianceDiv.className = 'rate-preview-metric-cell-variance';
    applyRatePreviewVariance(varianceDiv, null);
    if (varianceValue === null || varianceValue === undefined) {
      varianceDiv.textContent = '--';
    } else {
      varianceDiv.textContent = formatSignedCurrency(varianceValue);
      const varianceForColor = invertTrend ? -varianceValue : varianceValue;
      applyRatePreviewVariance(varianceDiv, varianceForColor);
      if (Number.isFinite(Number(variancePercent))) {
        const percentSpan = document.createElement('span');
        percentSpan.className = 'rate-preview-metric-cell-percent';
        percentSpan.textContent = `(${formatPercentValue(variancePercent)})`;
        varianceDiv.appendChild(percentSpan);
      }
    }
    const currentDiv = document.createElement('div');
    currentDiv.className = 'rate-preview-metric-cell-sub';
    if (currentValue === null || currentValue === undefined) {
      currentDiv.textContent = 'Current: --';
    } else {
      currentDiv.textContent = `Current: ${formatCurrency(currentValue)}`;
    }
    cell.append(scenarioDiv, varianceDiv, currentDiv);
    rowEl.appendChild(cell);
  }

  function renderRatePreviewMonthlyRows(rows) {
    if (!ratePreviewMonthlyBody) return;
    ratePreviewMonthlyBody.innerHTML = '';
    if (!rows.length) {
      const emptyRow = document.createElement('tr');
      const cell = document.createElement('td');
      cell.colSpan = 5;
      cell.style.textAlign = 'center';
      cell.textContent = 'No months to display yet.';
      emptyRow.appendChild(cell);
      ratePreviewMonthlyBody.appendChild(emptyRow);
      return;
    }
    rows.forEach((row) => {
      const tr = document.createElement('tr');
      const monthTd = document.createElement('td');
      monthTd.textContent = row.label || row.month || '--';
      const hoursTd = document.createElement('td');
      hoursTd.textContent = `${formatDecimalHours(row.hours || 0)} hrs`;
      tr.append(monthTd, hoursTd);
      appendRatePreviewMetricCell(tr, row.scenarioEarnings, row.currentEarnings, row.variance, row.variancePercent);
      appendRatePreviewMetricCell(tr, row.scenarioSuper, row.currentSuper, row.superVariance, row.superVariancePercent);
      appendRatePreviewMetricCell(tr, row.scenarioTax, row.currentTax, row.taxVariance, row.taxVariancePercent, true);
      appendRatePreviewMetricCell(tr, row.scenarioNet, row.currentNet, row.netVariance, row.netVariancePercent);
      ratePreviewMonthlyBody.appendChild(tr);
    });
  }

  function handleRatePreviewContractChange() {
    const contractId = ratePreviewContractSelect ? ratePreviewContractSelect.value : '';
    state.ratePreview.selectedContractId = contractId || '';
    state.ratePreview.data = null;
    state.ratePreview.loading = false;
    state.ratePreview.inputs = { percentChange: null, newRate: null };
    state.ratePreview.requestToken += 1;
    hideRatePreviewLoading();
    clearRatePreviewContent();
    if (!contractId || !state.contractMap[contractId]) {
      updateRatePreviewEmptyState();
      return;
    }
    const contract = state.contractMap[contractId];
    const baseRate = normalizeRateValue(contract.hourly_rate);
    ratePreviewInputSyncing = true;
    if (ratePreviewPercentInput) {
      ratePreviewPercentInput.value = '';
      ratePreviewPercentInput.disabled = baseRate === 0;
      ratePreviewPercentInput.placeholder = baseRate === 0 ? 'Unavailable for $0 rates' : 'e.g. 5';
    }
    if (ratePreviewRateInput) ratePreviewRateInput.value = baseRate.toFixed(2);
    ratePreviewInputSyncing = false;
    state.ratePreview.inputs.newRate = baseRate;
    state.ratePreview.inputs.percentChange = null;
    updateRatePreviewEmptyState();
    scheduleRatePreviewFetch(true);
  }

  function resetRatePreviewInputs() {
    const contractId = state.ratePreview.selectedContractId;
    if (!contractId || !state.contractMap[contractId]) return;
    const baseRate = normalizeRateValue(state.contractMap[contractId].hourly_rate);
    state.ratePreview.inputs = { percentChange: null, newRate: baseRate };
    ratePreviewInputSyncing = true;
    if (ratePreviewPercentInput) ratePreviewPercentInput.value = '';
    if (ratePreviewRateInput) ratePreviewRateInput.value = baseRate.toFixed(2);
    ratePreviewInputSyncing = false;
    scheduleRatePreviewFetch(true);
  }

  function handleRatePreviewPercentInput() {
    if (ratePreviewInputSyncing) return;
    const contractId = state.ratePreview.selectedContractId;
    if (!contractId || !state.contractMap[contractId]) return;
    const contract = state.contractMap[contractId];
    const baseRate = normalizeRateValue(contract.hourly_rate);
    if (!ratePreviewPercentInput) return;
    if (baseRate === 0) {
      ratePreviewPercentInput.value = '';
      return;
    }
    const raw = ratePreviewPercentInput.value.trim();
    if (raw === '') {
      state.ratePreview.inputs.percentChange = null;
      state.ratePreview.inputs.newRate = baseRate;
      ratePreviewInputSyncing = true;
      if (ratePreviewRateInput) ratePreviewRateInput.value = baseRate.toFixed(2);
      ratePreviewInputSyncing = false;
      scheduleRatePreviewFetch();
      return;
    }
    const parsed = Number(raw);
    if (!Number.isFinite(parsed)) return;
    const percent = normalizePercentValue(parsed);
    const calculatedRate = Math.max(0, baseRate * (1 + percent / 100));
    const normalizedRate = normalizeRateValue(calculatedRate);
    state.ratePreview.inputs.percentChange = percent;
    state.ratePreview.inputs.newRate = normalizedRate;
    ratePreviewInputSyncing = true;
    if (ratePreviewRateInput) ratePreviewRateInput.value = normalizedRate.toFixed(2);
    ratePreviewInputSyncing = false;
    scheduleRatePreviewFetch();
  }

  function handleRatePreviewPercentBlur() {
    if (!ratePreviewPercentInput) return;
    const raw = ratePreviewPercentInput.value.trim();
    if (raw === '') return;
    const parsed = Number(raw);
    if (!Number.isFinite(parsed)) {
      ratePreviewPercentInput.value = '';
      return;
    }
    ratePreviewPercentInput.value = formatPercentInputValue(parsed);
  }

  function handleRatePreviewRateInput() {
    if (ratePreviewInputSyncing) return;
    const contractId = state.ratePreview.selectedContractId;
    if (!contractId || !state.contractMap[contractId]) return;
    if (!ratePreviewRateInput) return;
    const raw = ratePreviewRateInput.value.trim();
    if (raw === '') {
      state.ratePreview.inputs.newRate = null;
      return;
    }
    const parsed = Number(raw);
    if (!Number.isFinite(parsed)) return;
    const normalizedRate = normalizeRateValue(parsed);
    state.ratePreview.inputs.newRate = normalizedRate;
    const contract = state.contractMap[contractId];
    const baseRate = normalizeRateValue(contract.hourly_rate);
    ratePreviewInputSyncing = true;
    if (ratePreviewPercentInput) {
      if (baseRate === 0) {
        ratePreviewPercentInput.value = '';
        state.ratePreview.inputs.percentChange = null;
      } else {
        const percent = normalizePercentValue(((normalizedRate - baseRate) / baseRate) * 100);
        state.ratePreview.inputs.percentChange = percent;
        ratePreviewPercentInput.value = percent != null ? formatPercentInputValue(percent) : '';
      }
    }
    ratePreviewInputSyncing = false;
    scheduleRatePreviewFetch();
  }

  function handleRatePreviewRateBlur() {
    if (!ratePreviewRateInput) return;
    const raw = ratePreviewRateInput.value.trim();
    if (raw === '') return;
    const parsed = Number(raw);
    if (!Number.isFinite(parsed)) {
      ratePreviewRateInput.value = state.ratePreview.inputs.newRate != null
        ? normalizeRateValue(state.ratePreview.inputs.newRate).toFixed(2)
        : '';
      return;
    }
    ratePreviewRateInput.value = normalizeRateValue(parsed).toFixed(2);
  }

  function renderRatePreviewPage(forceRefresh) {
    if (!isRatePreviewEnabled()) {
      updateRatePreviewEmptyState();
      return;
    }
    renderRatePreviewContractOptions();
    if (state.ratePreview.selectedContractId && !state.contractMap[state.ratePreview.selectedContractId]) {
      state.ratePreview.selectedContractId = '';
    }
    if (ratePreviewContractSelect) {
      ratePreviewContractSelect.value = state.ratePreview.selectedContractId || '';
    }
    updateRatePreviewEmptyState();
    if (forceRefresh && state.ratePreview.selectedContractId) {
      scheduleRatePreviewFetch(true);
      return;
    }
    if (state.ratePreview.data) {
      applyRatePreviewData(state.ratePreview.data);
    }
  }

  function renderContractsUI() {
    renderContractSelectorOptions();
    renderContractDetail();
    renderRatePreviewContractOptions();
    if (isRatePreviewEnabled()) {
      updateRatePreviewEmptyState();
    }
  }

  function handleContractSave() {
    if (!contractSaveBtn) return;
    const payload = getContractFormPayload();
    if (!payload) return;
    contractSaveBtn.disabled = true;
    const isEdit = !!state.editingContractId;
    setStatus(isEdit ? 'Updating contract...' : 'Saving contract...', 'warn');
    const handler = (res) => {
      contractSaveBtn.disabled = false;
      if (res && res.success && res.contract) {
        const normalized = sanitizeContract(res.contract);
        state.contracts = [...state.contracts.filter((c) => c.id !== normalized.id), normalized];
        state.selectedContractId = normalized.id;
        refreshContractBindings(normalized.id, normalized.id);
        saveCache();
        hideContractForm();
        renderContractDetail();
        setStatus(isEdit ? 'Contract updated' : 'Contract saved', 'success');
      } else {
        setStatus('Contract save failed', 'error');
      }
    };
    const failure = () => {
      contractSaveBtn.disabled = false;
      setStatus('Contract save failed', 'error');
    };
    if (isEdit) {
      google.script.run
        .withSuccessHandler(handler)
        .withFailureHandler(failure)
        .api_updateContract({ id: state.editingContractId, ...payload });
    } else {
      google.script.run
        .withSuccessHandler(handler)
        .withFailureHandler(failure)
        .api_addContract(payload);
    }
  }

  function handleContractEdit(id) {
    const contract = state.contracts.find((c) => c.id === id);
    if (!contract) return;
    populateContractForm(contract);
    showPage('contracts');
  }

  async function handleContractDelete(id) {
    if (!id) return;
    const hasEntries = state.entries.some((entry) => entry.contract_id === id);
    if (hasEntries) {
      customAlert('This contract already has time entries and cannot be deleted.');
      return;
    }
    const confirmed = await customConfirm('Delete this contract?', { danger: true });
    if (!confirmed) return;
    setStatus('Deleting contract...', 'warn');
    google.script.run
      .withSuccessHandler(() => {
        state.contracts = state.contracts.filter((contract) => contract.id !== id);
        if (state.editingContractId === id) {
          hideContractForm();
        }
        if (state.selectedContractId === id) {
          state.selectedContractId = '';
        }
        refreshContractBindings();
        saveCache();
        setStatus('Contract deleted', 'success');
      })
      .withFailureHandler(() => setStatus('Contract delete failed', 'error'))
      .api_deleteContract(id);
  }

  function handleContractTemplateNew() {
    if (!state.contractTemplateForm) state.contractTemplateForm = {};
    state.contractTemplateForm = { mode: 'add', editingIndex: null, draft: {} };
    renderContractTemplateForm();
  }

  function handleContractTemplateCancel() {
    state.contractTemplateForm = { mode: 'hidden', editingIndex: null, draft: {} };
    renderContractTemplateForm();
  }

  function handleContractTemplateSave() {
    if (!contractTemplateLabelInput || !contractTemplateDescriptionInput || !contractTemplateAmountInput) return;
    const label = contractTemplateLabelInput.value.trim();
    const description = contractTemplateDescriptionInput.value.trim();
    const amount = Number(contractTemplateAmountInput.value);
    if (!label) {
      setStatus('Template label is required.', 'warn');
      return;
    }
    if (!description) {
      setStatus('Template description is required.', 'warn');
      return;
    }
    if (!Number.isFinite(amount) || amount <= 0) {
      setStatus('Enter a valid amount for this template.', 'warn');
      return;
    }
    const contract = getEditingContract();
    if (!contract) return;
    let templates = [];
    try {
      templates = contract.line_item_templates_json ? JSON.parse(contract.line_item_templates_json) : [];
      if (!Array.isArray(templates)) templates = [];
    } catch (e) {
      templates = [];
    }
    const template = { label, description, amount };
    const isEdit = state.contractTemplateForm && state.contractTemplateForm.mode === 'edit' && state.contractTemplateForm.editingIndex != null;
    if (isEdit) {
      templates[state.contractTemplateForm.editingIndex] = template;
    } else {
      templates.push(template);
    }
    contract.line_item_templates_json = JSON.stringify(templates);
    state.contractTemplateForm = { mode: 'hidden', editingIndex: null, draft: {} };
    renderContractTemplateList();
    renderContractTemplateForm();

    if (state.contractFormMode === 'edit' && state.editingContractId) {
      setStatus('Saving template to contract...', 'warn');
      const payload = {
        id: state.editingContractId,
        name: contract.name,
        start_date: contract.start_date,
        end_date: contract.end_date,
        hourly_rate: contract.hourly_rate,
        total_hours: contract.total_hours,
        standard_hours_per_day: contract.standard_hours_per_day,
        include_weekends: contract.include_weekends,
        line_item_templates_json: contract.line_item_templates_json
      };
      google.script.run
        .withSuccessHandler((res) => {
          if (res && res.success && res.contract) {
            const normalized = sanitizeContract(res.contract);
            state.contracts = [...state.contracts.filter((c) => c.id !== normalized.id), normalized];
            saveCache();
            setStatus('Template saved', 'success');
          } else {
            setStatus('Failed to save template', 'error');
          }
        })
        .withFailureHandler(() => {
          setStatus('Failed to save template', 'error');
        })
        .api_updateContract(payload);
    } else if (state.contractFormMode === 'create') {
      setStatus('Template added (remember to save the contract)', 'success');
    }
  }

  function handleContractTemplateAction(event) {
    const target = event.target;
    if (!target) return;
    const action = target.dataset.action;
    const index = target.dataset.index != null ? Number(target.dataset.index) : null;
    if (action === 'edit' && index != null) {
      const contract = getEditingContract();
      if (!contract) return;
      let templates = [];
      try {
        templates = contract.line_item_templates_json ? JSON.parse(contract.line_item_templates_json) : [];
      } catch (e) {
        templates = [];
      }
      const template = templates[index];
      if (!template) return;
      state.contractTemplateForm = { mode: 'edit', editingIndex: index, draft: template };
      renderContractTemplateForm();
    } else if (action === 'delete' && index != null) {
      const contract = getEditingContract();
      if (!contract) return;
      let templates = [];
      try {
        templates = contract.line_item_templates_json ? JSON.parse(contract.line_item_templates_json) : [];
      } catch (e) {
        templates = [];
      }
      templates.splice(index, 1);
      contract.line_item_templates_json = JSON.stringify(templates);
      renderContractTemplateList();

      if (state.contractFormMode === 'edit' && state.editingContractId) {
        setStatus('Deleting template from contract...', 'warn');
        const payload = {
          id: state.editingContractId,
          name: contract.name,
          start_date: contract.start_date,
          end_date: contract.end_date,
          hourly_rate: contract.hourly_rate,
          total_hours: contract.total_hours,
          standard_hours_per_day: contract.standard_hours_per_day,
          include_weekends: contract.include_weekends,
          line_item_templates_json: contract.line_item_templates_json
        };
        google.script.run
          .withSuccessHandler((res) => {
            if (res && res.success && res.contract) {
              const normalized = sanitizeContract(res.contract);
              state.contracts = [...state.contracts.filter((c) => c.id !== normalized.id), normalized];
              saveCache();
              setStatus('Template deleted', 'success');
            } else {
              setStatus('Failed to delete template', 'error');
            }
          })
          .withFailureHandler(() => {
            setStatus('Failed to delete template', 'error');
          })
          .api_updateContract(payload);
      }
    }
  }

  function getEditingContract() {
    if (state.contractFormMode === 'edit' && state.editingContractId) {
      return state.contracts.find((c) => c.id === state.editingContractId);
    } else if (state.contractFormMode === 'create') {
      if (!state.contractDraft) state.contractDraft = {};
      return state.contractDraft;
    }
    return null;
  }

  function renderContractTemplateList() {
    if (!contractTemplateList || !contractTemplateEmpty) return;
    const showTemplates = getFeatureFlag('enable_contract_line_item_templates') && getFeatureFlag('enable_invoices');
    if (!showTemplates) return;
    const contract = getEditingContract();
    if (!contract) {
      contractTemplateList.innerHTML = '';
      contractTemplateEmpty.style.display = 'none';
      return;
    }
    let templates = [];
    try {
      templates = contract.line_item_templates_json ? JSON.parse(contract.line_item_templates_json) : [];
      if (!Array.isArray(templates)) templates = [];
    } catch (e) {
      templates = [];
    }
    if (!templates.length) {
      contractTemplateList.innerHTML = '';
      contractTemplateEmpty.style.display = 'block';
      return;
    }
    contractTemplateEmpty.style.display = 'none';
    const escape = (str) => {
      const div = document.createElement('div');
      div.textContent = str || '';
      return div.innerHTML;
    };
    const rows = templates.map((template, index) => {
      const amount = Number(template.amount) || 0;
      return `
        <li style="display:flex; justify-content:space-between; align-items:center; padding:8px; border:1px solid var(--border-color); border-radius:4px;">
          <div style="flex:1 1 auto;">
            <div style="font-weight:600;">${escape(template.label)}</div>
            <div class="ts-note" style="margin-top:2px;">${escape(template.description)}</div>
            <div style="margin-top:4px; font-size:14px;">$${amount.toFixed(2)}</div>
          </div>
          <div style="display:flex; gap:8px;">
            <button class="ghost" style="font-size:12px;" data-action="edit" data-index="${index}">Edit</button>
            <button class="ghost" style="font-size:12px;" data-action="delete" data-index="${index}">Delete</button>
          </div>
        </li>
      `;
    }).join('');
    contractTemplateList.innerHTML = rows;
  }

  function renderContractTemplateForm() {
    if (!contractTemplateForm) return;
    const showTemplates = getFeatureFlag('enable_contract_line_item_templates') && getFeatureFlag('enable_invoices');
    if (!showTemplates || !state.contractTemplateForm || state.contractTemplateForm.mode === 'hidden') {
      contractTemplateForm.style.display = 'none';
      if (contractTemplateLabelInput) contractTemplateLabelInput.value = '';
      if (contractTemplateDescriptionInput) contractTemplateDescriptionInput.value = '';
      if (contractTemplateAmountInput) contractTemplateAmountInput.value = '';
      return;
    }
    contractTemplateForm.style.display = 'block';
    const draft = state.contractTemplateForm.draft || {};
    if (contractTemplateLabelInput) contractTemplateLabelInput.value = draft.label || '';
    if (contractTemplateDescriptionInput) contractTemplateDescriptionInput.value = draft.description || '';
    if (contractTemplateAmountInput) contractTemplateAmountInput.value = draft.amount != null ? draft.amount : '';
  }

  function updateContractTemplatesSectionVisibility() {
    if (!contractTemplatesSection) return;
    const showTemplates = getFeatureFlag('enable_contract_line_item_templates') && getFeatureFlag('enable_invoices');
    const showForm = state.contractFormMode === 'edit' || state.contractFormMode === 'create';
    const shouldShow = showTemplates && showForm;
    contractTemplatesSection.style.display = shouldShow ? 'block' : 'none';
    if (shouldShow) {
      renderContractTemplateList();
    }
  }

  function renderFeatureFlags() {
    if (!featureFlagsListEl) return;
    featureFlagsListEl.innerHTML = '';
    if (featureFlagCollapseControls) {
      featureFlagCollapseControls.style.display = 'none';
    }

    const formatGroupTitle = (value) => {
      if (!value) return 'Other';
      return value.split('_').map((part) => part.charAt(0).toUpperCase() + part.slice(1)).join(' ');
    };

    if (!state.featureFlagCollapse || typeof state.featureFlagCollapse !== 'object') {
      state.featureFlagCollapse = {};
    }

    const groups = {};
    const ensureGroup = (groupId) => {
      if (!groupId) groupId = 'other';
      if (!groups[groupId]) {
        const config = FEATURE_FLAG_GROUP_MAP[groupId] || { id: groupId, title: formatGroupTitle(groupId), order: 900 };
        groups[groupId] = {
          id: groupId,
          title: config.title || formatGroupTitle(groupId),
          order: config.order != null ? config.order : 900,
          items: []
        };
        if (state.featureFlagCollapse[groupId] === undefined) {
          state.featureFlagCollapse[groupId] = true;
        }
      }
      return groups[groupId];
    };
    const processed = new Set();
    const rawFlags = state.featureFlags && typeof state.featureFlags === 'object' ? state.featureFlags : {};

    const addFlagToGroup = (key, config, stateMeta) => {
      const shouldHideCompanyDependent = (key === 'enable_company_quarterly_bas' || key === 'is_sole_trader')
        && !state.companyTrackingEnabled;
      if (shouldHideCompanyDependent) return;

      const groupId = config.group || 'other';
      const group = ensureGroup(groupId);
      const item = {
        key,
        enabled: !!(stateMeta && stateMeta.enabled),
        name: config.name || (stateMeta && stateMeta.name) || key,
        description: config.description || (stateMeta && stateMeta.description) || '',
        order: config.order != null ? config.order : 0
      };
      group.items.push(item);
    };

    Object.keys(DEFAULT_FEATURE_FLAGS).forEach((key) => {
      const config = DEFAULT_FEATURE_FLAGS[key];
      const stateMeta = rawFlags[key];
      addFlagToGroup(key, config, stateMeta);
      processed.add(key);
    });

    Object.keys(rawFlags).forEach((key) => {
      if (processed.has(key)) return;
      const stateMeta = rawFlags[key] || {};
      const fallbackConfig = {
        name: (stateMeta && stateMeta.name) || key,
        description: (stateMeta && stateMeta.description) || '',
        order: 1000,
        group: 'other'
      };
      addFlagToGroup(key, fallbackConfig, stateMeta);
    });

    const groupList = Object.values(groups).filter((group) => group.items.length > 0);
    groupList.sort((a, b) => {
      if (a.order !== b.order) return a.order - b.order;
      return a.title.localeCompare(b.title);
    });

    if (featureFlagCollapseControls) {
      featureFlagCollapseControls.style.display = groupList.length ? 'flex' : 'none';
    }

    if (!groupList.length) {
      const empty = document.createElement('div');
      empty.className = 'ts-note';
      empty.textContent = 'No feature flags configured.';
      featureFlagsListEl.appendChild(empty);
      return;
    }

    const toggleGroup = (groupId) => {
      const current = !!state.featureFlagCollapse[groupId];
      state.featureFlagCollapse[groupId] = !current;
      saveCache();
      renderFeatureFlags();
    };

    groupList.forEach((group) => {
      group.items.sort((a, b) => {
        if (a.order !== b.order) return a.order - b.order;
        return a.name.localeCompare(b.name);
      });

      const container = document.createElement('div');
      container.className = 'ts-flag-group';

      const header = document.createElement('div');
      header.className = 'ts-flag-group-header';
      header.setAttribute('role', 'button');
      header.setAttribute('tabindex', '0');

      const collapsed = !!state.featureFlagCollapse[group.id];
      header.setAttribute('aria-expanded', collapsed ? 'false' : 'true');

      const titleWrapper = document.createElement('div');
      titleWrapper.className = 'ts-flag-group-header-title';
      const title = document.createElement('span');
      title.textContent = group.title;
      titleWrapper.appendChild(title);

      const count = document.createElement('span');
      count.className = 'ts-flag-group-count';
      count.textContent = `${group.items.length} item${group.items.length === 1 ? '' : 's'}`;
      titleWrapper.appendChild(count);

      const toggle = document.createElement('span');
      toggle.className = 'ts-flag-group-toggle';
      toggle.textContent = collapsed ? '' : '';

      header.appendChild(titleWrapper);
      header.appendChild(toggle);
      header.addEventListener('click', () => toggleGroup(group.id));
      header.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          toggleGroup(group.id);
        }
      });

      container.appendChild(header);

      const bodyId = `feature-flag-group-${group.id}`;
      header.setAttribute('aria-controls', bodyId);

      const body = document.createElement('div');
      body.className = 'ts-flag-group-body';
      body.id = bodyId;
      body.style.display = collapsed ? 'none' : 'block';

      group.items.forEach((flag) => {
        const row = document.createElement('div');
        row.className = 'ts-flag-row';

        const meta = document.createElement('div');
        meta.className = 'ts-flag-meta';
        meta.innerHTML = `<div class="ts-flag-title">${flag.name}</div>` + (flag.description ? `<div class="ts-flag-desc">${flag.description}</div>` : '');

        const toggleLabel = document.createElement('label');
        toggleLabel.className = 'ts-toggle';
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = flag.enabled;
        input.dataset.flag = flag.key;
        input.setAttribute('aria-label', flag.name);
        const track = document.createElement('span');
        track.className = 'ts-toggle-track';
        const thumb = document.createElement('span');
        thumb.className = 'ts-toggle-thumb';
        track.appendChild(thumb);
        toggleLabel.appendChild(input);
        toggleLabel.appendChild(track);

        input.addEventListener('change', () => {
          if (!!state.featureFlags[flag.key]?.enabled === input.checked) return;
          updateFeatureFlag(flag.key, input.checked);
        });

        row.append(meta, toggleLabel);
        body.appendChild(row);
      });

      container.appendChild(body);
      featureFlagsListEl.appendChild(container);
    });
  }

  function updateFeatureFlag(featureKey, enabled) {
    const toggleInput = featureFlagsListEl ? featureFlagsListEl.querySelector(`input[data-flag="${featureKey}"]`) : null;
    if (toggleInput) toggleInput.disabled = true;
    const defaultMeta = DEFAULT_FEATURE_FLAGS[featureKey];
    const currentMeta = state.featureFlags[featureKey] || {
      name: defaultMeta ? defaultMeta.name : featureKey,
      description: defaultMeta ? defaultMeta.description : '',
      enabled: false
    };
    setStatus('Updating feature flags...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (toggleInput) toggleInput.disabled = false;
        if (res && res.success && res.flags) {
          state.featureFlags = normalizeFeatureFlags(res.flags);
          saveCache();
          renderFeatureFlags();
          applyFeatureFlagsLazy();
          handleFeatureFlagDataLoad(featureKey, enabled);
          if (state.annualData) {
            loadAnnualData();
          }

          // If no_lost_super_to_deductions was just enabled and the setting doesn't exist, save default
          if (featureKey === 'no_lost_super_to_deductions' && enabled && !state.settings.lost_super_recovery_mode) {
            const defaultMode = 'extra_contribution';
            state.settings.lost_super_recovery_mode = defaultMode;
            saveCache();
            google.script.run
              .withSuccessHandler(() => {
                if (lostSuperRecoveryModeSelect) lostSuperRecoveryModeSelect.value = defaultMode;
                captureSettingsState();
                renderIncomeSummary();
              })
              .withFailureHandler(() => {})
              .api_updateSettings({ lost_super_recovery_mode: defaultMode });
          } else if (featureKey === 'no_lost_super_to_deductions') {
            // Recalculate income summary when this flag changes (and we didn't already queue it above)
            renderIncomeSummary();
          }

          setStatus('Feature flags updated', 'success');
        } else {
          if (toggleInput) toggleInput.checked = !!currentMeta.enabled;
          setStatus('Feature flag update failed', 'error');
        }
      })
      .withFailureHandler(() => {
        if (toggleInput) {
          toggleInput.disabled = false;
          toggleInput.checked = !!currentMeta.enabled;
        }
        setStatus('Feature flag update failed', 'error');
      })
      .api_setFeatureFlag({
        feature: featureKey,
        enabled: enabled
      });
  }

  function applyFeatureFlagsLazy() {
    const rememberFlag = state.featureFlags.remember_last_page || DEFAULT_FEATURE_FLAGS.remember_last_page || { enabled: false };
    if (rememberFlag.enabled) {
      let stored = null;
      try {
        stored = localStorage.getItem(LAST_PAGE_KEY);
      } catch (e) {}
      if (!stored) {
        persistLastPage(state.currentPage);
      } else if (stored && PAGE_KEYS.includes(stored) && stored !== state.currentPage) {
        showPage(stored);
      }
    } else {
      try {
        localStorage.removeItem(LAST_PAGE_KEY);
      } catch (e) {}
    }
    const zeroFlag = state.featureFlags.show_zero_hours || DEFAULT_FEATURE_FLAGS.show_zero_hours || { enabled: false };
    state.showZeroHours = !!zeroFlag.enabled;
    renderCalendar();
    updateClearCacheVisibility();

    const recurringFlag = state.featureFlags.recurring_time_entries || DEFAULT_FEATURE_FLAGS.recurring_time_entries || { enabled: false };
    const recurringEnabled = !!recurringFlag.enabled;
    if (recurringManageBtn) recurringManageBtn.style.display = recurringEnabled ? 'inline-flex' : 'none';
    if (!recurringEnabled) {
      closeRecurringModal();
    }

    const bulkFlag = state.featureFlags.bulk_time_entries || DEFAULT_FEATURE_FLAGS.bulk_time_entries || { enabled: false };
    const bulkEnabled = !!bulkFlag.enabled;
    if (bulkManageBtn) bulkManageBtn.style.display = bulkEnabled ? 'inline-flex' : 'none';
    if (!bulkEnabled) {
      closeBulkModal();
    }

    const expectedMonthlyFlag = state.featureFlags.expected_monthly_hours || DEFAULT_FEATURE_FLAGS.expected_monthly_hours || { enabled: false };
    if (contractIncludeWeekendsRow) {
      contractIncludeWeekendsRow.style.display = expectedMonthlyFlag.enabled ? 'flex' : 'none';
    }

    const companyFlag = state.featureFlags.enable_company_tracking_features || DEFAULT_FEATURE_FLAGS.enable_company_tracking_features || { enabled: false };
    state.companyTrackingEnabled = !!companyFlag.enabled;
    updateDeductionFormVisibility();

    const categoryFlag = state.featureFlags.enable_deduction_categories || DEFAULT_FEATURE_FLAGS.enable_deduction_categories || { enabled: false };
    if (btnManageDeductionCategories) {
      btnManageDeductionCategories.style.display = categoryFlag.enabled ? 'inline-flex' : 'none';
    }
    if (!categoryFlag.enabled) {
      state.deductionCategories = [];
      state.deductionCategoryCollapse = { __uncategorised__: true };
      updateDeductionCategoryMap();
      renderDeductionCategoryOptions('');
      renderDeductionCategoryList();
      saveCache();
    }

    renderDeductionsList();
    renderIncomeSummary();

    const quarterlyFlag = state.featureFlags.enable_company_quarterly_bas || DEFAULT_FEATURE_FLAGS.enable_company_quarterly_bas || { enabled: false };
    state.companyBasQuarterly = state.companyTrackingEnabled && !!quarterlyFlag.enabled;
    if (navBasBtn) {
      navBasBtn.style.display = state.companyTrackingEnabled ? 'block' : 'none';
    }
    if (!state.companyTrackingEnabled && state.currentPage === 'bas') {
      showPage('time');
    }
    renderBasReporting();

    updatePayrollHelperButtons();

    // Show/hide hour types navigation
    const hourTypesFlag = state.featureFlags.hour_types || DEFAULT_FEATURE_FLAGS.hour_types || { enabled: false };
    if (navHourTypesBtn) {
      navHourTypesBtn.style.display = hourTypesFlag.enabled ? 'block' : 'none';
    }
    if (hourTypesFlag.enabled) {
      loadHourTypes();
    }
    updateHourTypeFormVisibility();
    updateRecurringHourTypeVisibility();
    updateBulkHourTypeVisibility();

    const ratePreviewFlag = state.featureFlags.contract_rate_preview || DEFAULT_FEATURE_FLAGS.contract_rate_preview || { enabled: false };
    if (navRatePreviewBtn) {
      navRatePreviewBtn.style.display = ratePreviewFlag.enabled ? 'block' : 'none';
    }
    if (ratePreviewFlag.enabled) {
      renderRatePreviewContractOptions();
      updateRatePreviewEmptyState();
    } else {
      if (state.currentPage === 'rate-preview') {
        showPage('contracts');
      }
      resetRatePreviewState();
    }

    const invoicesFlag = state.featureFlags.enable_invoices || DEFAULT_FEATURE_FLAGS.enable_invoices || { enabled: false };
    if (navInvoicesBtn) {
      navInvoicesBtn.style.display = invoicesFlag.enabled ? 'block' : 'none';
    }
    if (!invoicesFlag.enabled && state.currentPage === 'invoices') {
      showPage('time');
    }
    if (invoicesFlag.enabled) {
      initializeInvoicesFeature();
    } else {
      resetInvoicesState();
    }

    // Show/hide public holidays state setting
    const publicHolidaysFlag = state.featureFlags.enable_public_holidays || DEFAULT_FEATURE_FLAGS.enable_public_holidays || { enabled: false };
    if (publicHolidaysFlag.enabled) {
      loadPublicHolidays();
    }

    // Show/hide colorblind theme options
    const colorblindThemesFlag = state.featureFlags.enable_colorblind_themes || DEFAULT_FEATURE_FLAGS.enable_colorblind_themes || { enabled: false };
    const colorblindThemeOptions = document.querySelectorAll('.ts-colorblind-theme');
    colorblindThemeOptions.forEach(function(option) {
      option.style.display = colorblindThemesFlag.enabled ? 'block' : 'none';
    });

    // Update custom theme availability and controls
    updateCustomThemeControls();
    renderSettingsSections();
  }

  function handleFeatureFlagDataLoad(featureKey, enabled) {
    if (featureKey === 'enable_public_holidays') {
      if (enabled) {
        loadPublicHolidays(true);
      } else {
        state.publicHolidays = [];
        updatePublicHolidayMap();
        renderCalendar();
      }
    } else if (featureKey === 'enable_deduction_categories') {
      if (enabled) {
        fetchDeductionCategoriesFromServer();
      }
    } else if (featureKey === 'recurring_time_entries' && enabled) {
      syncRecurringEntries({ silent: true });
    } else if (featureKey === 'bulk_time_entries' && enabled) {
      syncBulkEntries({ silent: true });
    } else if (featureKey === 'enable_invoices' && enabled) {
      initializeInvoicesFeature();
    } else if (featureKey === 'hour_types' && enabled) {
      loadHourTypes();
    }
  }

  if (contractSaveBtn) {
    contractSaveBtn.onclick = handleContractSave;
  }
  if (contractCancelBtn) {
    contractCancelBtn.onclick = () => {
      hideContractForm();
      renderContractDetail();
    };
  }
  if (contractAddToggle) {
    contractAddToggle.addEventListener('click', () => {
      showPage('contracts');
      if (state.contractFormMode === 'create') {
        hideContractForm();
        renderContractDetail();
        return;
      }
      if (state.contractFormMode === 'edit') {
        hideContractForm();
      }
      showContractForm('create');
    });
  }
  if (btnContractTemplateNew) {
    btnContractTemplateNew.addEventListener('click', handleContractTemplateNew);
  }
  if (btnContractTemplateCancel) {
    btnContractTemplateCancel.addEventListener('click', handleContractTemplateCancel);
  }
  if (btnContractTemplateSave) {
    btnContractTemplateSave.addEventListener('click', handleContractTemplateSave);
  }
  if (contractTemplateList) {
    contractTemplateList.addEventListener('click', handleContractTemplateAction);
  }
  if (contractSelector) {
    contractSelector.addEventListener('change', () => {
      const nextId = contractSelector.value || '';
      if (state.contractFormMode === 'create' || (state.contractFormMode === 'edit' && state.editingContractId && state.editingContractId !== nextId)) {
        hideContractForm();
      }
      state.selectedContractId = nextId;
      renderContractDetail();
    });
  }
  setContractFormMode('hidden');

  function updateClearCacheVisibility() {
    if (!clearCacheWrapper) return;
    const enabled = !!(state.featureFlags.show_clear_cache && state.featureFlags.show_clear_cache.enabled);
    clearCacheWrapper.style.display = enabled ? 'block' : 'none';
  }

  if (clearCacheBtn) {
    clearCacheBtn.addEventListener('click', async () => {
      const confirmed = await customConfirm('Clear cached entries and settings from this browser?', {
        title: 'Clear Cache',
        danger: true
      });
      if (!confirmed) return;
      try {
        localStorage.removeItem(state.cacheKey);
        localStorage.removeItem(LAST_PAGE_KEY);
      } catch (e) {}
      setStatus('Local cache cleared. Data will be reloaded from the server on next sync.', 'success');
    });
  }

  if (payrollXeroBtn) {
    payrollXeroBtn.addEventListener('click', () => {
      renderXeroPayrollHelper();
      showModal(xeroHelperModal);
    });
  }

  if (payrollMyobBtn) {
    payrollMyobBtn.addEventListener('click', () => {
      renderMyobPayrollHelper();
      showModal(myobHelperModal);
    });
  }

  // Actual Income Modal Event Listeners
  if (actualIncomeBtn) {
    actualIncomeBtn.addEventListener('click', openActualIncomeModal);
  }
  if (btnSaveActualIncome) {
    btnSaveActualIncome.addEventListener('click', saveActualIncome);
  }
  if (btnCancelActualIncome) {
    btnCancelActualIncome.addEventListener('click', closeActualIncomeModal);
  }
  if (btnDeleteActualIncome) {
    btnDeleteActualIncome.addEventListener('click', deleteActualIncome);
  }

  // Monthly Print View Event Listeners
  if (printMonthlyBtn) {
    printMonthlyBtn.addEventListener('click', openPrintViewConfigModal);
  }
  if (btnCancelPrintView) {
    btnCancelPrintView.addEventListener('click', closePrintViewConfigModal);
  }
  if (btnGeneratePrintView) {
    btnGeneratePrintView.addEventListener('click', generatePrintView);
  }
  if (btnUnselectAllOther) {
    btnUnselectAllOther.addEventListener('click', unselectAllOtherHourTypes);
  }
  if (timesheet1Btn) {
    timesheet1Btn.addEventListener('click', openTimesheet1Importer);
  }
  if (timesheet1PreviewBtn) {
    timesheet1PreviewBtn.addEventListener('click', previewTimesheet1Import);
  }
  if (timesheet1RunBtn) {
    timesheet1RunBtn.addEventListener('click', runTimesheet1Import);
  }
  if (timesheet1CancelBtn) {
    timesheet1CancelBtn.addEventListener('click', closeTimesheet1Importer);
  }
  if (timesheet1SkipHolidaysToggle) {
    timesheet1SkipHolidaysToggle.addEventListener('change', () => {
      timesheet1State.skipPublicHolidays = !!timesheet1SkipHolidaysToggle.checked;
      if (timesheet1RunBtn) timesheet1RunBtn.disabled = true;
      setTimesheet1Status('Skip holidays setting changed. Run preview again to refresh totals.', 'warn');
    });
  }
  if (timesheet1Modal) {
    const closeBtn = timesheet1Modal.querySelector('.ts-modal-close');
    if (closeBtn) closeBtn.addEventListener('click', closeTimesheet1Importer);
  }

  // Entries & KPIs
  function minutesForDate(date) {
    const target = isoDate(date);
    if (!target) return 0;
    return state.entries.reduce((acc, entry) => {
      return getEntryDateIso(entry) === target ? acc + (Number(entry.duration_minutes) || 0) : acc;
    }, 0);
  }
const monthKeyFor = (year, month) => `${year}-${String(month + 1).padStart(2, '0')}`;

function monthKeyFromDateIso(dateIso) {
  if (!dateIso) return null;
  const date = parseIsoDate(dateIso);
  if (!date || Number.isNaN(date.getTime())) return null;
  return monthKeyFor(date.getFullYear(), date.getMonth());
}

function parseMonthKey(monthKey) {
  if (!monthKey) return null;
  const parts = monthKey.split('-');
  if (parts.length !== 2) return null;
  const year = Number(parts[0]);
  const month = Number(parts[1]) - 1;
  if (Number.isNaN(year) || Number.isNaN(month)) return null;
  return { year, month };
}

function hourTypeContributesToIncome(hourTypeId) {
  const id = hourTypeId || getDefaultHourTypeId();
  const hourType = state.hourTypeMap[id];
  return hourType ? hourType.contributes_to_income : true;
}

function entryContributesToIncome(entry) {
  if (!entry || !entry.date) return false;
  return hourTypeContributesToIncome(entry.hour_type_id);
}

function ensureIncomeCacheStructures() {
  if (!state.incomeSummaryCache || typeof state.incomeSummaryCache !== 'object') state.incomeSummaryCache = {};
  if (!state.dirtyIncomeMonths || !(state.dirtyIncomeMonths instanceof Set)) {
    state.dirtyIncomeMonths = new Set();
  }
  if (!state.incomeCacheMetadata || typeof state.incomeCacheMetadata !== 'object') {
    state.incomeCacheMetadata = {};
  }
}

function markMonthDirty(monthKey) {
  if (!monthKey) return;
  ensureIncomeCacheStructures();
  state.dirtyIncomeMonths.add(monthKey);
  if (state.incomeSummaryCache[monthKey]) delete state.incomeSummaryCache[monthKey];
  if (!state.incomeCacheMetadata[monthKey]) state.incomeCacheMetadata[monthKey] = {};
  state.incomeCacheMetadata[monthKey].isDirty = true;
}

function markIncomeMonthDirty(monthKey) {
  markMonthDirty(monthKey);
}

function markIncomeSummaryDirtyForEntry(entry) {
  if (!entryContributesToIncome(entry)) return;
  const monthKey = monthKeyFromDateIso(entry.date);
  if (monthKey) markIncomeMonthDirty(monthKey);
}

function markIncomeSummaryDirtyForEntries(entries) {
  (entries || []).forEach((entry) => markIncomeSummaryDirtyForEntry(entry));
}

function markAllIncomeSummariesDirty() {
  ensureIncomeCacheStructures();
  const keys = new Set([
    ...Object.keys(state.incomeSummaryCache || {}),
    ...Object.keys(state.incomeCacheMetadata || {})
  ]);
  keys.forEach((key) => markMonthDirty(key));
}

function getTrackedIncomeMonthKeys(extraKeys = []) {
  ensureIncomeCacheStructures();
  const keys = new Set([
    ...Object.keys(state.incomeSummaryCache || {}),
    ...Object.keys(state.incomeCacheMetadata || {})
  ]);
  if (state.calendar && Number.isInteger(state.calendar.year) && Number.isInteger(state.calendar.month)) {
    keys.add(monthKeyFor(state.calendar.year, state.calendar.month));
  }
  (extraKeys || []).forEach((key) => {
    if (key) keys.add(key);
  });
  return Array.from(keys);
}

function deductionHasOccurrenceInMonth(deduction, monthKey, exceptionsSnapshot) {
  if (!deduction || !monthKey) return false;
  const coords = parseMonthKey(monthKey);
  if (!coords) return false;
  const monthStart = startOfDay(new Date(coords.year, coords.month, 1));
  const monthEnd = startOfDay(new Date(coords.year, coords.month + 1, 0));
  const occurrences = getDeductionOccurrencesWithExceptions(
    deduction,
    monthStart,
    monthEnd,
    undefined,
    exceptionsSnapshot
  );
  return Array.isArray(occurrences) && occurrences.length > 0;
}

function markIncomeMonthsDirtyForDeductionChange(prevDeduction, nextDeduction, prevExceptions, nextExceptions, extraMonthKeys = []) {
  const monthsToCheck = getTrackedIncomeMonthKeys(extraMonthKeys);
  monthsToCheck.forEach((monthKey) => {
    const hadBefore = deductionHasOccurrenceInMonth(prevDeduction, monthKey, prevExceptions);
    const hasAfter = deductionHasOccurrenceInMonth(nextDeduction, monthKey, nextExceptions);
    if (hadBefore || hasAfter) {
      markIncomeMonthDirty(monthKey);
    }
  });
}

function buildEntryHashPayload(entry) {
  if (!entry) return '';
  const punches = Array.isArray(entry.punches)
    ? entry.punches.map((punch) => `${punch.type || ''}:${punch.time || ''}`).join(',')
    : '';
  return [
    entry.id || '',
    entry.date || '',
    entry.duration_minutes || 0,
    entry.contract_id || '',
    entry.hour_type_id || '',
    punches
  ].join('|');
}

function calculateEntryListHash(entries) {
  if (!Array.isArray(entries) || !entries.length) return '0';
  const normalized = entries
    .map((entry) => ({
      payload: buildEntryHashPayload(entry),
      date: entry.date || '',
      id: entry.id || ''
    }))
    .sort((a, b) => {
      if (a.date !== b.date) return a.date.localeCompare(b.date);
      return a.id.localeCompare(b.id);
    })
    .map((entry) => entry.payload);
  return `${normalized.length}:${normalized.join('||')}`;
}

function calculateMonthEntryHash(year, month) {
  const monthEntries = entriesForMonth(year, month);
  return calculateEntryListHash(monthEntries);
}

function shouldRecalculateMonth(year, month) {
  ensureIncomeCacheStructures();
  const monthKey = monthKeyFor(year, month);
  const metadata = state.incomeCacheMetadata[monthKey];
  if (!metadata) return true;
  if (metadata.isDirty) return true;
  if (!state.incomeSummaryCache[monthKey]) return true;
  const currentHash = calculateMonthEntryHash(year, month);
  if (metadata.entryHash !== currentHash) {
    metadata.entryHash = currentHash;
    metadata.isDirty = true;
    if (state.incomeSummaryCache[monthKey]) delete state.incomeSummaryCache[monthKey];
    state.dirtyIncomeMonths.add(monthKey);
    return true;
  }
  return false;
}

function serializeIncomeSummary(summary) {
  if (!summary) return null;
  const { periodStart, ...rest } = summary;
  return {
    ...rest,
    periodStartIso: periodStart ? periodStart.toISOString() : null
  };
}

function deserializeIncomeSummary(data) {
  if (!data) return null;
  const { periodStartIso, ...rest } = data;
  return {
    ...rest,
    periodStart: periodStartIso ? new Date(periodStartIso) : null
  };
}

function serializeIncomeSummaryCache() {
  const cache = state.incomeSummaryCache || {};
  const out = {};
  Object.keys(cache).forEach((key) => {
    if (cache[key]) out[key] = { ...cache[key] };
  });
  return out;
}

function deserializeIncomeSummaryCache(raw) {
  const out = {};
  if (!raw || typeof raw !== 'object') return out;
  Object.keys(raw).forEach((key) => {
    if (raw[key]) out[key] = { ...raw[key] };
  });
  return out;
}

function cacheIncomeSummary(monthKey, summary) {
  if (!monthKey || !summary) return;
  ensureIncomeCacheStructures();
  state.incomeSummaryCache[monthKey] = serializeIncomeSummary(summary);
  state.dirtyIncomeMonths.delete(monthKey);
  const coords = parseMonthKey(monthKey);
  const entryHash = coords ? calculateMonthEntryHash(coords.year, coords.month) : '';
  if (!state.incomeCacheMetadata[monthKey]) state.incomeCacheMetadata[monthKey] = {};
  state.incomeCacheMetadata[monthKey].entryHash = entryHash;
  state.incomeCacheMetadata[monthKey].lastCalculated = Date.now();
  state.incomeCacheMetadata[monthKey].isDirty = false;
  saveCache();
}

function getCachedIncomeSummary(monthKey) {
  if (!monthKey || !state.incomeSummaryCache) return null;
  return deserializeIncomeSummary(state.incomeSummaryCache[monthKey]);
}
  const getEntryDateIso = (entry) => {
    if (!entry || !entry.date) return '';
    if (entry._isoDate) return entry._isoDate;
    const normalized = isoDate(entry.date);
    entry._isoDate = normalized;
    return normalized;
  };
  function resolveContractForEntry(entry) {
    if (!entry) return null;
    const directId = entry.contract_id;
    if (directId) {
      const direct = state.contractMap[directId];
      if (direct) return direct;
    }
    if (!entryContributesToIncome(entry)) {
      const entryDateIso = getEntryDateIso(entry);
      if (!entryDateIso) return null;
      const matches = validContractsForDate(entryDateIso);
      if (matches.length === 1) {
        return matches[0];
      }
    }
    return null;
  }

  function entriesForMonth(year, month) {
    const prefix = monthKeyFor(year, month);
    return state.entries.filter((entry) => {
      const dateIso = getEntryDateIso(entry);
      return dateIso ? dateIso.startsWith(prefix) : false;
    });
  }
  function payrollEligibleEntries(year, month) {
    return entriesForMonth(year, month).filter((entry) => entry && entryContributesToIncome(entry));
  }
  function formatRangeLabel(startDate, endDate) {
    const startLabel = MONTH_DAY_FORMATTER.format(startDate);
    const endLabel = MONTH_DAY_FORMATTER.format(endDate);
    return startLabel === endLabel ? startLabel : `${startLabel} - ${endLabel}`;
  }
  function buildXeroPayrollReport(year, month) {
    const eligibleEntries = payrollEligibleEntries(year, month);
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const minutesByDay = Array.from({ length: daysInMonth + 1 }, () => 0);
    eligibleEntries.forEach((entry) => {
      const dateIso = getEntryDateIso(entry);
      const dayString = dateIso ? dateIso.slice(-2) : '';
      const day = Number(dayString);
      if (!Number.isFinite(day)) return;
      minutesByDay[day] += Number(entry.duration_minutes) || 0;
    });
    const weeks = [];
    let cumulativeMinutes = 0;
    for (let start = 1; start <= daysInMonth; start += 7) {
      const end = Math.min(start + 6, daysInMonth);
      let weekMinutes = 0;
      const days = [];
      for (let offset = 0; offset < 7; offset += 1) {
        const day = start + offset;
        const existsInMonth = day <= daysInMonth;
        const dateObj = new Date(year, month, day);
        const minutes = existsInMonth ? (minutesByDay[day] || 0) : 0;
        if (existsInMonth) weekMinutes += minutes;
        days.push({
          date: dateObj,
          minutes,
          inMonth: existsInMonth
        });
      }
      cumulativeMinutes += weekMinutes;
      weeks.push({
        startDay: start,
        endDay: end,
        days,
        weekMinutes,
        cumulativeMinutes
      });
    }
    return {
      weeks,
      totalMinutes: cumulativeMinutes,
      hasEntries: eligibleEntries.length > 0
    };
  }
  function buildMyobPayrollReport(year, month) {
    const eligibleEntries = payrollEligibleEntries(year, month);
    const minutesByDate = eligibleEntries.reduce((map, entry) => {
      if (!entry.date) return map;
      map[entry.date] = (map[entry.date] || 0) + (Number(entry.duration_minutes) || 0);
      return map;
    }, {});
    const monthStart = startOfDay(new Date(year, month, 1));
    const monthEnd = startOfDay(new Date(year, month + 1, 0));
    const firstWeekStart = (() => {
      const first = new Date(monthStart);
      const offset = (first.getDay() + 6) % 7; // shift Sunday to 6, Monday to 0
      first.setDate(first.getDate() - offset);
      return startOfDay(first);
    })();
    const weeks = [];
    for (let cursor = new Date(firstWeekStart); cursor <= monthEnd; cursor.setDate(cursor.getDate() + 7)) {
      const weekStart = startOfDay(new Date(cursor));
      const weekEnd = startOfDay(new Date(cursor));
      weekEnd.setDate(weekEnd.getDate() + 6);
      const days = [];
      let weekMinutes = 0;
      for (let i = 0; i < 7; i += 1) {
        const dayDate = new Date(weekStart);
        dayDate.setDate(dayDate.getDate() + i);
        const key = isoDate(dayDate);
        const inMonth = dayDate >= monthStart && dayDate <= monthEnd;
        const minutes = inMonth ? (minutesByDate[key] || 0) : 0;
        if (inMonth) weekMinutes += minutes;
        days.push({
          date: dayDate,
          minutes,
          inMonth
        });
      }
      weeks.push({
        weekStart,
        weekEnd,
        days,
        weekMinutes
      });
      if (weekEnd >= monthEnd) break;
    }
    const totalMinutes = weeks.reduce((acc, week) => acc + week.weekMinutes, 0);
    return {
      weeks,
      totalMinutes,
      hasEntries: eligibleEntries.length > 0
    };
  }
  function entryContributesToIncome(entry) {
    if (!entry) return false;
    const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
    const hourType = hourTypeId ? state.hourTypeMap[hourTypeId] : null;
    if (hourType && Object.prototype.hasOwnProperty.call(hourType, 'contributes_to_income')) {
      return !!hourType.contributes_to_income;
    }
    return true;
  }
  function renderXeroPayrollHelper() {
    if (!xeroHelperContent) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const report = buildXeroPayrollReport(year, month);
    xeroHelperContent.innerHTML = '';

    report.weeks.forEach((week) => {
      const section = document.createElement('section');
      section.className = 'ts-payroll-week ts-payroll-xero';
      const rangeStart = new Date(year, month, week.startDay);
      const rangeEnd = new Date(year, month, week.endDay);

      const heading = document.createElement('div');
      heading.className = 'ts-payroll-week-header';
      const title = document.createElement('h4');
      title.textContent = `Week ending ${MONTH_DAY_FORMATTER.format(rangeEnd)}`;
      heading.appendChild(title);
      section.appendChild(heading);

      const table = document.createElement('table');
      table.className = 'ts-payroll-table ts-payroll-table-grid';
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      week.days.forEach((day) => {
        const th = document.createElement('th');
        const label = `${WEEKDAY_FORMATTER.format(day.date)} ${MONTH_DAY_FORMATTER.format(day.date)}`;
        th.textContent = label;
        if (!day.inMonth) th.classList.add('ts-payroll-outside');
        headRow.appendChild(th);
      });
      const weekHead = document.createElement('th');
      weekHead.textContent = 'Weekly total';
      weekHead.classList.add('ts-payroll-divider');
      headRow.appendChild(weekHead);
      const totalHead = document.createElement('th');
      totalHead.textContent = 'Month-to-date total';
      totalHead.classList.add('ts-payroll-divider');
      headRow.appendChild(totalHead);
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      const row = document.createElement('tr');
      week.days.forEach((day) => {
        const td = document.createElement('td');
        if (!day.inMonth) {
          td.classList.add('ts-payroll-outside');
          td.textContent = '';
        } else {
          const minutes = day.minutes || 0;
          const rounded = minutes > 0 ? roundDuration(minutes) : 0;
          td.textContent = formatDecimalHours(rounded / 60);
        }
        row.appendChild(td);
      });
      const weekMinutes = week.weekMinutes || 0;
      const roundedWeek = weekMinutes > 0 ? roundDuration(weekMinutes) : 0;
      const weekCell = document.createElement('td');
      weekCell.classList.add('ts-payroll-divider');
      weekCell.textContent = formatDecimalHours(roundedWeek / 60);
      row.appendChild(weekCell);
      const totalCell = document.createElement('td');
      const cumulativeMinutes = week.cumulativeMinutes || 0;
      const roundedTotal = cumulativeMinutes > 0 ? roundDuration(cumulativeMinutes) : 0;
      totalCell.textContent = formatDecimalHours(roundedTotal / 60);
      totalCell.classList.add('ts-payroll-divider');
      row.appendChild(totalCell);
      tbody.appendChild(row);
      table.appendChild(tbody);

      section.appendChild(table);
      xeroHelperContent.appendChild(section);
    });

    const total = document.createElement('div');
    total.className = 'ts-payroll-total';
    const totalMinutes = report.totalMinutes || 0;
    const roundedMonthlyTotal = totalMinutes > 0 ? roundDuration(totalMinutes) : 0;
    total.textContent = `Monthly total across all weeks: ${formatDecimalHours(roundedMonthlyTotal / 60)} hrs`;
    xeroHelperContent.appendChild(total);

    if (!report.hasEntries) {
      const empty = document.createElement('p');
      empty.className = 'ts-note';
      empty.textContent = 'No income-contributing hours logged for this month yet. Week ranges are shown with zero values so you can prepare entries ahead of time.';
      xeroHelperContent.appendChild(empty);
    }
  }
  function renderMyobPayrollHelper() {
    if (!myobHelperContent) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const report = buildMyobPayrollReport(year, month);
    myobHelperContent.innerHTML = '';

    report.weeks.forEach((week) => {
      const section = document.createElement('section');
      section.className = 'ts-payroll-week ts-payroll-myob';

      const heading = document.createElement('div');
      heading.className = 'ts-payroll-week-header';
      const title = document.createElement('h4');
      title.textContent = `Week of ${MONTH_DAY_FORMATTER.format(week.weekStart)}`;
      heading.appendChild(title);
      section.appendChild(heading);

      const table = document.createElement('table');
      table.className = 'ts-payroll-table ts-myob-table';
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      week.days.forEach((day) => {
        const th = document.createElement('th');
        th.textContent = `${WEEKDAY_FORMATTER.format(day.date)} ${MONTH_DAY_FORMATTER.format(day.date)}`;
        if (!day.inMonth) th.classList.add('ts-payroll-outside');
        headRow.appendChild(th);
      });
      const totalHead = document.createElement('th');
      totalHead.textContent = 'Week total';
      headRow.appendChild(totalHead);
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      const row = document.createElement('tr');
      week.days.forEach((day) => {
        const td = document.createElement('td');
        if (!day.inMonth) {
          td.classList.add('ts-payroll-outside');
          td.textContent = '';
        } else {
          const minutes = day.minutes || 0;
          const rounded = minutes > 0 ? roundDuration(minutes) : 0;
          td.textContent = formatDecimalHours(rounded / 60);
        }
        row.appendChild(td);
      });
      const totalCell = document.createElement('td');
      const weekMinutes = week.weekMinutes || 0;
      const roundedTotal = weekMinutes > 0 ? roundDuration(weekMinutes) : 0;
      totalCell.textContent = formatDecimalHours(roundedTotal / 60);
      row.appendChild(totalCell);
      tbody.appendChild(row);
      table.appendChild(tbody);
      section.appendChild(table);
      myobHelperContent.appendChild(section);
    });

    const total = document.createElement('div');
    total.className = 'ts-payroll-total';
    const totalMinutes = report.totalMinutes || 0;
    const roundedMonthlyTotal = totalMinutes > 0 ? roundDuration(totalMinutes) : 0;
    total.textContent = `Monthly total across all weeks: ${formatDecimalHours(roundedMonthlyTotal / 60)} hrs`;
    myobHelperContent.appendChild(total);

    if (!report.hasEntries) {
      const empty = document.createElement('p');
      empty.className = 'ts-note';
      empty.textContent = 'No income-contributing hours logged for this month yet. Weekly ranges include out-of-month days for context; in-month days show 0 hrs.';
      myobHelperContent.appendChild(empty);
    }
  }
  function updatePayrollHelperButtons() {
    if (!payrollXeroBtn && !payrollMyobBtn) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const hasEligibleEntries = payrollEligibleEntries(year, month).length > 0;
    if (payrollXeroBtn) {
      const visible = getFeatureFlag('xero_payroll_helper');
      payrollXeroBtn.style.display = visible ? 'inline-flex' : 'none';
      payrollXeroBtn.setAttribute('aria-disabled', visible && !hasEligibleEntries ? 'true' : 'false');
      payrollXeroBtn.title = visible && !hasEligibleEntries
        ? 'No income-contributing hours logged yet in this month'
        : 'Open the Xero payroll helper';
    }
    if (payrollMyobBtn) {
      const visible = getFeatureFlag('myob_payroll_helper');
      payrollMyobBtn.style.display = visible ? 'inline-flex' : 'none';
      payrollMyobBtn.setAttribute('aria-disabled', visible && !hasEligibleEntries ? 'true' : 'false');
      payrollMyobBtn.title = visible && !hasEligibleEntries
        ? 'No income-contributing hours logged yet in this month'
        : 'Open the MYOB payroll helper';
    }
    // Update actual income button visibility
    if (actualIncomeBtn) {
      const visible = getFeatureFlag('enable_actual_income');
      actualIncomeBtn.style.display = visible ? 'inline-flex' : 'none';
      actualIncomeBtn.title = 'Add or view actual income for the current month';
    }
    // Update print monthly button visibility
    if (printMonthlyBtn) {
      const visible = getFeatureFlag('enable_monthly_print_view');
      printMonthlyBtn.style.display = visible ? 'inline-flex' : 'none';
      printMonthlyBtn.title = 'Generate printable monthly hours view';
    }
    if (timesheet1Btn) {
      const visible = getFeatureFlag('enable_timesheet1_importer');
      timesheet1Btn.style.display = visible ? 'inline-flex' : 'none';
      timesheet1Btn.title = 'Import legacy Timesheet 1.0 hours from Google Sheets';
    }
  }

  // Actual Income Functions
  function openActualIncomeModal() {
    if (!actualIncomeModal) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const monthStr = `${year}-${String(month + 1).padStart(2, '0')}`;

    // Format month display text to match calendar (e.g., "October 2025")
    const monthDate = new Date(year, month, 1);
    const monthDisplayText = monthDate.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    if (actualIncomeMonthDisplay) actualIncomeMonthDisplay.textContent = monthDisplayText;

    // Check if there's existing data for this month
    const existing = state.actualIncome.find(item => item.month === monthStr);

    if (existing) {
      state.editingActualIncomeId = existing.id;
      if (actualIncomeTitle) actualIncomeTitle.textContent = 'Edit Actual Income';
      if (actualIncomeMonthInput) actualIncomeMonthInput.value = existing.month;
      if (actualIncomeGrossInput) actualIncomeGrossInput.value = existing.gross_income;
      if (actualIncomeSuperInput) actualIncomeSuperInput.value = existing.superannuation;
      if (actualIncomeTaxInput) actualIncomeTaxInput.value = existing.tax;
      if (actualIncomeNetInput) actualIncomeNetInput.value = existing.net_income;
      if (btnDeleteActualIncome) btnDeleteActualIncome.style.display = 'inline-flex';
    } else {
      state.editingActualIncomeId = null;
      if (actualIncomeTitle) actualIncomeTitle.textContent = 'Add Actual Income';
      if (actualIncomeMonthInput) actualIncomeMonthInput.value = monthStr;
      if (actualIncomeGrossInput) actualIncomeGrossInput.value = '';
      if (actualIncomeSuperInput) actualIncomeSuperInput.value = '';
      if (actualIncomeTaxInput) actualIncomeTaxInput.value = '';
      if (actualIncomeNetInput) actualIncomeNetInput.value = '';
      if (btnDeleteActualIncome) btnDeleteActualIncome.style.display = 'none';
    }

    showModal(actualIncomeModal);
  }

  function closeActualIncomeModal() {
    if (!actualIncomeModal) return;
    hideModal(actualIncomeModal);
    state.editingActualIncomeId = null;
  }

  async function saveActualIncome() {
    if (!actualIncomeMonthInput || !actualIncomeGrossInput || !actualIncomeSuperInput ||
        !actualIncomeTaxInput || !actualIncomeNetInput) return;

    const payload = {
      id: state.editingActualIncomeId || undefined,
      month: actualIncomeMonthInput.value,
      gross_income: Number(actualIncomeGrossInput.value) || 0,
      superannuation: Number(actualIncomeSuperInput.value) || 0,
      tax: Number(actualIncomeTaxInput.value) || 0,
      net_income: Number(actualIncomeNetInput.value) || 0
    };

    // Optimistic update
    const previousList = state.actualIncome.slice();
    if (state.editingActualIncomeId) {
      const index = state.actualIncome.findIndex(item => item.id === state.editingActualIncomeId);
      if (index !== -1) {
        state.actualIncome[index] = { ...state.actualIncome[index], ...payload };
      }
    } else {
      const tempId = 'temp_' + Date.now();
      state.actualIncome.push({ ...payload, id: tempId, created_at: '', updated_at: '' });
    }
    refreshActualIncomeMap();
    saveCache();
    renderIncomeSummary();
    closeActualIncomeModal();
    setStatus('Saving actual income...', 'warn');

    google.script.run
      .withSuccessHandler((response) => {
        if (response && response.success && response.actualIncome) {
          const updated = response.actualIncome;
          const index = state.actualIncome.findIndex(item =>
            item.id === state.editingActualIncomeId || item.id === updated.id || item.id.startsWith('temp_')
          );
          if (index !== -1) {
            state.actualIncome[index] = updated;
          } else {
            state.actualIncome.push(updated);
          }
          refreshActualIncomeMap();
          saveCache();
          renderIncomeSummary();
          setStatus('Actual income saved', 'success');
        } else {
          state.actualIncome = previousList;
          refreshActualIncomeMap();
          saveCache();
          renderIncomeSummary();
          setStatus('Actual income save failed', 'error');
        }
      })
      .withFailureHandler(() => {
        state.actualIncome = previousList;
        refreshActualIncomeMap();
        saveCache();
        renderIncomeSummary();
        setStatus('Actual income save failed', 'error');
      })
      .api_upsertActualIncome(payload);
  }

  async function deleteActualIncome() {
    if (!state.editingActualIncomeId) return;
    const confirmed = await customConfirm('Delete this actual income entry?', { danger: true });
    if (!confirmed) return;

    const previousList = state.actualIncome.slice();
    state.actualIncome = state.actualIncome.filter(item => item.id !== state.editingActualIncomeId);
    refreshActualIncomeMap();
    saveCache();
    renderIncomeSummary();
    closeActualIncomeModal();
    setStatus('Deleting actual income...', 'warn');

    google.script.run
      .withSuccessHandler(() => {
        setStatus('Actual income deleted', 'success');
      })
      .withFailureHandler(() => {
        state.actualIncome = previousList;
        refreshActualIncomeMap();
        saveCache();
        renderIncomeSummary();
        setStatus('Failed to delete actual income', 'error');
      })
      .api_deleteActualIncome(state.editingActualIncomeId);
  }

  function refreshActualIncomeMap() {
    state.actualIncomeMap = {};
    state.actualIncome.forEach(item => {
      state.actualIncomeMap[item.month] = item;
    });
  }

  // Timesheet 1.0 Importer
  function resetTimesheet1State() {
    timesheet1State = { mapping: {}, contractSelections: {}, preview: null, skipPublicHolidays: true };
    if (timesheet1Status) {
      timesheet1Status.className = 'ts-note';
      timesheet1Status.textContent = '';
    }
    if (timesheet1RunBtn) timesheet1RunBtn.disabled = true;
    if (timesheet1MappingSection) timesheet1MappingSection.style.display = 'none';
    if (timesheet1MappingList) timesheet1MappingList.innerHTML = '';
    if (timesheet1ContractSection) timesheet1ContractSection.style.display = 'none';
    if (timesheet1ContractList) timesheet1ContractList.innerHTML = '';
    if (timesheet1PreviewSection) timesheet1PreviewSection.style.display = 'none';
    if (timesheet1PreviewSummary) timesheet1PreviewSummary.innerHTML = '';
    if (timesheet1ImportSummary) {
      timesheet1ImportSummary.style.display = 'none';
      timesheet1ImportSummary.innerHTML = '';
    }
    if (timesheet1SkipHolidaysToggle) timesheet1SkipHolidaysToggle.checked = true;
  }

  function setTimesheet1Status(message, tone) {
    if (!timesheet1Status) return;
    timesheet1Status.className = (tone === 'error' || tone === 'warn') ? 'ts-warning' : 'ts-note';
    timesheet1Status.textContent = message || '';
  }

  function openTimesheet1Importer() {
    if (!timesheet1Modal) return;
    resetTimesheet1State();
    showModal(timesheet1Modal);
    if (timesheet1FileInput) {
      timesheet1FileInput.readOnly = false;
      timesheet1FileInput.focus();
    }
  }

  function closeTimesheet1Importer() {
    if (!timesheet1Modal) return;
    hideModal(timesheet1Modal);
  }

  function formatMonthLabel(monthKey, fallback) {
    if (!monthKey) return fallback || '';
    const parts = monthKey.split('-');
    if (parts.length !== 2) return fallback || monthKey;
    const year = Number(parts[0]);
    const month = Number(parts[1]) - 1;
    if (!Number.isFinite(year) || !Number.isFinite(month)) return fallback || monthKey;
    const date = new Date(year, month, 1);
    if (Number.isNaN(date.getTime())) return fallback || monthKey;
    return date.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
  }

  function monthOrderIndex(monthKey, sheetName) {
    if (monthKey) {
      const parts = monthKey.split('-');
      if (parts.length === 2) {
        const monthNum = Number(parts[1]);
        if (monthNum >= 1 && monthNum <= 12) return monthNum - 1;
      }
    }
    const name = (sheetName || '').toLowerCase();
    const idx = MONTH_ORDER.indexOf(name);
    return idx === -1 ? Number.POSITIVE_INFINITY : idx;
  }

  function onTimesheet1MappingChange(event) {
    const select = event.target;
    const label = select.dataset.label;
    if (!label) return;
    const value = select.value;
    timesheet1State.mapping[label] = value || '';
    if (timesheet1RunBtn) timesheet1RunBtn.disabled = true;
    setTimesheet1Status('Mapping changed. Re-run Preview so duplicates, contracts, and totals use your new mapping.', 'warn');
  }

  function renderTimesheet1Mapping(mapping) {
    if (!timesheet1MappingList || !timesheet1MappingSection) return;
    const labels = Object.keys(mapping || {});
    if (!labels.length) {
      timesheet1MappingSection.style.display = 'none';
      timesheet1MappingList.innerHTML = '';
      return;
    }
    timesheet1MappingSection.style.display = 'block';
    labels.sort((a, b) => a.localeCompare(b));
    timesheet1MappingList.innerHTML = '';

    labels.forEach((label) => {
      const item = mapping[label] || {};
      const row = document.createElement('div');
      row.className = 'ts-grid ts-grid--gap-sm';
      row.style.alignItems = 'center';

      const labelCell = document.createElement('div');
      labelCell.className = 'ts-col-span-4';
      labelCell.style.fontWeight = '600';
      labelCell.textContent = label;

      const selectCell = document.createElement('div');
      selectCell.className = 'ts-col-span-8';
      const select = document.createElement('select');
      select.dataset.label = label;
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select hour type';
      select.appendChild(placeholder);
      state.hourTypes.forEach((ht) => {
        const opt = document.createElement('option');
        opt.value = ht.id;
        opt.textContent = ht.name;
        if (item.hour_type_id === ht.id) opt.selected = true;
        select.appendChild(opt);
      });
      select.addEventListener('change', onTimesheet1MappingChange);
      selectCell.appendChild(select);

      row.appendChild(labelCell);
      row.appendChild(selectCell);
      timesheet1MappingList.appendChild(row);

      // Persist mapping state
      timesheet1State.mapping[label] = item.hour_type_id || '';
    });
  }

  function onTimesheet1ContractChange(event) {
    const select = event.target;
    const selectionKey = select.dataset.selectionKey;
    if (!selectionKey) return;
    const value = select.value;
    timesheet1State.contractSelections[selectionKey] = value || '';
    if (timesheet1RunBtn) timesheet1RunBtn.disabled = true;
    setTimesheet1Status('Contract selection changed. Re-run Preview so validation and totals match your selection.', 'warn');
  }

  function renderTimesheet1Contracts(months) {
    if (!timesheet1ContractList || !timesheet1ContractSection) return;
    const pending = [];
    const missing = [];
    (months || []).forEach((month) => {
      (month.needsContractSelection || []).forEach((item) => {
        pending.push({
          month: month.month,
          sheetName: month.sheetName,
          hourTypeId: item.hourTypeId,
          hourTypeName: item.hourTypeName,
          selectionKey: item.selectionKey,
          options: item.options || []
        });
      });
      if (month.missingContracts && month.missingContracts.length) {
        missing.push(month);
      }
    });

    // Sort pending by calendar order
    pending.sort((a, b) => monthOrderIndex(a.month, a.sheetName) - monthOrderIndex(b.month, b.sheetName));

    if (!pending.length && !missing.length) {
      timesheet1ContractSection.style.display = 'none';
      timesheet1ContractList.innerHTML = '';
      return;
    }

    timesheet1ContractSection.style.display = 'block';
    timesheet1ContractList.innerHTML = '';

    if (missing.length) {
      const missingNote = document.createElement('div');
      missingNote.className = 'ts-warning';
      const seen = new Set();
      const monthList = missing
        .map((m) => formatMonthLabel(m.month, m.sheetName || m.month || 'Unknown'))
        .filter((label) => {
          if (seen.has(label)) return false;
          seen.add(label);
          return true;
        })
        .join(', ');
      missingNote.textContent = `No valid contract covers: ${monthList}. Add or update contracts to cover those months before importing.`;
      timesheet1ContractList.appendChild(missingNote);
    }

    pending.forEach((item) => {
      const row = document.createElement('div');
      row.className = 'ts-grid ts-grid--gap-sm';
      row.style.alignItems = 'center';

      const label = document.createElement('div');
      label.className = 'ts-col-span-4';
      const monthLabel = formatMonthLabel(item.month, item.month);
      label.innerHTML = `<div style="font-weight:600;">${item.hourTypeName}</div><div class="ts-note">${monthLabel}</div>`;

      const selectCell = document.createElement('div');
      selectCell.className = 'ts-col-span-8';
      const select = document.createElement('select');
      select.dataset.selectionKey = item.selectionKey;
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select contract';
      select.appendChild(placeholder);

      item.options.forEach((opt) => {
        const option = document.createElement('option');
        option.value = opt.id;
        const end = opt.end_date ? ` to ${opt.end_date}` : '';
        option.textContent = `${opt.name} (${opt.start_date}${end || ''})`;
        if (timesheet1State.contractSelections[item.selectionKey] === opt.id) option.selected = true;
        select.appendChild(option);
      });

      // Auto-select when only one option exists and none chosen yet
      if (!timesheet1State.contractSelections[item.selectionKey] && item.options.length === 1) {
        timesheet1State.contractSelections[item.selectionKey] = item.options[0].id;
        select.value = item.options[0].id;
      }

      select.addEventListener('change', onTimesheet1ContractChange);
      selectCell.appendChild(select);

      row.appendChild(label);
      row.appendChild(selectCell);
      timesheet1ContractList.appendChild(row);
    });
  }

  function renderTimesheet1Preview(preview) {
    if (!timesheet1PreviewSection || !timesheet1PreviewSummary) return;
    if (!preview || !preview.success) {
      resetTimesheet1State();
      return;
    }

    renderTimesheet1Mapping(preview.mapping || {});
    renderTimesheet1Contracts(preview.months || []);

    const monthsSorted = (preview.months || []).slice().sort((a, b) => {
      return monthOrderIndex(a.month, a.sheetName) - monthOrderIndex(b.month, b.sheetName);
    });

    const totalImportable = preview.totals ? (preview.totals.importable || 0) : 0;
    const totalDuplicates = preview.totals ? (preview.totals.duplicates || 0) : 0;
    const totalSkippedHolidays = preview.totals ? (preview.totals.skippedPublicHolidays || 0) : 0;
    const totalUnmapped = preview.totals ? (preview.totals.unmapped || 0) : 0;
    const hasMissingContracts = monthsSorted.some((m) => (m.missingContracts || []).length > 0);
    const needsContractSelection = monthsSorted.some((m) => (m.needsContractSelection || []).length > 0);

    const rows = monthsSorted.map((month) => {
      const monthLabel = formatMonthLabel(month.month, month.sheetName || month.month || 'Unknown month');
      const totals = (month.totalsByHourType || []).map((t) => {
        const hours = (t.minutes || 0) / 60;
        return `<div class="ts-preview-row"><span>${t.hourTypeName}</span><span>${hours.toFixed(2)} hrs (${t.entries} entries)</span></div>`;
      }).join('') || '<div class="ts-note">No importable entries</div>';

      const dupes = (month.duplicateExamples || []).slice(0, 3).map((d) => {
        return `<div class="ts-note">Duplicate on ${d.date} (${d.hourTypeName})</div>`;
      }).join('');

      const unmapped = (month.unmapped || []).length
        ? `<div class="ts-warning">${month.unmapped.length} entries need hour type mapping.</div>`
        : '';
      const missingContracts = (month.missingContracts || []).length
        ? `<div class="ts-warning">${month.missingContracts.length} contract gaps detected.</div>`
        : '';

      return `
        <div class="ts-panel" style="padding:12px;">
          <div style="font-weight:700; margin-bottom:6px;">${monthLabel}</div>
          ${totals}
          ${dupes}
          ${unmapped}
          ${missingContracts}
        </div>
      `;
    }).join('');

    timesheet1PreviewSection.style.display = 'block';
    timesheet1PreviewSummary.innerHTML = `
      <div class="ts-grid ts-grid--gap-sm" style="margin-bottom:12px;">
        <div class="ts-col-span-6"><strong>Importable entries</strong><div>${totalImportable}</div></div>
        <div class="ts-col-span-6"><strong>Already in Tempus</strong><div>${totalDuplicates}</div></div>
        ${totalSkippedHolidays ? `<div class="ts-col-span-6"><strong>Skipped public holidays</strong><div>${totalSkippedHolidays}</div></div>` : ''}
      </div>
      ${rows}
    `;

    const blocking = totalUnmapped > 0 || hasMissingContracts || needsContractSelection || totalImportable === 0;
    if (timesheet1RunBtn) timesheet1RunBtn.disabled = blocking;

    if (totalUnmapped > 0) {
      setTimesheet1Status('Map hour types before importing.', 'warn');
    } else if (hasMissingContracts) {
      setTimesheet1Status('Add contracts covering these dates before importing.', 'warn');
    } else if (needsContractSelection) {
      setTimesheet1Status('Select a contract for each hour type/month before importing.', 'warn');
    } else if (totalImportable === 0) {
      setTimesheet1Status('No new entries to import (all duplicates).', 'warn');
    } else {
      setTimesheet1Status('Preview ready. Review and click Import.', 'success');
    }

    if (timesheet1ImportSummary) {
      timesheet1ImportSummary.style.display = 'none';
      timesheet1ImportSummary.innerHTML = '';
    }
  }

  function previewTimesheet1Import() {
    if (!timesheet1FileInput) return;
    const spreadsheetId = timesheet1FileInput.value.trim();
    if (!spreadsheetId) {
      setTimesheet1Status('Enter the Google Sheets file ID to preview.', 'error');
      return;
    }
    setTimesheet1Status('Loading preview...', 'warn');
    if (timesheet1RunBtn) timesheet1RunBtn.disabled = true;

    const payload = {
      spreadsheetId,
      hourTypeMapping: timesheet1State.mapping,
      contractSelections: timesheet1State.contractSelections,
      skipPublicHolidays: timesheet1SkipHolidaysToggle ? !!timesheet1SkipHolidaysToggle.checked : true
    };

    timesheet1State.skipPublicHolidays = payload.skipPublicHolidays;

    google.script.run
      .withSuccessHandler((res) => {
        console.log('[Timesheet1] Preview response', res);
        if (res && res.success) {
          timesheet1State.preview = res;
          timesheet1State.mapping = res.mapping || {};
          renderTimesheet1Preview(res);
        } else {
          const message = res && (res.message || res.error) ? `Preview failed: ${res.message || res.error}` : 'Preview failed. Please check the file ID.';
          setTimesheet1Status(message, 'error');
        }
      })
      .withFailureHandler((err) => {
        console.log('[Timesheet1] Preview failed', err);
        const message = err && err.message ? err.message : 'Preview failed. Please check the file ID.';
        setTimesheet1Status(message, 'error');
      })
      .api_previewTimesheet1Import(payload);
  }

  function hideTimesheet1ContentSections() {
    if (timesheet1MappingSection) timesheet1MappingSection.style.display = 'none';
    if (timesheet1ContractSection) timesheet1ContractSection.style.display = 'none';
    if (timesheet1PreviewSection) timesheet1PreviewSection.style.display = 'none';
    if (timesheet1ImportSummary) timesheet1ImportSummary.style.display = 'none';
    if (timesheet1PreviewSummary) timesheet1PreviewSummary.innerHTML = '';
    if (timesheet1MappingList) timesheet1MappingList.innerHTML = '';
    if (timesheet1ContractList) timesheet1ContractList.innerHTML = '';
  }

  function runTimesheet1Import() {
    if (!timesheet1State.preview || !timesheet1State.preview.success) {
      setTimesheet1Status('Run a preview before importing.', 'error');
      return;
    }
    if (timesheet1RunBtn) timesheet1RunBtn.disabled = true;
    setTimesheet1Status('Importing entries...', 'warn');
    hideTimesheet1ContentSections();
    if (timesheet1FileInput) timesheet1FileInput.readOnly = true;

    const importProgress = {
      imported: 0,
      skippedDuplicates: 0,
      summaryMap: {}
    };

    const mergeImportSummaryIntoMap = (map, list) => {
      (list || []).forEach((item) => {
        if (!item) return;
        const key = `${item.month || ''}|${item.hourTypeId || item.hour_type_id || item.hour_type || ''}`;
        if (!map[key]) {
          map[key] = { ...item, entries: item.entries || 0, minutes: item.minutes || 0 };
        } else {
          map[key].entries += item.entries || 0;
          map[key].minutes += item.minutes || 0;
        }
      });
    };

    const summaryMapToList = (map) => Object.keys(map || {}).map((k) => map[k]);

    const renderFinal = (res) => {
      const finalRes = {
        ...res,
        imported: importProgress.imported,
        skippedDuplicates: importProgress.skippedDuplicates,
        importSummary: summaryMapToList(importProgress.summaryMap)
      };
      timesheet1State.preview = finalRes.preview || timesheet1State.preview;
      // Keep content sections hidden after import completes
      if (timesheet1ImportSummary && finalRes.importSummary && finalRes.importSummary.length) {
        const byMonth = {};
        (finalRes.importSummary || []).forEach((item) => {
          const key = item.month || 'unknown';
          if (!byMonth[key]) byMonth[key] = [];
          byMonth[key].push(item);
        });

        const monthBlocks = Object.keys(byMonth).map((monthKey) => {
          const label = formatMonthLabel(monthKey, monthKey === 'unknown' ? 'Imported entries' : monthKey);
          const lines = byMonth[monthKey].map((item) => {
            const hours = (item.minutes || 0) / 60;
            return `<div>${item.hourTypeName}, ${hours.toFixed(2)} hrs (${item.entries} entries)</div>`;
          }).join('');
          return `
            <div class="ts-panel" style="padding:12px;">
              <div style="font-weight:700; margin-bottom:6px;">${label}</div>
              ${lines}
            </div>
          `;
        }).join('');

        timesheet1ImportSummary.innerHTML = `
          <div style="font-weight:700; margin-bottom:6px;">Import complete</div>
          ${monthBlocks}
        `;
        timesheet1ImportSummary.style.display = 'block';
      }
      refreshEntriesFromServer(() => {
        markAllIncomeSummariesDirty();
        renderIncomeSummary();
        onCalendarMonthChange();
        if (state.currentPage === 'annual-views') {
          loadAnnualData();
        }
        setStatus(`Imported ${finalRes.imported || 0} entries (skipped ${finalRes.skippedDuplicates || 0} duplicates).`, 'success');
      });
      setTimesheet1Status(`Import complete. Imported ${finalRes.imported || 0} entries (skipped ${finalRes.skippedDuplicates || 0} duplicates). Please refresh your browser before running another import to ensure data is synced.`, 'success');
    };

    const handleSuccess = (res) => {
      console.log('[Timesheet1] Import response', res);
      if (!res || !res.success) {
        const message = res && (res.message || res.error) ? `Import failed: ${res.message || res.error}` : 'Import failed. Resolve blocking issues and try again.';
        setTimesheet1Status(message, 'error');
        return;
      }

      if (res.preview) {
        timesheet1State.preview = res.preview;
      }

      importProgress.imported += res.imported || 0;
      importProgress.skippedDuplicates += res.skippedDuplicates || 0;
      mergeImportSummaryIntoMap(importProgress.summaryMap, res.importSummary || []);

      if (res.partial && res.continuation) {
        const nextPayload = {
          continuation: {
            ...res.continuation,
            progress: {
              imported: importProgress.imported,
              skippedDuplicates: importProgress.skippedDuplicates,
              importSummary: importProgress.summaryMap
            }
          }
        };
        const remainingCount = (res.continuation.workItems || []).length;
        setTimesheet1Status(`Importing entries... (${importProgress.imported} added so far, ${importProgress.skippedDuplicates} duplicates skipped; ${remainingCount} remaining)`, 'warn');
        google.script.run
          .withSuccessHandler(handleSuccess)
          .withFailureHandler((err) => {
            console.log('[Timesheet1] Import failed', err);
            const message = err && err.message ? err.message : 'Import failed. Resolve blocking issues and try again.';
            setTimesheet1Status(message, 'error');
          })
          .api_runTimesheet1Import(nextPayload);
        return;
      }

      renderFinal(res);
    };

    const payload = {
      spreadsheetId: timesheet1State.preview.spreadsheetId,
      hourTypeMapping: timesheet1State.mapping,
      contractSelections: timesheet1State.contractSelections,
      skipPublicHolidays: timesheet1State.skipPublicHolidays,
      preview: timesheet1State.preview
    };

    google.script.run
      .withSuccessHandler(handleSuccess)
      .withFailureHandler((err) => {
        console.log('[Timesheet1] Import failed', err);
        const message = err && err.message ? err.message : 'Import failed. Resolve blocking issues and try again.';
        setTimesheet1Status(message, 'error');
      })
      .api_runTimesheet1Import(payload);
  }

  // Monthly Print View Functions
  let printViewSelectedHourTypes = new Set();

  function openPrintViewConfigModal() {
    if (!printViewConfigModal) return;
    ensureCalendarState();
    const { year, month } = state.calendar;

    // Get all entries for the current month
    const monthEntries = entriesForMonth(year, month);

    if (monthEntries.length === 0) {
      customAlert('No time entries for this month', 'No entries to print');
      return;
    }

    // Get unique hour type IDs from the entries
    const hourTypeIds = new Set();
    monthEntries.forEach(entry => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      hourTypeIds.add(hourTypeId);
    });

    // Separate into income and non-income hour types
    const incomeTypes = [];
    const otherTypes = [];

    hourTypeIds.forEach(id => {
      const hourType = state.hourTypeMap[id];
      if (hourType) {
        if (hourType.contributes_to_income) {
          incomeTypes.push(hourType);
        } else {
          otherTypes.push(hourType);
        }
      }
    });

    // Initialize all selected by default
    printViewSelectedHourTypes.clear();
    incomeTypes.forEach(ht => printViewSelectedHourTypes.add(ht.id));
    otherTypes.forEach(ht => printViewSelectedHourTypes.add(ht.id));

    // Helper to create hour type row
    function createHourTypeRow(hourType, isIncome) {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.justifyContent = 'space-between';
      row.style.alignItems = 'center';
      row.style.padding = '8px';
      row.style.borderRadius = '6px';
      row.style.transition = 'background 0.15s ease';

      const leftSide = document.createElement('div');
      leftSide.style.display = 'flex';
      leftSide.style.alignItems = 'center';
      leftSide.style.gap = '8px';

      const colorDot = document.createElement('span');
      colorDot.style.width = '12px';
      colorDot.style.height = '12px';
      colorDot.style.borderRadius = '50%';
      colorDot.style.backgroundColor = hourType.color || '#6b7280';
      colorDot.style.flexShrink = '0';

      const name = document.createElement('span');
      name.textContent = hourType.name;

      leftSide.appendChild(colorDot);
      leftSide.appendChild(name);

      const toggleLabel = document.createElement('label');
      toggleLabel.className = 'ts-toggle';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = true;
      checkbox.dataset.hourTypeId = hourType.id;
      checkbox.dataset.isIncome = isIncome ? 'true' : 'false';
      checkbox.addEventListener('change', updatePrintViewSelection);

      const track = document.createElement('span');
      track.className = 'ts-toggle-track';
      const thumb = document.createElement('span');
      thumb.className = 'ts-toggle-thumb';
      track.appendChild(thumb);

      toggleLabel.appendChild(checkbox);
      toggleLabel.appendChild(track);

      row.appendChild(leftSide);
      row.appendChild(toggleLabel);

      return row;
    }

    // Render income hour types
    if (printViewIncomeList) {
      printViewIncomeList.innerHTML = '';
      if (incomeTypes.length === 0) {
        const note = document.createElement('div');
        note.className = 'ts-note';
        note.textContent = 'No income-generating hour types in this month';
        printViewIncomeList.appendChild(note);
      } else {
        incomeTypes.forEach(hourType => {
          printViewIncomeList.appendChild(createHourTypeRow(hourType, true));
        });
      }
    }

    // Render other hour types
    if (printViewOtherList) {
      printViewOtherList.innerHTML = '';
      if (otherTypes.length === 0) {
        const note = document.createElement('div');
        note.className = 'ts-note';
        note.textContent = 'No non-income hour types in this month';
        printViewOtherList.appendChild(note);
      } else {
        otherTypes.forEach(hourType => {
          printViewOtherList.appendChild(createHourTypeRow(hourType, false));
        });
      }
    }

    // Validate initial selection - require at least 1 income type and max 2 non-income types
    const selectedIncome = incomeTypes.length; // All are selected by default
    const selectedNonIncome = otherTypes.length; // All are selected by default
    const invalidIncome = selectedIncome === 0;
    const invalidNonIncome = selectedNonIncome > 2;
    const isInvalid = invalidIncome || invalidNonIncome;

    if (printViewWarning) {
      printViewWarning.style.display = isInvalid ? 'block' : 'none';
      if (printViewWarningText) {
        if (invalidIncome && invalidNonIncome) {
          printViewWarningText.textContent = 'Select at least one income hour type and keep non-income hour types to two or fewer.';
        } else if (invalidIncome) {
          printViewWarningText.textContent = 'Select at least one income hour type.';
        } else if (invalidNonIncome) {
          printViewWarningText.textContent = 'Maximum 2 non-income hour types allowed.';
        }
      }
    }
    if (btnGeneratePrintView) {
      btnGeneratePrintView.disabled = isInvalid || printViewSelectedHourTypes.size === 0;
    }

    showModal(printViewConfigModal);
  }

  function updatePrintViewSelection(event) {
    const checkbox = event.target;
    const hourTypeId = checkbox.dataset.hourTypeId;

    if (checkbox.checked) {
      printViewSelectedHourTypes.add(hourTypeId);
    } else {
      printViewSelectedHourTypes.delete(hourTypeId);
    }

    // Validate: at least one income type and max 2 non-income types
    const selectedIncome = Array.from(printViewSelectedHourTypes).filter(id => {
      const hourType = state.hourTypeMap[id];
      return hourType && hourType.contributes_to_income;
    });

    const selectedNonIncome = Array.from(printViewSelectedHourTypes).filter(id => {
      const hourType = state.hourTypeMap[id];
      return hourType && !hourType.contributes_to_income;
    });

    const invalidIncome = selectedIncome.length === 0;
    const invalidNonIncome = selectedNonIncome.length > 2;
    const isInvalid = invalidIncome || invalidNonIncome;

    if (printViewWarning) {
      printViewWarning.style.display = isInvalid ? 'block' : 'none';
      if (printViewWarningText) {
        if (invalidIncome && invalidNonIncome) {
          printViewWarningText.textContent = 'Select at least one income hour type and keep non-income hour types to two or fewer.';
        } else if (invalidIncome) {
          printViewWarningText.textContent = 'Select at least one income hour type.';
        } else if (invalidNonIncome) {
          printViewWarningText.textContent = 'Maximum 2 non-income hour types allowed.';
        }
      }
    }
    if (btnGeneratePrintView) {
      btnGeneratePrintView.disabled = isInvalid || printViewSelectedHourTypes.size === 0;
    }
  }

  function closePrintViewConfigModal() {
    if (!printViewConfigModal) return;
    hideModal(printViewConfigModal);
    printViewSelectedHourTypes.clear();
  }

  function unselectAllOtherHourTypes() {
    if (!printViewOtherList) return;

    // Find all checkboxes in the other hour types list and uncheck them
    const checkboxes = printViewOtherList.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(checkbox => {
      if (checkbox.checked) {
        checkbox.checked = false;
        const hourTypeId = checkbox.dataset.hourTypeId;
        printViewSelectedHourTypes.delete(hourTypeId);
      }
    });

    // Update validation state - check if at least 1 income type is selected
    const selectedIncome = Array.from(printViewSelectedHourTypes).filter(id => {
      const hourType = state.hourTypeMap[id];
      return hourType && hourType.contributes_to_income;
    });

    const invalidIncome = selectedIncome.length === 0;
    const isInvalid = invalidIncome;

    if (printViewWarning) {
      printViewWarning.style.display = isInvalid ? 'block' : 'none';
      if (printViewWarningText && invalidIncome) {
        printViewWarningText.textContent = 'Select at least one income hour type.';
      }
    }
    if (btnGeneratePrintView) {
      btnGeneratePrintView.disabled = isInvalid || printViewSelectedHourTypes.size === 0;
    }
  }

  function generatePrintView() {
    ensureCalendarState();
    const { year, month } = state.calendar;

    if (printViewSelectedHourTypes.size === 0) {
      return;
    }

    // Get rounding interval
    const roundInterval = getRoundInterval();

    // Helper to format hours with rounding
    function formatHours(minutes) {
      let displayMinutes = minutes;
      if (roundInterval > 1 && minutes > 0) {
        displayMinutes = Math.max(roundInterval, Math.round(minutes / roundInterval) * roundInterval);
      }
      return (displayMinutes / 60).toFixed(2);
    }

    // Get selected hour types
    const selectedTypes = Array.from(printViewSelectedHourTypes)
      .map(id => state.hourTypeMap[id])
      .filter(Boolean)
      .sort((a, b) => {
        // Sort income types first
        if (a.contributes_to_income && !b.contributes_to_income) return -1;
        if (!a.contributes_to_income && b.contributes_to_income) return 1;
        return a.name.localeCompare(b.name);
      });

    // Get all entries for the month
    const monthEntries = entriesForMonth(year, month);

    const selectedIncomeTypes = selectedTypes.filter(ht => ht.contributes_to_income);
    const incomeAccent = selectedIncomeTypes.length ? (selectedIncomeTypes[0].color || '#0d6efd') : '#0d6efd';

    // Build daily summaries and monthly totals
    const dailySummaries = {};
    const hourTypeTotals = {};
    monthEntries.forEach(entry => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      if (!printViewSelectedHourTypes.has(hourTypeId)) return;

      if (!dailySummaries[entry.date]) {
        dailySummaries[entry.date] = {};
      }
      if (!dailySummaries[entry.date][hourTypeId]) {
        dailySummaries[entry.date][hourTypeId] = 0;
      }

      const minutes = entry.duration_minutes || 0;
      dailySummaries[entry.date][hourTypeId] += minutes;

      if (!hourTypeTotals[hourTypeId]) {
        hourTypeTotals[hourTypeId] = 0;
      }
      hourTypeTotals[hourTypeId] += minutes;
    });

    // Generate HTML
    const monthDate = new Date(year, month, 1);
    const monthName = monthDate.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });

    // Build calendar grid
    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const daysInMonth = lastDay.getDate();
    const firstDayOfWeek = firstDay.getDay(); // 0 = Sunday
    const startOffset = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1; // Convert to Monday = 0

    let calendarHtml = '<div style="display:grid; grid-template-columns:repeat(7, 1fr); gap:1px; margin-bottom:24px; border:2px solid #333; border-radius:8px; overflow:hidden; box-shadow:0 2px 8px rgba(0,0,0,0.1);">';

    // Add day headers
    ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].forEach(day => {
      calendarHtml += `<div style="font-weight:700; font-size:10px; padding:8px 4px; text-align:center; background:#333; color:#fff; letter-spacing:0.5px;">${day.toUpperCase()}</div>`;
    });

    // Add empty cells for offset
    for (let i = 0; i < startOffset; i++) {
      calendarHtml += '<div style="background:#f8f9fa; border-right:1px solid #dee2e6;"></div>';
    }

    // Add days
    for (let day = 1; day <= daysInMonth; day++) {
      const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
      const daySummary = dailySummaries[dateStr] || {};

      calendarHtml += '<div style="background:#fff; padding:6px; min-height:70px; font-size:10px; display:flex; flex-direction:column; border-right:1px solid #dee2e6; border-bottom:1px solid #dee2e6; position:relative;">';
      calendarHtml += `<div style="font-weight:600; font-size:11px; margin-bottom:6px; color:#6c757d;">${day}</div>`;

      // Collect income and other hours separately
      let incomeMinutesForDay = 0;
      const otherHoursHtml = [];

      selectedTypes.forEach(hourType => {
        const minutes = daySummary[hourType.id] || 0;
        if (minutes > 0) {
          const hours = formatHours(minutes);
          const isIncome = hourType.contributes_to_income;
          if (isIncome) {
            incomeMinutesForDay += minutes;
          } else {
            // Other hours: regular weight, with label, smaller with subtle styling
            const style = 'font-size:9px; color:#6c757d; margin:2px 0; padding:2px 4px; background:#f8f9fa; border-radius:3px;';
            otherHoursHtml.push(`<div style="${style}">${hours} ${hourType.name}</div>`);
          }
        }
      });

      // Add other hours first (between date and income)
      otherHoursHtml.forEach(html => {
        calendarHtml += html;
      });

      // Add income hours as a single total anchored to the bottom of the cell
      if (incomeMinutesForDay > 0) {
        const incomeHours = formatHours(incomeMinutesForDay);
        const incomeStyle = 'margin-top:auto; text-align:center; font-weight:600; font-size:16px; color:#0f172a; letter-spacing:0.4px;';
        calendarHtml += `<div style="${incomeStyle}">${incomeHours}</div>`;
      }

      calendarHtml += '</div>';
    }

    calendarHtml += '</div>';

    // Build summary table listing totals per hour type
    let totalsHtml = '';
    const incomeRows = selectedTypes
      .filter(ht => ht.contributes_to_income)
      .map(hourType => ({
        hourType: hourType,
        minutes: hourTypeTotals[hourType.id] || 0
      }))
      .filter(row => row.minutes > 0);

    const otherRows = selectedTypes
      .filter(ht => !ht.contributes_to_income)
      .map(hourType => ({
        hourType: hourType,
        minutes: hourTypeTotals[hourType.id] || 0
      }))
      .filter(row => row.minutes > 0);

    function buildTotalsTable(title, rows, options) {
      if (!rows.length) return '';
      const totalMinutes = rows.reduce((acc, row) => acc + row.minutes, 0);
      const borderColor = options.borderColor || '#333';
      const headerBg = options.headerBg || '#333';
      const headerColor = options.headerColor || '#fff';
      const accentColor = options.accentColor || '#0f5132';

      let html = '<table style="width:100%; border-collapse:collapse; margin-top:20px; border:1px solid ' + borderColor + '; border-radius:6px; overflow:hidden; box-shadow:0 1px 4px rgba(0,0,0,0.08);">';
      html += '<thead><tr style="background:' + headerBg + '; color:' + headerColor + ';"><th style="text-align:left; padding:8px 10px; font-size:12px; font-weight:600; letter-spacing:0.4px;">' + title + '</th><th style="text-align:right; padding:8px 10px; font-size:12px; font-weight:600;">TOTAL HOURS</th></tr></thead>';
      html += '<tbody style="background:#fff;">';

      rows.forEach(row => {
        const { hourType, minutes } = row;
        const hours = formatHours(minutes);
        const dotColor = hourType.color || headerBg;
        html += '<tr style="border-bottom:1px solid #e9ecef;">';
        html += '<td style="padding:8px 10px; color:#495057; font-size:11px; display:flex; align-items:center; gap:6px;"><span style="width:8px; height:8px; border-radius:50%; background:' + dotColor + '; flex-shrink:0;"></span>' + hourType.name + '</td>';
        html += '<td style="text-align:right; padding:8px 10px; color:#212529; font-size:11px; font-variant-numeric:tabular-nums;">' + hours + '</td>';
        html += '</tr>';
      });

      html += '</tbody>';
      html += '<tfoot><tr style="background:#f8f9fa;"><td style="padding:8px 10px; font-weight:600; font-size:11px; color:' + accentColor + '">Total</td><td style="text-align:right; padding:8px 10px; font-weight:600; font-size:11px; color:' + accentColor + '; font-variant-numeric:tabular-nums;">' + formatHours(totalMinutes) + '</td></tr></tfoot>';
      html += '</table>';
      return html;
    }

    totalsHtml += buildTotalsTable('BILLABLE HOURS', incomeRows, {
      borderColor: incomeAccent,
      headerBg: incomeAccent,
      headerColor: '#fff',
      accentColor: '#0f5132'
    });

    totalsHtml += buildTotalsTable('OTHER HOURS', otherRows, {
      borderColor: '#6c757d',
      headerBg: '#6c757d',
      headerColor: '#fff',
      accentColor: '#495057'
    });

    // Complete HTML document
    const printHtml = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Monthly Hours - ${monthName}</title>
  <style>
    @page {
      size: A4 portrait;
      margin: 10mm 15mm;
    }
    @media print {
      html, body {
        margin: 0;
        padding: 0;
        width: 210mm;
        height: 297mm;
      }
      body {
        margin: 0 !important;
        padding: 10mm 15mm !important;
      }
      .no-print {
        display: none;
      }
      /* Try to hide browser headers/footers - browser dependent */
      @page {
        margin: 0;
      }
      body {
        padding-top: 10mm;
        padding-bottom: 10mm;
      }
    }
    @media screen {
      body {
        max-width: 210mm;
        margin: 0 auto;
        padding: 10mm 15mm;
      }
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      font-size: 11px;
      line-height: 1.45;
      color: #212529;
      background: #fff;
    }
    h1 {
      margin: 0 0 20px 0;
      font-size: 24px;
      font-weight: 700;
      text-align: center;
      color: #212529;
      letter-spacing: -0.3px;
      padding-bottom: 12px;
      border-bottom: 2px solid #333;
    }
    * {
      box-sizing: border-box;
    }
  </style>
</head>
<body>
  <h1>Monthly Hours<br><span style="font-size:20px; font-weight:500; color:#6c757d;">${monthName}</span></h1>
  ${calendarHtml}
  ${totalsHtml}
  <script>
    window.onload = function() {
      window.print();
    };
  <\/script>
</body>
</html>`;

    // Open in new window
    const printWindow = window.open('', '_blank');
    if (printWindow) {
      printWindow.document.write(printHtml);
      printWindow.document.close();
    }

    closePrintViewConfigModal();
  }

  function buildIncomeSummary(year, month) {
    const entries = entriesForMonth(year, month).filter(entry => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      const hourType = state.hourTypeMap[hourTypeId];
      return hourType ? hourType.contributes_to_income : true; // Default to true for backwards compatibility
    });
    const periodStart = new Date(year, month, 1);
    const periodStartStr = periodStart.toISOString().substring(0, 10);
    const superRate = getSuperGuaranteeRateForDate(periodStartStr);
    let totalMinutes = 0;
    let totalHours = 0;
    let totalPackage = 0;
    if (entries.length) {
      totalMinutes = entries.reduce((acc, entry) => acc + (Number(entry.duration_minutes) || 0), 0);
      totalHours = totalMinutes / 60;
    }
    const roundingScale = totalMinutes > 0 ? 1 : 0;
    const roundedHours = totalHours;
    const validContractsUsed = entries.reduce((set, entry) => {
      const contract = state.contractMap[entry.contract_id];
      if (contract && contractIsValid(contract, entry.date)) set.add(contract.id);
      return set;
    }, new Set());
    const validContractsAcrossDates = entries.reduce((set, entry) => {
      const valids = validContractsForDate(entry.date);
      valids.forEach((contract) => set.add(contract.id));
      return set;
    }, new Set());
    if (validContractsUsed.size === 1) {
      const onlyId = Array.from(validContractsUsed)[0];
      const contract = state.contractMap[onlyId];
      const rate = contract ? Number(contract.hourly_rate || 0) : 0;
      totalPackage = roundedHours * rate;
    } else if (!validContractsUsed.size && validContractsAcrossDates.size === 1) {
      const fallbackId = Array.from(validContractsAcrossDates)[0];
      const contract = state.contractMap[fallbackId];
      const rate = contract ? Number(contract.hourly_rate || 0) : 0;
      totalPackage = roundedHours * rate;
    } else {
      totalPackage = entries.reduce((acc, entry) => {
        const minutes = Number(entry.duration_minutes) || 0;
        let rate = 0;
        const contract = state.contractMap[entry.contract_id];
        if (contract && contractIsValid(contract, entry.date)) {
          rate = Number(contract.hourly_rate || 0);
        } else {
          const valids = validContractsForDate(entry.date);
          if (valids.length === 1) rate = Number(valids[0].hourly_rate || 0);
        }
        const scaledMinutes = roundingScale > 0 ? (minutes * roundingScale) : 0;
        return acc + (scaledMinutes / 60) * rate;
      }, 0);
    }
    // Calculate hours for the hour type marked for rate calculation
    let rateCalcHours = 0;
    let rateCalcHourTypeId = null;

    // Find the hour type marked for rate calculation (works regardless of hour types feature flag)
    const rateCalcHourType = Object.values(state.hourTypeMap).find(ht => ht && ht.use_for_rate_calculation);
    if (rateCalcHourType) {
      rateCalcHourTypeId = rateCalcHourType.id;
      const matchingEntries = entriesForMonth(year, month).filter(entry => {
        const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
        return hourTypeId === rateCalcHourType.id;
      });

      const rateCalcMinutes = matchingEntries.reduce((acc, entry) => acc + (Number(entry.duration_minutes) || 0), 0);
      rateCalcHours = rateCalcMinutes / 60;
    }

    const deductionTotals = computeMonthlyDeductionTotals(year, month);
    const salarySacrifice = deductionTotals.personalStandardTotal;
    const companyExpenses = state.companyTrackingEnabled ? deductionTotals.companyStandardTotal : 0;
    const companyExpensesGst = state.companyTrackingEnabled ? deductionTotals.companyGstTotal : 0;

    const companyIncome = state.companyTrackingEnabled ? totalPackage : 0;
    const invoiceTotal = state.companyTrackingEnabled ? companyIncome * (1 + GST_RATE) : 0;
    const employeePackage = state.companyTrackingEnabled
      ? Math.max(0, companyIncome - companyExpenses)
      : totalPackage;
    const grossIncome = deriveGrossFromPackage(employeePackage, superRate);

    const extraSuperPercent = Math.max(0, deductionTotals.extraSuperPercentRate) * Math.max(0, grossIncome);
    const extraSuper = deductionTotals.extraSuperFlat + extraSuperPercent;

    // Calculate super base and lost super
    let superBase = Math.max(0, grossIncome - salarySacrifice);
    const idealSuper = Math.max(0, grossIncome * superRate);
    let superGuarantee = Math.max(0, superBase * superRate);
    let superLostDueToDeductions = Math.max(0, idealSuper - superGuarantee);

    // Check if "no lost super to deductions" feature is enabled
    const noLostSuperFlag = state.featureFlags.no_lost_super_to_deductions || DEFAULT_FEATURE_FLAGS.no_lost_super_to_deductions || { enabled: false };
    const recoveryMode = state.settings.lost_super_recovery_mode || 'extra_contribution';
    let recoveredSuper = 0;
    let recoveredToSuperBase = 0;

    if (noLostSuperFlag.enabled && superLostDueToDeductions > 0) {
      if (recoveryMode === 'extra_contribution') {
        // Add lost super as extra contribution
        recoveredSuper = superLostDueToDeductions;
        superLostDueToDeductions = 0;
      } else if (recoveryMode === 'add_to_taxable') {
        // Add lost super back to super base and taxable income
        recoveredToSuperBase = superLostDueToDeductions;
        superBase = Math.max(0, superBase + recoveredToSuperBase);
        superGuarantee = Math.max(0, superBase * superRate);
        superLostDueToDeductions = 0;
      }
    }

    const taxableIncome = Math.max(0, grossIncome - extraSuper - salarySacrifice + recoveredToSuperBase);
    const requestKey = `${monthKeyFor(year, month)}:${Math.round(taxableIncome * 100)}`;
    return {
      monthKey: monthKeyFor(year, month),
      periodStart,
      hasEntries: entries.length > 0,
      totalMinutes,
      totalHours,
      totalPackage,
      companyIncome,
      invoiceTotal,
      invoiceGst: invoiceTotal - companyIncome,
      companyExpenses,
      companyExpensesGst,
      grossIncome,
      superRate,
      superGuarantee,
      extraSuper: extraSuper + recoveredSuper,
      otherDeductions: salarySacrifice,
      totalSuper: superGuarantee + extraSuper + recoveredSuper,
      taxableIncome,
      superLostDueToDeductions,
      taxStatus: taxableIncome > 0 ? 'pending' : 'resolved',
      tax: taxableIncome > 0 ? null : 0,
      netIncome: taxableIncome > 0 ? null : taxableIncome,
      requestKey,
      rateCalcHours,
      rateCalcHourTypeId,
      deductionSnapshot: {
        salarySacrifice,
        companyStandardTotal: deductionTotals.companyStandardTotal,
        companyGstTotal: deductionTotals.companyGstTotal,
        extraSuperFlat: deductionTotals.extraSuperFlat,
        extraSuperPercentRate: deductionTotals.extraSuperPercentRate
      }
    };
  }
  function applyIncomeBreakdownVisibility() {
    if (!incomeBreakdownEl) return;
    incomeBreakdownEl.hidden = !incomeBreakdownExpanded;
    if (incomeToggleBtn) {
      incomeToggleBtn.dataset.expanded = incomeBreakdownExpanded ? 'true' : 'false';
      incomeToggleBtn.setAttribute('aria-expanded', incomeBreakdownExpanded ? 'true' : 'false');
    }
  }
  function updateIncomeSummaryUI(summary) {
    if (!incomeNetBadge && !incomeBreakdownEl) return;
    const hourlyRateDivider = document.getElementById('hourly-rate-divider');
    const hourlyRateGrossRow = document.getElementById('hourly-rate-gross-row');
    const hourlyRateNetRow = document.getElementById('hourly-rate-net-row');
    const hourlyRateGrossEl = document.getElementById('income-hourly-rate-gross');
    const hourlyRateNetEl = document.getElementById('income-hourly-rate-net');
    const hourlyRateGrossLabel = document.getElementById('hourly-rate-gross-label');
    const hourlyRateNetLabel = document.getElementById('hourly-rate-net-label');

    if (!summary) {
      if (incomeNetBadge) incomeNetBadge.textContent = 'Net income: --';
      if (incomeNetDetailEl) incomeNetDetailEl.textContent = '--';
      if (incomeInvoiceTotalEl) incomeInvoiceTotalEl.textContent = '--';
      if (incomeCompanyIncomeEl) incomeCompanyIncomeEl.textContent = '--';
      if (incomeInvoiceTotalRow) incomeInvoiceTotalRow.style.display = 'none';
      if (incomeCompanyIncomeRow) incomeCompanyIncomeRow.style.display = 'none';
      if (incomeCompanyExpensesEl) incomeCompanyExpensesEl.textContent = '--';
      if (incomeCompanyExpensesRow) incomeCompanyExpensesRow.style.display = 'none';
      if (incomeGrossEl) incomeGrossEl.textContent = '--';
      if (incomeSuperGuaranteeEl) incomeSuperGuaranteeEl.textContent = '--';
      if (incomeSuperLostEl) incomeSuperLostEl.textContent = '--';
      if (incomeSuperLostRow) incomeSuperLostRow.style.display = 'none';
      if (incomeExtraSuperEl) incomeExtraSuperEl.textContent = '--';
      if (incomeOtherDeductionsEl) incomeOtherDeductionsEl.textContent = '--';
      if (incomeTaxableEl) incomeTaxableEl.textContent = '--';
      if (incomeTaxEl) incomeTaxEl.textContent = '--';
      if (incomeActualGrossValueEl) incomeActualGrossValueEl.textContent = '';
      if (incomeActualSuperValueEl) incomeActualSuperValueEl.textContent = '';
      if (incomeActualTaxValueEl) incomeActualTaxValueEl.textContent = '';
      if (incomeActualNetValueEl) incomeActualNetValueEl.textContent = '';
      if (btnCompanyExpensesDetails) btnCompanyExpensesDetails.style.display = 'none';
      if (btnDeductionsDetails) btnDeductionsDetails.style.display = 'none';
      if (hourlyRateDivider) {
        hourlyRateDivider.hidden = true;
        hourlyRateDivider.style.display = 'none';
      }
      if (hourlyRateGrossRow) {
        hourlyRateGrossRow.hidden = true;
        hourlyRateGrossRow.style.display = 'none';
      }
      if (hourlyRateNetRow) {
        hourlyRateNetRow.hidden = true;
        hourlyRateNetRow.style.display = 'none';
      }
      if (hourlyRateGrossEl) hourlyRateGrossEl.textContent = '--';
      if (hourlyRateNetEl) hourlyRateNetEl.textContent = '--';
      if (hourlyRateGrossLabel) hourlyRateGrossLabel.textContent = '--';
      if (hourlyRateNetLabel) hourlyRateNetLabel.textContent = '--';
      hidePotentialIncomeSection();
      return;
    }
    const netValue = summary.netIncome != null ? summary.netIncome : summary.taxableIncome;
    const netDisplay = (() => {
      if (summary.taxStatus === 'pending') return 'Calculating...';
      if (summary.taxStatus === 'error') return 'Tax unavailable';
      return formatCurrency(netValue);
    })();
    const taxText = (() => {
      if (summary.taxStatus === 'pending') return 'Calculating...';
      if (summary.taxStatus === 'error') return 'Tax unavailable';
      return formatCurrency(summary.tax || 0);
    })();

    // Check for actual income data - show actual if available, otherwise show estimate
    if (incomeNetBadge) {
      let displayValue = netDisplay;

      if (getFeatureFlag('enable_actual_income')) {
        const monthStr = `${state.calendar.year}-${String(state.calendar.month + 1).padStart(2, '0')}`;
        const actualData = state.actualIncomeMap[monthStr];

        // If we have actual data, show it immediately regardless of tax calculation status
        if (actualData) {
          displayValue = formatCurrency(actualData.net_income);
        }
      }

      incomeNetBadge.textContent = `Net income: ${displayValue}`;
    }
    if (incomeNetDetailEl) incomeNetDetailEl.textContent = netDisplay;
    if (incomeInvoiceTotalEl) incomeInvoiceTotalEl.textContent = formatCurrency(summary.invoiceTotal || 0);
    if (incomeCompanyIncomeEl) incomeCompanyIncomeEl.textContent = formatCurrency(summary.companyIncome || 0);
    if (incomeCompanyExpensesEl) incomeCompanyExpensesEl.textContent = formatCurrency(summary.companyExpenses || 0);
    if (incomeInvoiceTotalRow) {
      incomeInvoiceTotalRow.hidden = !state.companyTrackingEnabled;
      incomeInvoiceTotalRow.style.display = state.companyTrackingEnabled ? '' : 'none';
    }
    if (incomeCompanyIncomeRow) {
      incomeCompanyIncomeRow.hidden = !state.companyTrackingEnabled;
      incomeCompanyIncomeRow.style.display = state.companyTrackingEnabled ? '' : 'none';
    }
    if (incomeCompanyExpensesRow) {
      incomeCompanyExpensesRow.hidden = !state.companyTrackingEnabled;
      incomeCompanyExpensesRow.style.display = state.companyTrackingEnabled ? '' : 'none';
    }
    if (incomeGrossEl) incomeGrossEl.textContent = formatCurrency(summary.grossIncome);
    if (incomeSuperGuaranteeEl) incomeSuperGuaranteeEl.textContent = formatCurrency(summary.superGuarantee);
    if (incomeSuperLostEl) incomeSuperLostEl.textContent = formatCurrency(summary.superLostDueToDeductions || 0);
    if (incomeSuperLostRow) {
      const noLostSuperEnabled = state.featureFlags.no_lost_super_to_deductions?.enabled || false;
      const shouldShowSuperLost = !noLostSuperEnabled && summary.superLostDueToDeductions && summary.superLostDueToDeductions > 0.009;
      incomeSuperLostRow.style.display = shouldShowSuperLost ? '' : 'none';
    }
    if (incomeExtraSuperEl) incomeExtraSuperEl.textContent = formatCurrency(summary.extraSuper);
    if (incomeSuperTotalEl) {
      const estimatedSuperTotal = (summary.superGuarantee || 0) + (summary.extraSuper || 0);
      incomeSuperTotalEl.textContent = formatCurrency(estimatedSuperTotal);
    }
    if (incomeOtherDeductionsEl) incomeOtherDeductionsEl.textContent = formatCurrency(summary.otherDeductions);
    if (incomeTaxableEl) incomeTaxableEl.textContent = formatCurrency(summary.taxableIncome);
    if (incomeTaxEl) incomeTaxEl.textContent = taxText;

    // Show/hide detail buttons based on whether there are expenses
    if (btnCompanyExpensesDetails) {
      btnCompanyExpensesDetails.style.display = (summary.companyExpenses > 0.01) ? 'inline-block' : 'none';
    }
    if (btnDeductionsDetails) {
      btnDeductionsDetails.style.display = (summary.otherDeductions > 0.01) ? 'inline-block' : 'none';
    }

    // Show/hide and populate hourly rate section
    if (hourlyRateDivider && hourlyRateGrossRow && hourlyRateNetRow) {
      const rateCalcType = summary.rateCalcHourTypeId ? state.hourTypeMap[summary.rateCalcHourTypeId] : null;
      const shouldShowHourlyRate = rateCalcType &&
                                   rateCalcType.use_for_rate_calculation &&
                                   !rateCalcType.contributes_to_income &&
                                   summary.rateCalcHours > 0;

      if (shouldShowHourlyRate) {
        if (hourlyRateDivider) {
          hourlyRateDivider.hidden = false;
          hourlyRateDivider.style.display = '';
        }
        if (hourlyRateGrossRow) {
          hourlyRateGrossRow.hidden = false;
          hourlyRateGrossRow.style.display = '';
        }
        if (hourlyRateNetRow) {
          hourlyRateNetRow.hidden = false;
          hourlyRateNetRow.style.display = '';
        }

        const grossHourlyRate = summary.rateCalcHours > 0 ? summary.grossIncome / summary.rateCalcHours : 0;
        const netHourlyRateBase = summary.netIncome != null ? summary.netIncome : summary.taxableIncome;
        const netHourlyRate = summary.rateCalcHours > 0 ? netHourlyRateBase / summary.rateCalcHours : 0;
        const hourlyRateName = rateCalcType ? rateCalcType.name : '--';

        if (hourlyRateGrossEl) hourlyRateGrossEl.textContent = formatCurrency(grossHourlyRate) + '/hr';
        if (hourlyRateNetEl) hourlyRateNetEl.textContent = formatCurrency(netHourlyRate) + '/hr';
        if (hourlyRateGrossLabel) hourlyRateGrossLabel.textContent = hourlyRateName;
        if (hourlyRateNetLabel) hourlyRateNetLabel.textContent = hourlyRateName;
      } else {
        if (hourlyRateDivider) {
          hourlyRateDivider.hidden = true;
          hourlyRateDivider.style.display = 'none';
        }
        if (hourlyRateGrossRow) {
          hourlyRateGrossRow.hidden = true;
          hourlyRateGrossRow.style.display = 'none';
        }
        if (hourlyRateNetRow) {
          hourlyRateNetRow.hidden = true;
          hourlyRateNetRow.style.display = 'none';
        }
        if (hourlyRateGrossEl) hourlyRateGrossEl.textContent = '--';
        if (hourlyRateNetEl) hourlyRateNetEl.textContent = '--';
        if (hourlyRateGrossLabel) hourlyRateGrossLabel.textContent = '--';
        if (hourlyRateNetLabel) hourlyRateNetLabel.textContent = '--';
      }
    }

    // Handle actual income inline comparisons
    if (getFeatureFlag('enable_actual_income')) {
      const monthStr = `${state.calendar.year}-${String(state.calendar.month + 1).padStart(2, '0')}`;
      const actualData = state.actualIncomeMap[monthStr];

      if (actualData) {
        // Helper function to calculate and format variance display
        const formatActualWithVariance = (actual, estimated) => {
          const variance = actual - estimated;
          const absVariance = Math.abs(variance);
          if (absVariance < 0.01) {
            return `Act: ${formatCurrency(actual)}`;
          }
          const arrow = variance > 0 ? '' : '';
          const color = variance > 0 ? 'var(--success)' : 'var(--danger)';
          return `Act: ${formatCurrency(actual)} <span style="color:${color}">${arrow} ${formatCurrency(absVariance)}</span>`;
        };

        // Calculate estimated superannuation (super guarantee + extra super)
        const estimatedSuper = (summary.superGuarantee || 0) + (summary.extraSuper || 0);

        // For net income, if tax is still calculating, compare against taxable income instead
        const effectiveNetEstimate = (summary.taxStatus === 'pending' || summary.taxStatus === 'error')
          ? summary.taxableIncome
          : netValue;

        // Populate actual gross income
        if (incomeActualGrossValueEl) {
          incomeActualGrossValueEl.innerHTML = formatActualWithVariance(actualData.gross_income, summary.grossIncome);
        }

        // Populate actual superannuation
        if (incomeActualSuperValueEl) {
          incomeActualSuperValueEl.innerHTML = formatActualWithVariance(actualData.superannuation, estimatedSuper);
        }

        // Populate actual tax (only if we have a valid estimated tax)
        if (incomeActualTaxValueEl) {
          if (summary.taxStatus === 'pending') {
            incomeActualTaxValueEl.innerHTML = `Act: ${formatCurrency(actualData.tax)} <span style="color:var(--muted)">(Est pending)</span>`;
          } else if (summary.taxStatus === 'error') {
            incomeActualTaxValueEl.innerHTML = `Act: ${formatCurrency(actualData.tax)} <span style="color:var(--muted)">(Est unavailable)</span>`;
          } else {
            incomeActualTaxValueEl.innerHTML = formatActualWithVariance(actualData.tax, summary.tax || 0);
          }
        }

        // Populate actual net income
        if (incomeActualNetValueEl) {
          if (summary.taxStatus === 'pending') {
            incomeActualNetValueEl.innerHTML = `Act: ${formatCurrency(actualData.net_income)} <span style="color:var(--muted)">(Est pending)</span>`;
          } else if (summary.taxStatus === 'error') {
            incomeActualNetValueEl.innerHTML = `Act: ${formatCurrency(actualData.net_income)} <span style="color:var(--muted)">(Est unavailable)</span>`;
          } else {
            incomeActualNetValueEl.innerHTML = formatActualWithVariance(actualData.net_income, effectiveNetEstimate);
          }
        }
      } else {
        // Clear actual values if no data
        if (incomeActualGrossValueEl) incomeActualGrossValueEl.textContent = '';
        if (incomeActualSuperValueEl) incomeActualSuperValueEl.textContent = '';
        if (incomeActualTaxValueEl) incomeActualTaxValueEl.textContent = '';
        if (incomeActualNetValueEl) incomeActualNetValueEl.textContent = '';
      }
    } else {
      // Clear actual values if feature flag is disabled
      if (incomeActualGrossValueEl) incomeActualGrossValueEl.textContent = '';
      if (incomeActualSuperValueEl) incomeActualSuperValueEl.textContent = '';
      if (incomeActualTaxValueEl) incomeActualTaxValueEl.textContent = '';
      if (incomeActualNetValueEl) incomeActualNetValueEl.textContent = '';
    }

    updatePotentialIncomeSection(summary);
  }

  function updatePotentialIncomeSection(summary) {
    if (!potentialNetDivider || !incomePotentialNetRow) return;
    if (!summary || !state.calendar) {
      hidePotentialIncomeSection();
      return;
    }
    const { year, month } = state.calendar;
    if (!Number.isInteger(year) || !Number.isInteger(month)) {
      hidePotentialIncomeSection();
      return;
    }
    const contract = getSelectedPotentialContract();
    if (!contract || !(Number(contract.hourly_rate) > 0)) {
      hidePotentialIncomeSection();
      return;
    }
    const contextKey = `${year}-${month}-${contract.id}`;
    if (state.potentialIncomeContextKey !== contextKey) {
      state.potentialIncomeContextKey = contextKey;
      state.potentialIncomeScenarios = {};
      state.potentialIncomeTaxRequests = {};
    }
    ensurePotentialIncomeState();
    const monthKey = monthKeyFor(year, month);
    const isDirty = state.dirtyIncomeMonths && state.dirtyIncomeMonths.has(monthKey);
    if (!isDirty && state.potentialIncomeCache && state.potentialIncomeCache[contextKey]) {
      const cached = state.potentialIncomeCache[contextKey];
      const cachedScenarios = cached.scenarios ? JSON.parse(JSON.stringify(cached.scenarios)) : {};
      const hasCachedScenarios = cachedScenarios && Object.keys(cachedScenarios).length > 0;
      state.potentialIncomeStats = cached.stats || null;
      state.potentialIncomeScenarios = cachedScenarios;
      if (hasCachedScenarios) {
        renderPotentialIncomeFromState();
        return;
      }
    }
    const stats = buildPotentialIncomeStats(contract, summary, year, month);
    state.potentialIncomeStats = stats;
    if (!stats) {
      hidePotentialIncomeSection();
      return;
    }
    applyPotentialIncomeDisplay(contract, stats, summary, year, month);
  }

  function getSelectedPotentialContract() {
    if (!state.selectedContractId) return null;
    return getContractById(state.selectedContractId) || null;
  }

  function hidePotentialIncomeSection() {
    state.potentialIncomeStats = null;
    const rows = [
      potentialNetDivider,
      incomeProjectionsHeader,
      incomePotentialNetRow,
      incomeEstimatedStandardRow,
      incomeEstimatedProjectedRow
    ];
    rows.forEach((row) => {
      if (row) row.hidden = true;
    });
    const placeholders = [
      incomePotentialNetEl,
      incomeEstimatedStandardNetEl,
      incomeEstimatedProjectedNetEl
    ];
    placeholders.forEach((el) => {
      if (el) el.textContent = '--';
    });
    resetPotentialIncomeInfoIcons();
  }

  function setPotentialHoursTooltip(el, breakdown) {
    if (!el) return;
    if (!breakdown || !Number.isFinite(breakdown.logged) || !Number.isFinite(breakdown.extra)) {
      el.title = 'Hours used: --';
      return;
    }
    const loggedMinutes = breakdown.logged * 60;
    const extraMinutes = breakdown.extra * 60;
    const totalMinutes = (breakdown.logged + breakdown.extra) * 60;
    const extraLabel = breakdown.extraLabel ? ` (${breakdown.extraLabel})` : '';
    const loggedLabel = breakdown.loggedLabel ? ` (${breakdown.loggedLabel})` : ' (logged)';
    el.title = `Hours used: ${formatHours(loggedMinutes)}h${loggedLabel} + ${formatHours(extraMinutes)}h${extraLabel} = ${formatHours(totalMinutes)}h`;
  }

  function resetPotentialIncomeInfoIcons() {
    setPotentialHoursTooltip(incomeEstimatedStandardInfo, null);
    setPotentialHoursTooltip(incomeEstimatedProjectedInfo, null);
  }

  function buildPotentialIncomeStats(contract, summary, year, month) {
    const standardHoursPerDay = Number(contract.standard_hours_per_day || 7.5);
    if (!(standardHoursPerDay > 0)) return null;
    const monthStart = startOfDay(new Date(year, month, 1));
    const monthEnd = startOfDay(new Date(year, month + 1, 0));
    const contractStart = contract.start_date ? parseIsoDate(contract.start_date) : null;
    const contractEnd = contract.end_date ? parseIsoDate(contract.end_date) : null;
    const periodStart = contractStart && contractStart > monthStart ? contractStart : monthStart;
    const boundedContractEnd = contractEnd && contractEnd < monthEnd ? contractEnd : monthEnd;
    if (boundedContractEnd < periodStart) return null;
    const businessDays = collectBusinessDays(periodStart, boundedContractEnd, !!contract.include_weekends);
    if (!businessDays.length) return null;

    const monthEntries = entriesForMonth(year, month);
    const today = startOfDay(new Date());
    const nonIncomeMinutesByDay = {};
    let totalIncomeMinutes = 0;

    monthEntries.forEach((entry) => {
      let resolvedId = entry._resolvedContractId;
      if (!resolvedId) {
        const resolved = resolveContractForEntry(entry);
        if (resolved) {
          resolvedId = resolved.id;
          entry._resolvedContractId = resolved.id;
        }
      }
      if (resolvedId !== contract.id) return;
      const dateIso = getEntryDateIso(entry);
      if (!dateIso) return;
      const minutes = Number(entry.duration_minutes) || 0;
      if (entryContributesToIncome(entry)) {
        totalIncomeMinutes += minutes;
      } else {
        nonIncomeMinutesByDay[dateIso] = (nonIncomeMinutesByDay[dateIso] || 0) + minutes;
      }
    });

    const actualIncomeHours = totalIncomeMinutes / 60;
    let availableFractionTotal = 0;
    let availableFractionFuture = 0;
    businessDays.forEach((dayIso) => {
      const nonIncomeMinutes = nonIncomeMinutesByDay[dayIso] || 0;
      const nonIncomeHours = nonIncomeMinutes / 60;
      const blockFraction = Math.min(1, standardHoursPerDay > 0 ? (nonIncomeHours / standardHoursPerDay) : 0);
      const availableFraction = Math.max(0, 1 - blockFraction);
      if (availableFraction <= 0) return;
      availableFractionTotal += availableFraction;
      const dayDate = parseIsoDate(dayIso);
      if (dayDate > today) {
        availableFractionFuture += availableFraction;
      }
    });
    if (availableFractionTotal <= 0) return null;

    const standardPotentialHours = standardHoursPerDay * availableFractionTotal;
    const remainingStandardHours = standardHoursPerDay * availableFractionFuture;
    const projectedAverageDailyHours = getProjectedAverageDailyHoursForContract(
      contract,
      actualIncomeHours,
      availableFractionTotal,
      year,
      month
    );
    const projectedPotentialHours = projectedAverageDailyHours * availableFractionTotal;
    const projectedRemainingHours = projectedAverageDailyHours * availableFractionFuture;

    const standardScenarioHours = actualIncomeHours + remainingStandardHours;
    const projectedScenarioHours = actualIncomeHours + projectedRemainingHours;

    return {
      standardHoursPerDay,
      standardPotentialHours,
      remainingStandardHours,
      projectedPotentialHours,
      projectedRemainingHours,
      standardScenarioHours,
      projectedScenarioHours,
      actualIncomeHours,
      periodStart: monthStart
    };
  }

  function getProjectedAverageDailyHoursForContract(contract, actualIncomeHours, availableFractionTotal, year, month) {
    const monthKey = monthKeyFor(year, month);
    if (
      state.expectedHoursSummary &&
      state.expectedHoursSummary.monthKey === monthKey &&
      Array.isArray(state.expectedHoursSummary.contracts)
    ) {
      const match = state.expectedHoursSummary.contracts.find((c) => c.contractId === contract.id);
      if (match && Number.isFinite(Number(match.projectedAverageDailyHours))) {
        return Number(match.projectedAverageDailyHours);
      }
    }
    const evaluatedDays = Math.max(availableFractionTotal, 1);
    const currentMonthAverage = actualIncomeHours / evaluatedDays;
    const trendResult = calculateTrendAverage(
      contract,
      state.entries,
      getTrendMethod(),
      month,
      year,
      { average: currentMonthAverage, businessDays: evaluatedDays }
    );
    if (trendResult && Number.isFinite(Number(trendResult.averageDailyHours))) {
      return Number(trendResult.averageDailyHours);
    }
    return currentMonthAverage > 0 ? currentMonthAverage : Number(contract.standard_hours_per_day || 7.5);
  }

  function calculateScenarioAmounts(contract, hours, summary, year, month) {
    const rate = Number(contract.hourly_rate || 0);
    if (!(rate > 0) || !(hours > 0)) {
      return { hours: Math.max(0, hours), taxableIncome: 0, periodStart: startOfDay(new Date(year, month, 1)) };
    }
    const deductionSnapshot = summary && summary.deductionSnapshot
      ? summary.deductionSnapshot
      : computeMonthlyDeductionTotals(year, month);
    const periodStart = startOfDay(new Date(year, month, 1));
    const periodStartStr = periodStart.toISOString().substring(0, 10);
    const superRate = summary && summary.superRate != null
      ? summary.superRate
      : getSuperGuaranteeRateForDate(periodStartStr);
    const salarySacrifice = deductionSnapshot && deductionSnapshot.salarySacrifice
      ? deductionSnapshot.salarySacrifice
      : 0;
    const extraSuperFlat = deductionSnapshot && deductionSnapshot.extraSuperFlat
      ? deductionSnapshot.extraSuperFlat
      : 0;
    const extraSuperPercentRate = deductionSnapshot && deductionSnapshot.extraSuperPercentRate
      ? deductionSnapshot.extraSuperPercentRate
      : 0;
    const companyEnabled = !!state.companyTrackingEnabled;
    const companyExpenses = companyEnabled && deductionSnapshot && deductionSnapshot.companyStandardTotal
      ? deductionSnapshot.companyStandardTotal
      : 0;
    const companyExpensesGst = companyEnabled && deductionSnapshot && deductionSnapshot.companyGstTotal
      ? deductionSnapshot.companyGstTotal
      : 0;
    const totalPackage = hours * rate;
    const companyIncome = companyEnabled ? totalPackage : 0;
    const invoiceTotal = companyEnabled ? companyIncome * (1 + GST_RATE) : 0;
    const employeePackage = companyEnabled ? Math.max(0, companyIncome - companyExpenses) : totalPackage;
    const grossIncome = deriveGrossFromPackage(employeePackage, superRate);
    const extraSuperPercent = Math.max(0, extraSuperPercentRate) * Math.max(0, grossIncome);
    const extraSuper = extraSuperFlat + extraSuperPercent;
    let superBase = Math.max(0, grossIncome - salarySacrifice);
    const idealSuper = Math.max(0, grossIncome * superRate);
    let superGuarantee = Math.max(0, superBase * superRate);
    let superLostDueToDeductions = Math.max(0, idealSuper - superGuarantee);
    const noLostSuperFlag = state.featureFlags.no_lost_super_to_deductions || DEFAULT_FEATURE_FLAGS.no_lost_super_to_deductions || { enabled: false };
    const recoveryMode = state.settings.lost_super_recovery_mode || 'extra_contribution';
    let recoveredSuper = 0;
    let recoveredToSuperBase = 0;
    if (noLostSuperFlag.enabled && superLostDueToDeductions > 0) {
      if (recoveryMode === 'extra_contribution') {
        recoveredSuper = superLostDueToDeductions;
        superLostDueToDeductions = 0;
      } else if (recoveryMode === 'add_to_taxable') {
        recoveredToSuperBase = superLostDueToDeductions;
        superBase = Math.max(0, superBase + recoveredToSuperBase);
        superGuarantee = Math.max(0, superBase * superRate);
        superLostDueToDeductions = 0;
      }
    }
    const taxableIncome = Math.max(0, grossIncome - extraSuper - salarySacrifice + recoveredToSuperBase);
    return {
      hours,
      taxableIncome,
      periodStart,
      grossIncome,
      companyIncome,
      invoiceTotal
    };
  }

  function ensurePotentialIncomeState() {
    if (!state.potentialIncomeScenarios) state.potentialIncomeScenarios = {};
    if (!state.potentialIncomeTaxRequests) state.potentialIncomeTaxRequests = {};
    if (!state.potentialIncomeCache) state.potentialIncomeCache = {};
  }

  function ensurePotentialScenarioState(id) {
    ensurePotentialIncomeState();
    if (!state.potentialIncomeScenarios[id]) {
      state.potentialIncomeScenarios[id] = {
        status: 'idle',
        netIncome: null,
        taxableIncome: 0,
        contextKey: state.potentialIncomeContextKey || ''
      };
    }
    return state.potentialIncomeScenarios[id];
  }

  function requestPotentialScenarioTax(id, taxableIncome, periodStart) {
    if (!state.potentialIncomeTaxRequests) state.potentialIncomeTaxRequests = {};
    const scenario = ensurePotentialScenarioState(id);
    if (!(taxableIncome > 0)) {
      scenario.status = 'resolved';
      scenario.netIncome = taxableIncome;
      scenario.pendingRequestId = null;
      renderPotentialIncomeFromState();
      return;
    }
    const requestId = `${id}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
    scenario.status = 'pending';
    scenario.pendingRequestId = requestId;
    scenario.taxableIncome = taxableIncome;
    state.potentialIncomeTaxRequests[id] = requestId;
    renderPotentialIncomeFromState();
    google.script.run
      .withSuccessHandler((value) => {
        if (state.potentialIncomeTaxRequests[id] !== requestId) return;
        const tax = Number(value) || 0;
        const activeScenario = state.potentialIncomeScenarios && state.potentialIncomeScenarios[id];
        if (!activeScenario || activeScenario.contextKey !== state.potentialIncomeContextKey) {
          state.potentialIncomeTaxRequests[id] = null;
          return;
        }
        activeScenario.netIncome = Math.max(0, taxableIncome - tax);
        activeScenario.status = 'resolved';
        activeScenario.pendingRequestId = null;
        state.potentialIncomeTaxRequests[id] = null;
        renderPotentialIncomeFromState();
        state.potentialIncomeCache[state.potentialIncomeContextKey] = {
          stats: state.potentialIncomeStats,
          scenarios: JSON.parse(JSON.stringify(state.potentialIncomeScenarios))
        };
        saveCache();
      })
      .withFailureHandler(() => {
        if (state.potentialIncomeTaxRequests[id] !== requestId) return;
        const activeScenario = state.potentialIncomeScenarios && state.potentialIncomeScenarios[id];
        if (!activeScenario || activeScenario.contextKey !== state.potentialIncomeContextKey) {
          state.potentialIncomeTaxRequests[id] = null;
          return;
        }
        activeScenario.status = 'error';
        activeScenario.netIncome = null;
        activeScenario.pendingRequestId = null;
        state.potentialIncomeTaxRequests[id] = null;
        renderPotentialIncomeFromState();
        state.potentialIncomeCache[state.potentialIncomeContextKey] = {
          stats: state.potentialIncomeStats,
          scenarios: JSON.parse(JSON.stringify(state.potentialIncomeScenarios))
        };
        saveCache();
      })
      .estimateTax(Number(taxableIncome) || 0, periodStart.toISOString());
  }

  function applyPotentialIncomeDisplay(contract, stats, summary, year, month) {
    if (!potentialNetDivider || !incomePotentialNetRow) return;
    const scenarios = [
      { id: 'potential', hours: stats.standardPotentialHours, element: incomePotentialNetEl },
      { id: 'standard', hours: stats.actualIncomeHours + stats.remainingStandardHours, element: incomeEstimatedStandardNetEl },
      { id: 'projected', hours: stats.actualIncomeHours + stats.projectedRemainingHours, element: incomeEstimatedProjectedNetEl }
    ];
    scenarios.forEach(({ id, hours }) => {
      const scenarioData = calculateScenarioAmounts(contract, hours, summary, year, month);
      const scenarioState = ensurePotentialScenarioState(id);
      scenarioState.hours = scenarioData.hours;
      scenarioState.taxableIncome = scenarioData.taxableIncome;
      scenarioState.contextKey = state.potentialIncomeContextKey;
      if (scenarioData.taxableIncome > 0) {
        requestPotentialScenarioTax(id, scenarioData.taxableIncome, scenarioData.periodStart);
      } else {
        scenarioState.status = 'resolved';
        scenarioState.netIncome = scenarioData.taxableIncome;
        scenarioState.pendingRequestId = null;
      }
    });
    const rowsToShow = [
      potentialNetDivider,
      incomeProjectionsHeader,
      incomePotentialNetRow,
      incomeEstimatedStandardRow,
      incomeEstimatedProjectedRow
    ];
    rowsToShow.forEach((row) => {
      if (row) row.hidden = false;
    });
    renderPotentialIncomeFromState();
    state.potentialIncomeCache[state.potentialIncomeContextKey] = {
      stats: state.potentialIncomeStats,
      scenarios: JSON.parse(JSON.stringify(state.potentialIncomeScenarios))
    };
    saveCache();
  }

  function renderPotentialIncomeFromState() {
    if (!state.potentialIncomeStats) return;
    const mapping = [
      { id: 'potential', el: incomePotentialNetEl },
      { id: 'standard', el: incomeEstimatedStandardNetEl },
      { id: 'projected', el: incomeEstimatedProjectedNetEl }
    ];
    mapping.forEach(({ id, el }) => {
      if (!el) return;
      const scenario = state.potentialIncomeScenarios && state.potentialIncomeScenarios[id];
      if (!scenario) {
        el.textContent = '--';
        return;
      }
      if (scenario.status === 'pending') {
        el.textContent = 'Calculating...';
      } else if (scenario.status === 'error') {
        el.textContent = 'Tax unavailable';
      } else if (scenario.status === 'resolved') {
        el.textContent = formatCurrency(scenario.netIncome || 0);
      } else {
        el.textContent = '--';
      }
    });
    updatePotentialIncomeInfoIcons();
  }

  function updatePotentialIncomeInfoIcons() {
    const stats = state.potentialIncomeStats;
    if (!stats) {
      resetPotentialIncomeInfoIcons();
      return;
    }
    const standardBreakdown = {
      logged: Math.max(0, stats.actualIncomeHours || 0),
      extra: Math.max(0, stats.remainingStandardHours || 0),
      loggedLabel: 'logged',
      extraLabel: 'standard remainder'
    };
    const projectedBreakdown = {
      logged: Math.max(0, stats.actualIncomeHours || 0),
      extra: Math.max(0, stats.projectedRemainingHours || 0),
      loggedLabel: 'logged',
      extraLabel: 'projected'
    };
    setPotentialHoursTooltip(incomeEstimatedStandardInfo, standardBreakdown);
    setPotentialHoursTooltip(incomeEstimatedProjectedInfo, projectedBreakdown);
  }
  function handleTaxSuccess(requestId, monthKey, taxValue) {
    const targetMonthKey = monthKey;
    let summary = null;
    if (state.incomeSummary && state.incomeSummary.monthKey === targetMonthKey) {
      summary = state.incomeSummary;
    } else {
      summary = getCachedIncomeSummary(targetMonthKey);
    }
    if (!summary || summary.monthKey !== targetMonthKey) {
      if (state.pendingTaxRequest && state.pendingTaxRequest.id === requestId) {
        state.pendingTaxRequest = null;
      }
      return;
    }
    const computedTax = Math.max(0, Number(taxValue) || 0);
    summary.tax = computedTax;
    summary.taxStatus = 'resolved';
    summary.netIncome = summary.taxableIncome - computedTax;
    if (state.pendingTaxRequest && state.pendingTaxRequest.id === requestId) {
      state.pendingTaxRequest = null;
    }
    if (state.incomeSummary && state.incomeSummary.monthKey === targetMonthKey) {
      updateIncomeSummaryUI(summary);
    }
    cacheIncomeSummary(summary.monthKey, summary);
  }
  function handleTaxFailure(requestId, monthKey) {
    const targetMonthKey = monthKey;
    let summary = null;
    if (state.incomeSummary && state.incomeSummary.monthKey === targetMonthKey) {
      summary = state.incomeSummary;
    } else {
      summary = getCachedIncomeSummary(targetMonthKey);
    }
    if (!summary || summary.monthKey !== targetMonthKey) {
      if (state.pendingTaxRequest && state.pendingTaxRequest.id === requestId) {
        state.pendingTaxRequest = null;
      }
      return;
    }
    summary.tax = 0;
    summary.taxStatus = 'error';
    summary.netIncome = summary.taxableIncome;
    if (state.pendingTaxRequest && state.pendingTaxRequest.id === requestId) {
      state.pendingTaxRequest = null;
    }
    if (state.incomeSummary && state.incomeSummary.monthKey === targetMonthKey) {
      updateIncomeSummaryUI(summary);
    }
    cacheIncomeSummary(summary.monthKey, summary);
  }
  function requestTaxEstimate(summary) {
    if (!summary || summary.taxStatus !== 'pending') return;
    if (!summary.taxableIncome || summary.taxableIncome <= 0) {
      summary.taxStatus = 'resolved';
      summary.tax = 0;
      summary.netIncome = summary.taxableIncome;
      updateIncomeSummaryUI(summary);
      cacheIncomeSummary(summary.monthKey, summary);
      return;
    }
    if (state.pendingTaxRequest && state.pendingTaxRequest.key === summary.requestKey) return;
    if (typeof google === 'undefined' || !google.script || !google.script.run) {
      summary.taxStatus = 'error';
      summary.tax = 0;
      summary.netIncome = summary.taxableIncome;
      updateIncomeSummaryUI(summary);
      state.pendingTaxRequest = null;
      cacheIncomeSummary(summary.monthKey, summary);
      return;
    }
    const requestId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    const monthKey = summary.monthKey;
    state.pendingTaxRequest = {
      id: requestId,
      key: summary.requestKey,
      monthKey: monthKey
    };
    google.script.run
      .withSuccessHandler((value) => handleTaxSuccess(requestId, monthKey, value))
      .withFailureHandler(() => handleTaxFailure(requestId, monthKey))
      .estimateTax(Number(summary.taxableIncome) || 0, summary.periodStart.toISOString());
  }
  function renderIncomeSummary() {
    if (!incomeNetBadge && !incomeBreakdownEl) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const monthKey = monthKeyFor(year, month);
    const isDirty = state.dirtyIncomeMonths && state.dirtyIncomeMonths.has(monthKey);
    let summary = null;
    if (!isDirty) {
      summary = getCachedIncomeSummary(monthKey);
    }
    if (!summary) {
      summary = buildIncomeSummary(year, month);
      cacheIncomeSummary(monthKey, summary);
    }
    state.incomeSummary = summary;
    updateIncomeSummaryUI(summary);
    applyIncomeBreakdownVisibility();
    if (summary.taxStatus === 'pending') {
      requestTaxEstimate(summary);
    } else {
      state.pendingTaxRequest = null;
    }
    renderBasReporting();
  }


  function buildExpectedHoursSummary(year, month) {
    if (!getFeatureFlag('expected_monthly_hours')) return null;
    const monthEntries = entriesForMonth(year, month);
    const filteredEntries = monthEntries.reduce((acc, entry) => {
      if (!entry || !entry.date) {
        return acc;
      }
      const contract = resolveContractForEntry(entry);
      if (!contract) {
        return acc;
      }
      entry._resolvedContractId = contract.id;
      entry._resolvedContract = contract;
      acc.push(entry);
      return acc;
    }, []);
    if (!filteredEntries.length) return null;

    const contractBuckets = new Map();
    filteredEntries.forEach((entry) => {
      const contract = entry._resolvedContract || state.contractMap[entry.contract_id];
      if (!contract) return;
      if (!contractBuckets.has(contract.id)) {
        contractBuckets.set(contract.id, { contract, entries: [] });
      }
      contractBuckets.get(contract.id).entries.push(entry);
    });
    if (!contractBuckets.size) return null;

    const monthStartDate = startOfDay(new Date(year, month, 1));
    const monthEndDate = startOfDay(new Date(year, month + 1, 0));

    const aggregatedPastDays = new Set();
    const aggregatedIncomeEntryDays = new Set();
    let aggregatedFutureBusinessDays = 0;
    let aggregatedAverageContractHours = 0;
    let aggregatedProjectedHoursThisMonth = 0;
    let aggregatedStandardHoursBasedOnBusinessDays = 0;
    let aggregatedIncomeHoursToDate = 0;
    let aggregatedCapacityComparisonTotal = 0;
    let aggregatedContractPaceComparisonTotal = 0;
    let aggregatedContractPaceComparisonCount = 0;
    let aggregatedProjectedVsContractAverage = 0;
    let aggregatedProjectedVsContractAverageCount = 0;
    let aggregatedProjectedVsStandardHours = 0;
    let baselineContracts = 0;

    const contractSummaries = [];

    contractBuckets.forEach(({ contract, entries }) => {
      const sortedEntries = [...entries].sort((a, b) => a.date.localeCompare(b.date));
      const contractStartRaw = contract.start_date ? parseIsoDate(contract.start_date) : null;
      if (!contractStartRaw || Number.isNaN(contractStartRaw.getTime())) return;
      const contractStart = startOfDay(contractStartRaw);
      const contractEndRaw = contract.end_date ? parseIsoDate(contract.end_date) : null;
      const includeWeekends = !!contract.include_weekends;

      const periodStart = contractStart > monthStartDate ? contractStart : monthStartDate;
      const boundedContractEnd = (contractEndRaw && !Number.isNaN(contractEndRaw.getTime())) ? startOfDay(contractEndRaw) : null;
      const periodEnd = boundedContractEnd && boundedContractEnd < monthEndDate ? boundedContractEnd : monthEndDate;
      if (periodEnd < periodStart) return;

      const periodStartIso = isoDate(periodStart);
      const periodEndIso = isoDate(periodEnd);

      const monthBusinessDaysList = collectBusinessDays(periodStart, periodEnd, includeWeekends);
      const monthBusinessDays = monthBusinessDaysList.length;
      if (monthBusinessDays === 0) return;

      const today = startOfDay(new Date());
      const pastBusinessEnd = today < periodEnd ? today : periodEnd;
      const pastBusinessDaysList = collectBusinessDays(periodStart, pastBusinessEnd, includeWeekends);
      pastBusinessDaysList.forEach((day) => aggregatedPastDays.add(day));
      const pastBusinessDays = pastBusinessDaysList.length;

      const totalMinutes = sortedEntries.reduce((acc, entry) => {
        if (!entry) return acc;
        const entryDateIso = getEntryDateIso(entry);
        if (!entryDateIso) return acc;
        if (entryDateIso < periodStartIso || entryDateIso > periodEndIso) return acc;
        const entryDate = parseIsoDate(entryDateIso);
        if (!entryDate || Number.isNaN(entryDate.getTime())) return acc;
        if (entryDate > today) return acc;
        if (!entryContributesToIncome(entry)) return acc;
        return acc + (Number(entry.duration_minutes) || 0);
      }, 0);
      const totalHours = totalMinutes / 60;

      const allContractEntries = monthEntries.filter((e) => {
        if (!e) return false;
        const resolvedId = e._resolvedContractId || e.contract_id;
        if (resolvedId !== contract.id) return false;
        const entryDateIso = getEntryDateIso(e);
        if (!entryDateIso) return false;
        return entryDateIso >= periodStartIso && entryDateIso <= periodEndIso;
      });

      const standardHoursPerDayRaw = Number(contract.standard_hours_per_day);
      const standardHoursPerDay = Number.isFinite(standardHoursPerDayRaw) && standardHoursPerDayRaw > 0 ? standardHoursPerDayRaw : 7.5;

      let futureIncomeHours = 0;
      const futureBusinessDayHours = new Map();

      allContractEntries.forEach((entry) => {
        const entryDateIso = getEntryDateIso(entry);
        if (!entryDateIso) return;
        const entryDateObj = parseIsoDate(entryDateIso);
        if (!entryDateObj || Number.isNaN(entryDateObj.getTime())) return;
        if (entryDateObj <= today || entryDateObj > periodEnd) return;
        const hours = (Number(entry.duration_minutes) || 0) / 60;
        if (entryContributesToIncome(entry)) {
          futureIncomeHours += hours;
        }
        if (!includeWeekends && isWeekendDate(entryDateObj)) return;
        const dayKey = isoDate(entryDateObj);
        futureBusinessDayHours.set(dayKey, (futureBusinessDayHours.get(dayKey) || 0) + hours);
      });

      let futureBusinessDayContribution = 0;
      futureBusinessDayHours.forEach((hoursForDay, dayKey) => {
        if (standardHoursPerDay <= 0) return;
        const fraction = Math.min(1, hoursForDay / standardHoursPerDay);
        futureBusinessDayContribution += fraction;
      });

      const hoursLoggedToDate = totalHours + futureIncomeHours;
      const evaluatedBusinessDaysWithFuture = pastBusinessDays + futureBusinessDayContribution;
      if (evaluatedBusinessDaysWithFuture === 0) return;

      aggregatedFutureBusinessDays += futureBusinessDayContribution;

      const currentMonthAverage = evaluatedBusinessDaysWithFuture > 0 ? hoursLoggedToDate / evaluatedBusinessDaysWithFuture : 0;
      const selectedTrendMethod = getTrendMethod();
      const trendResult = calculateTrendAverage(
        contract,
        state.entries,
        selectedTrendMethod,
        month,
        year,
        { average: currentMonthAverage, standardHoursPerDay }
      );
      const projectedAverageDailyHours = Number(trendResult.averageDailyHours) || 0;
      const trendMethod = trendResult.method;
      const trendFallbackApplied = trendResult.fallbackApplied;
      let actualAverageDailyHours = 0;

      const expectedHoursLoggedToDate = projectedAverageDailyHours * evaluatedBusinessDaysWithFuture;
      const totalExpectedHoursThisMonth = projectedAverageDailyHours * monthBusinessDays;

      const hasBaseline = Number(contract.total_hours || 0) > 0 && contract.end_date;
      let averageContractHoursThisMonth = null;
      if (hasBaseline) {
        const proRatedMonths = calculateProRatedMonths(contractStart, boundedContractEnd || contractStart);
        if (proRatedMonths > 0) {
          averageContractHoursThisMonth = Number(contract.total_hours || 0) / proRatedMonths;
          aggregatedAverageContractHours += averageContractHoursThisMonth;
          baselineContracts += 1;
        }
      }

      const projectedVariance = averageContractHoursThisMonth != null
        ? totalExpectedHoursThisMonth - averageContractHoursThisMonth
        : null;
      const businessDaysRemaining = Math.max(0, monthBusinessDays - Math.min(evaluatedBusinessDaysWithFuture, monthBusinessDays));
      const expectedHoursRemaining = Math.max(0, totalExpectedHoursThisMonth - expectedHoursLoggedToDate);

      let status = 'ontrack';
      let statusText = 'Projected on target';
      if (projectedVariance != null) {
        const roundedVariance = Math.round(projectedVariance * 100) / 100;
        const varianceMagnitude = Math.abs(roundedVariance);
        if (roundedVariance > 0.01) {
          status = 'behind';
          statusText = `Projected over by ${formatDecimalHours(varianceMagnitude)} hrs`;
        } else if (roundedVariance < -0.01) {
          status = 'ahead';
          statusText = `Projected under by ${formatDecimalHours(varianceMagnitude)} hrs`;
        }
      } else if (!hasBaseline) {
        status = 'ontrack';
        statusText = 'Variance not available for unlimited contracts';
      }

      // NEW: Three-metric calculation system
      // Group entries by date with income/non-income breakdown
      const dailyHours = new Map();
      let totalIncomeHoursToDate = 0;
      let totalNonIncomeHoursToDate = 0;

      allContractEntries.forEach((entry) => {
        const entryDateIso = getEntryDateIso(entry);
        if (!entryDateIso) return;
        const entryDateObj = parseIsoDate(entryDateIso);
        if (!entryDateObj || Number.isNaN(entryDateObj.getTime())) return;
        if (entryDateObj > periodEnd) return;

        // Only count entries up to today for "to date" calculations
        const isToDate = entryDateObj <= today;

        const hours = (Number(entry.duration_minutes) || 0) / 60;
        if (hours <= 0) return;

        if (!dailyHours.has(entryDateIso)) {
          dailyHours.set(entryDateIso, { income: 0, nonIncome: 0 });
        }

        const dayData = dailyHours.get(entryDateIso);
        if (entryContributesToIncome(entry)) {
          dayData.income += hours;
          if (isToDate) totalIncomeHoursToDate += hours;
        } else {
          dayData.nonIncome += hours;
          if (isToDate) totalNonIncomeHoursToDate += hours;
        }
      });

      // Count full non-income days (days where non_income >= standard_hours)
      let fullNonIncomeDays = 0;
      let daysWithEntriesCount = 0;
      let incomeEntryDaysCount = 0;
      dailyHours.forEach((dayData, dateIso) => {
        const dateObj = parseIsoDate(dateIso);
        if (!dateObj || Number.isNaN(dateObj.getTime())) return;

        const incomeHours = dayData.income;
        const nonIncomeHours = dayData.nonIncome;

        // Count days that consume a business day: any income OR non-income >= standard hours
        if (incomeHours > 0 || nonIncomeHours >= standardHoursPerDay) {
          daysWithEntriesCount++;
        }

        // If a day has non-income hours >= standard hours, it's a full non-income day
        if (nonIncomeHours >= standardHoursPerDay) {
          fullNonIncomeDays++;
        }
        if (incomeHours > 0 && dateObj <= today) {
          incomeEntryDaysCount++;
          aggregatedIncomeEntryDays.add(dateIso);
        }
      });
      actualAverageDailyHours = incomeEntryDaysCount > 0 ? totalIncomeHoursToDate / incomeEntryDaysCount : 0;

      // Calculate total income hours for the entire month (including future entries)
      let totalIncomeHoursThisMonth = 0;
      dailyHours.forEach((dayData) => {
        totalIncomeHoursThisMonth += dayData.income;
      });

      // Calculate business days elapsed to date
      const businessDaysElapsed = collectBusinessDays(periodStart, today < periodEnd ? today : periodEnd, includeWeekends).length;

      // Calculate number of months in contract (needed for both capacity and contract pace calculations)
      let contractMonths = 12; // default
      if (hasBaseline && contractStart && boundedContractEnd) {
        const startYear = contractStart.getFullYear();
        const startMonth = contractStart.getMonth();
        const endYear = boundedContractEnd.getFullYear();
        const endMonth = boundedContractEnd.getMonth();
        contractMonths = (endYear - startYear) * 12 + (endMonth - startMonth) + 1;
      }

      // FIELD 1: Capacity Comparison - Calculate for ALL months from contract start to current viewing month
      // This ensures monthly and cumulative values use the same calculation
      const monthlyCapacityValues = [];
      let iterMonth = contractStart.getMonth();
      let iterYear = contractStart.getFullYear();
      const currentMonth = month;
      const currentYear = year;

      while (iterYear < currentYear || (iterYear === currentYear && iterMonth <= currentMonth)) {
        const iterMonthStart = startOfDay(new Date(iterYear, iterMonth, 1));
        const iterMonthEnd = startOfDay(new Date(iterYear, iterMonth + 1, 0));

        // Calculate period bounds for this iteration month
        const iterPeriodStart = contractStart > iterMonthStart ? contractStart : iterMonthStart;
        const iterPeriodEnd = boundedContractEnd && boundedContractEnd < iterMonthEnd ? boundedContractEnd : iterMonthEnd;

        let iterCapacityComparison = 0;

        if (iterPeriodEnd >= iterPeriodStart) {
          // Calculate business days for this month period
          const iterBusinessDaysList = collectBusinessDays(iterPeriodStart, iterPeriodEnd, includeWeekends);
          const iterBusinessDays = iterBusinessDaysList.length;

          // Get all entries for this contract in this month period
          const iterPeriodStartIso = isoDate(iterPeriodStart);
          const iterPeriodEndIso = isoDate(iterPeriodEnd);
          const iterMonthEntries = state.entries.filter((e) => {
            if (!e) return false;
            const resolvedId = e._resolvedContract?.id || e.contract_id;
            if (resolvedId !== contract.id) return false;
            const entryDateIso = getEntryDateIso(e);
            if (!entryDateIso) return false;
            return entryDateIso >= iterPeriodStartIso && entryDateIso <= iterPeriodEndIso;
          });

          // Determine if this iteration month is TODAY'S actual current month (not the viewing month)
          const todayMonth = today.getMonth();
          const todayYear = today.getFullYear();
          const isCurrentIterationMonth = (iterYear === todayYear && iterMonth === todayMonth);
          const iterCutoffDate = isCurrentIterationMonth ? today : iterMonthEnd;

          // Group by date and calculate hours
          const iterDailyHours = new Map();
          let iterTotalIncomeHoursThisMonth = 0;

          iterMonthEntries.forEach((entry) => {
            const entryDateIso = getEntryDateIso(entry);
            if (!entryDateIso) return;
            const entryDateObj = parseIsoDate(entryDateIso);
            if (!entryDateObj || Number.isNaN(entryDateObj.getTime())) return;

            const hours = (Number(entry.duration_minutes) || 0) / 60;
            if (hours <= 0) return;

            // For current month, include all entries; for past months, only up to end of month
            const includeInMap = isCurrentIterationMonth || entryDateObj <= iterCutoffDate;
            if (!includeInMap) return;

            if (!iterDailyHours.has(entryDateIso)) {
              iterDailyHours.set(entryDateIso, { income: 0, nonIncome: 0 });
            }

            const dayData = iterDailyHours.get(entryDateIso);
            if (entryContributesToIncome(entry)) {
              dayData.income += hours;
              iterTotalIncomeHoursThisMonth += hours;
            } else {
              dayData.nonIncome += hours;
            }
          });

          // Count full non-income days and days with entries
          let iterFullNonIncomeDays = 0;
          let iterDaysWithEntriesCount = 0;
          iterDailyHours.forEach((dayData, dateIso) => {
            const dateObj = parseIsoDate(dateIso);
            if (!dateObj) return;

            const incomeHours = dayData.income;
            const nonIncomeHours = dayData.nonIncome;

            // Count days that consume a business day: any income OR non-income >= standard hours
            if (incomeHours > 0 || nonIncomeHours >= standardHoursPerDay) {
              iterDaysWithEntriesCount++;
            }

            if (nonIncomeHours >= standardHoursPerDay) {
              iterFullNonIncomeDays++;
            }
          });

          // Calculate capacity comparison for this month
          const iterTotalExpected = iterBusinessDays * standardHoursPerDay;
          const iterAdjustedExpected = iterTotalExpected - (iterFullNonIncomeDays * standardHoursPerDay);

          // Calculate remaining days: only count future business days without entries
          let iterRemainingDays = 0;
          if (isCurrentIterationMonth) {
            // For current month, calculate future business days
            const iterTomorrow = new Date(today);
            iterTomorrow.setDate(iterTomorrow.getDate() + 1);
            const iterFutureBusinessDays = collectBusinessDays(
              iterTomorrow > iterPeriodEnd ? iterPeriodEnd : iterTomorrow,
              iterPeriodEnd,
              includeWeekends
            );
            const iterFutureDaysTotal = iterFutureBusinessDays.length;

            // Count how many future days already have entries
            let iterFutureDaysWithEntries = 0;
            iterDailyHours.forEach((dayData, dateIso) => {
              const dateObj = parseIsoDate(dateIso);
              if (!dateObj || dateObj <= today) return;
              const incomeHours = dayData.income;
              const nonIncomeHours = dayData.nonIncome;
              if (incomeHours > 0 || nonIncomeHours >= standardHoursPerDay) {
                iterFutureDaysWithEntries++;
              }
            });

            iterRemainingDays = Math.max(0, iterFutureDaysTotal - iterFutureDaysWithEntries);
          }
          // For past months, iterRemainingDays stays 0

          const iterProjectedTotal = iterTotalIncomeHoursThisMonth + (iterRemainingDays * standardHoursPerDay);
          iterCapacityComparison = iterAdjustedExpected - iterProjectedTotal;
        }

        monthlyCapacityValues.push({
          month: iterMonth,
          year: iterYear,
          capacityComparison: iterCapacityComparison
        });

        // Move to next month
        iterMonth++;
        if (iterMonth > 11) {
          iterMonth = 0;
          iterYear++;
        }
      }

      // Extract current month's capacity from the calculated values
      const currentMonthCapacity = monthlyCapacityValues.find(m => m.month === month && m.year === year);
      const capacityComparison = currentMonthCapacity ? currentMonthCapacity.capacityComparison : 0;

      // Calculate cumulative as simple sum of all monthly values
      const cumulativeCapacityComparison = monthlyCapacityValues.reduce((sum, m) => sum + m.capacityComparison, 0);

      // Still need these for other calculations
      const totalExpected = monthBusinessDays * standardHoursPerDay;
      const adjustedExpected = totalExpected - (fullNonIncomeDays * standardHoursPerDay);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const futureBusinessDays = collectBusinessDays(
        tomorrow > periodEnd ? periodEnd : tomorrow,
        periodEnd,
        includeWeekends
      );
      const futureDaysTotal = futureBusinessDays.length;
      let futureDaysWithEntries = 0;
      dailyHours.forEach((dayData, dateIso) => {
        const dateObj = parseIsoDate(dateIso);
        if (!dateObj || dateObj <= today) return;
        const incomeHours = dayData.income;
        const nonIncomeHours = dayData.nonIncome;
        if (incomeHours > 0 || nonIncomeHours >= standardHoursPerDay) {
          futureDaysWithEntries++;
        }
      });
      const remainingDays = Math.max(0, futureDaysTotal - futureDaysWithEntries);
      const projectedHoursThisMonth = totalIncomeHoursToDate + (remainingDays * projectedAverageDailyHours);
      const projectedVsContractAverage = averageContractHoursThisMonth != null
        ? projectedHoursThisMonth - averageContractHoursThisMonth
        : null;
      const projectedVsStandard = projectedHoursThisMonth - adjustedExpected;

      // FIELD 2: Contract Pace Comparison - Calculate for ALL months from contract start to current viewing month
      // This ensures monthly and cumulative values use the same calculation
      const monthlyContractPaceValues = [];
      let iterMonth2 = contractStart.getMonth();
      let iterYear2 = contractStart.getFullYear();

      while (iterYear2 < currentYear || (iterYear2 === currentYear && iterMonth2 <= currentMonth)) {
        const iterMonthStart = startOfDay(new Date(iterYear2, iterMonth2, 1));
        const iterMonthEnd = startOfDay(new Date(iterYear2, iterMonth2 + 1, 0));

        // Calculate period bounds for this iteration month
        const iterPeriodStart = contractStart > iterMonthStart ? contractStart : iterMonthStart;
        const iterPeriodEnd = boundedContractEnd && boundedContractEnd < iterMonthEnd ? boundedContractEnd : iterMonthEnd;

        let iterContractPaceComparison = null;

        if (iterPeriodEnd >= iterPeriodStart && hasBaseline) {
          // Calculate business days for this month period
          const iterBusinessDaysList = collectBusinessDays(iterPeriodStart, iterPeriodEnd, includeWeekends);
          const iterBusinessDays = iterBusinessDaysList.length;

          // Get all entries for this contract in this month period
          const iterPeriodStartIso = isoDate(iterPeriodStart);
          const iterPeriodEndIso = isoDate(iterPeriodEnd);
          const iterMonthEntries = state.entries.filter((e) => {
            if (!e) return false;
            const resolvedId = e._resolvedContract?.id || e.contract_id;
            if (resolvedId !== contract.id) return false;
            const entryDateIso = getEntryDateIso(e);
            if (!entryDateIso) return false;
            return entryDateIso >= iterPeriodStartIso && entryDateIso <= iterPeriodEndIso;
          });

          // Determine if this iteration month is TODAY'S actual current month (not the viewing month)
          const todayMonth = today.getMonth();
          const todayYear = today.getFullYear();
          const isCurrentIterationMonth = (iterYear2 === todayYear && iterMonth2 === todayMonth);
          const iterCutoffDate = isCurrentIterationMonth ? today : iterMonthEnd;

          // Calculate total income hours to date (up to cutoff)
          let iterTotalIncomeHoursToDate = 0;
          iterMonthEntries.forEach((entry) => {
            const entryDateIso = getEntryDateIso(entry);
            if (!entryDateIso) return;
            const entryDateObj = parseIsoDate(entryDateIso);
            if (!entryDateObj || Number.isNaN(entryDateObj.getTime())) return;

            // Only count entries up to cutoff
            if (entryDateObj > iterCutoffDate) return;

            const hours = (Number(entry.duration_minutes) || 0) / 60;
            if (hours <= 0) return;

            if (entryContributesToIncome(entry)) {
              iterTotalIncomeHoursToDate += hours;
            }
          });

          // Calculate contract pace comparison
          const iterMonthlyPace = Number(contract.total_hours || 0) / contractMonths;
          if (iterBusinessDays > 0) {
            const iterBusinessDaysElapsed = collectBusinessDays(iterPeriodStart, iterCutoffDate < iterPeriodEnd ? iterCutoffDate : iterPeriodEnd, includeWeekends).length;
            const iterProRatedPace = iterMonthlyPace * (iterBusinessDaysElapsed / iterBusinessDays);
            iterContractPaceComparison = iterProRatedPace - iterTotalIncomeHoursToDate;
          }
        }

        monthlyContractPaceValues.push({
          month: iterMonth2,
          year: iterYear2,
          contractPaceComparison: iterContractPaceComparison
        });

        // Move to next month
        iterMonth2++;
        if (iterMonth2 > 11) {
          iterMonth2 = 0;
          iterYear2++;
        }
      }

      // Extract current month's contract pace from the calculated values
      const currentMonthContractPace = monthlyContractPaceValues.find(m => m.month === month && m.year === year);
      const contractPaceComparison = currentMonthContractPace ? currentMonthContractPace.contractPaceComparison : null;

      // Calculate cumulative as simple sum of all monthly values (only for non-null values)
      const cumulativeContractPaceComparison = monthlyContractPaceValues
        .filter(m => m.contractPaceComparison !== null)
        .reduce((sum, m) => sum + m.contractPaceComparison, 0);

      // Aggregate values for multi-contract summaries
      aggregatedIncomeHoursToDate += totalIncomeHoursToDate;
      aggregatedProjectedHoursThisMonth += projectedHoursThisMonth;
      aggregatedStandardHoursBasedOnBusinessDays += adjustedExpected;
      aggregatedProjectedVsStandardHours += projectedVsStandard;
      if (typeof capacityComparison === 'number') {
        aggregatedCapacityComparisonTotal += capacityComparison;
      }
      if (contractPaceComparison !== null && contractPaceComparison !== undefined) {
        aggregatedContractPaceComparisonTotal += contractPaceComparison;
        aggregatedContractPaceComparisonCount++;
      }
      if (projectedVsContractAverage !== null) {
        aggregatedProjectedVsContractAverage += projectedVsContractAverage;
        aggregatedProjectedVsContractAverageCount++;
      }

      contractSummaries.push({
        contractId: contract.id,
        contractName: contract.name || 'Untitled contract',
        includeWeekends,
        monthBusinessDays,
        businessDaysEvaluated: evaluatedBusinessDaysWithFuture,
        pastBusinessDays,
        futureBusinessDays: futureBusinessDayContribution,
        businessDaysRemaining,
        hoursLoggedToDate,
        pastHours: totalHours,
        futureHours: futureIncomeHours,
        actualAverageDailyHours,
        projectedAverageDailyHours,
        projectedHoursThisMonth,
        expectedHoursLoggedToDate,
        totalExpectedHoursThisMonth,
        averageContractHoursThisMonth,
        standardHoursBasedOnBusinessDays: adjustedExpected,
        expectedHoursRemaining,
        projectedVariance,
        trendMethod,
        trendFallbackApplied,
        status,
        statusText,
        contractPaceComparison,
        capacityComparison,
        cumulativeCapacityComparison,
        cumulativeContractPaceComparison
      });
    });

    if (!contractSummaries.length) return null;

    const uniquePastDays = aggregatedPastDays.size;
    const totalEvaluatedDays = uniquePastDays + aggregatedFutureBusinessDays;
    if (totalEvaluatedDays <= 2) return null;

    const aggregatedIncomeDays = aggregatedIncomeEntryDays.size;
    const averageHours = aggregatedIncomeDays > 0 ? (aggregatedIncomeHoursToDate / aggregatedIncomeDays) : 0;

    contractSummaries.sort((a, b) => a.contractName.localeCompare(b.contractName));

    return {
      monthKey: monthKeyFor(year, month),
      contracts: contractSummaries,
      contractCount: contractSummaries.length,
      averageDailyHours: averageHours,
      totalProjectedHoursThisMonth: aggregatedProjectedHoursThisMonth,
      totalStandardHoursBasedOnBusinessDays: aggregatedStandardHoursBasedOnBusinessDays,
      totalCapacityComparison: aggregatedCapacityComparisonTotal,
      totalContractPaceComparison: aggregatedContractPaceComparisonCount > 0 ? aggregatedContractPaceComparisonTotal : null,
      totalProjectedVsContractAverage: aggregatedProjectedVsContractAverageCount > 0 ? aggregatedProjectedVsContractAverage : null,
      totalProjectedVsStandardHours: aggregatedProjectedVsStandardHours,
      totalAverageContractHoursThisMonth: aggregatedAverageContractHours,
      baselineContractCount: baselineContracts
    };

  }



  function renderExpectedHoursBreakdown(summary) {
    if (!expectedHoursContentEl) return;
    expectedHoursContentEl.innerHTML = '';
    if (!summary || !summary.contracts || !summary.contracts.length) return;

    const buildLineRow = (label, title) => {
      const row = document.createElement('div');
      row.className = 'ts-expected-line';
      const labelEl = document.createElement('span');
      labelEl.textContent = label;
      if (title) {
        const infoIcon = document.createElement('span');
        infoIcon.className = 'ts-info-icon';
        infoIcon.textContent = 'i';
        infoIcon.style.marginLeft = '4px';
        infoIcon.style.fontSize = '0.75em';
        infoIcon.title = title;
        infoIcon.style.cursor = 'help';
        labelEl.appendChild(infoIcon);
      }
      const valueEl = document.createElement('span');
      valueEl.style.display = 'flex';
      valueEl.style.alignItems = 'center';
      valueEl.style.justifyContent = 'flex-end';
      valueEl.style.gap = '6px';
      row.append(labelEl, valueEl);
      return { row, valueEl };
    };

    const makeLine = (label, value, title) => {
      const { row, valueEl } = buildLineRow(label, title);
      valueEl.textContent = value;
      return row;
    };

    const makeLineWithDiff = (label, value, diffHours, title) => {
      const { row, valueEl } = buildLineRow(label, title);
      if (typeof diffHours === 'number' && !Number.isNaN(diffHours)) {
        const roundedDiff = Math.round(diffHours * 100) / 100;
        if (Math.abs(roundedDiff) >= 0.01) {
          const diffEl = document.createElement('span');
          const isPositive = roundedDiff >= 0;
          diffEl.style.color = isPositive ? 'var(--danger)' : 'var(--success)';
          diffEl.style.whiteSpace = 'nowrap';
          const arrow = isPositive ? '' : '';
          const diffValue = `${formatDecimalHours(Math.abs(roundedDiff))} hrs`;
          diffEl.textContent = `${arrow} ${diffValue}`;
          valueEl.appendChild(diffEl);
        }
      }
      const valueText = document.createElement('span');
      valueText.textContent = value;
      valueEl.appendChild(valueText);
      return row;
    };

    const appendSectionHeader = (container, text) => {
      const header = document.createElement('div');
      header.className = 'ts-expected-section-title';
      header.textContent = text;
      header.style.gridColumn = '1 / -1';
      header.style.fontWeight = '600';
      header.style.margin = '8px 0 4px';
      container.appendChild(header);
    };

    const createDivider = () => {
      const divider = document.createElement('div');
      divider.style.gridColumn = '1 / -1';
      divider.style.height = '1px';
      divider.style.background = 'var(--border)';
      divider.style.margin = '16px 0 8px';
      return divider;
    };

    const showProjectedAverage = getTrendMethod() !== 'current_month';
    const firstContract = summary.contracts[0];

    const methodLabels = {
      standard_contract_hours: 'standard contract hours',
      current_month: 'current month',
      last_3_months: 'last 3 months',
      contract_lifetime: 'contract lifetime',
      same_month_last_year: 'same month last year'
    };
    const getTrendTooltip = (contract) => {
      if (!contract || !contract.trendMethod) return null;
      const methodLabel = methodLabels[contract.trendMethod] || contract.trendMethod;
      if (contract.trendFallbackApplied) {
        return `Trend projection based on ${methodLabel} average (insufficient data for selected method)`;
      }
      return `Trend projection based on ${methodLabel} average`;
    };
    const tooltipText = {
      averageDaily: 'Income-generating hours logged so far divided by the count of days that include income entries.',
      projectedAverage: 'The projected daily trend, based on your selected calculation method.',
      totalProjected: 'Hours logged to date plus the remaining business days multiplied by the projected average daily hours.',
      targetContract: 'Average contract hours per month (total contract hours  contract duration).',
      targetBusiness: '(Business days in this month - business days the user takes leave)  standard hours per day.',
      expectedHoursRemaining: 'Projected hours still needed to hit this months target after accounting for logged/projected time.',
      businessDaysRemaining: 'Business days left in the current month (includes upcoming leave as deductions).'
    };
    const appendCapacityLines = (container, contract) => {
      if (!contract) return false;
      let appended = false;
      if (contract.contractPaceComparison !== null && contract.contractPaceComparison !== undefined) {
        const paceValue = formatSignedHours(contract.contractPaceComparison);
        const tooltip = 'Shows if you\'re ahead or behind the linear contract pace (target hours per month). ' +
                       '\n\nFormula: (contract_hours  contract_months  days_elapsed  business_days) - income_hours_logged';
        container.appendChild(makeLine('Contract monthly average capacity', `${paceValue} hrs`, tooltip));
        appended = true;
      }
      if (typeof contract.cumulativeContractPaceComparison === 'number') {
        const cumulativePaceValue = formatSignedHours(contract.cumulativeContractPaceComparison);
        const tooltip = 'Running total showing cumulative performance against contract pace across all months. ' +
                       'Positive means you\'re behind on contract hours, negative means you\'re ahead.';
        container.appendChild(makeLine('Cumulative contract monthly average capacity', `${cumulativePaceValue} hrs`, tooltip));
        appended = true;
      }
      if (typeof contract.capacityComparison === 'number') {
        const capacityValue = formatSignedHours(contract.capacityComparison);
        const tooltip = 'Shows how many hours you need to work to hit standard hours for the business days in this month, accounting for leave. ' +
                       '\n\nFormula: (business_days  standard_hours - full_non_income_days  standard_hours) - (income_logged + remaining_days  standard_hours)';
        container.appendChild(makeLine('Monthly capacity based on available business days', `${capacityValue} hrs`, tooltip));
        appended = true;
      }
      if (typeof contract.cumulativeCapacityComparison === 'number') {
        const cumulativeValue = formatSignedHours(contract.cumulativeCapacityComparison);
        const tooltip = 'Running total of monthly capacity across all months in the contract. ' +
                       'Shows cumulative hours needed to maintain standard hours for all days worked.';
        container.appendChild(makeLine('Cumulative monthly capacity based on available business days', `${cumulativeValue} hrs`, tooltip));
        appended = true;
      }
      return appended;
    };

    const appendCapacitySection = (container, contract) => {
      const fragment = document.createDocumentFragment();
      const appended = appendCapacityLines(fragment, contract);
      if (!appended) return false;
      appendSectionHeader(container, 'Hour Budgets');
      container.appendChild(fragment);
      return true;
    };

    const aggregate = document.createElement('div');
    aggregate.className = 'ts-expected-aggregate';
    const isSingleContract = summary.contractCount === 1;
    if (isSingleContract && firstContract) {
      const budgetsRendered = appendCapacitySection(aggregate, firstContract);
      if (budgetsRendered) aggregate.appendChild(createDivider());
    }

    appendSectionHeader(aggregate, 'Projections');
    aggregate.appendChild(makeLine('Average daily hours', `${formatDecimalHours(summary.averageDailyHours)} hrs`, tooltipText.averageDaily));

    if (showProjectedAverage && firstContract && firstContract.projectedAverageDailyHours != null) {
      aggregate.appendChild(makeLine('Projected average daily hours', `${formatDecimalHours(firstContract.projectedAverageDailyHours)} hrs`, getTrendTooltip(firstContract)));
    }

    if (isSingleContract && firstContract) {
      aggregate.appendChild(makeLine('Total projected hours', `${formatDecimalHours(firstContract.projectedHoursThisMonth)} hrs`, tooltipText.totalProjected));
      if (firstContract.averageContractHoursThisMonth != null) {
        const contractDiff = firstContract.projectedHoursThisMonth - firstContract.averageContractHoursThisMonth;
        aggregate.appendChild(makeLineWithDiff('Target hours based on contract average', `${formatDecimalHours(firstContract.averageContractHoursThisMonth)} hrs`, contractDiff, tooltipText.targetContract));
      } else {
        aggregate.appendChild(makeLine('Target hours based on contract average', 'Not available for unlimited contracts', tooltipText.targetContract));
      }
      const standardHours = Number(firstContract.standardHoursBasedOnBusinessDays) || 0;
      const standardDiff = firstContract.projectedHoursThisMonth - standardHours;
      aggregate.appendChild(makeLineWithDiff('Target hours based on available business days', `${formatDecimalHours(standardHours)} hrs`, standardDiff, tooltipText.targetBusiness));
    } else {
      aggregate.appendChild(makeLine('Total projected hours', `${formatDecimalHours(summary.totalProjectedHoursThisMonth)} hrs`, tooltipText.totalProjected));
      if (summary.baselineContractCount > 0) {
        const contractDiff = summary.totalProjectedHoursThisMonth - summary.totalAverageContractHoursThisMonth;
        aggregate.appendChild(makeLineWithDiff('Target hours based on contract average', `${formatDecimalHours(summary.totalAverageContractHoursThisMonth)} hrs`, contractDiff, tooltipText.targetContract));
      }
      const standardTarget = Number(summary.totalStandardHoursBasedOnBusinessDays) || 0;
      const standardDiff = summary.totalProjectedHoursThisMonth - standardTarget;
      aggregate.appendChild(makeLineWithDiff('Target hours based on available business days', `${formatDecimalHours(standardTarget)} hrs`, standardDiff, tooltipText.targetBusiness));
    }

    expectedHoursContentEl.appendChild(aggregate);

    if (summary.contractCount > 1) {
      summary.contracts.forEach((contract) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'ts-expected-contract';

        const header = document.createElement('div');
        header.className = 'ts-expected-contract-header';
        const nameEl = document.createElement('span');
        nameEl.textContent = contract.contractName;
        const hoursEl = document.createElement('span');
        hoursEl.textContent = `${formatDecimalHours(contract.hoursLoggedToDate)} hrs logged`;
        header.append(nameEl, hoursEl);
        wrapper.appendChild(header);

        const meta = document.createElement('div');
        meta.className = 'ts-expected-meta';
        meta.textContent = contract.includeWeekends
          ? 'Including weekends in averages'
          : 'Weekdays only (Mon-Fri)';
        wrapper.appendChild(meta);

        const lines = document.createElement('div');
        lines.className = 'ts-expected-lines';
        const budgetsRendered = appendCapacitySection(lines, contract);
        if (budgetsRendered) lines.appendChild(createDivider());

        appendSectionHeader(lines, 'Projections');
        lines.appendChild(makeLine('Average daily hours', `${formatDecimalHours(contract.actualAverageDailyHours)} hrs`, tooltipText.averageDaily));
        if (showProjectedAverage) {
          lines.appendChild(makeLine('Projected average daily hours', `${formatDecimalHours(contract.projectedAverageDailyHours)} hrs`, getTrendTooltip(contract)));
        }

        lines.appendChild(makeLine('Total projected hours', `${formatDecimalHours(contract.projectedHoursThisMonth)} hrs`, tooltipText.totalProjected));

        if (contract.averageContractHoursThisMonth != null) {
          const contractDiff = contract.projectedHoursThisMonth - contract.averageContractHoursThisMonth;
          lines.appendChild(makeLineWithDiff('Target hours based on contract average', `${formatDecimalHours(contract.averageContractHoursThisMonth)} hrs`, contractDiff, tooltipText.targetContract));
        } else {
          lines.appendChild(makeLine('Target hours based on contract average', 'Not available for unlimited contracts', tooltipText.targetContract));
        }

        const contractStandardHours = Number(contract.standardHoursBasedOnBusinessDays) || 0;
        const standardDiff = contract.projectedHoursThisMonth - contractStandardHours;
        lines.appendChild(makeLineWithDiff('Target hours based on available business days', `${formatDecimalHours(contractStandardHours)} hrs`, standardDiff, tooltipText.targetBusiness));

        lines.appendChild(makeLine('Expected hours remaining', `${formatDecimalHours(contract.expectedHoursRemaining)} hrs`, tooltipText.expectedHoursRemaining));
        lines.appendChild(makeLine('Business days remaining', formatDecimalHours(contract.businessDaysRemaining), tooltipText.businessDaysRemaining));
        wrapper.appendChild(lines);

        const statusEl = document.createElement('div');
        statusEl.className = `ts-expected-status ${contract.status}`;
        statusEl.textContent = contract.statusText;
        wrapper.appendChild(statusEl);

        expectedHoursContentEl.appendChild(wrapper);
      });
    }
  }


  function resolveProjectedVarianceValue(summary) {
    if (!summary) return null;
    const selection = getProjectionsVarianceValue();
    const singleContract = summary.contractCount === 1 ? summary.contracts[0] : null;
    const projectedVsContract = (contract) => {
      if (!contract || contract.averageContractHoursThisMonth == null) return null;
      return contract.projectedHoursThisMonth - contract.averageContractHoursThisMonth;
    };
    const projectedVsStandard = (contract) => {
      if (!contract) return null;
      const standardHours = Number(contract.standardHoursBasedOnBusinessDays) || 0;
      return contract.projectedHoursThisMonth - standardHours;
    };

    switch (selection) {
      case 'contract_pace':
        return singleContract ? singleContract.contractPaceComparison : summary.totalContractPaceComparison;
      case 'projected_vs_contract':
        if (singleContract) return projectedVsContract(singleContract);
        return summary.totalProjectedVsContractAverage;
      case 'projected_vs_standard':
        if (singleContract) return projectedVsStandard(singleContract);
        return summary.totalProjectedVsStandardHours;
      case 'monthly_capacity':
      default:
        return singleContract ? singleContract.capacityComparison : summary.totalCapacityComparison;
    }
  }

  function resetExpectedHoursBadge(text) {
    if (!expectedHoursBadge) return;
    expectedHoursBadge.className = 'ts-badge ts-expected-badge';
    expectedHoursBadge.textContent = text || 'Projected variance: --';
  }

  function applyExpectedHoursBadge(summary) {
    if (!expectedHoursBadge) return;
    resetExpectedHoursBadge();
    if (!summary) return;

    const varianceValue = resolveProjectedVarianceValue(summary);
    const suffix = summary.contractCount > 1 ? ` (${summary.contractCount})` : '';
    if (varianceValue === null || varianceValue === undefined || Number.isNaN(varianceValue)) {
      expectedHoursBadge.textContent = `Projected variance: --${suffix}`;
      return;
    }

    const rounded = Math.round(varianceValue * 100) / 100;
    expectedHoursBadge.textContent = `Projected variance: ${formatSignedHours(varianceValue)} hrs${suffix}`;
    if (rounded > 0.01) {
      expectedHoursBadge.classList.add('error');
    } else if (rounded < -0.01) {
      expectedHoursBadge.classList.add('success');
    }
  }

  function renderExpectedHoursSummary() {
    if (!expectedHoursBadge || !expectedHoursBreakdownEl) return;
    if (!getFeatureFlag('expected_monthly_hours')) {
      expectedHoursBadge.style.display = 'none';
      resetExpectedHoursBadge();
      state.expectedHoursSummary = null;
      expectedHoursExpanded = false;
      applyExpectedHoursVisibility();
      if (expectedHoursContentEl) expectedHoursContentEl.innerHTML = '';
      return;
    }

    ensureCalendarState();
    const { year, month } = state.calendar;
    const summary = buildExpectedHoursSummary(year, month);
    state.expectedHoursSummary = summary;

    if (!summary) {
      expectedHoursBadge.style.display = 'none';
      resetExpectedHoursBadge();
      expectedHoursExpanded = false;
      applyExpectedHoursVisibility();
      if (expectedHoursContentEl) expectedHoursContentEl.innerHTML = '';
      return;
    }

    expectedHoursBadge.style.display = 'inline-flex';
    applyExpectedHoursBadge(summary);

    applyExpectedHoursVisibility();
    if (expectedHoursExpanded) {
      renderExpectedHoursBreakdown(summary);
    } else if (expectedHoursContentEl) {
      expectedHoursContentEl.innerHTML = '';
    }
  }
  function renderEntries() {
    renderCalendar();
    renderContractsUI();
  }
  function deleteEntry(id) {
    const idx = state.entries.findIndex((e) => e.id === id);
    if (idx === -1) return;
    const backup = state.entries[idx];
    state.entries.splice(idx, 1);
    recordPendingEntryDelete(id);
    saveCache();
    renderEntries();
    setStatus('Deleting...', 'warn');
    google.script.run
      .withSuccessHandler(() => {
        if (!entriesSyncInFlight) resolvePendingEntryDelete(id);
        setStatus('Deleted', 'success');
      })
      .withFailureHandler(() => {
        state.entries.splice(idx, 0, backup);
        resolvePendingEntryDelete(id);
        saveCache();
        renderEntries();
        setStatus('Delete failed', 'error');
      })
      .api_deleteEntry(id);
  }
  function editEntry(id) {
    const entry = state.entries.find((e) => e.id === id);
    if (!entry) return;
    state.selectedCalendarDate = entry.date;
    populateManualForm(entry, true);
    renderCalendar();
  }

  // Calendar rendering
  function ensureCalendarState() {
    if (!state.calendar) {
      const today = new Date();
      state.calendar = { year: today.getFullYear(), month: today.getMonth() };
    }
    if (!state.selectedCalendarDate) {
      state.selectedCalendarDate = todayIso();
      if (!state.editingEntryId) setManualDate(state.selectedCalendarDate);
    }
  }
  function calendarStartDate(year, month) {
    const first = new Date(year, month, 1);
    const offset = (first.getDay() + 6) % 7; // shift so Monday=0
    return new Date(year, month, 1 - offset);
  }
  function minutesByDate() {
    return state.entries.reduce((map, entry) => {
      if (!entry.date) return map;
      const key = entry.date;
      map[key] = (map[key] || 0) + (Number(entry.duration_minutes) || 0);
      return map;
    }, {});
  }

  function minutesByDateAndHourType() {
    return state.entries.reduce((map, entry) => {
      if (!entry.date) return map;
      const date = entry.date;
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();

      if (!map[date]) map[date] = {};
      if (!map[date][hourTypeId]) map[date][hourTypeId] = 0;

      map[date][hourTypeId] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});
  }

  function getDefaultHourType() {
    if (!state.hourTypes.length) return null;
    return state.hourTypes.find(ht => ht.is_default) || state.hourTypes[0];
  }

  function getFeatureFlag(flagKey) {
  const flag = state.featureFlags[flagKey] || DEFAULT_FEATURE_FLAGS[flagKey];
  return flag ? flag.enabled : false;
}

  function isDeductionCategoriesEnabled() {
  return !!getFeatureFlag('enable_deduction_categories');
}
  function renderCalendar() {
    ensureCalendarState();

    // Get filtered hour type IDs
    const activeHourTypeIds = state.calendarFilteredHourTypes || state.hourTypes.map(ht => ht.id);

    // Filter entries by active hour types
    const filteredEntries = state.entries.filter(entry => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      return activeHourTypeIds.includes(hourTypeId);
    });

    // Calculate totals based on filtered entries
    const totals = filteredEntries.reduce((map, entry) => {
      if (!entry.date) return map;
      if (!map[entry.date]) map[entry.date] = 0;
      map[entry.date] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});

    const hourTypeTotals = filteredEntries.reduce((map, entry) => {
      if (!entry.date) return map;
      const date = entry.date;
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      if (!map[date]) map[date] = {};
      if (!map[date][hourTypeId]) map[date][hourTypeId] = 0;
      map[date][hourTypeId] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});

    const defaultHourType = getDefaultHourType();
    const defaultHourTypeId = defaultHourType?.id || getDefaultHourTypeId();
    const hourTypeOrderIndex = (state.hourTypes || []).reduce((idxMap, ht, idx) => {
      if (ht && ht.id) idxMap[ht.id] = idx;
      return idxMap;
    }, {});
    const sortHourTypeIds = (ids) => {
      return ids.slice().sort((a, b) => {
        const orderA = Number.isInteger(hourTypeOrderIndex[a]) ? hourTypeOrderIndex[a] : Number.MAX_SAFE_INTEGER;
        const orderB = Number.isInteger(hourTypeOrderIndex[b]) ? hourTypeOrderIndex[b] : Number.MAX_SAFE_INTEGER;
        if (orderA !== orderB) return orderA - orderB;
        const nameA = state.hourTypeMap[a]?.name || '';
        const nameB = state.hourTypeMap[b]?.name || '';
        return nameA.localeCompare(nameB);
      });
    };
    const grid = document.getElementById('calendar-grid');
    const label = document.getElementById('calendar-label');
    const monthTotalEl = document.getElementById('calendar-month-total');
    const activeMonth = new Date(state.calendar.year, state.calendar.month, 1);
    label.textContent = activeMonth.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    const monthKey = `${activeMonth.getFullYear()}-${String(activeMonth.getMonth() + 1).padStart(2, '0')}`;
    const monthTotalMinutes = Object.keys(totals).reduce((acc, key) => {
      if (key.startsWith(monthKey)) {
        acc += totals[key];
      }
      return acc;
    }, 0);

    // If hour types are enabled, also calculate income-contributing hours
    let monthIncomeMinutes = 0;
    if (getFeatureFlag('hour_types') && state.hourTypes.length > 0) {
      const monthEntries = filteredEntries.filter(entry =>
        entry.date && entry.date.startsWith(monthKey)
      );
      monthIncomeMinutes = monthEntries.reduce((acc, entry) => {
        const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
        const hourType = state.hourTypeMap[hourTypeId];
        const contributesToIncome = hourType ? hourType.contributes_to_income : true;
        if (contributesToIncome) {
          acc += Number(entry.duration_minutes) || 0;
        }
        return acc;
      }, 0);
    }

    const roundedMonthTotal = roundDuration(monthTotalMinutes);
    if (getFeatureFlag('hour_types') && state.hourTypes.length > 0 && monthIncomeMinutes !== monthTotalMinutes) {
      const roundedIncomeTotal = roundDuration(monthIncomeMinutes);
      monthTotalEl.textContent = `Total hours: ${formatHours(roundedMonthTotal)} (${formatHours(roundedIncomeTotal)} billable)`;
    } else {
      monthTotalEl.textContent = `Total hours: ${formatHours(roundedMonthTotal)}`;
    }

    // Render hour types breakdown
    renderHourTypesBreakdown(filteredEntries, monthKey);

    grid.innerHTML = '';
    const start = calendarStartDate(state.calendar.year, state.calendar.month);
    for (let i = 0; i < 42; i++) {
      const current = new Date(start.getFullYear(), start.getMonth(), start.getDate() + i);
      const iso = isoDate(current);
      const cell = document.createElement('div');
      cell.className = 'ts-calendar-cell';
      cell.dataset.date = iso;
      if (current.getMonth() !== state.calendar.month) cell.classList.add('inactive');
      if (iso === todayIso()) cell.classList.add('today');
      const totalMinutes = totals[iso] || 0;
      if (totalMinutes > 0) cell.classList.add('has-entries');
      if (iso === state.selectedCalendarDate) cell.classList.add('selected');
      const dayEl = document.createElement('div');
      dayEl.className = 'ts-calendar-day';

      // Check for public holiday
      const holiday = state.publicHolidayMap[iso];
      if (holiday && getFeatureFlag('enable_public_holidays')) {
        const holidayName = holiday.localName || holiday.name || '';
        const truncatedName = holidayName.length > 12 ? holidayName.substring(0, 12) + '' : holidayName;
        dayEl.innerHTML = `${current.getDate()} <span class="ts-calendar-holiday-label">${truncatedName}</span>`;
        cell.classList.add('ts-calendar-holiday');
      } else {
        dayEl.textContent = current.getDate();
      }

      // Check if hour types feature is enabled and we have multiple hour types
      const showHourTypes = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
      const dayHourTypes = hourTypeTotals[iso] || {};

      if (showHourTypes && Object.keys(dayHourTypes).length > 0) {
        const defaultMinutes = dayHourTypes[defaultHourTypeId] || 0;
        const hasDefault = defaultMinutes > 0;
        const hasMultiple = Object.keys(dayHourTypes).length > 1 || (Object.keys(dayHourTypes).length === 1 && !hasDefault);

        // When there are multiple hour types with default present: show non-default on top, default on bottom
        // When only non-default hours exist: show them on bottom
        if (hasMultiple && hasDefault) {
          // Show other hour types as small colored indicators at top
          const otherTypesEl = document.createElement('div');
          otherTypesEl.className = 'ts-calendar-hour-types';
          const orderedOtherIds = sortHourTypeIds(Object.keys(dayHourTypes).filter(id => id !== defaultHourTypeId && dayHourTypes[id] > 0));
          orderedOtherIds.forEach(hourTypeId => {
            if (hourTypeId !== defaultHourTypeId && dayHourTypes[hourTypeId] > 0) {
              const hourType = state.hourTypeMap[hourTypeId];
              if (hourType) {
                const minutes = dayHourTypes[hourTypeId];
                const roundedMinutes = roundDuration(minutes);
                const indicator = document.createElement('span');
                indicator.className = 'ts-calendar-hour-type-indicator';
                indicator.style.color = hourType.color;
                indicator.textContent = formatHours(roundedMinutes);
                indicator.title = `${hourType.name}: ${formatHours(roundedMinutes)}`;
                indicator.dataset.hourTypeId = hourTypeId;
                indicator.addEventListener('click', (event) => {
                  event.stopPropagation();
                  handleCalendarClick(iso, hourTypeId);
                });
                otherTypesEl.appendChild(indicator);
              }
            }
          });

          // Show default hour type as main total at bottom
          const totalEl = document.createElement('div');
          totalEl.className = 'ts-calendar-total';
          const roundedMinutes = roundDuration(defaultMinutes);
          totalEl.textContent = formatHours(roundedMinutes);

          cell.append(dayEl, otherTypesEl, totalEl);
        } else if (!hasDefault) {
          // Only non-default hours exist - show them at bottom
          const otherTypesEl = document.createElement('div');
          otherTypesEl.className = 'ts-calendar-hour-types';
          const orderedIds = sortHourTypeIds(Object.keys(dayHourTypes).filter(id => dayHourTypes[id] > 0));
          orderedIds.forEach(hourTypeId => {
            if (dayHourTypes[hourTypeId] > 0) {
              const hourType = state.hourTypeMap[hourTypeId];
              if (hourType) {
                const minutes = dayHourTypes[hourTypeId];
                const roundedMinutes = roundDuration(minutes);
                const indicator = document.createElement('span');
                indicator.className = 'ts-calendar-hour-type-indicator';
                indicator.style.color = hourType.color;
                indicator.textContent = formatHours(roundedMinutes);
                indicator.title = `${hourType.name}: ${formatHours(roundedMinutes)}`;
                indicator.dataset.hourTypeId = hourTypeId;
                indicator.addEventListener('click', (event) => {
                  event.stopPropagation();
                  handleCalendarClick(iso, hourTypeId);
                });
                otherTypesEl.appendChild(indicator);
              }
            }
          });

          cell.append(dayEl, otherTypesEl);
        } else {
          // Only default hour type exists
          const totalEl = document.createElement('div');
          totalEl.className = 'ts-calendar-total';
          if (defaultMinutes === 0) totalEl.classList.add('empty');
          if (defaultMinutes === 0) {
            totalEl.textContent = state.showZeroHours ? '0' : '';
          } else {
            const roundedMinutes = roundDuration(defaultMinutes);
            totalEl.textContent = formatHours(roundedMinutes);
          }

          cell.append(dayEl, totalEl);
        }
      } else {
        // Original behavior - show total hours
        const totalEl = document.createElement('div');
        totalEl.className = 'ts-calendar-total';
        if (totalMinutes === 0) totalEl.classList.add('empty');
        if (totalMinutes === 0) {
          totalEl.textContent = state.showZeroHours ? '0' : '';
        } else {
          const roundedMinutes = roundDuration(totalMinutes);
          totalEl.textContent = formatHours(roundedMinutes);
        }
        cell.append(dayEl, totalEl);
      }

      cell.onclick = () => handleCalendarClick(iso);
    grid.appendChild(cell);
  }
  renderIncomeSummary();
  renderExpectedHoursSummary();
  updatePayrollHelperButtons();
}

  function renderHourTypesBreakdown(entries, monthKey) {
    if (!hourTypesBreakdownListEl) return;

    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
    if (!hourTypesEnabled) {
      hourTypesBreakdownListEl.innerHTML = '';
      return;
    }

    // Calculate totals for each hour type in the month
    const monthEntries = entries.filter(entry => entry.date && entry.date.startsWith(monthKey));
    const hourTypeTotals = monthEntries.reduce((map, entry) => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      if (!map[hourTypeId]) map[hourTypeId] = 0;
      map[hourTypeId] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});

    // Sort hour types by total (descending)
    const sortedHourTypes = Object.keys(hourTypeTotals)
      .map(id => ({
        id,
        hourType: state.hourTypeMap[id],
        minutes: hourTypeTotals[id]
      }))
      .filter(item => item.hourType && item.minutes > 0)
      .sort((a, b) => b.minutes - a.minutes);

    if (sortedHourTypes.length === 0) {
      hourTypesBreakdownListEl.innerHTML = '<div class="ts-note">No hours tracked this month</div>';
      return;
    }

    const html = sortedHourTypes.map(item => {
      const roundedMinutes = roundDuration(item.minutes);
      return `
        <div class="ts-hour-type-breakdown-row">
          <div class="ts-hour-type-breakdown-color" style="background-color: ${item.hourType.color}"></div>
          <div class="ts-hour-type-breakdown-name">${item.hourType.name}</div>
          <div class="ts-hour-type-breakdown-value">${formatHours(roundedMinutes)}</div>
        </div>
      `;
    }).join('');

    hourTypesBreakdownListEl.innerHTML = html;
  }

  function handleCalendarClick(dateIso, targetHourTypeId) {
    state.selectedCalendarDate = dateIso;
    setManualDate(dateIso);
    updateTabStates();
    renderCalendar();

    // Check if there's an existing entry for this date
    const existingEntries = state.entries.filter(entry => entry.date === dateIso);
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
    const defaultHourTypeId = getDefaultHourTypeId();

    if (existingEntries.length > 0) {
      let existingEntry = null;
      if (targetHourTypeId && hourTypesEnabled) {
        existingEntry = existingEntries.find(entry => (entry.hour_type_id || getDefaultHourTypeId()) === targetHourTypeId) || null;
      }
      if (!existingEntry && hourTypesEnabled) {
        existingEntry = existingEntries.find(entry => (entry.hour_type_id || defaultHourTypeId) === defaultHourTypeId) || null;
      }
      if (!existingEntry) existingEntry = existingEntries[0];

      const entryType = resolveEntryType(existingEntry);

      // Prepopulate the form with the existing entry
      if (entryType === 'basic') {
        populateManualForm(existingEntry, true);
      } else {
        // For advanced entries, switch to advanced tab and populate
      state.currentTab = 'punch';
      state.editingEntryType = entryType;
      activateTab('punch');
      if (punchDate) punchDate.value = existingEntry.date;
      ensurePunchDraft(existingEntry.contract_id, existingEntry);
      if (state.punchDraft) {
        state.punchDraft.entryId = existingEntry.id;
        state.punchDraft.contractId = existingEntry.contract_id;
        state.punchDraft.date = existingEntry.date;
        state.punchDraft.punches = clonePunches(existingEntry.punches || []);
        state.punchDraft.dirty = false;
        if (punchHourType && existingEntry.hour_type_id) {
          punchHourType.value = existingEntry.hour_type_id;
          updatePunchContractVisibility();
        }
        renderPunchDraft();
      }
      }
    } else {
      // No existing entry, keep current tab but clear editing state
      if (state.currentTab === 'manual') {
        clearManualEditing();
      } else {
        // For advanced mode, just clear the editing state without changing tabs
        state.editingEntryId = null;
        state.editingEntryType = null;
        setPunchDate(dateIso);
        ensurePunchDraft();
      }
    }
    focusDefaultEntryField();
  }
  function changeCalendarMonth(delta) {
    ensureCalendarState();
    const oldYear = state.calendar.year;
    const next = new Date(state.calendar.year, state.calendar.month + delta, 1);
    state.calendar.year = next.getFullYear();
    state.calendar.month = next.getMonth();
    if (state.selectedCalendarDate) {
      const selected = parseIsoDate(state.selectedCalendarDate);
      if (selected.getFullYear() !== state.calendar.year || selected.getMonth() !== state.calendar.month) {
        state.selectedCalendarDate = null;
      }
    }
    // Reload public holidays if year changed
    if (oldYear !== state.calendar.year && getFeatureFlag('enable_public_holidays')) {
      loadPublicHolidays(true); // Re-render after load when year changes
    }
    renderCalendar();
    renderIncomeSummary();
    onCalendarMonthChange();
  }
  document.getElementById('calendar-prev').onclick = () => changeCalendarMonth(-1);
  document.getElementById('calendar-next').onclick = () => changeCalendarMonth(1);

  // Month picker modal
  const monthPickerModal = document.getElementById('modal-month-picker');
  const monthPickerJumpBtn = document.getElementById('calendar-jump');
  const monthPickerYearDisplay = document.getElementById('month-picker-year-display');
  const monthPickerYearPrev = document.getElementById('month-picker-year-prev');
  const monthPickerYearNext = document.getElementById('month-picker-year-next');
  const monthPickerGrid = document.getElementById('month-picker-grid');

  var monthPickerState = {
    year: null
  };

  function openMonthPicker() {
    if (!state.calendar) return;
    monthPickerState.year = state.calendar.year;
    renderMonthPicker();
    monthPickerModal.style.display = 'flex';
  }

  function closeMonthPicker() {
    monthPickerModal.style.display = 'none';
  }

  function renderMonthPicker() {
    if (!state.calendar) return;
    monthPickerYearDisplay.textContent = monthPickerState.year;

    const currentDate = new Date();
    const currentYear = currentDate.getFullYear();
    const currentMonth = currentDate.getMonth();
    const activeYear = state.calendar.year;
    const activeMonth = state.calendar.month;

    monthPickerGrid.innerHTML = '';

    for (var i = 0; i < 12; i++) {
      var btn = document.createElement('button');
      btn.className = 'ts-month-picker-cell';
      btn.textContent = MONTH_ABBREVIATIONS[i];
      btn.dataset.month = i;

      // Highlight current month
      if (i === currentMonth && monthPickerState.year === currentYear) {
        btn.classList.add('current-month');
      }

      // Highlight active month
      if (i === activeMonth && monthPickerState.year === activeYear) {
        btn.classList.add('active');
      }

      btn.onclick = function() {
        var selectedMonth = parseInt(this.dataset.month);
        state.calendar.month = selectedMonth;
        state.calendar.year = monthPickerState.year;
        renderCalendar();
        renderIncomeSummary();
        onCalendarMonthChange();
        closeMonthPicker();
      };

      monthPickerGrid.appendChild(btn);
    }
  }

  monthPickerJumpBtn.onclick = openMonthPicker;

  monthPickerYearPrev.onclick = function() {
    monthPickerState.year--;
    renderMonthPicker();
  };

  monthPickerYearNext.onclick = function() {
    monthPickerState.year++;
    renderMonthPicker();
  };

  // Close modal when clicking the X or outside
  var monthPickerClose = monthPickerModal.querySelector('.ts-modal-close');
  if (monthPickerClose) {
    monthPickerClose.onclick = closeMonthPicker;
  }

  monthPickerModal.onclick = function(e) {
    if (e.target === monthPickerModal) {
      closeMonthPicker();
    }
  };

  // Calendar filtering
  const calendarFilterToggle = document.getElementById('calendar-filter-toggle');
  const calendarFilterPanel = document.getElementById('calendar-filter-panel');
  const calendarFilterList = document.getElementById('calendar-filter-list');
  const filterSelectAll = document.getElementById('filter-select-all');
  const filterSelectNone = document.getElementById('filter-select-none');
  const filterSelectIncome = document.getElementById('filter-select-income');
  const calendarGridEl = document.getElementById('calendar-grid');
  const calendarContextMenu = document.getElementById('calendar-context-menu');
  const calendarContextBasicList = document.getElementById('calendar-context-basic');
  const calendarContextAdvancedList = document.getElementById('calendar-context-advanced');
  const calendarContextEmptyState = document.getElementById('calendar-context-empty');
  const calendarContextBasicSection = calendarContextMenu ? calendarContextMenu.querySelector('[data-section="basic"]') : null;
  const calendarContextAdvancedSection = calendarContextMenu ? calendarContextMenu.querySelector('[data-section="advanced"]') : null;
  let calendarContextMenuDate = null;

  function renderCalendarFilters() {
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;

    if (!hourTypesEnabled || !calendarFilterToggle) {
      if (calendarFilterToggle) calendarFilterToggle.style.display = 'none';
      if (calendarFilterPanel) calendarFilterPanel.style.display = 'none';
      return;
    }

    calendarFilterToggle.style.display = 'block';

    if (!calendarFilterList) return;

    // Initialize filter state if null
    if (state.calendarFilteredHourTypes === null) {
      state.calendarFilteredHourTypes = state.hourTypes.map(ht => ht.id);
    }

    calendarFilterList.innerHTML = '';
    state.hourTypes.forEach(hourType => {
      const isActive = state.calendarFilteredHourTypes.includes(hourType.id);

      const item = document.createElement('div');
      item.className = 'ts-calendar-filter-item' + (isActive ? ' active' : '');
      item.innerHTML = `
        <input type="checkbox" class="ts-calendar-filter-checkbox" ${isActive ? 'checked' : ''} data-hour-type-id="${hourType.id}" />
        <div class="ts-calendar-filter-color" style="background-color:${hourType.color};"></div>
        <span class="ts-calendar-filter-name">${hourType.name}</span>
      `;

      item.onclick = () => toggleHourTypeFilter(hourType.id);
      calendarFilterList.appendChild(item);
    });
  }

  function toggleHourTypeFilter(hourTypeId) {
    if (!state.calendarFilteredHourTypes) {
      state.calendarFilteredHourTypes = state.hourTypes.map(ht => ht.id);
    }

    const index = state.calendarFilteredHourTypes.indexOf(hourTypeId);
    if (index > -1) {
      state.calendarFilteredHourTypes.splice(index, 1);
    } else {
      state.calendarFilteredHourTypes.push(hourTypeId);
    }

    saveCache();
    renderCalendarFilters();
    renderCalendar();
  }

  if (calendarFilterToggle) {
    calendarFilterToggle.onclick = () => {
      if (calendarFilterPanel) {
        const isHidden = calendarFilterPanel.style.display === 'none';
        calendarFilterPanel.style.display = isHidden ? 'block' : 'none';
      }
    };
  }

  if (filterSelectAll) {
    filterSelectAll.onclick = () => {
      state.calendarFilteredHourTypes = state.hourTypes.map(ht => ht.id);
      saveCache();
      renderCalendarFilters();
      renderCalendar();
    };
  }

  if (filterSelectNone) {
    filterSelectNone.onclick = () => {
      state.calendarFilteredHourTypes = [];
      saveCache();
      renderCalendarFilters();
      renderCalendar();
    };
  }

  if (filterSelectIncome) {
    filterSelectIncome.onclick = () => {
      state.calendarFilteredHourTypes = state.hourTypes
        .filter(ht => ht.contributes_to_income)
        .map(ht => ht.id);
      saveCache();
      renderCalendarFilters();
      renderCalendar();
    };
  }

  // Settings configuration - add new settings here
  const SETTINGS_CONFIG = {
    round_to_nearest: {
      section: 'core',
      order: 10,
      element: () => roundInput,
      getValue: (el) => clampRoundIntervalValue(el.value),
      setValue: (el, val) => el.value = clampRoundIntervalValue(val || 0),
      defaultValue: 0,
      event: 'input'
    },
    theme: {
      section: 'core',
      order: 20,
      element: () => themeSelect,
      getValue: (el) => el.value,
      setValue: (el, val) => el.value = val || 'dark',
      defaultValue: 'dark',
      event: 'change'
    },
    status_notification_mode: {
      section: 'core',
      order: 30,
      element: () => statusNotificationSelect,
      getValue: (el) => el.value,
      setValue: (el, val) => { if (el) el.value = val || 'status_bar'; },
      defaultValue: 'status_bar',
      event: 'change'
    },
    payg_instalment_rate: {
      section: 'is_sole_trader',
      order: 50,
      element: () => paygRateInput,
      getValue: (el) => parseFloat(el.value) || 2,
      setValue: (el, val) => el.value = String(val || 2),
      defaultValue: () => Number(state.settings.payg_instalment_rate) || 2,
      event: 'input'
    },
    public_holiday_state: {
      section: 'enable_public_holidays',
      order: 60,
      element: () => publicHolidayStateSelect,
      getValue: (el) => el.value,
      setValue: (el, val) => el.value = val || 'ACT',
      defaultValue: 'ACT',
      event: 'change'
    },
    minimum_end_time: {
      section: 'suggest_end_time',
      order: 70,
      element: () => minimumEndTimeInput,
      getValue: (el) => el.value,
      setValue: (el, val) => el.value = val || '17:00',
      defaultValue: '17:00',
      event: 'input'
    },
    lost_super_recovery_mode: {
      section: 'no_lost_super_to_deductions',
      order: 40,
      element: () => lostSuperRecoveryModeSelect,
      getValue: (el) => el.value,
      setValue: (el, val) => el.value = val || 'extra_contribution',
      defaultValue: 'extra_contribution',
      event: 'change'
    },
    monthly_insights_trend_method: {
      section: 'expected_monthly_hours',
      order: 80,
      element: () => monthlyInsightsTrendMethodSelect,
      getValue: (el) => el.value,
      setValue: (el, val) => el.value = val || 'standard_contract_hours',
      defaultValue: 'standard_contract_hours',
      event: 'change'
    },
    projections_variance_value: {
      section: 'expected_monthly_hours',
      order: 90,
      element: () => projectionsVarianceValueSelect,
      getValue: (el) => el.value,
      setValue: (el, val) => el.value = val || 'monthly_capacity',
      defaultValue: 'monthly_capacity',
      event: 'change'
    },
    invoice_template_reference: {
      section: 'enable_invoices',
      order: 100,
      element: () => invoiceTemplateInput,
      getValue: (el) => el.value.trim(),
      setValue: (el, val) => { el.value = val || ''; },
      defaultValue: '',
      event: 'input'
    },
    invoice_output_folder_path: {
      section: 'enable_invoices',
      order: 110,
      element: () => invoiceOutputFolderInput,
      getValue: (el) => el.value.trim(),
      setValue: (el, val) => { el.value = val || ''; },
      defaultValue: '',
      event: 'input'
    },
    invoice_line_item_limit: {
      section: 'enable_invoices',
      order: 120,
      element: () => invoiceLineLimitInput,
      getValue: (el) => {
        const val = el.value.trim();
        if (val === '') return '';
        const num = parseInt(val, 10);
        return Number.isFinite(num) && num > 0 ? num : '';
      },
      setValue: (el, val) => { el.value = val != null && val !== '' ? val : ''; },
      defaultValue: '',
      event: 'input'
    },
    invoice_hours_label: {
      section: 'enable_invoices',
      order: 130,
      element: () => invoiceHoursLabelInput,
      getValue: (el) => el.value.trim(),
      setValue: (el, val) => { el.value = val || ''; },
      defaultValue: 'Hours',
      event: 'input'
    }
  };

  // Settings dirty state tracking
  var settingsInitialState = {};
  var settingsServerSynced = false;

  function captureSettingsState() {
    settingsInitialState = {};
    Object.keys(SETTINGS_CONFIG).forEach((key) => {
      const config = SETTINGS_CONFIG[key];
      const element = config.element();
      if (element) {
        settingsInitialState[key] = config.getValue(element);
      } else {
        // Preserve existing value from state, only default if truly missing
        settingsInitialState[key] = state.settings[key] !== undefined
          ? state.settings[key]
          : (typeof config.defaultValue === 'function' ? config.defaultValue() : config.defaultValue);
      }
    });
  }

  function checkSettingsDirty() {
    const current = {};
    Object.keys(SETTINGS_CONFIG).forEach((key) => {
      const config = SETTINGS_CONFIG[key];
      const element = config.element();
      if (element) {
        current[key] = config.getValue(element);
      } else {
        const defaultVal = typeof config.defaultValue === 'function' ? config.defaultValue() : config.defaultValue;
        current[key] = defaultVal;
      }
    });

    let isDirty = false;
    Object.keys(SETTINGS_CONFIG).forEach((key) => {
      if (current[key] !== settingsInitialState[key]) {
        isDirty = true;
      }
    });

    // Only enable save button if settings have changed AND server sync is complete
    if (saveSettingsBtn) {
      saveSettingsBtn.disabled = !isDirty || !settingsServerSynced;
      // Update tooltip to show why button is disabled
      if (!settingsServerSynced) {
        saveSettingsBtn.title = 'Loading settings from server...';
      } else if (!isDirty) {
        saveSettingsBtn.title = 'No changes to save';
      } else {
        saveSettingsBtn.title = 'Save settings to database';
      }
    }
    if (discardSettingsBtn) discardSettingsBtn.style.display = isDirty ? 'inline-flex' : 'none';

    return isDirty;
  }

  function resetSettingsToInitial() {
    Object.keys(SETTINGS_CONFIG).forEach((key) => {
      const config = SETTINGS_CONFIG[key];
      const element = config.element();
      if (element) {
        config.setValue(element, settingsInitialState[key]);
      }
    });
    applyTheme(settingsInitialState.theme || 'dark');
    checkSettingsDirty();
  }

  // Attach change listeners to all settings inputs
  Object.keys(SETTINGS_CONFIG).forEach((key) => {
    const config = SETTINGS_CONFIG[key];
    const element = config.element();
    if (element) {
      element.addEventListener(config.event, checkSettingsDirty);
    }
  });

  // Settings persistence
  if (saveSettingsBtn) {
    saveSettingsBtn.onclick = function () {
      const next = {};
      Object.keys(SETTINGS_CONFIG).forEach((key) => {
        const config = SETTINGS_CONFIG[key];
        const element = config.element();
        if (element) {
          next[key] = config.getValue(element);
        } else {
          // Preserve existing value from state, only default if truly missing
          next[key] = state.settings[key] !== undefined
            ? state.settings[key]
            : (typeof config.defaultValue === 'function' ? config.defaultValue() : config.defaultValue);
        }
      });

      // Only send changed settings to reduce blast radius
      const changedSettings = {};
      Object.keys(next).forEach((key) => {
        if (next[key] !== settingsInitialState[key]) {
          changedSettings[key] = next[key];
        }
      });

      // Apply all settings locally for immediate UI update
      applyTheme(next.theme);
      if (paygRateInput) paygRateInput.value = String(next.payg_instalment_rate);
      state.settings = { ...state.settings, ...next };
      saveCache();
      applyStatusDisplay();
      // Clear annual data cache when lost super recovery mode changes to force recalculation
      if (state.annualData && next.lost_super_recovery_mode && next.lost_super_recovery_mode !== settingsInitialState.lost_super_recovery_mode) {
        state.annualData = null;
      }
      renderCalendar();
      setStatus('Saving settings...', 'warn');
      google.script.run
        .withSuccessHandler(() => {
          setStatus('Settings saved', 'success');
          captureSettingsState();
          checkSettingsDirty();
          renderIncomeSummary();
        })
        .withFailureHandler((error) => {
          console.error('[Settings] Save failed:', error);
          setStatus('Settings failed', 'error');
        })
        .api_updateSettings(changedSettings);
    };
  }

  // Discard settings changes
  if (discardSettingsBtn) {
    discardSettingsBtn.onclick = function () {
      resetSettingsToInitial();
    };
  }

  if (themeSelect) {
    themeSelect.addEventListener('change', () => {
      applyTheme(themeSelect.value);
      saveCache();
    });
  }

  function fetchEntriesFromServer() {
    return new Promise((resolve) => {
      setStatus('Syncing...', 'warn');
      entriesSyncInFlight = true;
      google.script.run
        .withSuccessHandler((entries) => {
          entriesSyncInFlight = false;
          const sanitizedEntries = (entries || []).map(sanitizeEntry);
          mergeEntriesWithServerEntries(sanitizedEntries);
          state.entriesLoaded = true;
          saveCache();
          renderEntries();
          updateTabStates();
          maybePromptDuplicateCleanup();
        ensurePunchDraft(state.punchDraft ? state.punchDraft.contractId : undefined);
        setStatus('Synced', 'success');
        renderBasReporting();
        maybeAutoPopulatePublicHolidayEntries();
        onCalendarMonthChange();
        resolve(true);
      })
        .withFailureHandler(() => {
          entriesSyncInFlight = false;
          setStatus('Entries sync failed', 'error');
          resolve(false);
        })
        .api_getEntries({});
    });
  }

  function fetchSettingsWithRetry() {
    const MAX_SETTINGS_RETRIES = 3;
    let settingsRetryCount = 0;

    return new Promise((resolve) => {
      const attempt = () => {
        google.script.run
          .withSuccessHandler((settings) => {
            if (!settings || (typeof settings === 'object' && Object.keys(settings).length === 0)) {
              if (settingsRetryCount < MAX_SETTINGS_RETRIES) {
                settingsRetryCount += 1;
                const delay = Math.pow(2, settingsRetryCount) * 500;
                console.warn(`[Settings] Received null/empty settings, retrying in ${delay}ms (attempt ${settingsRetryCount}/${MAX_SETTINGS_RETRIES})`);
                setTimeout(attempt, delay);
                return;
              }
              console.error('[Settings] Received null/empty after retries, using cached settings');
              if (!state.settings || Object.keys(state.settings).length === 0) {
                state.settings = {};
              }
              settingsServerSynced = true;
              checkSettingsDirty();
              resolve(false);
              return;
            }

            const previousLastNonCustomTheme = state.settings && state.settings.last_non_custom_theme
              ? state.settings.last_non_custom_theme
              : '';
            state.settings = settings;

            if (state.settings.custom_theme_config && typeof state.settings.custom_theme_config === 'string') {
              try {
                state.settings.custom_theme_config = JSON.parse(state.settings.custom_theme_config);
              } catch (e) {
                state.settings.custom_theme_config = null;
              }
            }

            if (!state.settings.last_non_custom_theme) {
              if (state.settings.theme && state.settings.theme !== 'custom') {
                state.settings.last_non_custom_theme = state.settings.theme;
              } else if (previousLastNonCustomTheme && previousLastNonCustomTheme !== 'custom') {
                state.settings.last_non_custom_theme = previousLastNonCustomTheme;
              }
            }

            saveCache();
            Object.keys(SETTINGS_CONFIG).forEach((key) => {
              const config = SETTINGS_CONFIG[key];
              const element = config.element();
              if (element) {
                const value = state.settings[key] !== undefined ? state.settings[key]
                  : (typeof config.defaultValue === 'function' ? config.defaultValue() : config.defaultValue);
                config.setValue(element, value);
              } else {
                console.warn('[Settings] Element not found for key:', key);
              }
            });
            applyTheme(state.settings.theme || 'dark');

            captureSettingsState();
            settingsServerSynced = true;
            checkSettingsDirty();
            applyStatusDisplay();
            renderCalendar();
            resolve(true);
          })
          .withFailureHandler((error) => {
            console.error('[Settings] Failed to load from server:', error);
            if (settingsRetryCount < MAX_SETTINGS_RETRIES) {
              settingsRetryCount += 1;
              const delay = Math.pow(2, settingsRetryCount) * 500;
              console.warn(`[Settings] API call failed, retrying in ${delay}ms (attempt ${settingsRetryCount}/${MAX_SETTINGS_RETRIES})`);
              setTimeout(attempt, delay);
              return;
            }
            settingsServerSynced = true;
            checkSettingsDirty();
            resolve(false);
          })
          .api_getSettings();
      };
      attempt();
    });
  }

  function fetchContractsFromServer() {
    return new Promise((resolve) => {
      google.script.run
        .withSuccessHandler((contracts) => {
          state.contracts = (contracts || []).map(sanitizeContract);
          refreshContractBindings();
          populateRecurringContractOptions(state.recurringEntryForm.draft ? state.recurringEntryForm.draft.contract_id : '');
          ensureInvoiceFormOptions();
          saveCache();
          renderCalendar();
          resolve(true);
        })
        .withFailureHandler(() => {
          setStatus('Contracts sync failed', 'error');
          resolve(false);
        })
        .api_getContracts();
    });
  }

  function fetchFeatureFlagsFromServer() {
    return new Promise((resolve) => {
      google.script.run
        .withSuccessHandler((flags) => {
          state.featureFlags = normalizeFeatureFlags(flags);
          saveCache();
          renderFeatureFlags();
          applyFeatureFlagsLazy();
          resolve(true);
        })
        .withFailureHandler(() => {
          resolve(false);
        })
        .api_getFeatureFlags();
    });
  }

  function fetchDeductionsFromServer() {
    return new Promise((resolve) => {
      google.script.run
        .withSuccessHandler((deductions) => {
          state.deductions = dedupeById((deductions || []).map(sanitizeDeduction));
          markAllIncomeSummariesDirty();
          saveCache();
          renderDeductionsList();
          renderIncomeSummary();
          renderAnnualCategorySection();
          onCalendarMonthChange();
          resolve(true);
        })
        .withFailureHandler(() => {
          setStatus('Deductions sync failed', 'error');
          resolve(false);
        })
        .api_getDeductions();
    });
  }

  function fetchActualIncomeFromServer() {
    return new Promise((resolve) => {
      google.script.run
        .withSuccessHandler((actualIncome) => {
          state.actualIncome = actualIncome || [];
          refreshActualIncomeMap();
          saveCache();
          renderIncomeSummary();
          onCalendarMonthChange();
          if (state.annualData) {
            loadAnnualData();
          }
          resolve(true);
        })
        .withFailureHandler((error) => {
          console.error('[ActualIncome] Failed to load:', error);
          resolve(false);
        })
        .api_getActualIncome();
    });
  }

  function fetchSuperGuaranteeRatesFromServer() {
    return new Promise((resolve) => {
      google.script.run
        .withSuccessHandler((rates) => {
          cacheSuperGuaranteeRates(rates);
          onCalendarMonthChange();
          if (state.annualData) {
            loadAnnualData();
          }
          resolve(true);
        })
        .withFailureHandler(() => {
          resolve(false);
        })
        .api_getSuperGuaranteeRates();
    });
  }

  function fetchBasSubmissionsFromServer() {
    return new Promise((resolve) => {
      google.script.run
        .withSuccessHandler((submissions) => {
          state.basSubmissions = submissions || [];
          saveCache();
          renderBasReporting();
          resolve(true);
        })
        .withFailureHandler(() => {
          resolve(false);
        })
        .api_getBasSubmissions();
    });
  }

  function fetchDeductionCategoriesFromServer() {
    if (!isDeductionCategoriesEnabled()) return Promise.resolve(false);
    return new Promise((resolve) => {
      google.script.run
        .withSuccessHandler((categories) => {
          state.deductionCategories = (categories || []).map(sanitizeDeductionCategory);
          updateDeductionCategoryMap();
          ensureDeductionCategoryCollapseState();
          saveCache();
          renderDeductionCategoryOptions('');
          renderDeductionsList();
          renderAnnualCategorySection();
          resolve(true);
        })
        .withFailureHandler(() => {
          console.error('Failed to load deduction categories');
          resolve(false);
        })
        .api_getDeductionCategories();
    });
  }

  function fetchDeductionExceptionsFromServer() {
    return new Promise((resolve) => {
      google.script.run
        .withSuccessHandler((exceptions) => {
          state.deductionExceptions = (exceptions || []).map(sanitizeDeductionException);
          saveCache();
          renderIncomeSummary();
          onCalendarMonthChange();
          resolve(true);
        })
        .withFailureHandler(() => {
          console.error('Failed to load deduction exceptions');
          resolve(false);
        })
        .api_getDeductionExceptions();
    });
  }

  // Initial load
  function init() {
    loadCache();
    initializeLazyLoadingState();
    renderEntries();
    // Load settings into UI inputs from cache
    Object.keys(SETTINGS_CONFIG).forEach((key) => {
      const config = SETTINGS_CONFIG[key];
      const element = config.element();
      if (element) {
        const value = state.settings[key] !== undefined ? state.settings[key] : (typeof config.defaultValue === 'function' ? config.defaultValue() : config.defaultValue);
        config.setValue(element, value);
      }
    });
    applyTheme(state.settings.theme || 'dark');
    captureSettingsState();
    checkSettingsDirty();
    applyStatusDisplay();
    renderContractsUI();
    renderDeductionsList();
    hideContractForm();
    refreshContractBindings();
    state.featureFlags = normalizeFeatureFlags(state.featureFlags);
    renderFeatureFlags();
    applyFeatureFlagsLazy();
    renderCalendar();
    onCalendarMonthChange();
    loadTier1Critical();
  }

  async function loadTier1Critical() {
    try {
      await Promise.all([
        fetchEntriesFromServer(),
        fetchSettingsWithRetry(),
        fetchContractsFromServer(),
        fetchFeatureFlagsFromServer()
      ]);
    } finally {
      state.loadingTiers.tier1Complete = true;
      saveCache();
      loadTier2Supporting();
    }
  }

  async function loadTier2Supporting() {
    const hourTypesEnabled = getFeatureFlag('hour_types');
    if (hourTypesEnabled) {
      updateLoadingFeatureState('hourTypes', { loading: true });
    }
    const hourTypePromise = hourTypesEnabled
      ? loadHourTypes().then((loaded) => {
          updateLoadingFeatureState('hourTypes', {
            loading: false,
            loaded: !!loaded,
            lastUpdate: loaded ? Date.now() : (state.loadingTiers.features.hourTypes.lastUpdate || null)
          });
        })
      : Promise.resolve(false);
    await Promise.all([
      hourTypePromise,
      fetchDeductionsFromServer(),
      fetchActualIncomeFromServer(),
      fetchSuperGuaranteeRatesFromServer(),
      fetchDeductionExceptionsFromServer()
    ]);
    state.loadingTiers.tier2Complete = true;
    saveCache();
    loadTier3BackgroundEager();
  }

  async function loadTier3BackgroundEager() {
    const tasks = [];

    updateLoadingFeatureState('basSubmissions', { loading: true });
    tasks.push(fetchBasSubmissionsFromServer().then((success) => {
      updateLoadingFeatureState('basSubmissions', {
        loading: false,
        loaded: !!success,
        lastUpdate: success ? Date.now() : state.loadingTiers.features.basSubmissions.lastUpdate
      });
    }));

    if (getFeatureFlag('enable_public_holidays')) {
      updateLoadingFeatureState('publicHolidays', { loading: true });
      tasks.push(loadPublicHolidays().then((success) => {
        updateLoadingFeatureState('publicHolidays', {
          loading: false,
          loaded: !!success,
          lastUpdate: success ? Date.now() : state.loadingTiers.features.publicHolidays.lastUpdate
        });
      }));
    }

    if (getFeatureFlag('recurring_time_entries')) {
      updateLoadingFeatureState('recurringEntries', { loading: true });
      tasks.push(new Promise((resolve) => {
        syncRecurringEntries({
          silent: true,
          onComplete: () => resolve(true),
          onError: () => resolve(false)
        });
      }).then((success) => {
        updateLoadingFeatureState('recurringEntries', {
          loading: false,
          loaded: !!success,
          lastUpdate: success ? Date.now() : state.loadingTiers.features.recurringEntries.lastUpdate
        });
      }));
    }

    if (getFeatureFlag('bulk_time_entries')) {
      updateLoadingFeatureState('bulkEntries', { loading: true });
      tasks.push(new Promise((resolve) => {
        syncBulkEntries({
          silent: true,
          onComplete: () => resolve(true),
          onError: () => resolve(false)
        });
      }).then((success) => {
        updateLoadingFeatureState('bulkEntries', {
          loading: false,
          loaded: !!success,
          lastUpdate: success ? Date.now() : state.loadingTiers.features.bulkEntries.lastUpdate
        });
      }));
    }

    if (getFeatureFlag('enable_invoices')) {
      updateLoadingFeatureState('invoices', { loading: true });
      initializeInvoicesFeature();
      updateLoadingFeatureState('invoices', {
        loading: false,
        loaded: true,
        lastUpdate: Date.now()
      });
    }

    if (isDeductionCategoriesEnabled()) {
      updateLoadingFeatureState('deductionCategories', { loading: true });
      tasks.push(fetchDeductionCategoriesFromServer().then((success) => {
        updateLoadingFeatureState('deductionCategories', {
          loading: false,
          loaded: !!success,
          lastUpdate: success ? Date.now() : state.loadingTiers.features.deductionCategories.lastUpdate
        });
      }));
    }

    await Promise.all(tasks);
    state.loadingTiers.tier3Complete = true;
    saveCache();
    loadTier4MonthPreCalculation();
  }

  function loadTier4MonthPreCalculation() {
    seedMonthCalculationQueue();
    processMonthCalculationQueue();
  }

  function preloadPotentialIncomeStats(year, month, summary) {
    if (!summary) return;
    const contract = getSelectedPotentialContract();
    if (!contract || !(Number(contract.hourly_rate) > 0)) return;
    const stats = buildPotentialIncomeStats(contract, summary, year, month);
    if (!stats) return;
    ensurePotentialIncomeState();
    const contextKey = `${year}-${month}-${contract.id}`;
    state.potentialIncomeCache[contextKey] = {
      stats,
      scenarios: {}
    };
  }

  function seedMonthCalculationQueue() {
    ensureCalendarState();
    resetLazyLoadQueue();
    const baseYear = state.calendar.year;
    const baseMonth = state.calendar.month;
    const baseIndex = (baseYear * 12) + baseMonth;
    const seen = new Set();
    let counter = 0;
    const queue = [];

    const enqueue = (year, month, priority) => {
      if (year == null || month == null) return;
      const monthKey = monthKeyFor(year, month);
      if (seen.has(monthKey)) return;
      seen.add(monthKey);
      queue.push({
        year,
        month,
        monthKey,
        priority,
        order: counter += 1,
        index: (year * 12) + month
      });
    };

    enqueue(baseYear, baseMonth, 0);
    [-2, -1, 1, 2].forEach((offset) => {
      const date = new Date(baseYear, baseMonth + offset, 1);
      enqueue(date.getFullYear(), date.getMonth(), Math.abs(offset));
    });

    const entryMonths = new Set();
    state.entries.forEach((entry) => {
      const key = monthKeyFromDateIso(entry.date);
      if (key) entryMonths.add(key);
    });
    entryMonths.forEach((monthKey) => {
      const coords = parseMonthKey(monthKey);
      if (!coords) return;
      const diff = Math.abs(((coords.year * 12) + coords.month) - baseIndex);
      enqueue(coords.year, coords.month, 5 + diff);
    });

    Object.keys(state.incomeCacheMetadata || {}).forEach((monthKey) => {
      const coords = parseMonthKey(monthKey);
      if (!coords) return;
      const diff = Math.abs(((coords.year * 12) + coords.month) - baseIndex);
      enqueue(coords.year, coords.month, 10 + diff);
    });

    queue.sort((a, b) => {
      if (a.priority !== b.priority) return a.priority - b.priority;
      if (a.index !== b.index) return Math.abs(a.index - baseIndex) - Math.abs(b.index - baseIndex);
      return a.order - b.order;
    });

    state.lazyLoadQueue.monthsToCalculate = queue;
    state.lazyLoadQueue.currentlyCalculating = null;
    state.lazyLoadQueue.progressiveLoadComplete = queue.length === 0;
  }

  function processMonthCalculationQueue() {
    if (!state.lazyLoadQueue) return;
    if (state.lazyLoadQueue.currentlyCalculating) return;
    const next = state.lazyLoadQueue.monthsToCalculate.shift();
    if (!next) {
      state.lazyLoadQueue.progressiveLoadComplete = true;
      state.loadingTiers.tier4Complete = true;
      saveCache();
      return;
    }
    const { year, month, monthKey } = next;
    state.lazyLoadQueue.currentlyCalculating = monthKey;
    const execute = () => {
      try {
        if (shouldRecalculateMonth(year, month)) {
          const summary = buildIncomeSummary(year, month);
          cacheIncomeSummary(monthKey, summary);
          preloadPotentialIncomeStats(year, month, summary);
          // Lazy load tax estimate in background if pending
          if (summary.taxStatus === 'pending') {
            requestTaxEstimate(summary);
          }
        }
      } finally {
        state.lazyLoadQueue.currentlyCalculating = null;
        saveCache();
        setTimeout(processMonthCalculationQueue, 25);
      }
    };
    setTimeout(execute, 25);
  }

  function onCalendarMonthChange() {
    seedMonthCalculationQueue();
    processMonthCalculationQueue();
  }

  // Default Entries

  // Default Entries Functionality
  const state_defaults = {
    entryDefaults: { basic: [], advanced: [] },
    currentDefaultType: null,
    editingDefaultName: null
  };

  // Default entry UI elements
  const createManualDefaultBtn = document.getElementById('btn-create-manual-default');
  const enterManualDefaultBtn = document.getElementById('btn-enter-manual-default');
  const editManualDefaultsBtn = document.getElementById('btn-edit-manual-defaults');
  const createPunchDefaultBtn = document.getElementById('btn-create-punch-default');
  const enterPunchDefaultBtn = document.getElementById('btn-enter-punch-default');
  const editPunchDefaultsBtn = document.getElementById('btn-edit-punch-defaults');


  // Modal elements
  const createDefaultModal = document.getElementById('modal-create-default');
  const selectDefaultModal = document.getElementById('modal-select-default');
  const editDefaultsModal = document.getElementById('modal-edit-defaults');
  const editDefaultDetailsModal = document.getElementById('modal-edit-default-details');
  const defaultHourTypeRow = document.getElementById('default-hour-type-row');
  const defaultHourTypeSelect = document.getElementById('default-hour-type');
  const editDefaultHourTypeRow = document.getElementById('edit-default-hour-type-row');
  const editDefaultHourTypeSelect = document.getElementById('edit-default-hour-type');

  function updateDefaultButtonsVisibility() {
    const featureEnabled = state.featureFlags.default_inputs && state.featureFlags.default_inputs.enabled;

    if (!featureEnabled) {
      // Hide all default buttons if feature is disabled
      [createManualDefaultBtn, enterManualDefaultBtn, editManualDefaultsBtn,
       createPunchDefaultBtn, enterPunchDefaultBtn, editPunchDefaultsBtn].forEach(btn => {
        if (btn) btn.style.display = 'none';
      });
      hideCalendarContextMenu();
      return;
    }

    const defaults = state_defaults.entryDefaults;
    const hasBasicDefaults = defaults.basic.length > 0;
    const hasAdvancedDefaults = defaults.advanced.length > 0;

    // Basic/Manual tab buttons
    if (createManualDefaultBtn) createManualDefaultBtn.style.display = 'inline-flex';
    if (enterManualDefaultBtn) enterManualDefaultBtn.style.display = hasBasicDefaults ? 'inline-flex' : 'none';
    if (editManualDefaultsBtn) editManualDefaultsBtn.style.display = hasBasicDefaults ? 'inline-flex' : 'none';

    // Advanced/Punch tab buttons
    if (createPunchDefaultBtn) createPunchDefaultBtn.style.display = 'inline-flex';
    if (enterPunchDefaultBtn) enterPunchDefaultBtn.style.display = hasAdvancedDefaults ? 'inline-flex' : 'none';
    if (editPunchDefaultsBtn) editPunchDefaultsBtn.style.display = hasAdvancedDefaults ? 'inline-flex' : 'none';
  }

  function loadEntryDefaults() {
    google.script.run
      .withSuccessHandler((result) => {
        state_defaults.entryDefaults = result || { basic: [], advanced: [] };
        updateDefaultButtonsVisibility();
        hideCalendarContextMenu();
      })
      .withFailureHandler(() => {
        console.log('Failed to load entry defaults');
      })
      .api_getEntryDefaults();
  }

  function populateDefaultHourTypeOptions(selectEl, selectedValue) {
    if (!selectEl) return;
    const hasHourTypes = Array.isArray(state.hourTypes) && state.hourTypes.length > 0;
    selectEl.innerHTML = '';

    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Use current hour type';
    selectEl.appendChild(placeholder);

    if (!hasHourTypes) {
      selectEl.value = '';
      return;
    }

    state.hourTypes.forEach(hourType => {
      const option = document.createElement('option');
      option.value = hourType.id;
      option.textContent = hourType.name;
      selectEl.appendChild(option);
    });

    const targetValue = selectedValue !== undefined ? selectedValue : selectEl.value;
    if (targetValue && state.hourTypeMap[targetValue]) {
      selectEl.value = targetValue;
    } else {
      selectEl.value = '';
    }
  }

  function refreshDefaultHourTypeControls() {
    const hourTypesEnabled = !!(state.featureFlags.hour_types && state.featureFlags.hour_types.enabled);
    const hasHourTypes = hourTypesEnabled && state.hourTypes.length > 0;

    if (defaultHourTypeRow) {
      defaultHourTypeRow.style.display = hasHourTypes ? 'block' : 'none';
    }
    if (editDefaultHourTypeRow) {
      editDefaultHourTypeRow.style.display = hasHourTypes ? 'block' : 'none';
    }

    if (hasHourTypes) {
      populateDefaultHourTypeOptions(defaultHourTypeSelect);
      populateDefaultHourTypeOptions(editDefaultHourTypeSelect);
    } else {
      if (defaultHourTypeSelect) defaultHourTypeSelect.value = '';
      if (editDefaultHourTypeSelect) editDefaultHourTypeSelect.value = '';
    }
  }

  function showModal(modal) {
    if (modal) modal.style.display = 'flex';
  }

  function hideModal(modal) {
    if (modal) modal.style.display = 'none';
  }

  function showMonthlyDeductionsModal(type) {
    if (!modalMonthlyDeductions || !monthlyDeductionsContent || !monthlyDeductionsTitle) return;

    ensureCalendarState();
    const baseDate = state.calendar
      ? new Date(state.calendar.year, state.calendar.month, 1)
      : new Date();
    const year = baseDate.getFullYear();
    const month = baseDate.getMonth();

    // Set modal title
    const monthName = MONTH_ABBREVIATIONS[month];
    const typeLabel = type === 'company' ? 'Company Expenses' : 'Pre-tax Deductions';
    monthlyDeductionsTitle.textContent = `${typeLabel} - ${monthName} ${year}`;

    // Calculate deductions for the month
    const monthStart = startOfDay(new Date(year, month, 1));
    const monthEnd = startOfDay(new Date(year, month + 1, 0));

    const deductionsList = [];
    if (Array.isArray(state.deductions) && state.deductions.length) {
      state.deductions.forEach((deduction) => {
        if (!deduction || deduction.active === false) return;

        // Filter by type
        const isCompany = deduction.company_expense === true;
        if (type === 'company' && !isCompany) return;
        if (type === 'personal' && isCompany) return;

        // Skip extra super for personal deductions (it's shown separately)
        if (type === 'personal' && deduction.deduction_type === 'extra_super') return;

        const occurrencesWithExceptions = getDeductionOccurrencesWithExceptions(deduction, monthStart, monthEnd);
        if (!occurrencesWithExceptions.length) return;

        let totalAmount = 0;
        occurrencesWithExceptions.forEach(occ => {
          const baseAmount = occ.amount !== null ? occ.amount : deduction.amount_value;
          let netAmount = baseAmount;
          if (type === 'company' && deduction.gst_inclusive) {
            netAmount = baseAmount / (1 + GST_RATE);
          }
          totalAmount += netAmount;
        });

        deductionsList.push({
          deduction: deduction,
          name: deduction.name,
          occurrences: occurrencesWithExceptions,
          totalAmount: totalAmount,
          frequency: deduction.frequency,
          gst_inclusive: deduction.gst_inclusive && type === 'company',
          category_id: deduction.category_id || ''
        });
      });
    }

    // Sort by total amount descending
    deductionsList.sort((a, b) => b.totalAmount - a.totalAmount);

    // Render content
    if (!deductionsList.length) {
      monthlyDeductionsContent.innerHTML = `
        <div class="ts-note">No ${typeLabel.toLowerCase()} found for this month.</div>
      `;
    } else {
      const categoriesEnabled = isDeductionCategoriesEnabled();
      let html = '<div class="ts-list" style="margin:0;">';

      deductionsList.forEach((item) => {
        const categoryMeta = categoriesEnabled ? getDeductionCategoryMeta(item.category_id) : null;
        const categoryBadge = categoriesEnabled && categoryMeta
          ? `<span class="ts-badge" style="background-color:${categoryMeta.color}20; color:${categoryMeta.color}; font-size:10px; padding:2px 6px;">${categoryMeta.name}</span>`
          : '';

        const deductionId = `deduction-${item.deduction.id}`;
        const expandedClass = state.monthlyDeductionsExpanded && state.monthlyDeductionsExpanded[item.deduction.id] ? 'expanded' : '';
        const exceptionCount = item.occurrences.filter(occ => occ.hasException).length;
        const exceptionBadge = exceptionCount > 0
          ? ` <span class="ts-badge" style="background-color:var(--warning)20; color:var(--warning); font-size:10px; padding:2px 6px;">${exceptionCount} adjustment${exceptionCount > 1 ? 's' : ''}</span>`
          : '';

        html += `
          <div class="ts-item ${expandedClass}" style="display:block;" data-deduction-id="${item.deduction.id}">
            <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" class="deduction-header">
              <div style="flex:1;">
                <div style="font-weight:600;">${item.name}${exceptionBadge}</div>
                <div class="ts-note" style="margin-top:4px;">
                  ${item.occurrences.length} occurrence${item.occurrences.length > 1 ? 's' : ''}
                  ${categoryBadge ? ' ' + categoryBadge : ''}
                </div>
              </div>
              <div style="font-weight:600; font-size:16px;">${formatCurrency(item.totalAmount)}</div>
            </div>
            <div class="deduction-occurrences" style="display:none; margin-top:12px; padding-left:16px;">
        `;

        item.occurrences.forEach(occ => {
          const baseAmount = occ.amount !== null ? occ.amount : item.deduction.amount_value;
          let netAmount = baseAmount;
          if (type === 'company' && item.gst_inclusive) {
            netAmount = baseAmount / (1 + GST_RATE);
          }

          const exceptionIcon = occ.hasException
            ? `<span style="color:var(--warning); margin-left:4px;" title="${occ.exceptionType === 'move' ? 'Moved from ' + (occ.originalDate || '') : occ.exceptionType === 'adjust_amount' ? 'Amount adjusted' : 'Exception'}"></span>`
            : '';

          html += `
            <div style="display:flex; justify-content:space-between; align-items:center; padding:8px 0; border-bottom:1px solid var(--border);">
              <div>
                <span>${formatDate(new Date(occ.date))}${exceptionIcon}</span>
              </div>
              <div style="display:flex; align-items:center; gap:12px;">
                <span>${formatCurrency(netAmount)}</span>
                <button class="ghost small adjust-occurrence-btn" data-deduction-id="${item.deduction.id}" data-occurrence-date="${occ.date}" data-original-date="${occ.originalDate || occ.date}">Adjust</button>
              </div>
            </div>
          `;
        });

        html += `
            </div>
          </div>
        `;
      });

      const total = deductionsList.reduce((sum, item) => sum + item.totalAmount, 0);
      html += `
        <div class="ts-item" style="display:flex; justify-content:space-between; align-items:center; border-top:2px solid var(--border); padding-top:12px; margin-top:8px;">
          <div style="font-weight:600; font-size:16px;">Total</div>
          <div style="font-weight:600; font-size:18px;">${formatCurrency(total)}</div>
        </div>
      `;
      html += '</div>';

      monthlyDeductionsContent.innerHTML = html;

      // Add click handlers for expand/collapse
      const headers = monthlyDeductionsContent.querySelectorAll('.deduction-header');
      headers.forEach(header => {
        header.addEventListener('click', (e) => {
          const item = e.currentTarget.closest('.ts-item');
          const deductionId = item.dataset.deductionId;
          const occurrencesDiv = item.querySelector('.deduction-occurrences');

          if (!state.monthlyDeductionsExpanded) state.monthlyDeductionsExpanded = {};

          if (item.classList.contains('expanded')) {
            item.classList.remove('expanded');
            occurrencesDiv.style.display = 'none';
            state.monthlyDeductionsExpanded[deductionId] = false;
          } else {
            item.classList.add('expanded');
            occurrencesDiv.style.display = 'block';
            state.monthlyDeductionsExpanded[deductionId] = true;
          }
        });
      });

      // Add click handlers for adjust buttons
      const adjustBtns = monthlyDeductionsContent.querySelectorAll('.adjust-occurrence-btn');
      adjustBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation(); // Don't trigger expand/collapse
          const deductionId = btn.dataset.deductionId;
          const occurrenceDate = btn.dataset.occurrenceDate;
          const originalDate = btn.dataset.originalDate;
          const deduction = state.deductions.find(d => d.id === deductionId);
          if (deduction) {
            showAdjustOccurrenceModal(deduction, originalDate, type);
          }
        });
      });
    }

    showModal(modalMonthlyDeductions);
  }

  function showAdjustOccurrenceModal(deduction, originalDate, type) {
    if (!modalAdjustOccurrence || !deduction || !originalDate) return;

    adjustingDeduction = deduction;
    adjustingOriginalDate = originalDate;
    adjustingType = type;

    // Find if there's already an exception for this occurrence
    const existingException = state.deductionExceptions.find(ex =>
      ex.deduction_id === deduction.id && ex.original_date === originalDate
    );

    // Calculate the display amount
    let displayAmount = deduction.amount_value;
    if (type === 'company' && deduction.gst_inclusive) {
      displayAmount = deduction.amount_value / (1 + GST_RATE);
    }

    // Set form values
    if (adjustDeductionName) adjustDeductionName.textContent = deduction.name;
    if (adjustOriginalDate) adjustOriginalDate.textContent = formatDate(new Date(originalDate));
    if (adjustOriginalAmount) adjustOriginalAmount.textContent = formatCurrency(displayAmount);

    // Reset form
    const adjustSkip = document.getElementById('adjust-skip');
    if (adjustNotes) adjustNotes.value = '';
    if (adjustNewDate) adjustNewDate.value = '';
    if (adjustNewAmount) adjustNewAmount.value = '';
    if (adjustSkip) adjustSkip.checked = false;

    // If there's an existing exception, pre-fill the form
    if (existingException) {
      if (existingException.exception_type === 'skip') {
        if (adjustSkip) adjustSkip.checked = true;
      } else {
        if (existingException.exception_type === 'move' || existingException.exception_type === 'move_and_adjust') {
          if (adjustNewDate) adjustNewDate.value = existingException.new_date;
        }
        if (existingException.exception_type === 'adjust_amount' || existingException.exception_type === 'move_and_adjust') {
          if (adjustNewAmount) adjustNewAmount.value = existingException.new_amount;
        }
      }
      if (adjustNotes) adjustNotes.value = existingException.notes || '';

      // Show delete button
      if (btnDeleteException) btnDeleteException.style.display = 'inline-block';
    } else {
      // New exception
      if (btnDeleteException) btnDeleteException.style.display = 'none';
    }

    showModal(modalAdjustOccurrence);
  }

  function handleSaveException() {
    if (!adjustingDeduction || !adjustingOriginalDate) return;

    const adjustSkip = document.getElementById('adjust-skip');
    const hasSkip = adjustSkip && adjustSkip.checked;
    const hasNewDate = adjustNewDate && adjustNewDate.value;
    const hasNewAmount = adjustNewAmount && adjustNewAmount.value;

    // Determine exception type based on what fields are filled
    let selectedType = 'skip';
    if (!hasSkip) {
      if (hasNewDate && hasNewAmount) {
        selectedType = 'move_and_adjust';
      } else if (hasNewDate) {
        selectedType = 'move';
      } else if (hasNewAmount) {
        selectedType = 'adjust_amount';
      } else {
        setStatus('Please select a date, amount, or check skip', 'warn');
        return;
      }
    }

    const payload = {
      deduction_id: adjustingDeduction.id,
      original_date: adjustingOriginalDate,
      exception_type: selectedType,
      new_date: '',
      new_amount: 0,
      notes: adjustNotes ? adjustNotes.value.trim() : ''
    };

    // Find existing exception
    const existingException = state.deductionExceptions.find(ex =>
      ex.deduction_id === adjustingDeduction.id && ex.original_date === adjustingOriginalDate
    );
    if (existingException) {
      payload.id = existingException.id;
    }

    // Validate and set values based on type
    if (selectedType === 'move' || selectedType === 'move_and_adjust') {
      if (!adjustNewDate || !adjustNewDate.value) {
        setStatus('Please select a new date', 'warn');
        return;
      }
      payload.new_date = adjustNewDate.value;
    }

    if (selectedType === 'adjust_amount' || selectedType === 'move_and_adjust') {
      if (!adjustNewAmount || !adjustNewAmount.value) {
        setStatus('Please enter a new amount', 'warn');
        return;
      }
      const amount = parseFloat(adjustNewAmount.value);
      if (isNaN(amount) || amount < 0) {
        setStatus('Please enter a valid amount', 'warn');
        return;
      }
      payload.new_amount = amount;
    }

    const previousExceptions = state.deductionExceptions.slice();
    const optimisticId = payload.id ? String(payload.id) : `temp_exception_${Date.now()}`;
    const optimisticException = sanitizeDeductionException({
      id: optimisticId,
      deduction_id: payload.deduction_id,
      original_date: payload.original_date,
      exception_type: payload.exception_type,
      new_date: payload.new_date || '',
      new_amount: payload.new_amount || 0,
      notes: payload.notes || '',
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    });

    const optimisticIndex = state.deductionExceptions.findIndex(ex => ex.id === optimisticException.id);
    if (optimisticIndex !== -1) {
      state.deductionExceptions.splice(optimisticIndex, 1, optimisticException);
    } else {
      state.deductionExceptions.push(optimisticException);
    }

    const extraMonthKeys = [
      monthKeyFromDateIso(adjustingOriginalDate),
      monthKeyFromDateIso(payload.new_date)
    ];
    markIncomeMonthsDirtyForDeductionChange(
      adjustingDeduction,
      adjustingDeduction,
      previousExceptions,
      state.deductionExceptions,
      extraMonthKeys
    );

    saveCache();
    renderIncomeSummary();
    renderAnnualCategorySection();
    showMonthlyDeductionsModal(adjustingType);

    // Close modal optimistically
    hideModal(modalAdjustOccurrence);
    setStatus('Saving adjustment...', 'info');

    const revertOptimistic = () => {
      state.deductionExceptions = previousExceptions;
      saveCache();
      renderIncomeSummary();
      renderAnnualCategorySection();
      showMonthlyDeductionsModal(adjustingType);
    };

    // Save to backend
    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success && res.exception) {
          // Update local state with real data
          const exception = sanitizeDeductionException(res.exception);
          const existingIndex = state.deductionExceptions.findIndex(ex => ex.id === optimisticId || ex.id === exception.id);
          if (existingIndex !== -1) {
            state.deductionExceptions.splice(existingIndex, 1, exception);
          } else {
            state.deductionExceptions.push(exception);
          }

          saveCache();
          setStatus('Adjustment saved', 'success');

          // Refresh the monthly deductions modal only if it's still open
          if (modalMonthlyDeductions && modalMonthlyDeductions.style.display !== 'none') {
            showMonthlyDeductionsModal(adjustingType);
          }
          renderIncomeSummary();
          renderAnnualCategorySection();
        } else {
          revertOptimistic();
          setStatus('Failed to save adjustment', 'error');
        }
      })
      .withFailureHandler(() => {
        revertOptimistic();
        setStatus('Failed to save adjustment', 'error');
      })
      .api_upsertDeductionException(payload);
  }

  function handleDeleteException() {
    if (!adjustingDeduction || !adjustingOriginalDate) return;

    const existingException = state.deductionExceptions.find(ex =>
      ex.deduction_id === adjustingDeduction.id && ex.original_date === adjustingOriginalDate
    );

    if (!existingException) {
      hideModal(modalAdjustOccurrence);
      return;
    }

    const previousExceptions = state.deductionExceptions.slice();
    state.deductionExceptions = state.deductionExceptions.filter(ex => ex.id !== existingException.id);

    const extraMonthKeys = [
      monthKeyFromDateIso(adjustingOriginalDate),
      monthKeyFromDateIso(existingException.new_date)
    ];
    markIncomeMonthsDirtyForDeductionChange(
      adjustingDeduction,
      adjustingDeduction,
      previousExceptions,
      state.deductionExceptions,
      extraMonthKeys
    );

    saveCache();
    renderIncomeSummary();
    renderAnnualCategorySection();
    showMonthlyDeductionsModal(adjustingType);

    // Close modal optimistically
    hideModal(modalAdjustOccurrence);
    setStatus('Removing adjustment...', 'info');

    const revertDeleteOptimistic = () => {
      state.deductionExceptions = previousExceptions;
      saveCache();
      renderIncomeSummary();
      renderAnnualCategorySection();
      showMonthlyDeductionsModal(adjustingType);
    };

    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success) {
          setStatus('Adjustment removed', 'success');

          // Refresh the monthly deductions modal only if it's still open
          if (modalMonthlyDeductions && modalMonthlyDeductions.style.display !== 'none') {
            showMonthlyDeductionsModal(adjustingType);
          }
          renderIncomeSummary();
          renderAnnualCategorySection();
        } else {
          revertDeleteOptimistic();
          setStatus('Failed to remove adjustment', 'error');
        }
      })
      .withFailureHandler(() => {
        revertDeleteOptimistic();
        setStatus('Failed to remove adjustment', 'error');
      })
      .api_deleteDeductionException(existingException.id);
  }

  function resetInvoicesState() {
    state.invoices = [];
    state.invoiceMap = {};
    state.invoiceDefaults = [];
    state.invoiceDefaultMap = {};
    state.invoiceFilters = { year: '', month: '' };
    state.invoiceSelectedId = '';
    state.invoiceDetail = null;
    state.invoiceDetailLoading = false;
    state.invoiceListLoading = false;
    state.invoiceLineForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: 'hours' };
    state.invoiceDefaultForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: 'hours' };
    state.invoicePending = { savingInvoice: false, generating: false };
    state.invoicesInitialized = false;
    renderInvoicesPage();
    renderBasInvoiceTable();
    saveCache();
  }

  function initializeInvoicesFeature() {
    if (!getFeatureFlag('enable_invoices')) return;
    if (state.invoicesInitialized) {
      renderInvoicesPage();
      return;
    }
    state.invoicesInitialized = true;
    ensureInvoiceFiltersInitialized();
    ensureInvoiceFormOptions();
    loadInvoiceDefaults();
    loadInvoicesList();
    renderInvoicesPage();
  }

  function refreshInvoices(forceDetail) {
    if (!getFeatureFlag('enable_invoices')) return;
    loadInvoiceDefaults();
    loadInvoicesList(forceDetail);
  }

  function loadInvoiceDefaults() {
    if (!getFeatureFlag('enable_invoices')) return;
    google.script.run
      .withSuccessHandler((defaults) => {
        if (!Array.isArray(defaults)) {
          state.invoiceDefaults = [];
          state.invoiceDefaultMap = {};
        } else {
          state.invoiceDefaults = defaults.slice();
          state.invoiceDefaultMap = defaults.reduce((acc, item) => {
            if (item && item.id) acc[item.id] = item;
            return acc;
          }, {});
        }
        renderInvoiceDefaults();
        saveCache();
      })
      .withFailureHandler(() => {
        setStatus('Failed to load invoice defaults', 'error');
      })
      .api_listInvoiceDefaultLineItems();
  }

  function loadInvoicesList(forceDetail) {
    if (!getFeatureFlag('enable_invoices')) return;
    state.invoiceListLoading = true;
    renderInvoiceSelector();
    google.script.run
      .withSuccessHandler((invoices) => {
        const list = Array.isArray(invoices) ? invoices.slice() : [];
        state.invoices = list;
        sortInvoices();
        updateInvoiceMaps();
        if (state.invoiceSelectedId && !state.invoiceMap[state.invoiceSelectedId]) {
          state.invoiceSelectedId = '';
          state.invoiceDetail = null;
        }
        state.invoiceListLoading = false;
        renderInvoiceNavigator();
        renderInvoiceSelector();
        if (!state.invoiceSelectedId) {
          const filtered = getFilteredInvoices();
          if (filtered.length) {
            selectInvoice(filtered[0].id, { autoLoad: true });
          } else {
            renderInvoiceDetail();
          }
        } else if (forceDetail) {
          loadInvoiceDetail(state.invoiceSelectedId, { force: true });
        } else {
          renderInvoiceDetail();
        }
        renderBasInvoiceTable();
        saveCache();
      })
      .withFailureHandler(() => {
        state.invoiceListLoading = false;
        setStatus('Failed to load invoices', 'error');
        renderInvoiceSelector();
      })
      .api_listInvoices({ include_summary: true });
  }

  function updateInvoiceMaps() {
    state.invoiceMap = state.invoices.reduce((acc, invoice) => {
      if (invoice && invoice.id) acc[invoice.id] = invoice;
      return acc;
    }, {});
  }

  function ensureInvoiceFiltersInitialized() {
    if (state.invoiceFilters.year) return;
    const now = new Date();
    state.invoiceFilters.year = String(now.getFullYear());
    state.invoiceFilters.month = String(now.getMonth() + 1);
  }

  const INVOICE_MONTH_NAMES = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  var invoiceMonthPickerState = { year: null };

  function renderInvoiceNavigator() {
    if (!invoiceNavJump) return;
    ensureInvoiceFiltersInitialized();
    const year = Number(state.invoiceFilters.year);
    const month = Number(state.invoiceFilters.month);
    const monthIndex = Math.max(1, Math.min(12, month)) - 1;
    invoiceNavJump.textContent = `${INVOICE_MONTH_NAMES[monthIndex]} ${year}`;
  }

  function renderInvoiceSelector() {
    if (!invoiceSelector) return;
    ensureInvoiceFiltersInitialized();
    if (state.invoiceListLoading) {
      invoiceSelector.innerHTML = '<option>Loading</option>';
      invoiceSelector.disabled = true;
      return;
    }
    const filtered = getFilteredInvoices();
    if (!filtered.length) {
      invoiceSelector.innerHTML = '<option value=\"\">No invoices this month</option>';
      invoiceSelector.disabled = true;
      state.invoiceSelectedId = '';
      state.invoiceDetail = null;
      renderInvoiceDetail();
      invoiceSelector.value = '';
      return;
    }
    invoiceSelector.innerHTML = '';
    filtered.forEach((invoice) => {
      const option = document.createElement('option');
      option.value = invoice.id;
      const description = invoice.invoice_number || `Invoice ${invoice.sequence || ''}`;
      option.textContent = description;
      invoiceSelector.appendChild(option);
    });
    const hasSelection = filtered.some((invoice) => invoice.id === state.invoiceSelectedId);
    if (hasSelection) {
      invoiceSelector.value = state.invoiceSelectedId;
    } else {
      invoiceSelector.value = filtered[0].id;
      selectInvoice(filtered[0].id, { autoLoad: true });
    }
    invoiceSelector.disabled = filtered.length <= 1;
  }

  function changeInvoiceMonth(offset) {
    ensureInvoiceFiltersInitialized();
    let year = Number(state.invoiceFilters.year);
    let month = Number(state.invoiceFilters.month);
    if (!Number.isFinite(year) || !Number.isFinite(month)) {
      const now = new Date();
      year = now.getFullYear();
      month = now.getMonth() + 1;
    }
    month += offset;
    while (month < 1) { month += 12; year -= 1; }
    while (month > 12) { month -= 12; year += 1; }
    state.invoiceFilters.year = String(year);
    state.invoiceFilters.month = String(month);
    state.invoiceSelectedId = '';
    state.invoiceDetail = null;
    renderInvoiceNavigator();
    renderInvoiceSelector();
    renderInvoiceDetail();
    saveCache();
  }

  function openInvoiceMonthPicker() {
    if (!invoiceMonthPickerModal) return;
    ensureInvoiceFiltersInitialized();
    invoiceMonthPickerState.year = Number(state.invoiceFilters.year);
    renderInvoiceMonthPicker();
    invoiceMonthPickerModal.style.display = 'flex';
  }

  function closeInvoiceMonthPicker() {
    if (invoiceMonthPickerModal) invoiceMonthPickerModal.style.display = 'none';
  }

  function renderInvoiceMonthPicker() {
    if (!invoiceMonthPickerModal || !invoiceMonthPickerGrid) return;
    invoiceMonthPickerYearDisplay.textContent = invoiceMonthPickerState.year;
    invoiceMonthPickerGrid.innerHTML = '';
    for (var i = 0; i < 12; i++) {
      const btn = document.createElement('button');
      btn.className = 'ts-month-picker-cell';
      btn.textContent = INVOICE_MONTH_NAMES[i].slice(0, 3);
      btn.dataset.month = String(i + 1);
      const current = new Date();
      if (invoiceMonthPickerState.year === current.getFullYear() && i === current.getMonth()) {
        btn.classList.add('current-month');
      }
      const activeMonth = Number(state.invoiceFilters.month);
      const activeYear = Number(state.invoiceFilters.year);
      if (invoiceMonthPickerState.year === activeYear && (i + 1) === activeMonth) {
        btn.classList.add('active');
      }
      btn.onclick = function() {
        const selectedMonth = Number(this.dataset.month);
        state.invoiceFilters.year = String(invoiceMonthPickerState.year);
        state.invoiceFilters.month = String(selectedMonth);
        state.invoiceSelectedId = '';
        state.invoiceDetail = null;
        renderInvoiceNavigator();
        renderInvoiceSelector();
        renderInvoiceDetail();
        closeInvoiceMonthPicker();
        saveCache();
      };
      invoiceMonthPickerGrid.appendChild(btn);
    }
  }

  function renderInvoicesPage() {
    if (!pageInvoices) return;
    if (!getFeatureFlag('enable_invoices')) {
      pageInvoices.style.display = 'none';
      return;
    }
    updateInvoiceConfigNote();
    updateInvoiceHoursLabels();
    updateInvoiceTemplateOptionVisibility();
    renderInvoiceNavigator();
    renderInvoiceSelector();
    renderInvoiceDefaults();
    renderInvoiceDetail();
  }

  function updateInvoiceTemplateOptionVisibility() {
    const showTemplate = getFeatureFlag('enable_contract_line_item_templates') && getFeatureFlag('enable_invoices');
    const lineTemplateOption = document.getElementById('invoice-line-amount-mode-template');
    const defaultTemplateOption = document.getElementById('invoice-default-amount-mode-template');
    if (lineTemplateOption) lineTemplateOption.style.display = showTemplate ? '' : 'none';
    if (defaultTemplateOption) defaultTemplateOption.style.display = showTemplate ? '' : 'none';
  }

  function updateInvoiceConfigNote() {
    if (!invoiceConfigNote) return;
    const templateConfigured = !!(state.settings.invoice_template_doc_id || state.settings.invoice_template_path || state.settings.invoice_template_reference);
    const folderConfigured = !!(state.settings.invoice_output_folder_id || state.settings.invoice_output_folder_path);
    if (templateConfigured && folderConfigured) {
      invoiceConfigNote.style.display = 'none';
      invoiceConfigNote.textContent = '';
      return;
    }
    const parts = [];
    if (!templateConfigured) parts.push('set an invoice template path or document ID');
    if (!folderConfigured) parts.push('choose an output folder path');
    invoiceConfigNote.style.display = 'block';
    invoiceConfigNote.innerHTML = `Finish setup in Settings: ${parts.join(' and ')}.`;
  }

  function updateInvoiceHoursLabels() {
    const hoursLabel = state.settings.invoice_hours_label || 'Hours';
    const lineHoursLabel = document.querySelector('label[for="invoice-line-hours"]');
    const defaultHoursLabel = document.querySelector('label[for="invoice-default-hours"]');
    if (lineHoursLabel) lineHoursLabel.textContent = hoursLabel;
    if (defaultHoursLabel) defaultHoursLabel.textContent = hoursLabel;
  }

  function renderInvoiceDefaults() {
    if (!invoiceDefaultList || !invoiceDefaultEmpty) return;
    invoiceDefaultList.innerHTML = '';
    if (!state.invoiceDefaults.length) {
      invoiceDefaultEmpty.style.display = 'block';
    } else {
      invoiceDefaultEmpty.style.display = 'none';
      const sortedDefaults = state.invoiceDefaults.slice().sort((a, b) => Number(a.position || 0) - Number(b.position || 0));
      sortedDefaults.forEach((item) => {
        const card = createInvoiceDefaultCard(item);
        const wrapper = document.createElement('li');
        wrapper.style.listStyle = 'none';
        wrapper.style.margin = '0';
        wrapper.style.padding = '0';
        wrapper.style.marginBottom = '8px';
        wrapper.appendChild(card);
        invoiceDefaultList.appendChild(wrapper);
      });
    }
    if (invoiceDefaultForm) {
      mountInvoiceDefaultFormForMode();
      if (state.invoiceDefaultForm.mode === 'hidden') {
        invoiceDefaultForm.style.display = 'none';
      } else {
        invoiceDefaultForm.style.display = 'block';
        const draft = state.invoiceDefaultForm.draft || {};
        if (invoiceDefaultLabelInput) invoiceDefaultLabelInput.value = draft.default_label || '';
        if (invoiceDefaultDescriptionInput) invoiceDefaultDescriptionInput.value = draft.description || '';
        if (invoiceDefaultHoursInput) invoiceDefaultHoursInput.value = draft.hours != null ? draft.hours : '';
        if (invoiceDefaultHourTypeSelect) populateInvoiceHourTypeOptions(invoiceDefaultHourTypeSelect, draft.hour_type_id || '');
        if (invoiceDefaultContractSelect) populateContractOptions(invoiceDefaultContractSelect, draft.contract_id || '');
        if (invoiceDefaultAmountInput) invoiceDefaultAmountInput.value = draft.amount != null ? draft.amount : '';
        if (!state.invoiceDefaultForm.amountMode) {
          state.invoiceDefaultForm.amountMode = determineInvoiceDefaultAmountMode(draft);
        }
        updateInvoiceDefaultAmountModeUI();
      }
    }
  }

  function renderInvoiceDetail() {
    if (!invoiceDetail || !invoiceDetailEmpty) return;
    if (state.invoiceDetailLoading) {
      invoiceDetail.style.display = 'none';
      invoiceDetailEmpty.style.display = 'block';
      if (invoiceDetailEmptyText) invoiceDetailEmptyText.textContent = 'Loading invoice...';
      return;
    }
    if (!state.invoiceDetail || !state.invoiceSelectedId) {
      invoiceDetail.style.display = 'none';
      invoiceDetailEmpty.style.display = 'block';
      if (invoiceDetailEmptyText) invoiceDetailEmptyText.textContent = 'Select an invoice to start editing, or create a new one.';
      return;
    }
    invoiceDetailEmpty.style.display = 'none';
    invoiceDetail.style.display = 'block';
    const detail = state.invoiceDetail.invoice || {};
    const isInvoiceLocked = invoiceIsLocked();
    if (invoiceSelector) {
      invoiceSelector.value = state.invoiceSelectedId || '';
      invoiceSelector.disabled = state.invoiceListLoading || getFilteredInvoices().length <= 1;
    }
    if (invoiceDetailNumberInput) invoiceDetailNumberInput.value = detail.invoice_number || '';
    if (invoiceDetailDateInput) invoiceDetailDateInput.value = detail.invoice_date || '';
    if (invoiceDetailStatusSelect) invoiceDetailStatusSelect.value = detail.status || 'draft';
    const hasInvoice = !!state.invoiceDetail && !!state.invoiceDetail.invoice;
    if (btnInvoiceDelete) btnInvoiceDelete.disabled = !hasInvoice || !!state.invoicePending.savingInvoice;
    if (btnInvoiceSave) btnInvoiceSave.disabled = !hasInvoice || !!state.invoicePending.savingInvoice;
    if (btnInvoiceAddLine) btnInvoiceAddLine.disabled = !hasInvoice || state.invoiceDetailLoading || isInvoiceLocked;
    if (btnInvoiceGenerate) {
      const templateConfigured = !!(state.settings.invoice_template_doc_id || state.settings.invoice_template_path || state.settings.invoice_template_reference);
      const folderConfigured = !!(state.settings.invoice_output_folder_id || state.settings.invoice_output_folder_path);
      btnInvoiceGenerate.disabled = !templateConfigured || !folderConfigured || !!state.invoicePending.generating || !hasInvoice;
    }
    const summary = state.invoiceDetail.summary || { lineCount: 0, totalHours: 0, totalAmount: 0, gstAmount: 0, totalWithGst: 0 };
    if (invoiceLineSummary) {
      const countText = `${summary.lineCount} line${summary.lineCount === 1 ? '' : 's'}`;
      const hoursText = `${Number(summary.totalHours || 0).toFixed(2)} hrs`;
      const summaryText = `${countText}  ${hoursText}  ${formatCurrency(summary.totalAmount || 0)}`;
      invoiceLineSummary.textContent = isInvoiceLocked ? `${summaryText}  Locked` : summaryText;
    }
    const subtotalAmount = Number(summary.totalAmount || 0);
    const gstAmount = summary.gstAmount != null ? Number(summary.gstAmount) : Math.round(subtotalAmount * GST_RATE * 100) / 100;
    const totalAmount = summary.totalWithGst != null ? Number(summary.totalWithGst) : Math.round((subtotalAmount + gstAmount) * 100) / 100;
    if (invoiceLineSubtotal) {
      invoiceLineSubtotal.textContent = formatCurrency(subtotalAmount);
    }
    if (invoiceLineGst) {
      invoiceLineGst.textContent = formatCurrency(gstAmount);
    }
    if (invoiceLineTotal) {
      invoiceLineTotal.textContent = formatCurrency(totalAmount);
    }
    renderInvoiceLineItems();
    if (invoiceLineForm) {
      if (isInvoiceLocked) {
        state.invoiceLineForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: getDefaultInvoiceAmountMode() };
        invoiceLineForm.style.display = 'none';
      } else {
        mountInvoiceLineFormForMode();
        if (state.invoiceLineForm.mode === 'hidden') {
          invoiceLineForm.style.display = 'none';
        } else {
          invoiceLineForm.style.display = 'block';
          applyInvoiceLineDraftToForm(state.invoiceLineForm.draft || {});
        }
      }
    }
  }

  function renderInvoiceLineItems() {
    if (!invoiceLineItemsBody) return;
    invoiceLineItemsBody.innerHTML = '';
    const items = (state.invoiceDetail && Array.isArray(state.invoiceDetail.lineItems)) ? state.invoiceDetail.lineItems : [];
    if (invoiceLineEmpty) {
      invoiceLineEmpty.style.display = items.length ? 'none' : 'block';
    }
    if (invoiceLineItemsBody) {
      invoiceLineItemsBody.style.display = items.length ? 'flex' : 'none';
    }
    if (!items.length) return;
    items.forEach((item) => {
      const card = createInvoiceLineCard(item);
      invoiceLineItemsBody.appendChild(card);
    });
  }

  function createInvoiceLineCard(item) {
    const amountValue = formatCurrency(item.amount != null ? item.amount : 0);
    const hoursValue = Number(item.hours);
    const hasHours = Number.isFinite(hoursValue) && hoursValue > 0;
    const invoiceLocked = invoiceIsLocked();
    const contractName = (item.contract_id ? getContractName(item.contract_id) : '') || item.contract_name_snapshot || '';
    const infoItems = [
      { label: 'Amount', value: amountValue, strong: true },
      { label: 'Date', value: item.line_date || '' },
      hasHours ? { label: 'Hours', value: `${hoursValue.toFixed(2)} hrs` } : null,
      hasHours && item.hour_type_name_snapshot ? { label: 'Hour type', value: item.hour_type_name_snapshot } : null,
      contractName ? { label: 'Contract', value: contractName } : null
    ].filter(Boolean);

    const hasEntry = !!item.timesheet_entry_id;
    const statusItems = [];
    if (invoiceLocked) {
      statusItems.push({
        type: 'badge',
        text: 'Locked',
        variant: 'default'
      });
    }
    if (item.entry_pending) {
      statusItems.push({
        type: 'badge',
        text: hasEntry ? 'Entry updating' : 'Entry pending',
        variant: 'warn'
      });
    } else if (hasEntry) {
      statusItems.push({
        type: 'badge',
        text: item.entry_modified ? 'Modified' : 'Synced',
        variant: item.entry_modified ? 'warn' : 'default'
      });
    } else {
      statusItems.push({ type: 'note', text: 'No linked entry' });
    }
    if ((item.entry_pending || hasEntry)) {
      const entrySummary = buildInvoiceEntrySummary(item);
      if (entrySummary) {
        const text = item.entry_pending ? `${entrySummary} (pending sync)` : entrySummary;
        statusItems.push({ type: 'note', text: `Linked entry: ${text}` });
      }
    }
    if (hasEntry && item.source_default_id) {
      const source = state.invoiceDefaultMap && state.invoiceDefaultMap[item.source_default_id]
        ? state.invoiceDefaultMap[item.source_default_id].default_label || 'Saved default'
        : 'Saved default';
      statusItems.push({ type: 'note', text: `Seeded from: ${source}` });
    }

    const actions = [];
    if (!invoiceLocked) {
      actions.push(
        { label: 'Edit', action: 'edit-line', id: item.id },
        { label: 'Delete', action: 'delete-line', id: item.id },
        { label: 'Save as default', action: 'default-line', id: item.id }
      );
      if (item.timesheet_entry_id) {
        actions.push({ label: 'Refresh', action: 'refresh-line', id: item.id });
      }
    }

    return buildInvoiceCardLayout({
      id: item.id,
      kind: 'invoice-line',
      title: item.description || '(No description)',
      infoItems: infoItems,
      statusItems: statusItems,
      actions: actions
    });
  }

  function buildInvoiceCardLayout(config) {
    const card = document.createElement('div');
    card.className = 'ts-item';
    card.style.padding = '12px';
    if (config.id) card.dataset.id = config.id;
    if (config.kind) card.dataset.kind = config.kind;

    const container = document.createElement('div');
    container.style.display = 'flex';
    container.style.alignItems = 'stretch';
    container.style.gap = '16px';
    container.style.width = '100%';

    const left = document.createElement('div');
    left.style.flex = '0 0 220px';
    left.style.display = 'flex';
    left.style.alignItems = 'center';
    left.style.fontWeight = '600';
    left.style.lineHeight = '1.4';
    left.textContent = config.title || '';
    container.appendChild(left);

    const middle = document.createElement('div');
    middle.style.flex = '1 1 auto';
    middle.style.display = 'flex';
    middle.style.flexDirection = 'column';
    middle.style.justifyContent = 'center';
    middle.style.gap = '8px';

    const infoRow = document.createElement('div');
    infoRow.style.display = 'flex';
    infoRow.style.flexWrap = 'wrap';
    infoRow.style.alignItems = 'center';
    infoRow.style.gap = '16px';

    (config.infoItems || []).forEach((item) => {
      if (!item || !item.value) return;
      const wrap = document.createElement('div');
      wrap.style.display = 'flex';
      wrap.style.alignItems = 'center';
      wrap.style.gap = '4px';

      const labelEl = document.createElement('span');
      labelEl.className = 'ts-note';
      labelEl.textContent = item.label;
      wrap.appendChild(labelEl);

      const valueEl = document.createElement('span');
      if (item.strong) valueEl.style.fontWeight = '600';
      valueEl.textContent = item.value;
      wrap.appendChild(valueEl);

      infoRow.appendChild(wrap);
    });

    middle.appendChild(infoRow);

    const statusItems = config.statusItems || [];
    if (statusItems.length) {
      const statusRow = document.createElement('div');
      statusRow.style.display = 'flex';
      statusRow.style.flexWrap = 'wrap';
      statusRow.style.alignItems = 'center';
      statusRow.style.gap = '12px';

      statusItems.forEach((status) => {
        if (!status || !status.text) return;
        if (status.type === 'badge') {
          const badge = document.createElement('span');
          badge.className = status.variant === 'warn' ? 'ts-badge ts-badge--warn' : 'ts-badge';
          badge.textContent = status.text;
          statusRow.appendChild(badge);
        } else {
          const note = document.createElement('span');
          note.className = 'ts-note';
          note.textContent = status.text;
          statusRow.appendChild(note);
        }
      });

      middle.appendChild(statusRow);
    }

    container.appendChild(middle);

    const rightWrapper = document.createElement('div');
    rightWrapper.style.display = 'flex';
    rightWrapper.style.alignItems = 'center';
    rightWrapper.style.justifyContent = 'flex-end';
    rightWrapper.style.flex = '0 0 260px';

    const actionsGrid = document.createElement('div');
    actionsGrid.style.display = 'grid';
    actionsGrid.style.gridTemplateColumns = 'repeat(2, minmax(0, 1fr))';
    actionsGrid.style.gap = '8px';
    actionsGrid.style.width = '100%';
    actionsGrid.style.maxWidth = '260px';

    const actions = (config.actions || []).slice();
    while (actions.length < 4) {
      actions.push(null);
    }

    actions.forEach((action) => {
      if (!action) {
        const placeholder = document.createElement('span');
        placeholder.style.display = 'block';
        placeholder.style.visibility = 'hidden';
        placeholder.textContent = 'Placeholder';
        actionsGrid.appendChild(placeholder);
        return;
      }
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'ghost';
      btn.dataset.action = action.action;
      if (action.id) btn.dataset.id = action.id;
      if (action.disabled) btn.disabled = true;
      if (action.title) btn.title = action.title;
      btn.textContent = action.label;
      btn.style.fontSize = '12px';
      btn.style.minWidth = '120px';
      btn.style.whiteSpace = 'nowrap';
      actionsGrid.appendChild(btn);
    });

    rightWrapper.appendChild(actionsGrid);
    container.appendChild(rightWrapper);

    card.appendChild(container);
    return card;
  }

  function getInvoiceLineCard(lineId) {
    if (!invoiceLineItemsBody || !lineId) return null;
    return invoiceLineItemsBody.querySelector(`.ts-item[data-kind="invoice-line"][data-id="${lineId}"]`);
  }

  function clearInvoiceLineEditingCard() {
    if (!invoiceLineItemsBody) return;
    const editingCards = invoiceLineItemsBody.querySelectorAll('.ts-item[data-kind="invoice-line"][data-editing="true"]');
    editingCards.forEach((card) => {
      card.style.display = '';
      card.removeAttribute('data-editing');
    });
  }

  function mountInvoiceLineFormForMode() {
    if (!invoiceLineForm) return;
    clearInvoiceLineEditingCard();
    if (state.invoiceLineForm.mode === 'edit' && state.invoiceLineForm.editingId) {
      const card = getInvoiceLineCard(state.invoiceLineForm.editingId);
      if (card && card.parentNode) {
        card.dataset.editing = 'true';
        card.style.display = 'none';
        card.parentNode.insertBefore(invoiceLineForm, card);
        invoiceLineForm.style.marginBottom = '8px';
        return;
      }
    }
    if (invoiceLineFormAnchor) {
      invoiceLineFormAnchor.appendChild(invoiceLineForm);
      invoiceLineForm.style.marginBottom = '12px';
    }
  }

  function getInvoiceDefaultCard(defaultId) {
    if (!invoiceDefaultList || !defaultId) return null;
    return invoiceDefaultList.querySelector(`.ts-item[data-kind="invoice-default"][data-id="${defaultId}"]`);
  }

  function clearInvoiceDefaultEditingCard() {
    if (!invoiceDefaultList) return;
    const editingCards = invoiceDefaultList.querySelectorAll('.ts-item[data-kind="invoice-default"][data-editing="true"]');
    editingCards.forEach((card) => {
      card.style.display = '';
      card.removeAttribute('data-editing');
    });
  }

  function mountInvoiceDefaultFormForMode() {
    if (!invoiceDefaultForm) return;
    clearInvoiceDefaultEditingCard();
    if (state.invoiceDefaultForm.mode === 'edit' && state.invoiceDefaultForm.editingId) {
      const card = getInvoiceDefaultCard(state.invoiceDefaultForm.editingId);
      if (card && card.parentNode) {
        card.dataset.editing = 'true';
        card.style.display = 'none';
        card.parentNode.insertBefore(invoiceDefaultForm, card);
        invoiceDefaultForm.style.marginTop = '0';
        return;
      }
    }
    if (invoiceDefaultFormAnchor) {
      invoiceDefaultFormAnchor.appendChild(invoiceDefaultForm);
      invoiceDefaultForm.style.marginTop = '12px';
    }
  }

  function buildInvoiceEntrySummary(item) {
    if (!item) return '';
    const entrySnapshot = item.entry_state && item.entry_state.snapshot ? item.entry_state.snapshot : null;
    const date = item.line_date || (entrySnapshot ? entrySnapshot.date : '');
    let hoursValue = Number(item.hours);
    if (!Number.isFinite(hoursValue) || hoursValue <= 0) {
      const minutes = entrySnapshot ? Number(entrySnapshot.duration_minutes) : 0;
      hoursValue = Number.isFinite(minutes) ? minutes / 60 : 0;
    }
    const contractName = item.contract_name_snapshot || getContractName(item.contract_id);
    let hourTypeName = '';
    if (Number.isFinite(hoursValue) && hoursValue > 0) {
      hourTypeName = item.hour_type_name_snapshot || getHourTypeName(item.hour_type_id);
    }
    const segments = [];
    if (date) segments.push(date);
    if (contractName) segments.push(contractName);
    if (Number.isFinite(hoursValue) && hoursValue > 0) {
      segments.push(`${hoursValue.toFixed(2)} hrs`);
    }
    if (hourTypeName) segments.push(hourTypeName);
    return segments.join('  ');
  }

  function createInvoiceDefaultCard(item) {
    const amountValue = (item.amount || item.amount === 0) ? formatCurrency(item.amount) : '';
    const hoursValue = Number(item.hours);
    const infoItems = [
      amountValue ? { label: 'Amount', value: amountValue, strong: true } : null,
      Number.isFinite(hoursValue) && hoursValue > 0 ? { label: 'Hours', value: `${hoursValue.toFixed(2)} hrs` } : null,
      Number.isFinite(hoursValue) && hoursValue > 0 && item.hour_type_name_snapshot ? { label: 'Hour type', value: item.hour_type_name_snapshot } : null,
      item.contract_name_snapshot ? { label: 'Contract', value: item.contract_name_snapshot } : null
    ].filter(Boolean);

    const statusItems = [];
    if (item.description) {
      statusItems.push({ type: 'note', text: item.description });
    }
    statusItems.push({ type: 'note', text: 'Default line item' });

    const canAddToInvoice = !!(state.invoiceDetail && state.invoiceDetail.invoice && !state.invoiceDetailLoading);
    const defaultActions = [];
    const addAction = {
      label: 'Add to invoice',
      action: 'insert-default',
      id: item.id,
      disabled: !canAddToInvoice
    };
    if (!canAddToInvoice) {
      addAction.title = 'Select an invoice to add this default';
    }
    defaultActions.push(addAction);
    defaultActions.push({ label: 'Edit', action: 'edit-default', id: item.id });
    defaultActions.push({ label: 'Delete', action: 'delete-default', id: item.id });

    return buildInvoiceCardLayout({
      id: item.id,
      kind: 'invoice-default',
      title: item.default_label || '(untitled)',
      infoItems,
      statusItems,
      actions: defaultActions
    });
  }

  function formatInvoiceMonthName(month) {
    if (!month) return '';
    const idx = Number(month) - 1;
    if (idx < 0 || idx >= INVOICE_MONTH_NAMES.length) return '';
    return INVOICE_MONTH_NAMES[idx];
  }

  function getFilteredInvoices() {
    return state.invoices.filter((invoice) => {
      if (state.invoiceFilters.year && String(invoice.year) !== state.invoiceFilters.year) return false;
      if (state.invoiceFilters.month && String(invoice.month) !== state.invoiceFilters.month) return false;
      return true;
    });
  }

  function selectInvoice(invoiceId, options) {
    const opts = options || {};
    if (!invoiceId) {
      state.invoiceSelectedId = '';
      state.invoiceDetail = null;
      state.invoiceDetailLoading = false;
      renderInvoiceDetail();
      saveCache();
      return;
    }
    if (state.invoiceSelectedId === invoiceId && !opts.force) {
      renderInvoiceDetail();
      return;
    }
    state.invoiceSelectedId = invoiceId;
    state.invoiceDetail = null;
    state.invoiceDetailLoading = true;
    renderInvoiceDetail();
    loadInvoiceDetail(invoiceId, opts);
  }

  function loadInvoiceDetail(invoiceId, options) {
    if (!invoiceId) return;
    const opts = options || {};
    state.invoiceDetailLoading = true;
    renderInvoiceDetail();
    google.script.run
      .withSuccessHandler((detail) => {
        if (state.invoiceSelectedId !== invoiceId) return;
        state.invoiceDetailLoading = false;
        if (detail && detail.invoice) {
          const summary = detail.summary || summarizeInvoiceLineItems(detail.lineItems || []);
          state.invoiceDetail = {
            invoice: detail.invoice,
            lineItems: Array.isArray(detail.lineItems) ? detail.lineItems.slice() : [],
            summary: summary
          };
          console.log('[Invoice Detail Loaded]', {
            invoice_id: detail.invoice.id,
            status: detail.invoice.status,
            lineItems: (detail.lineItems || []).map((item) => ({
              id: item.id,
              desc: item.description,
              amount_mode: item.amount_mode,
              hours: item.hours,
              amount: item.amount,
              contract_id: item.contract_id,
              contract_name_snapshot: item.contract_name_snapshot,
              resolved_contract_name: item.contract_id ? getContractName(item.contract_id) : ''
            }))
          });
          const invoiceWithSummary = Object.assign({}, detail.invoice, { summary: summary });
          upsertInvoiceInState(invoiceWithSummary);
          if (Array.isArray(detail.defaults)) {
            state.invoiceDefaults = detail.defaults.slice();
            state.invoiceDefaultMap = detail.defaults.reduce((acc, item) => {
              if (item && item.id) acc[item.id] = item;
              return acc;
            }, {});
          }
          renderInvoiceDefaults();
          ensureInvoiceFormOptions();
        } else {
          state.invoiceDetail = null;
        }
        renderInvoiceDetail();
        renderBasInvoiceTable();
        saveCache();
      })
      .withFailureHandler((error) => {
        if (state.invoiceSelectedId !== invoiceId) return;
        state.invoiceDetailLoading = false;
        console.error('[Invoice Load Error]', error);
        const errorMsg = error && error.message ? error.message : 'Failed to load invoice';
        setStatus(errorMsg, 'error');
        renderInvoiceDetail();
      })
      .api_getInvoice(invoiceId);
  }

  function upsertInvoiceInState(invoice) {
    if (!invoice || !invoice.id) return;
    const idx = state.invoices.findIndex((item) => item.id === invoice.id);
    if (idx === -1) {
      state.invoices.push(invoice);
    } else {
      state.invoices[idx] = Object.assign({}, state.invoices[idx], invoice);
    }
    sortInvoices();
    updateInvoiceMaps();
    renderInvoiceNavigator();
    renderInvoiceSelector();
  }

  function removeInvoiceFromState(invoiceId) {
    const idx = state.invoices.findIndex((item) => item.id === invoiceId);
    if (idx !== -1) {
      state.invoices.splice(idx, 1);
      updateInvoiceMaps();
      renderInvoiceNavigator();
      renderInvoiceSelector();
    }
  }

  function sortInvoices() {
    state.invoices.sort((a, b) => {
      if (a.year !== b.year) return b.year - a.year;
      if (a.month !== b.month) return b.month - a.month;
      return (b.sequence || 0) - (a.sequence || 0);
    });
  }

  function summarizeInvoiceLineItems(items) {
    const list = Array.isArray(items) ? items : [];
    const summary = list.reduce((acc, item) => {
      const amount = Number(item && item.amount != null ? item.amount : 0);
      const hours = Number(item && item.hours != null ? item.hours : 0);
      if (Number.isFinite(amount)) acc.totalAmount += amount;
      if (Number.isFinite(hours)) acc.totalHours += hours;
      return acc;
    }, { totalAmount: 0, totalHours: 0, lineCount: list.length });
    summary.totalAmount = Math.round(summary.totalAmount * 100) / 100;
    summary.totalHours = Math.round(summary.totalHours * 1000) / 1000;
    summary.gstAmount = Math.round(summary.totalAmount * GST_RATE * 100) / 100;
    summary.totalWithGst = Math.round((summary.totalAmount + summary.gstAmount) * 100) / 100;
    return summary;
  }

  function recalculateInvoiceSummary() {
    if (!state.invoiceDetail) return;
    const summary = summarizeInvoiceLineItems(state.invoiceDetail.lineItems || []);
    state.invoiceDetail.summary = summary;
  }

  function ensureInvoiceFormOptions() {
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes && state.hourTypes.length > 0;
    if (invoiceLineHourTypeSelect) populateInvoiceHourTypeOptions(invoiceLineHourTypeSelect, state.invoiceLineForm.draft && state.invoiceLineForm.draft.hour_type_id);
    if (invoiceDefaultHourTypeSelect) populateInvoiceHourTypeOptions(invoiceDefaultHourTypeSelect, state.invoiceDefaultForm.draft && state.invoiceDefaultForm.draft.hour_type_id);
    if (invoiceLineHourTypeCol) invoiceLineHourTypeCol.style.display = hourTypesEnabled ? '' : 'none';
    if (!hourTypesEnabled) {
      if (invoiceLineHourTypeSelect) invoiceLineHourTypeSelect.value = '';
      if (invoiceDefaultHourTypeSelect) invoiceDefaultHourTypeSelect.value = '';
    }
    if (invoiceLineContractSelect) populateContractOptions(invoiceLineContractSelect, state.invoiceLineForm.draft && state.invoiceLineForm.draft.contract_id);
    if (invoiceDefaultContractSelect) populateContractOptions(invoiceDefaultContractSelect, state.invoiceDefaultForm.draft && state.invoiceDefaultForm.draft.contract_id);
    updateInvoiceLineAmountModeUI();
    updateInvoiceDefaultAmountModeUI();
  }

  function populateInvoiceHourTypeOptions(selectEl, selectedId) {
    if (!selectEl) return;
    let value = selectedId || '';
    selectEl.innerHTML = '';
    const emptyOpt = document.createElement('option');
    emptyOpt.value = '';
    emptyOpt.textContent = 'Select hour type...';
    emptyOpt.style.fontStyle = 'italic';
    selectEl.appendChild(emptyOpt);
    const types = state.hourTypes && state.hourTypes.length ? state.hourTypes : [];
    const incomeTypes = types.filter((type) => type.contributes_to_income === true);
    incomeTypes.forEach((type) => {
      const opt = document.createElement('option');
      opt.value = type.id;
      opt.textContent = type.name;
      selectEl.appendChild(opt);
    });
    if (!value && incomeTypes.length === 1) {
      value = incomeTypes[0].id;
      if (selectEl === invoiceLineHourTypeSelect && state.invoiceLineForm && state.invoiceLineForm.draft) {
        state.invoiceLineForm.draft.hour_type_id = value;
      }
      if (selectEl === invoiceDefaultHourTypeSelect && state.invoiceDefaultForm && state.invoiceDefaultForm.draft) {
        state.invoiceDefaultForm.draft.hour_type_id = value;
      }
    }
    selectEl.value = value;
  }

  function populateContractOptions(selectEl, selectedId) {
    if (!selectEl) return;
    let value = selectedId || '';
    selectEl.innerHTML = '';
    const emptyOpt = document.createElement('option');
    emptyOpt.value = '';
    emptyOpt.textContent = 'Select a contract...';
    emptyOpt.style.fontStyle = 'italic';
    selectEl.appendChild(emptyOpt);

    const invoiceMonth = state.invoiceDetail && state.invoiceDetail.invoice ? state.invoiceDetail.invoice.month : null;
    const invoiceYear = state.invoiceDetail && state.invoiceDetail.invoice ? state.invoiceDetail.invoice.year : null;
    const invoiceDate = state.invoiceDetail && state.invoiceDetail.invoice ? state.invoiceDetail.invoice.invoice_date : null;

    let contracts = state.contracts && state.contracts.length ? state.contracts : [];
    let validContracts = contracts;

    if (invoiceDate && invoiceMonth && invoiceYear) {
      validContracts = contracts.filter((contract) => {
        if (!contract.start_date) return false;
        if (contract.end_date && contract.end_date < invoiceDate) return false;
        if (contract.start_date > invoiceDate) return false;
        return true;
      });
    }

    const selectedContract = value ? contracts.find((c) => c.id === value) : null;
    const isSelectedValid = selectedContract && validContracts.some((c) => c.id === value);

    if (selectedContract && !isSelectedValid) {
      const opt = document.createElement('option');
      opt.value = selectedContract.id;
      opt.textContent = `${selectedContract.name} (outside date range)`;
      opt.style.color = 'var(--warning-color)';
      selectEl.appendChild(opt);
    }

    validContracts.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      selectEl.appendChild(opt);
    });

    if (!value && validContracts.length === 1) {
      value = validContracts[0].id;
      if (selectEl === invoiceLineContractSelect && state.invoiceLineForm && state.invoiceLineForm.draft) {
        state.invoiceLineForm.draft.contract_id = value;
      }
      if (selectEl === invoiceDefaultContractSelect && state.invoiceDefaultForm && state.invoiceDefaultForm.draft) {
        state.invoiceDefaultForm.draft.contract_id = value;
      }
    }

    selectEl.value = value;

    if (selectEl === invoiceLineContractSelect) {
      populateInvoiceLineTemplateOptions();
    }
    if (selectEl === invoiceDefaultContractSelect) {
      populateInvoiceDefaultTemplateOptions();
    }
  }

  function getHourTypeName(hourTypeId) {
    if (!hourTypeId) return '';
    const existing = state.hourTypeMap && state.hourTypeMap[hourTypeId];
    if (existing) return existing.name || '';
    const found = state.hourTypes ? state.hourTypes.find((type) => type.id === hourTypeId) : null;
    return found ? found.name || '' : '';
  }

  function getContractName(contractId) {
    if (!contractId) return '';
    const existing = state.contractMap && state.contractMap[contractId];
    if (existing) return existing.name || '';
    const found = state.contracts ? state.contracts.find((contract) => contract.id === contractId) : null;
    return found ? found.name || '' : '';
  }

  function getContractRate(contractId) {
    if (!contractId) return 0;
    const existing = state.contractMap && state.contractMap[contractId];
    if (existing && Number.isFinite(Number(existing.hourly_rate))) {
      return Number(existing.hourly_rate);
    }
    const found = state.contracts ? state.contracts.find((contract) => contract.id === contractId) : null;
    if (found && Number.isFinite(Number(found.hourly_rate))) {
      return Number(found.hourly_rate);
    }
    return 0;
  }

  function generateTempId(prefix) {
    return `${prefix}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
  }

  function getNextInvoiceSequenceLocal(year, month) {
    const relevant = state.invoices.filter((invoice) => invoice.year === year && invoice.month === month);
    const maxSeq = relevant.reduce((max, invoice) => Math.max(max, Number(invoice.sequence || 0)), 0);
    return maxSeq + 1;
  }

  function startCreateInvoice() {
    if (!getFeatureFlag('enable_invoices')) return;
    ensureInvoiceFiltersInitialized();
    const now = new Date();
    const year = Number(state.invoiceFilters.year) || now.getFullYear();
    const month = Number(state.invoiceFilters.month) || (now.getMonth() + 1);
    const dateValue = `${year}-${String(month).padStart(2, '0')}-01`;
    const tempId = generateTempId('invoice');
    const sequence = getNextInvoiceSequenceLocal(year, month);
    const invoiceNumber = `INV-${year}${String(month).padStart(2, '0')}-${String(sequence).padStart(3, '0')}`;
    const draftInvoice = {
      id: tempId,
      year: year,
      month: month,
      sequence: sequence,
      invoice_number: invoiceNumber,
      invoice_date: dateValue,
      status: 'draft',
      generated_doc_id: '',
      generated_doc_url: ''
    };
    upsertInvoiceInState(draftInvoice);
    state.invoiceSelectedId = tempId;
    state.invoiceDetail = {
      invoice: draftInvoice,
      lineItems: [],
      summary: { lineCount: 0, totalHours: 0, totalAmount: 0, gstAmount: 0, totalWithGst: 0 }
    };
    renderInvoicesPage();
    setStatus('Creating invoice...', 'warn');
    google.script.run
      .withSuccessHandler((saved) => {
        if (!saved || !saved.id) {
          removeInvoiceFromState(tempId);
          state.invoiceSelectedId = '';
          state.invoiceDetail = null;
          renderInvoicesPage();
          setStatus('Failed to create invoice', 'error');
          return;
        }
        removeInvoiceFromState(tempId);
        upsertInvoiceInState(saved);
        state.invoiceSelectedId = saved.id;
        state.invoiceDetail = null;
        renderInvoicesPage();
        loadInvoiceDetail(saved.id, { force: true });
        setStatus('Invoice created', 'success');
      })
      .withFailureHandler(() => {
        removeInvoiceFromState(tempId);
        state.invoiceSelectedId = '';
        state.invoiceDetail = null;
        renderInvoicesPage();
        setStatus('Failed to create invoice', 'error');
      })
      .api_upsertInvoice({
        invoice_date: dateValue,
        status: 'draft',
        invoice_number: invoiceNumber
      });
  }

  function handleInvoiceSave(event) {
    if (event) event.preventDefault();
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) return;
    const invoice = state.invoiceDetail.invoice;
    const numberValue = invoiceDetailNumberInput ? invoiceDetailNumberInput.value.trim() : (invoice.invoice_number || '');
    const dateValue = invoiceDetailDateInput ? invoiceDetailDateInput.value : (invoice.invoice_date || '');
    if (!dateValue) {
      setStatus('Invoice date is required.', 'warn');
      return;
    }
    const statusValue = invoiceDetailStatusSelect ? invoiceDetailStatusSelect.value : (invoice.status || 'draft');
    const year = Number(dateValue.slice(0, 4)) || invoice.year;
    const month = Number(dateValue.slice(5, 7)) || invoice.month;
    const previous = Object.assign({}, invoice);
    const updatedInvoice = Object.assign({}, invoice, {
      invoice_number: numberValue,
      invoice_date: dateValue,
      status: statusValue,
      year: year,
      month: month
    });
    state.invoiceFilters.year = String(year);
    state.invoiceFilters.month = String(month);
    state.invoiceDetail.invoice = updatedInvoice;
    upsertInvoiceInState(updatedInvoice);
    state.invoicePending.savingInvoice = true;
    renderInvoiceDetail();
    setStatus('Saving invoice...', 'warn');
    google.script.run
      .withSuccessHandler((saved) => {
        state.invoicePending.savingInvoice = false;
        if (saved && saved.id) {
          state.invoiceDetail.invoice = saved;
          upsertInvoiceInState(saved);
          renderInvoiceDetail();
          setStatus('Invoice saved', 'success');
        } else {
          state.invoiceDetail.invoice = previous;
          upsertInvoiceInState(previous);
          renderInvoiceDetail();
          setStatus('Invoice save failed', 'error');
        }
        saveCache();
      })
      .withFailureHandler(() => {
        state.invoicePending.savingInvoice = false;
        state.invoiceDetail.invoice = previous;
        upsertInvoiceInState(previous);
        renderInvoiceDetail();
        setStatus('Invoice save failed', 'error');
        saveCache();
      })
      .api_upsertInvoice({
        id: invoice.id,
        invoice_number: numberValue,
        invoice_date: dateValue,
        status: statusValue
      });
  }

  async function handleInvoiceDelete() {
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) return;
    const invoice = state.invoiceDetail.invoice;
    const confirmed = await customConfirm('Delete this invoice?', { danger: true, okText: 'Delete' });
    if (!confirmed) return;
    const previousInvoices = state.invoices.slice();
    const previousSelected = state.invoiceSelectedId;
    const previousDetail = state.invoiceDetail ? JSON.parse(JSON.stringify(state.invoiceDetail)) : null;
    removeInvoiceFromState(invoice.id);
    state.invoiceSelectedId = '';
    state.invoiceDetail = null;
    renderBasInvoiceTable();
    renderInvoicesPage();
    setStatus('Deleting invoice...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success) {
          setStatus('Invoice deleted', 'success');
          const filtered = getFilteredInvoices();
          if (filtered.length) {
            selectInvoice(filtered[0].id, { autoLoad: true });
          } else {
            renderInvoicesPage();
          }
        } else {
          state.invoices = previousInvoices;
          updateInvoiceMaps();
          state.invoiceSelectedId = previousSelected;
          state.invoiceDetail = previousDetail;
          renderInvoicesPage();
          setStatus('Failed to delete invoice', 'error');
        }
        renderBasInvoiceTable();
        saveCache();
      })
      .withFailureHandler(() => {
        state.invoices = previousInvoices;
        updateInvoiceMaps();
        state.invoiceSelectedId = previousSelected;
        state.invoiceDetail = previousDetail;
        renderInvoicesPage();
        setStatus('Failed to delete invoice', 'error');
        renderBasInvoiceTable();
        saveCache();
      })
      .api_deleteInvoice(invoice.id, { deleteEntries: false });
  }

  function handleInvoiceGenerate(event) {
    if (event) event.preventDefault();
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) return;
    const invoice = state.invoiceDetail.invoice;
    const templateConfigured = !!(state.settings.invoice_template_doc_id || state.settings.invoice_template_path || state.settings.invoice_template_reference);
    const folderConfigured = !!(state.settings.invoice_output_folder_id || state.settings.invoice_output_folder_path);
    if (!templateConfigured || !folderConfigured) {
      setStatus('Configure the invoice template and output folder first.', 'warn');
      return;
    }
    state.invoicePending.generating = true;
    renderInvoiceDetail();
    setStatus('Publishing invoice...', 'info');
    google.script.run
      .withSuccessHandler((res) => {
        state.invoicePending.generating = false;
        if (res && res.success) {
          setStatus('Invoice published', 'success');
          loadInvoiceDetail(invoice.id, { force: true });
        } else {
          setStatus('Failed to publish invoice', 'error');
          renderInvoiceDetail();
        }
      })
      .withFailureHandler(() => {
        state.invoicePending.generating = false;
        renderInvoiceDetail();
        setStatus('Failed to publish invoice', 'error');
      })
      .api_generateInvoiceDocument({ invoice_id: invoice.id });
  }

  function openInvoiceLineForm(mode, baseDraft) {
    if (!state.invoiceDetail) return;
    const invoiceDate = state.invoiceDetail.invoice ? (state.invoiceDetail.invoice.invoice_date || todayIso()) : todayIso();
    const draft = Object.assign({
      id: baseDraft && baseDraft.id,
      line_date: baseDraft && baseDraft.line_date ? baseDraft.line_date : invoiceDate,
      description: baseDraft && baseDraft.description ? baseDraft.description : '',
      hours: baseDraft && baseDraft.hours != null ? baseDraft.hours : '',
      amount: baseDraft && baseDraft.amount != null ? baseDraft.amount : '',
      hour_type_id: baseDraft && baseDraft.hour_type_id ? baseDraft.hour_type_id : '',
      contract_id: baseDraft && baseDraft.contract_id ? baseDraft.contract_id : '',
      source_default_id: baseDraft && baseDraft.source_default_id ? baseDraft.source_default_id : '',
      amount_mode: baseDraft && baseDraft.amount_mode ? baseDraft.amount_mode : '',
      amount_provided: baseDraft && baseDraft.amount_provided ? baseDraft.amount_provided : false
    }, {});
    const amountMode = draft.amount_mode ? draft.amount_mode : determineInvoiceLineAmountMode(draft);
    state.invoiceLineForm = {
      mode: mode,
      editingId: mode === 'edit' ? draft.id : null,
      draft: draft,
      amountMode: amountMode
    };
    console.log('[Invoice Line Form Open]', {
      mode,
      draft,
      amountMode
    });
    ensureInvoiceFormOptions();
    mountInvoiceLineFormForMode();
    applyInvoiceLineDraftToForm(draft);
    if (invoiceLineForm) invoiceLineForm.style.display = 'block';
  }

  function getDefaultInvoiceAmountMode() {
    const templateEnabled = getFeatureFlag('enable_contract_line_item_templates') && getFeatureFlag('enable_invoices');
    return templateEnabled ? 'contract_template' : 'monthly_hour_type';
  }

  function resetInvoiceLineForm() {
    state.invoiceLineForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: getDefaultInvoiceAmountMode() };
    mountInvoiceLineFormForMode();
    if (invoiceLineForm) invoiceLineForm.style.display = 'none';
    updateInvoiceLineAmountModeUI();
  }

  function handleInvoiceLineAmountModeChange() {
    const mode = invoiceLineAmountModeSelect ? invoiceLineAmountModeSelect.value : 'hours';
    if (!state.invoiceLineForm) {
      state.invoiceLineForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: mode };
    } else {
      state.invoiceLineForm.amountMode = mode;
      if (!state.invoiceLineForm.draft) {
        state.invoiceLineForm.draft = {};
      }
      if (mode === 'hours') {
        state.invoiceLineForm.draft.amount = '';
        if (invoiceLineAmountInput) invoiceLineAmountInput.value = '';
      } else if (mode === 'amount') {
        state.invoiceLineForm.draft.hours = '';
        state.invoiceLineForm.draft.hour_type_id = '';
        if (invoiceLineHoursInput) invoiceLineHoursInput.value = '';
        if (invoiceLineHourTypeSelect) invoiceLineHourTypeSelect.value = '';
      } else if (mode === 'monthly_hour_type') {
        state.invoiceLineForm.draft.hours = '';
        state.invoiceLineForm.draft.amount = '';
        if (invoiceLineHoursInput) invoiceLineHoursInput.value = '';
        if (invoiceLineAmountInput) invoiceLineAmountInput.value = '';
      } else if (mode === 'contract_template') {
        state.invoiceLineForm.draft.hours = '';
        state.invoiceLineForm.draft.amount = '';
        if (invoiceLineHoursInput) invoiceLineHoursInput.value = '';
        if (invoiceLineAmountInput) invoiceLineAmountInput.value = '';
      }
    }
    updateInvoiceLineAmountModeUI();
  }

  function handleInvoiceLineContractChange() {
    const contractId = invoiceLineContractSelect ? invoiceLineContractSelect.value : '';
    if (state.invoiceLineForm && state.invoiceLineForm.draft) {
      state.invoiceLineForm.draft.contract_id = contractId;
    }
    populateInvoiceLineTemplateOptions();
  }

  function handleInvoiceLineTemplateChange() {
    const templateIndex = invoiceLineTemplateSelect ? invoiceLineTemplateSelect.value : '';
    if (templateIndex === '') return;
    const contractId = invoiceLineContractSelect ? invoiceLineContractSelect.value : '';
    if (!contractId) return;
    const contract = state.contracts.find(c => c.id === contractId);
    if (!contract) return;
    let templates = [];
    try {
      templates = contract.line_item_templates_json ? JSON.parse(contract.line_item_templates_json) : [];
      if (!Array.isArray(templates)) templates = [];
    } catch (e) {
      templates = [];
    }
    const template = templates[Number(templateIndex)];
    if (!template) return;
    const templateAmount = Number(template.amount) || 0;
    if (invoiceLineDescriptionInput) invoiceLineDescriptionInput.value = template.description || '';
    if (invoiceLineAmountInput) invoiceLineAmountInput.value = templateAmount;
    if (state.invoiceLineForm && state.invoiceLineForm.draft) {
      state.invoiceLineForm.draft.description = template.description || '';
      state.invoiceLineForm.draft.amount = templateAmount;
    }
  }

  function determineInvoiceLineAmountMode(draft) {
    if (!draft) return getDefaultInvoiceAmountMode();
    if (draft.amount_mode) {
      return draft.amount_mode;
    }
    if (draft.hours != null && draft.hours !== '' && Number(draft.hours) > 0) {
      return 'hours';
    }
    if (draft.amount != null && draft.amount !== '' && Number(draft.amount) > 0) {
      return 'amount';
    }
    return getDefaultInvoiceAmountMode();
  }

  function updateInvoiceLineAmountModeUI() {
    const mode = state.invoiceLineForm && state.invoiceLineForm.amountMode ? state.invoiceLineForm.amountMode : getDefaultInvoiceAmountMode();
    if (invoiceLineAmountModeSelect) invoiceLineAmountModeSelect.value = mode;
    const showHours = mode === 'hours';
    const showMonthlyHourType = mode === 'monthly_hour_type';
    const showTemplate = mode === 'contract_template';
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes && state.hourTypes.length > 0;

    if (invoiceLineContractCol) invoiceLineContractCol.style.display = '';
    if (invoiceLineAmountCol) invoiceLineAmountCol.style.display = (showHours || showMonthlyHourType || showTemplate) ? 'none' : '';
    if (invoiceLineHoursCol) invoiceLineHoursCol.style.display = showHours ? '' : 'none';
    if (invoiceLineHourTypeCol) invoiceLineHourTypeCol.style.display = (showHours && hourTypesEnabled) || showMonthlyHourType ? '' : 'none';
    if (invoiceLineTemplateCol) invoiceLineTemplateCol.style.display = showTemplate ? '' : 'none';

    if (invoiceLineHoursInput) {
      if (!showHours) {
        invoiceLineHoursInput.value = '';
      }
      invoiceLineHoursInput.disabled = !showHours;
    }
    if (invoiceLineHourTypeSelect) {
      if (!showHours && !showMonthlyHourType) {
        invoiceLineHourTypeSelect.value = '';
      }
      invoiceLineHourTypeSelect.disabled = !(showHours && hourTypesEnabled) && !showMonthlyHourType;
    }
    if (invoiceLineAmountInput) {
      const amountReadOnly = showHours || showMonthlyHourType || showTemplate;
      invoiceLineAmountInput.disabled = amountReadOnly;
      invoiceLineAmountInput.readOnly = amountReadOnly;
      invoiceLineAmountInput.style.display = showHours ? 'none' : 'block';
      if (showHours && !showMonthlyHourType && !showTemplate) {
        invoiceLineAmountInput.value = '';
      }
    }
    if (showTemplate) {
      populateInvoiceLineTemplateOptions();
    }
  }

  function determineInvoiceDefaultAmountMode(draft) {
    if (!draft) return getDefaultInvoiceAmountMode();
    if (draft.amount_mode === 'monthly_hour_type') {
      return 'monthly_hour_type';
    }
    if (draft.amount_mode === 'contract_template') {
      return 'contract_template';
    }
    if (draft.amount_mode === 'amount') {
      return 'amount';
    }
    if (draft.hours != null && draft.hours !== '' && Number(draft.hours) > 0) {
      return 'hours';
    }
    if (draft.amount != null && draft.amount !== '' && Number(draft.amount) > 0) {
      return 'amount';
    }
    return getDefaultInvoiceAmountMode();
  }

  function handleInvoiceDefaultAmountModeChange() {
    const mode = invoiceDefaultAmountModeSelect ? invoiceDefaultAmountModeSelect.value : 'hours';
    if (!state.invoiceDefaultForm) {
      state.invoiceDefaultForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: mode };
    } else {
      state.invoiceDefaultForm.amountMode = mode;
      if (!state.invoiceDefaultForm.draft) state.invoiceDefaultForm.draft = {};
      if (mode === 'hours') {
        state.invoiceDefaultForm.draft.amount = '';
        if (invoiceDefaultAmountInput) invoiceDefaultAmountInput.value = '';
      } else if (mode === 'amount') {
        state.invoiceDefaultForm.draft.hours = '';
        state.invoiceDefaultForm.draft.hour_type_id = '';
        if (invoiceDefaultHoursInput) invoiceDefaultHoursInput.value = '';
        if (invoiceDefaultHourTypeSelect) invoiceDefaultHourTypeSelect.value = '';
      } else if (mode === 'monthly_hour_type') {
        state.invoiceDefaultForm.draft.hours = '';
        state.invoiceDefaultForm.draft.amount = '';
        if (invoiceDefaultHoursInput) invoiceDefaultHoursInput.value = '';
        if (invoiceDefaultAmountInput) invoiceDefaultAmountInput.value = '';
      } else if (mode === 'contract_template') {
        state.invoiceDefaultForm.draft.hours = '';
        state.invoiceDefaultForm.draft.amount = '';
        if (invoiceDefaultHoursInput) invoiceDefaultHoursInput.value = '';
        if (invoiceDefaultAmountInput) invoiceDefaultAmountInput.value = '';
      }
    }
    updateInvoiceDefaultAmountModeUI();
  }

  function handleInvoiceDefaultContractChange() {
    const contractId = invoiceDefaultContractSelect ? invoiceDefaultContractSelect.value : '';
    if (state.invoiceDefaultForm && state.invoiceDefaultForm.draft) {
      state.invoiceDefaultForm.draft.contract_id = contractId;
    }
    populateInvoiceDefaultTemplateOptions();
  }

  function handleInvoiceDefaultTemplateChange() {
    const templateIndex = invoiceDefaultTemplateSelect ? invoiceDefaultTemplateSelect.value : '';
    if (templateIndex === '') return;
    const contractId = invoiceDefaultContractSelect ? invoiceDefaultContractSelect.value : '';
    if (!contractId) return;
    const contract = state.contracts.find(c => c.id === contractId);
    if (!contract) return;
    let templates = [];
    try {
      templates = contract.line_item_templates_json ? JSON.parse(contract.line_item_templates_json) : [];
      if (!Array.isArray(templates)) templates = [];
    } catch (e) {
      templates = [];
    }
    const template = templates[Number(templateIndex)];
    if (!template) return;
    const templateAmount = Number(template.amount) || 0;
    if (invoiceDefaultDescriptionInput) invoiceDefaultDescriptionInput.value = template.description || '';
    if (invoiceDefaultAmountInput) invoiceDefaultAmountInput.value = templateAmount;
    if (state.invoiceDefaultForm && state.invoiceDefaultForm.draft) {
      state.invoiceDefaultForm.draft.description = template.description || '';
      state.invoiceDefaultForm.draft.amount = templateAmount;
    }
  }

  function updateInvoiceDefaultAmountModeUI() {
    const mode = state.invoiceDefaultForm && state.invoiceDefaultForm.amountMode ? state.invoiceDefaultForm.amountMode : getDefaultInvoiceAmountMode();
    if (invoiceDefaultAmountModeSelect) invoiceDefaultAmountModeSelect.value = mode;
    const showHours = mode === 'hours';
    const showMonthlyHourType = mode === 'monthly_hour_type';
    const showTemplate = mode === 'contract_template';
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes && state.hourTypes.length > 0;

    if (invoiceDefaultContractCol) invoiceDefaultContractCol.style.display = '';
    if (invoiceDefaultAmountCol) invoiceDefaultAmountCol.style.display = (showHours || showMonthlyHourType || showTemplate) ? 'none' : '';
    if (invoiceDefaultHoursCol) invoiceDefaultHoursCol.style.display = showHours ? '' : 'none';
    if (invoiceDefaultHourTypeCol) invoiceDefaultHourTypeCol.style.display = (showHours && hourTypesEnabled) || showMonthlyHourType ? '' : 'none';
    if (invoiceDefaultTemplateCol) invoiceDefaultTemplateCol.style.display = showTemplate ? '' : 'none';

    if (invoiceDefaultHoursInput) {
      if (!showHours) {
        invoiceDefaultHoursInput.value = '';
      }
      invoiceDefaultHoursInput.disabled = !showHours;
    }
    if (invoiceDefaultHourTypeSelect) {
      if (!showHours && !showMonthlyHourType) {
        invoiceDefaultHourTypeSelect.value = '';
      }
      invoiceDefaultHourTypeSelect.disabled = !(showHours && hourTypesEnabled) && !showMonthlyHourType;
    }
    if (invoiceDefaultAmountInput) {
      const amountReadOnly = showHours || showMonthlyHourType || showTemplate;
      invoiceDefaultAmountInput.disabled = amountReadOnly;
      invoiceDefaultAmountInput.readOnly = amountReadOnly;
      invoiceDefaultAmountInput.style.display = showHours ? 'none' : 'block';
      if (showHours && !showMonthlyHourType && !showTemplate) {
        invoiceDefaultAmountInput.value = '';
      }
    }
    if (showTemplate) {
      populateInvoiceDefaultTemplateOptions();
    }
  }

  function populateInvoiceLineTemplateOptions() {
    if (!invoiceLineTemplateSelect) return;
    const contractId = invoiceLineContractSelect ? invoiceLineContractSelect.value : '';
    invoiceLineTemplateSelect.innerHTML = '<option value="">Select a template...</option>';
    if (!contractId) return;
    const contract = state.contracts.find(c => c.id === contractId);
    if (!contract) return;
    let templates = [];
    try {
      templates = contract.line_item_templates_json ? JSON.parse(contract.line_item_templates_json) : [];
      if (!Array.isArray(templates)) templates = [];
    } catch (e) {
      templates = [];
    }
    templates.forEach((template, index) => {
      const option = document.createElement('option');
      option.value = String(index);
      const amount = Number(template.amount) || 0;
      option.textContent = `${template.label} ($${amount.toFixed(2)})`;
      invoiceLineTemplateSelect.appendChild(option);
    });
  }

  function populateInvoiceDefaultTemplateOptions() {
    if (!invoiceDefaultTemplateSelect) return;
    const contractId = invoiceDefaultContractSelect ? invoiceDefaultContractSelect.value : '';
    invoiceDefaultTemplateSelect.innerHTML = '<option value="">Select a template...</option>';
    if (!contractId) return;
    const contract = state.contracts.find(c => c.id === contractId);
    if (!contract) return;
    let templates = [];
    try {
      templates = contract.line_item_templates_json ? JSON.parse(contract.line_item_templates_json) : [];
      if (!Array.isArray(templates)) templates = [];
    } catch (e) {
      templates = [];
    }
    templates.forEach((template, index) => {
      const option = document.createElement('option');
      option.value = String(index);
      const amount = Number(template.amount) || 0;
      option.textContent = `${template.label} ($${amount.toFixed(2)})`;
      invoiceDefaultTemplateSelect.appendChild(option);
    });
  }

  function applyInvoiceLineDraftToForm(draft) {
    ensureInvoiceFormOptions();
    if (state.invoiceLineForm) {
      const inferredMode = (draft && draft.amount_mode) ? draft.amount_mode : determineInvoiceLineAmountMode(draft);
      state.invoiceLineForm.amountMode = inferredMode;
    }
    updateInvoiceLineAmountModeUI();
    if (invoiceLineDateInput) invoiceLineDateInput.value = draft.line_date || '';
    if (invoiceLineDescriptionInput) invoiceLineDescriptionInput.value = draft.description || '';
    if (invoiceLineHoursInput) invoiceLineHoursInput.value = draft.hours !== undefined && draft.hours !== null ? draft.hours : '';
  if (invoiceLineAmountInput) {
    const manualMode = state.invoiceLineForm && state.invoiceLineForm.amountMode === 'amount';
    if (manualMode && draft.amount !== undefined && draft.amount !== null && draft.amount !== '') {
      invoiceLineAmountInput.value = draft.amount;
    } else {
      invoiceLineAmountInput.value = '';
    }
  }
    if (invoiceLineHourTypeSelect) invoiceLineHourTypeSelect.value = draft.hour_type_id || '';
    if (invoiceLineContractSelect) invoiceLineContractSelect.value = draft.contract_id || '';
  }

  function buildInvoiceLineDraftFromForm() {
    if (!invoiceLineDateInput || !invoiceLineDescriptionInput) return null;
    const base = state.invoiceLineForm.draft || {};
    const amountMode = state.invoiceLineForm && state.invoiceLineForm.amountMode ? state.invoiceLineForm.amountMode : 'hours';
    const lineDate = invoiceLineDateInput.value || '';
    const description = invoiceLineDescriptionInput.value.trim();
    const hoursValue = amountMode === 'hours' && invoiceLineHoursInput && invoiceLineHoursInput.value !== '' ? Number(invoiceLineHoursInput.value) : null;
    const amountProvided = (amountMode === 'amount' || amountMode === 'contract_template') && invoiceLineAmountInput && invoiceLineAmountInput.value !== '';
    const amountValue = amountProvided ? Number(invoiceLineAmountInput.value) : null;
    const hourTypeId = invoiceLineHourTypeSelect ? invoiceLineHourTypeSelect.value : '';
    const contractId = invoiceLineContractSelect ? invoiceLineContractSelect.value : '';
    return {
      id: base.id,
      line_date: lineDate,
      description: description,
      hours: hoursValue,
      amount: amountValue,
      amountProvided: amountProvided,
      amountMode: amountMode,
      hour_type_id: hourTypeId,
      contract_id: contractId,
      source_default_id: base.source_default_id || ''
    };
  }

  function handleInvoiceLineSave(event) {
    console.log('[Invoice Line Save] Starting save process');
    if (event) event.preventDefault();
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) {
      console.log('[Invoice Line Save] No invoice detail or invoice found');
      return;
    }
    if (invoiceIsLocked()) {
      setStatus('This invoice has been published and cannot be edited.', 'warn');
      resetInvoiceLineForm();
      return;
    }
    const draft = buildInvoiceLineDraftFromForm();
    console.log('[Invoice Line Save] Draft built:', draft);
    if (!draft) {
      console.log('[Invoice Line Save] Draft is null, returning');
      return;
    }
    if (!draft.description) {
      console.log('[Invoice Line Save] Description missing');
      setStatus('Line item description is required.', 'warn');
      return;
    }
    if (!draft.contract_id) {
      console.log('[Invoice Line Save] Contract ID missing');
      setStatus('Select a contract for this line item.', 'warn');
      return;
    }
    const hasHours = draft.hours != null && draft.hours !== '' && Number.isFinite(Number(draft.hours)) && Number(draft.hours) > 0;
    const amountInputValid = draft.amountProvided && draft.amount != null && !Number.isNaN(Number(draft.amount));
    const isMonthlyHourType = draft.amountMode === 'monthly_hour_type';
    const isTemplate = draft.amountMode === 'contract_template';
    if (!hasHours && !amountInputValid && !isMonthlyHourType && !isTemplate) {
      setStatus('Enter hours to auto-calculate or provide a raw amount.', 'warn');
      return;
    }
    if (isMonthlyHourType && !draft.hour_type_id) {
      setStatus('Select an hour type for monthly total calculation.', 'warn');
      return;
    }
    if (isTemplate && (!Number.isFinite(draft.amount) || draft.amount < 0)) {
      setStatus('Select a template to set the amount.', 'warn');
      return;
    }
    if (draft.amountProvided && (draft.amount == null || Number.isNaN(Number(draft.amount)))) {
      setStatus('Enter a valid amount.', 'warn');
      return;
    }
    let amount = draft.amountProvided ? Number(draft.amount) : null;
    const contractRate = getContractRate(draft.contract_id);
    if (hasHours && !draft.amountProvided) {
      if (contractRate > 0) {
        amount = Math.round(Number(draft.hours) * contractRate * 100) / 100;
      } else {
        setStatus('Contract rate missing. Enter an amount manually.', 'warn');
        return;
      }
    } else if (isMonthlyHourType) {
      if (!(contractRate > 0)) {
        setStatus('Contract rate is required for monthly hour type calculation.', 'warn');
        return;
      }
      amount = 0;
    } else if (isTemplate) {
      amount = draft.amount ? Number(draft.amount) : 0;
    }
    draft.hours = hasHours ? Number(draft.hours) : null;
    if (!isMonthlyHourType && !isTemplate && (amount === null || Number.isNaN(amount))) {
      setStatus('Enter a valid amount for this line item.', 'warn');
      return;
    }
    amount = Math.round(Number(amount) * 100) / 100;
    console.log('[Invoice Line Save] Final amount calculated:', amount);
    const lineItems = state.invoiceDetail.lineItems || [];
    const hourTypeName = draft.hour_type_id ? getHourTypeName(draft.hour_type_id) : '';
    const contractName = draft.contract_id ? getContractName(draft.contract_id) : '';
    const payload = {
      invoice_id: state.invoiceDetail.invoice.id,
      line_date: draft.line_date || state.invoiceDetail.invoice.invoice_date || todayIso(),
      description: draft.description,
      hours: draft.hours != null ? Number(draft.hours) : 0,
      amount: Number(amount),
      amount_mode: draft.amountMode || 'hours',
      hour_type_id: draft.hour_type_id || '',
      hour_type_name_snapshot: hourTypeName,
      contract_id: draft.contract_id || '',
      contract_name_snapshot: contractName,
      source_default_id: draft.source_default_id || ''
    };
    payload.amount_provided = draft.amountProvided === true || !hasHours;
    const isEdit = state.invoiceLineForm.mode === 'edit' && state.invoiceLineForm.editingId;
    if (isEdit) payload.id = state.invoiceLineForm.editingId;
    console.log('[Invoice Line Save] Payload prepared:', payload);
    console.log('[Invoice Line Save] Is edit mode:', isEdit);
    const tempId = isEdit ? state.invoiceLineForm.editingId : generateTempId('invoice-line');
    const position = isEdit
      ? (lineItems.find((item) => item.id === state.invoiceLineForm.editingId)?.position || 0)
      : (lineItems.reduce((max, item) => Math.max(max, Number(item.position || 0)), 0) + 1);
    payload.position = position;

    const optimisticItem = {
      id: tempId,
      invoice_id: state.invoiceDetail.invoice.id,
      position: position,
      line_date: payload.line_date,
      description: payload.description,
      hours: payload.hours,
      amount: payload.amount,
      amount_mode: payload.amount_mode,
      amount_provided: payload.amount_provided,
      hour_type_id: payload.hour_type_id,
      hour_type_name_snapshot: hourTypeName,
      contract_id: payload.contract_id,
      contract_name_snapshot: contractName,
      timesheet_entry_id: isEdit ? (lineItems.find((item) => item.id === payload.id)?.timesheet_entry_id || '') : '',
      entry_modified: false,
      entry_state: null,
      source_default_id: payload.source_default_id || '',
      entry_pending: hasHours
    };
    if (isEdit) {
      const previousItem = lineItems.find((item) => item.id === payload.id);
      const previousSnapshot = previousItem ? Object.assign({}, previousItem) : null;
      mergeLineItemIntoDetail(optimisticItem);
      updateInvoiceSummaryAndRender();
      setStatus('Saving line item...', 'warn');
      console.log('[Invoice Line Save] Calling api_upsertInvoiceLineItem (edit mode) with payload:', payload);
      google.script.run
        .withSuccessHandler((saved) => {
          console.log('[Invoice Line Save] SUCCESS (edit mode) - Received:', saved);
          if (saved && saved.id) {
            mergeLineItemIntoDetail(saved);
            updateInvoiceSummaryAndRender();
            setStatus('Line item saved', 'success');
          } else if (previousSnapshot) {
            console.log('[Invoice Line Save] No valid saved object, reverting to snapshot');
            mergeLineItemIntoDetail(previousSnapshot);
            updateInvoiceSummaryAndRender();
            setStatus('Failed to save line item', 'error');
          }
        })
        .withFailureHandler((error) => {
          console.error('[Invoice Line Save] FAILURE (edit mode):', error);
          if (previousSnapshot) {
            mergeLineItemIntoDetail(previousSnapshot);
            updateInvoiceSummaryAndRender();
          }
          setStatus('Failed to save line item', 'error');
        })
        .api_upsertInvoiceLineItem(payload);
    } else {
      mergeLineItemIntoDetail(optimisticItem);
      updateInvoiceSummaryAndRender();
      setStatus('Saving line item...', 'warn');
      console.log('[Invoice Line Save] Calling api_upsertInvoiceLineItem (create mode) with payload:', payload);
      google.script.run
        .withSuccessHandler((saved) => {
          console.log('[Invoice Line Save] SUCCESS (create mode) - Received:', saved);
          if (saved && saved.id) {
            if (tempId && tempId !== saved.id) {
              removeLineItemFromDetail(tempId);
            }
            mergeLineItemIntoDetail(saved);
            updateInvoiceSummaryAndRender();
            setStatus('Line item saved', 'success');
          } else {
            console.log('[Invoice Line Save] No valid saved object, removing temp item');
            removeLineItemFromDetail(tempId);
            updateInvoiceSummaryAndRender();
            setStatus('Failed to save line item', 'error');
          }
        })
        .withFailureHandler((error) => {
          console.error('[Invoice Line Save] FAILURE (create mode):', error);
          removeLineItemFromDetail(tempId);
          updateInvoiceSummaryAndRender();
          setStatus('Failed to save line item', 'error');
        })
        .api_upsertInvoiceLineItem(payload);
    }
    console.log('[Invoice Line Save] Resetting form');
    resetInvoiceLineForm();
  }

  function handleInvoiceLineCancel(event) {
    if (event) event.preventDefault();
    resetInvoiceLineForm();
  }

  function handleInvoiceLineItemAction(event) {
    if (invoiceIsLocked()) {
      setStatus('This invoice has been published and line items are locked.', 'warn');
      return;
    }
    const button = event.target instanceof HTMLElement ? event.target.closest('button[data-action]') : null;
    if (!button) return;
    const action = button.dataset.action;
    const id = button.dataset.id;
    if (!action || !id) return;
    if (action === 'edit-line') {
      const lineItem = state.invoiceDetail && state.invoiceDetail.lineItems ? state.invoiceDetail.lineItems.find((item) => item.id === id) : null;
      if (!lineItem) return;
      openInvoiceLineForm('edit', lineItem);
    }
    if (action === 'delete-line') {
      handleInvoiceLineDelete(id);
    }
    if (action === 'default-line') {
      const lineItem = state.invoiceDetail && state.invoiceDetail.lineItems ? state.invoiceDetail.lineItems.find((item) => item.id === id) : null;
      if (lineItem) startDefaultFromLine(lineItem);
    }
    if (action === 'refresh-line') {
      handleInvoiceLineRefresh(id);
    }
  }

  async function handleInvoiceLineDelete(lineId) {
    if (!state.invoiceDetail) return;
    if (invoiceIsLocked()) {
      setStatus('This invoice has been published and line items are locked.', 'warn');
      return;
    }
    const lineItem = state.invoiceDetail.lineItems ? state.invoiceDetail.lineItems.find((item) => item.id === lineId) : null;
    if (!lineItem) return;
    const confirmed = await customConfirm('Delete this line item?', { danger: true, okText: 'Delete' });
    if (!confirmed) return;
    removeLineItemFromDetail(lineId);
    updateInvoiceSummaryAndRender();
    setStatus('Deleting line item...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success) {
          setStatus('Line item deleted', 'success');
        } else {
          mergeLineItemIntoDetail(lineItem);
          updateInvoiceSummaryAndRender();
          setStatus('Failed to delete line item', 'error');
        }
      })
      .withFailureHandler(() => {
        mergeLineItemIntoDetail(lineItem);
        updateInvoiceSummaryAndRender();
        setStatus('Failed to delete line item', 'error');
      })
      .api_deleteInvoiceLineItem(lineId, { preserveEntry: false });
  }

  function handleInvoiceLineRefresh(lineId) {
    if (!state.invoiceDetail) return;
    if (invoiceIsLocked()) {
      setStatus('This invoice has been published and line items are locked.', 'warn');
      return;
    }
    const lineItem = state.invoiceDetail.lineItems ? state.invoiceDetail.lineItems.find((item) => item.id === lineId) : null;
    if (!lineItem) return;
    setStatus('Refreshing entry status...', 'info');
    google.script.run
      .withSuccessHandler((updated) => {
        if (updated && updated.id) {
          mergeLineItemIntoDetail(updated);
          updateInvoiceSummaryAndRender();
          setStatus('Entry synced', 'success');
        } else {
          setStatus('Failed to refresh entry', 'error');
        }
      })
      .withFailureHandler(() => {
        setStatus('Failed to refresh entry', 'error');
      })
      .api_refreshInvoiceLineItemEntry(lineId);
  }

  function startDefaultFromLine(lineItem) {
    if (!lineItem) return;
    const draft = {
      default_label: lineItem.description || '',
      description: lineItem.description || '',
      hours: lineItem.hours != null ? Number(lineItem.hours) : '',
      amount: lineItem.amount != null && lineItem.amount !== '' ? Number(lineItem.amount) : '',
      hour_type_id: lineItem.hour_type_id || '',
      contract_id: lineItem.contract_id || ''
    };
    const amountMode = determineInvoiceDefaultAmountMode(draft);
    draft.hours = amountMode === 'hours' ? draft.hours : '';
    draft.amount = amountMode === 'amount' ? draft.amount : '';
    if (amountMode !== 'hours') {
      draft.hour_type_id = '';
    }
    state.invoiceDefaultForm = {
      mode: 'create',
      editingId: null,
      draft: draft,
      amountMode: amountMode
    };
    ensureInvoiceFormOptions();
    renderInvoiceDefaults();
    if (invoiceDefaultForm) {
      invoiceDefaultForm.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }

  function mergeLineItemIntoDetail(item) {
    if (!state.invoiceDetail) return;
    const list = state.invoiceDetail.lineItems || [];
    const idx = list.findIndex((existing) => existing.id === item.id);
    if (idx === -1) {
      list.push(Object.assign({}, item));
    } else {
      const merged = Object.assign({}, list[idx], item);
      if (!('entry_pending' in item) && Object.prototype.hasOwnProperty.call(merged, 'entry_pending')) {
        delete merged.entry_pending;
      }
      list[idx] = merged;
    }
    state.invoiceDetail.lineItems = list.slice().sort((a, b) => {
      const posA = Number(a.position || 0);
      const posB = Number(b.position || 0);
      if (posA !== posB) return posA - posB;
      return String(a.created_at || '').localeCompare(String(b.created_at || ''));
    });
  }

  function syncInvoiceSummaryToList() {
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) return;
    const invoiceId = state.invoiceDetail.invoice.id;
    if (!invoiceId) return;
    const summary = state.invoiceDetail.summary || summarizeInvoiceLineItems(state.invoiceDetail.lineItems || []);
    const idx = state.invoices.findIndex((inv) => inv.id === invoiceId);
    if (idx !== -1) {
      const updated = Object.assign({}, state.invoices[idx], { summary: summary });
      state.invoices[idx] = updated;
      state.invoiceMap[invoiceId] = updated;
    }
  }

  function removeLineItemFromDetail(lineId) {
    if (!state.invoiceDetail) return;
    state.invoiceDetail.lineItems = (state.invoiceDetail.lineItems || []).filter((item) => item.id !== lineId).sort((a, b) => {
      const posA = Number(a.position || 0);
      const posB = Number(b.position || 0);
      if (posA !== posB) return posA - posB;
      return String(a.created_at || '').localeCompare(String(b.created_at || ''));
    });
  }

  function insertDefaultLineIntoInvoice(defaultId) {
    if (!defaultId) return;
    if (!state.invoiceDetail || !state.invoiceDetail.invoice) {
      setStatus('Select an invoice before adding a default line.', 'warn');
      return;
    }
    if (invoiceIsLocked()) {
      setStatus('This invoice has been published and cannot be modified.', 'warn');
      return;
    }
    const def = state.invoiceDefaultMap[defaultId];
    if (!def) {
      setStatus('Default line not found', 'error');
      return;
    }
    openInvoiceLineForm('create', {
      line_date: state.invoiceDetail && state.invoiceDetail.invoice ? (state.invoiceDetail.invoice.invoice_date || todayIso()) : todayIso(),
      description: def.description || '',
      hours: def.hours != null && Number(def.hours) > 0 ? Number(def.hours) : '',
      amount: def.amount != null && def.amount !== '' ? def.amount : '',
      hour_type_id: def.hours != null && Number(def.hours) > 0 ? (def.hour_type_id || '') : '',
      contract_id: def.contract_id || '',
      source_default_id: def.id
    });
  }

  function handleInvoiceDefaultNew(event) {
    if (event) event.preventDefault();
    state.invoiceDefaultForm = {
      mode: 'create',
      editingId: null,
      draft: {
        default_label: '',
        description: '',
        hours: '',
        amount: '',
        hour_type_id: '',
        contract_id: ''
      },
      amountMode: getDefaultInvoiceAmountMode()
    };
    ensureInvoiceFormOptions();
    renderInvoiceDefaults();
  }

  function handleInvoiceDefaultCancel(event) {
    if (event) event.preventDefault();
    state.invoiceDefaultForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: getDefaultInvoiceAmountMode() };
    renderInvoiceDefaults();
  }

  function handleInvoiceDefaultSave(event) {
    if (event) event.preventDefault();
    if (!invoiceDefaultLabelInput) return;
    const label = invoiceDefaultLabelInput.value.trim();
    if (!label) {
      setStatus('Default label is required.', 'warn');
      return;
    }
    const description = invoiceDefaultDescriptionInput ? invoiceDefaultDescriptionInput.value : '';
    const amountMode = state.invoiceDefaultForm && state.invoiceDefaultForm.amountMode ? state.invoiceDefaultForm.amountMode : 'hours';
    const isMonthlyHourType = amountMode === 'monthly_hour_type';
    const isTemplate = amountMode === 'contract_template';
    const hoursValue = amountMode === 'hours' && invoiceDefaultHoursInput && invoiceDefaultHoursInput.value !== ''
      ? Number(invoiceDefaultHoursInput.value)
      : null;
    const amountValue = (amountMode === 'amount' || isTemplate) && invoiceDefaultAmountInput && invoiceDefaultAmountInput.value !== ''
      ? Number(invoiceDefaultAmountInput.value)
      : null;
    const hourTypeId = (amountMode === 'hours' || isMonthlyHourType) && invoiceDefaultHourTypeSelect ? invoiceDefaultHourTypeSelect.value : '';
    const hourTypeName = hourTypeId ? getHourTypeName(hourTypeId) : '';
    const contractId = invoiceDefaultContractSelect ? invoiceDefaultContractSelect.value : '';
    if (!contractId) {
      setStatus('Select a contract for this default line.', 'warn');
      return;
    }
    const contractName = contractId ? getContractName(contractId) : '';
    const contractRate = getContractRate(contractId);
    let resolvedHours = 0;
    let amount = null;
    if (amountMode === 'hours') {
      if (hoursValue == null || !Number.isFinite(hoursValue) || hoursValue <= 0) {
        setStatus('Enter hours to auto-calculate the amount.', 'warn');
        return;
      }
      if (!(contractRate > 0)) {
        setStatus('Contract rate missing. Enter an amount manually.', 'warn');
        return;
      }
      resolvedHours = Number(hoursValue);
      amount = Math.round(resolvedHours * contractRate * 100) / 100;
    } else if (isMonthlyHourType) {
      if (!hourTypeId) {
        setStatus('Select an hour type for monthly total calculation.', 'warn');
        return;
      }
      if (!(contractRate > 0)) {
        setStatus('Contract rate is required for monthly hour type calculation.', 'warn');
        return;
      }
      amount = 0;
      resolvedHours = 0;
    } else if (isTemplate) {
      if (amountValue == null || !Number.isFinite(amountValue) || amountValue < 0) {
        setStatus('Select a template to set the amount.', 'warn');
        return;
      }
      amount = Math.round(Number(amountValue) * 100) / 100;
      resolvedHours = 0;
    } else {
      if (amountValue == null || !Number.isFinite(amountValue) || amountValue <= 0) {
        setStatus('Enter a valid amount for this default.', 'warn');
        return;
      }
      amount = Math.round(Number(amountValue) * 100) / 100;
    }
    if (!isMonthlyHourType && !isTemplate && (amount == null || Number.isNaN(amount))) {
      setStatus('Enter a valid amount for this default.', 'warn');
      return;
    }
    const payload = {
      default_label: label,
      description: description,
      hours: amountMode === 'hours' ? resolvedHours : 0,
      amount: Number(amount),
      amount_mode: amountMode,
      hour_type_id: (amountMode === 'hours' || isMonthlyHourType) ? (hourTypeId || '') : '',
      hour_type_name_snapshot: (amountMode === 'hours' || isMonthlyHourType) ? hourTypeName : '',
      contract_id: contractId || '',
      contract_name_snapshot: contractName
    };
    const isEdit = state.invoiceDefaultForm.mode === 'edit' && state.invoiceDefaultForm.editingId;
    if (isEdit) payload.id = state.invoiceDefaultForm.editingId;
    const tempId = isEdit ? payload.id : generateTempId('invoice-default');
    const optimistic = Object.assign({}, payload, {
      id: tempId,
      hours: payload.hours === '' ? 0 : payload.hours,
      amount: payload.amount
    });
    if (!isEdit) {
      optimistic.position = state.invoiceDefaults.length + 1;
    }
    const previousDefaults = state.invoiceDefaults.slice();
    const previousDefaultForm = JSON.parse(JSON.stringify(state.invoiceDefaultForm));
    if (isEdit) {
      const idx = state.invoiceDefaults.findIndex((item) => item.id === payload.id);
      if (idx !== -1) state.invoiceDefaults[idx] = Object.assign({}, state.invoiceDefaults[idx], optimistic);
    } else {
      state.invoiceDefaults.push(optimistic);
    }
    state.invoiceDefaultMap[optimistic.id] = optimistic;
    state.invoiceDefaultForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: 'hours' };
    renderInvoiceDefaults();
    saveCache();
    setStatus('Saving default line...', 'warn');
    google.script.run
      .withSuccessHandler((saved) => {
        if (saved && saved.id) {
          state.invoiceDefaults = previousDefaults.filter((item) => item.id !== tempId && item.id !== saved.id).concat([saved]);
          state.invoiceDefaults.sort((a, b) => Number(a.position || 0) - Number(b.position || 0));
          state.invoiceDefaultMap = state.invoiceDefaults.reduce((acc, item) => {
            acc[item.id] = item;
            return acc;
          }, {});
          state.invoiceDefaultForm = { mode: 'hidden', editingId: null, draft: {}, amountMode: 'hours' };
          renderInvoiceDefaults();
          setStatus('Default saved', 'success');
          saveCache();
          loadInvoiceDefaults();
        } else {
          state.invoiceDefaults = previousDefaults;
          state.invoiceDefaultMap = previousDefaults.reduce((acc, item) => {
            acc[item.id] = item;
            return acc;
          }, {});
          state.invoiceDefaultForm = previousDefaultForm;
          renderInvoiceDefaults();
          setStatus('Failed to save default', 'error');
          saveCache();
        }
      })
      .withFailureHandler(() => {
        state.invoiceDefaults = previousDefaults;
        state.invoiceDefaults.sort((a, b) => Number(a.position || 0) - Number(b.position || 0));
        state.invoiceDefaultMap = previousDefaults.reduce((acc, item) => {
          acc[item.id] = item;
          return acc;
        }, {});
        state.invoiceDefaultForm = previousDefaultForm;
        renderInvoiceDefaults();
        setStatus('Failed to save default', 'error');
        saveCache();
      })
      .api_upsertInvoiceDefaultLineItem(payload);
  }

  function handleInvoiceDefaultAction(event) {
    const button = event.target instanceof HTMLElement ? event.target.closest('button[data-action]') : null;
    if (!button) return;
    const action = button.dataset.action;
    const id = button.dataset.id;
    if (!action || !id) return;
    if (action === 'edit-default') {
      const def = state.invoiceDefaultMap[id];
      if (!def) return;
      const amountMode = determineInvoiceDefaultAmountMode(def);
      const hoursDraft = amountMode === 'hours' && def.hours != null ? def.hours : '';
      const amountDraft = amountMode === 'amount' && def.amount != null ? def.amount : '';
      state.invoiceDefaultForm = {
        mode: 'edit',
        editingId: id,
        draft: {
          id: id,
          default_label: def.default_label || '',
          description: def.description || '',
          hours: hoursDraft,
          amount: amountDraft,
          hour_type_id: amountMode === 'hours' ? (def.hour_type_id || '') : '',
          contract_id: def.contract_id || ''
        },
        amountMode: amountMode
      };
      ensureInvoiceFormOptions();
      renderInvoiceDefaults();
    }
    if (action === 'insert-default') {
      insertDefaultLineIntoInvoice(id);
    }
    if (action === 'delete-default') {
      deleteInvoiceDefault(id);
    }
  }

  async function deleteInvoiceDefault(id) {
    const def = state.invoiceDefaultMap[id];
    if (!def) return;
    const confirmed = await customConfirm(`Delete the "${def.default_label || 'default'}" line?`, { danger: true, okText: 'Delete' });
    if (!confirmed) return;
    const previousDefaults = state.invoiceDefaults.slice();
    state.invoiceDefaults = state.invoiceDefaults.filter((item) => item.id !== id);
    delete state.invoiceDefaultMap[id];
    renderInvoiceDefaults();
    saveCache();
    setStatus('Deleting default...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success) {
          setStatus('Default deleted', 'success');
          saveCache();
        } else {
          state.invoiceDefaults = previousDefaults;
          state.invoiceDefaults.sort((a, b) => Number(a.position || 0) - Number(b.position || 0));
          state.invoiceDefaultMap = previousDefaults.reduce((acc, item) => {
            acc[item.id] = item;
            return acc;
          }, {});
          renderInvoiceDefaults();
          setStatus('Failed to delete default', 'error');
          saveCache();
        }
      })
      .withFailureHandler(() => {
        state.invoiceDefaults = previousDefaults;
        state.invoiceDefaults.sort((a, b) => Number(a.position || 0) - Number(b.position || 0));
        state.invoiceDefaultMap = previousDefaults.reduce((acc, item) => {
          acc[item.id] = item;
          return acc;
        }, {});
        renderInvoiceDefaults();
        setStatus('Failed to delete default', 'error');
        saveCache();
      })
      .api_deleteInvoiceDefaultLineItem(id);
  }

  function updateInvoiceSummaryAndRender() {
    recalculateInvoiceSummary();
    syncInvoiceSummaryToList();
    renderInvoiceDetail();
    renderBasInvoiceTable();
    saveCache();
  }

  function handleInvoiceAddLine(event) {
    if (event) event.preventDefault();
    if (invoiceIsLocked()) {
      setStatus('This invoice has been published and line items are locked.', 'warn');
      return;
    }
    openInvoiceLineForm('create', {});
  }

  // Custom confirm dialog replacement
  function customConfirm(message, options) {
    return new Promise((resolve) => {
      const opts = options || {};
      const title = opts.title || 'Confirm';
      const okText = opts.okText || 'OK';
      const cancelText = opts.cancelText || 'Cancel';
      const isDanger = opts.danger || false;

      const modal = document.getElementById('modal-confirm');
      const titleEl = document.getElementById('confirm-title');
      const messageEl = document.getElementById('confirm-message');
      const okBtn = document.getElementById('btn-confirm-ok');
      const cancelBtn = document.getElementById('btn-confirm-cancel');

      if (!modal || !titleEl || !messageEl || !okBtn || !cancelBtn) {
        // Fallback to native confirm if modal not found
        resolve(confirm(message));
        return;
      }

      titleEl.textContent = title;
      messageEl.textContent = message;
      okBtn.textContent = okText;
      cancelBtn.textContent = cancelText;

      // Apply danger styling if requested
      if (isDanger) {
        okBtn.className = 'danger';
      } else {
        okBtn.className = '';
      }

      const handleOk = () => {
        cleanup();
        resolve(true);
      };

      const handleCancel = () => {
        cleanup();
        resolve(false);
      };

      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          handleCancel();
        } else if (e.key === 'Enter' && !isDanger) {
          // Only allow Enter to confirm if not a danger action
          handleOk();
        }
      };

      const cleanup = () => {
        okBtn.removeEventListener('click', handleOk);
        cancelBtn.removeEventListener('click', handleCancel);
        document.removeEventListener('keydown', handleEscape);
        hideModal(modal);
      };

      okBtn.addEventListener('click', handleOk);
      cancelBtn.addEventListener('click', handleCancel);
      document.addEventListener('keydown', handleEscape);

      showModal(modal);
      // Focus the appropriate button
      if (isDanger) {
        cancelBtn.focus();
      } else {
        okBtn.focus();
      }
    });
  }

  // Custom alert dialog replacement
  function customAlert(message, options) {
    return new Promise((resolve) => {
      const opts = options || {};
      const title = opts.title || 'Notice';
      const okText = opts.okText || 'OK';

      const modal = document.getElementById('modal-alert');
      const titleEl = document.getElementById('alert-title');
      const messageEl = document.getElementById('alert-message');
      const okBtn = document.getElementById('btn-alert-ok');

      if (!modal || !titleEl || !messageEl || !okBtn) {
        // Fallback to native alert if modal not found
        alert(message);
        resolve();
        return;
      }

      titleEl.textContent = title;
      messageEl.textContent = message;
      okBtn.textContent = okText;

      const handleOk = () => {
        cleanup();
        resolve();
      };

      const handleEscape = (e) => {
        if (e.key === 'Escape' || e.key === 'Enter') {
          handleOk();
        }
      };

      const cleanup = () => {
        okBtn.removeEventListener('click', handleOk);
        document.removeEventListener('keydown', handleEscape);
        hideModal(modal);
      };

      okBtn.addEventListener('click', handleOk);
      document.addEventListener('keydown', handleEscape);

      showModal(modal);
      okBtn.focus();
    });
  }

  // BAS Detail Modal
  let currentBasPeriod = { fyYear: null, quarter: null, month: null };

  async function copyToClipboard(text, element) {
    try {
      await navigator.clipboard.writeText(text);
      // Visual feedback
      if (element) {
        element.classList.add('copied');
        setTimeout(() => {
          element.classList.remove('copied');
        }, 300);
      }
      return true;
    } catch (err) {
      console.error('Failed to copy:', err);
      return false;
    }
  }

  function openBasDetailModal(fyYear, quarter, month) {
    currentBasPeriod = { fyYear, quarter, month };

    const modal = document.getElementById('modal-bas-detail');
    const titleEl = document.getElementById('bas-detail-title');

    const monthRows = buildMonthlyBasRows(fyYear);
    let periodData;
    let periodLabel;

    if (quarter) {
      // Quarterly BAS
      const quarterlyRows = buildQuarterlyBasRows(monthRows);
      periodData = quarterlyRows[quarter - 1];
      periodLabel = ['Q1 (JulSep)', 'Q2 (OctDec)', 'Q3 (JanMar)', 'Q4 (AprJun)'][quarter - 1];
    } else if (month !== null && month !== undefined) {
      // Monthly BAS
      periodData = monthRows.find(r => r.month === month);
      const date = new Date(periodData.year, month, 1);
      periodLabel = MONTH_YEAR_FORMATTER.format(date);
    }

    if (!periodData) {
      customAlert('Unable to load BAS data for this period.');
      return;
    }

    // Calculate BAS fields
    const g1TotalSales = periodData.invoiceTotal;
    const field1aGstOnSales = periodData.invoiceGst;
    const field1bGstOnPurchases = periodData.companyExpensesGst;

    // Get PAYG rate from settings (default 2%)
    const paygRate = Number(state.settings.payg_instalment_rate || 2) / 100;

    // Calculate T1 based on sole trader flag
    const isSoleTrader = getFeatureFlag('is_sole_trader');
    const t1PaygIncome = isSoleTrader
      ? periodData.employeeGrossIncome // For sole traders: gross income minus expenses
      : periodData.companyIncome; // For companies: company income

    const t2InstalmentRate = paygRate * 100; // Convert back to percentage for display

    // Update modal title
    if (titleEl) {
      titleEl.textContent = `BAS Details - FY ${fyYear}-${String(fyYear + 1).slice(-2)} ${periodLabel}`;
    }

    // Update field values
    const g1El = document.getElementById('bas-g1-value');
    const field1aEl = document.getElementById('bas-1a-value');
    const field1bEl = document.getElementById('bas-1b-value');
    const t1El = document.getElementById('bas-t1-value');
    const t2El = document.getElementById('bas-t2-value');

    if (g1El) g1El.textContent = formatCurrency(g1TotalSales);
    if (field1aEl) field1aEl.textContent = formatCurrency(field1aGstOnSales);
    if (field1bEl) field1bEl.textContent = formatCurrency(field1bGstOnPurchases);
    if (t1El) t1El.textContent = formatCurrency(t1PaygIncome);
    if (t2El) t2El.textContent = t2InstalmentRate.toFixed(2) + '%';

    // Load submission status
    const submission = state.basSubmissions.find(s => {
      if (s.financial_year !== fyYear) return false;
      if (quarter) {
        return s.period_type === 'quarterly' && s.quarter === quarter;
      } else {
        return s.period_type === 'monthly' && s.month === month;
      }
    });
    const submittedToggle = document.getElementById('bas-submitted-toggle');
    if (submittedToggle) {
      submittedToggle.checked = submission ? submission.submitted : false;
    }

    // Attach click-to-copy handlers
    attachBasFieldCopyHandlers();

    showModal(modal);
  }

  function attachBasFieldCopyHandlers() {
    const fields = document.querySelectorAll('.bas-field-value[data-field]');
    fields.forEach(field => {
      const handler = async () => {
        // Extract numeric value (remove $ and ,)
        const text = field.textContent.replace(/[$,]/g, '').trim();
        const success = await copyToClipboard(text, field);
        if (success) {
          // Optional: show a toast notification
          setStatus('Copied to clipboard', 'success');
        }
      };
      // Remove existing listeners to avoid duplicates
      field.replaceWith(field.cloneNode(true));
    });
    // Re-query and attach
    document.querySelectorAll('.bas-field-value[data-field]').forEach(field => {
      field.addEventListener('click', async () => {
        const text = field.textContent.replace(/[$,]/g, '').trim();
        const success = await copyToClipboard(text, field);
        if (success) {
          setStatus('Copied to clipboard', 'success');
        }
      });
    });
  }

  // BAS Detail Modal - Close and Save handlers
  const basDetailCloseBtn = document.getElementById('btn-bas-detail-close');
  const basDetailSaveBtn = document.getElementById('btn-bas-detail-save');

  if (basDetailCloseBtn) {
    basDetailCloseBtn.addEventListener('click', () => {
      const modal = document.getElementById('modal-bas-detail');
      hideModal(modal);
    });
  }

  if (basDetailSaveBtn) {
    basDetailSaveBtn.addEventListener('click', async () => {
      const submittedToggle = document.getElementById('bas-submitted-toggle');
      const submitted = submittedToggle ? submittedToggle.checked : false;

      const { fyYear, quarter, month } = currentBasPeriod;
      if (!fyYear) return;
      if (!quarter && (month === null || month === undefined)) return;

      // Calculate all fields
      const monthRows = buildMonthlyBasRows(fyYear);
      let periodData;

      if (quarter) {
        const quarterlyRows = buildQuarterlyBasRows(monthRows);
        periodData = quarterlyRows[quarter - 1];
      } else {
        periodData = monthRows.find(r => r.month === month);
      }

      if (!periodData) return;

      const paygRate = Number(state.settings.payg_instalment_rate || 2) / 100;
      const isSoleTrader = getFeatureFlag('is_sole_trader');

      const basData = {
        financial_year: fyYear,
        period_type: quarter ? 'quarterly' : 'monthly',
        quarter: quarter || null,
        month: month !== null && month !== undefined ? month : null,
        g1_total_sales: periodData.invoiceTotal,
        g1_includes_gst: true,
        field_1a_gst_on_sales: periodData.invoiceGst,
        field_1b_gst_on_purchases: periodData.companyExpensesGst,
        t1_payg_income: isSoleTrader ? periodData.employeeGrossIncome : periodData.companyIncome,
        t2_instalment_rate: paygRate,
        submitted: submitted
      };

      // Save to backend
      setStatus('Saving BAS submission...', 'warn');
      basDetailSaveBtn.disabled = true;
      basDetailSaveBtn.textContent = 'Saving...';

      google.script.run
        .withSuccessHandler((savedSubmission) => {
          // Update local state
          const index = state.basSubmissions.findIndex(s => {
            if (s.financial_year !== fyYear) return false;
            if (quarter) {
              return s.period_type === 'quarterly' && s.quarter === quarter;
            } else {
              return s.period_type === 'monthly' && s.month === month;
            }
          });
          if (index >= 0) {
            state.basSubmissions[index] = savedSubmission;
          } else {
            state.basSubmissions.push(savedSubmission);
          }
          saveCache();

          // Close modal and refresh BAS report
          const modal = document.getElementById('modal-bas-detail');
          hideModal(modal);
          renderBasReporting();
          setStatus('BAS submission saved', 'success');
          basDetailSaveBtn.disabled = false;
          basDetailSaveBtn.textContent = 'Save';
        })
        .withFailureHandler((error) => {
          console.error('Failed to save BAS submission:', error);
          customAlert('Failed to save BAS submission: ' + error.message, { title: 'Error' });
          basDetailSaveBtn.disabled = false;
          basDetailSaveBtn.textContent = 'Save';
          setStatus('Failed to save', 'error');
        })
        .api_upsertBasSubmission(basData);
    });
  }

  function getCurrentFormData(type) {
    if (type === 'basic') {
      const hours = Number(manualHoursInput ? manualHoursInput.value : '');
      return {
        duration_minutes: Math.round(hours * 60)
      };
    } else if (type === 'advanced') {
      const draft = state.punchDraft;
      if (!draft || !draft.punches) return { punches: [] };
      return {
        punches: draft.punches.filter(p => p.in && p.out) // Only include closed punches
      };
    }
    return null;
  }

  function applyDefaultToForm(defaultData, type) {
    const hourTypeId = defaultData.hour_type_id ? String(defaultData.hour_type_id) : '';
    const canApplyHourType = hourTypeId && getFeatureFlag('hour_types') && state.hourTypeMap[hourTypeId];

    if (type === 'basic') {
      const hours = (defaultData.duration_minutes || 0) / 60;
      if (manualHoursInput) manualHoursInput.value = hours > 0 ? hours.toString() : '';
      if (canApplyHourType && manualHourType) {
        manualHourType.value = hourTypeId;
        updateManualContractVisibility();
      }
      updateBasicSaveEnabled();
    } else if (type === 'advanced') {
      // Apply punches to advanced form
      ensurePunchDraft();
      if (state.punchDraft) {
        // Clone so edits to the entry don't mutate the saved default
        state.punchDraft.punches = clonePunches(defaultData.punches || []);
        setPunchDraftDirty();
        renderPunchDraft();
        updatePunchSummary();
      }
      if (canApplyHourType && punchHourType) {
        punchHourType.value = hourTypeId;
        updatePunchContractVisibility();
      }
    }
  }

  function handleCreateDefault(type) {
    const formData = getCurrentFormData(type);
    if (!formData) {
      setStatus('Please enter some time data first', 'warn');
      return;
    }

    if (type === 'basic' && (!formData.duration_minutes || formData.duration_minutes <= 0)) {
      setStatus('Please enter a valid number of hours', 'warn');
      return;
    }

    if (type === 'advanced' && (!formData.punches || formData.punches.length === 0)) {
      setStatus('Please add some punch times first', 'warn');
      return;
    }

    state_defaults.currentDefaultType = type;
    state_defaults.currentFormData = formData;

    const nameInput = document.getElementById('default-name');
    if (nameInput) nameInput.value = '';
    if (defaultHourTypeSelect) {
      const currentHourTypeId = type === 'basic'
        ? (manualHourType ? manualHourType.value : '')
        : (punchHourType ? punchHourType.value : '');
      if (state.hourTypes.length && getFeatureFlag('hour_types')) {
        populateDefaultHourTypeOptions(defaultHourTypeSelect, currentHourTypeId || '');
      } else {
        defaultHourTypeSelect.value = '';
      }
    }
    if (defaultHourTypeRow) {
      const hourTypesEnabled = !!(state.featureFlags.hour_types && state.featureFlags.hour_types.enabled && state.hourTypes.length > 0);
      defaultHourTypeRow.style.display = hourTypesEnabled ? 'block' : 'none';
    }
    showModal(createDefaultModal);
    if (nameInput) nameInput.focus();
  }

  function handleEnterDefault(type) {
    const defaults = state_defaults.entryDefaults[type] || [];

    if (defaults.length === 0) {
      setStatus('No defaults available', 'warn');
      return;
    }

    if (defaults.length === 1) {
      // Single default - apply directly and submit
      applyDefaultToForm(defaults[0], type);

      // Trigger the appropriate save handler
      setTimeout(() => {
        if (type === 'basic' && manualSaveBtn) {
          manualSaveBtn.click();
        } else if (type === 'advanced' && punchSaveBtn) {
          punchSaveBtn.click();
        }
      }, 100);
    } else {
      // Multiple defaults - show selection modal
      state_defaults.currentDefaultType = type;
      renderDefaultSelection(defaults);
      showModal(selectDefaultModal);
    }
  }

  function renderDefaultSelection(defaults) {
    const listEl = document.getElementById('default-selection-list');
    if (!listEl) return;

    listEl.innerHTML = '';
    defaults.forEach((defaultData, index) => {
      const item = document.createElement('div');
      item.className = 'ts-default-item';
      item.style.cssText = 'padding: 12px; margin: 8px 0; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; transition: background-color 0.2s;';

      const title = document.createElement('div');
      title.style.fontWeight = 'bold';
      title.textContent = defaultData.name;

      const details = document.createElement('div');
      details.style.fontSize = '0.9em';
      details.style.color = 'var(--text-secondary)';
      details.style.marginTop = '4px';

      if (state_defaults.currentDefaultType === 'basic') {
        const hours = (defaultData.duration_minutes || 0) / 60;
        details.textContent = `${hours} hours`;
      } else {
        const punchCount = (defaultData.punches || []).length;
        details.textContent = `${punchCount} punch ${punchCount === 1 ? 'range' : 'ranges'}`;
      }

      item.appendChild(title);
      item.appendChild(details);

      item.addEventListener('click', () => {
        applyDefaultToForm(defaultData, state_defaults.currentDefaultType);
        hideModal(selectDefaultModal);

        // Trigger the appropriate save handler
        setTimeout(() => {
          if (state_defaults.currentDefaultType === 'basic' && manualSaveBtn) {
            manualSaveBtn.click();
          } else if (state_defaults.currentDefaultType === 'advanced' && punchSaveBtn) {
            punchSaveBtn.click();
          }
        }, 100);
      });

      item.addEventListener('mouseenter', () => {
        item.style.backgroundColor = 'var(--hover-bg)';
      });

      item.addEventListener('mouseleave', () => {
        item.style.backgroundColor = '';
      });

      listEl.appendChild(item);
    });
  }

  function handleEditDefaults(type) {
    state_defaults.currentDefaultType = type;
    renderEditDefaultsList();
    showModal(editDefaultsModal);
  }

  function renderEditDefaultsList() {
    const listEl = document.getElementById('edit-defaults-list');
    if (!listEl) return;

    const defaults = state_defaults.entryDefaults[state_defaults.currentDefaultType] || [];

    listEl.innerHTML = '';

    if (defaults.length === 0) {
      listEl.innerHTML = '<div class="ts-note">No defaults created yet.</div>';
      return;
    }

    defaults.forEach((defaultData, index) => {
      const item = document.createElement('div');
      item.className = 'ts-edit-default-item';
      item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px; margin: 8px 0; border: 1px solid var(--border-color); border-radius: 4px;';

      const content = document.createElement('div');
      content.style.flex = '1';
      content.style.cursor = 'pointer';

      const title = document.createElement('div');
      title.style.fontWeight = 'bold';
      title.textContent = defaultData.name;

      const details = document.createElement('div');
      details.style.fontSize = '0.9em';
      details.style.color = 'var(--text-secondary)';
      details.style.marginTop = '4px';

      if (state_defaults.currentDefaultType === 'basic') {
        const hours = (defaultData.duration_minutes || 0) / 60;
        details.textContent = `${hours} hours`;
      } else {
        const punchCount = (defaultData.punches || []).length;
        details.textContent = `${punchCount} punch ${punchCount === 1 ? 'range' : 'ranges'}`;
      }

      content.appendChild(title);
      content.appendChild(details);

      content.addEventListener('click', () => {
        openEditDefaultDetails(defaultData);
      });

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.className = 'ghost';
      deleteBtn.style.marginLeft = '12px';
      deleteBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const confirmed = await customConfirm(`Delete the "${defaultData.name}" default?`, { danger: true });
        if (confirmed) {
          deleteEntryDefault(defaultData.name, deleteBtn);
        }
      });

      item.appendChild(content);
      item.appendChild(deleteBtn);
      listEl.appendChild(item);
    });
  }

  function openEditDefaultDetails(defaultData) {
    state_defaults.editingDefaultName = defaultData.name;

    const nameInput = document.getElementById('edit-default-name');
    if (nameInput) nameInput.value = defaultData.name;

    const formEl = document.getElementById('edit-default-form');
    if (!formEl) return;

    formEl.innerHTML = '';

    if (state_defaults.currentDefaultType === 'basic') {
      const hours = (defaultData.duration_minutes || 0) / 60;

      formEl.innerHTML = `
        <div class="ts-row">
          <div class="ts-col">
            <label>Total hours</label>
            <input type="number" id="edit-default-hours" min="0" step="0.01" value="${hours}" />
          </div>
        </div>
      `;
    } else {
      const punchesHtml = (defaultData.punches || []).map((punch, i) => `
        <div class="ts-row" style="margin-top: 8px;">
          <div class="ts-col">
            <label>Punch ${i + 1} In</label>
            <input type="time" id="edit-punch-${i}-in" value="${punch.in || ''}" />
          </div>
          <div class="ts-col">
            <label>Punch ${i + 1} Out</label>
            <input type="time" id="edit-punch-${i}-out" value="${punch.out || ''}" />
          </div>
          <div class="ts-col" style="display:flex; align-items:flex-end;">
            <button type="button" class="ghost" onclick="removePunchRow(${i})">Remove</button>
          </div>
        </div>
      `).join('');

      formEl.innerHTML = `
        <div id="edit-punch-rows">
          ${punchesHtml}
        </div>
        <div style="margin-top: 12px;">
          <button type="button" class="ghost" onclick="addEditPunchRow()">Add Punch Range</button>
        </div>
      `;
    }

    if (editDefaultHourTypeSelect) {
      const hourTypesEnabled = !!(getFeatureFlag('hour_types') && state.hourTypes.length > 0);
      if (hourTypesEnabled) {
        populateDefaultHourTypeOptions(editDefaultHourTypeSelect, defaultData.hour_type_id || '');
        if (editDefaultHourTypeRow) editDefaultHourTypeRow.style.display = 'block';
      } else {
        editDefaultHourTypeSelect.value = '';
        if (editDefaultHourTypeRow) editDefaultHourTypeRow.style.display = 'none';
      }
    }

    if (editDefaultDetailsModal) {
      const wasListVisible = editDefaultsModal && editDefaultsModal.style.display !== 'none';
      editDefaultDetailsModal.dataset.returnToList = wasListVisible ? 'true' : 'false';
    }
    hideModal(editDefaultsModal);
    showModal(editDefaultDetailsModal);
  }

  // Global functions for punch editing (needed for onclick handlers)
  window.addEditPunchRow = function() {
    const container = document.getElementById('edit-punch-rows');
    if (!container) return;

    const existingRows = container.children.length;
    const newRow = document.createElement('div');
    newRow.className = 'ts-row';
    newRow.style.marginTop = '8px';
    newRow.innerHTML = `
      <div class="ts-col">
        <label>Punch ${existingRows + 1} In</label>
        <input type="time" id="edit-punch-${existingRows}-in" />
      </div>
      <div class="ts-col">
        <label>Punch ${existingRows + 1} Out</label>
        <input type="time" id="edit-punch-${existingRows}-out" />
      </div>
      <div class="ts-col" style="display:flex; align-items:flex-end;">
        <button type="button" class="ghost" onclick="removePunchRow(${existingRows})">Remove</button>
      </div>
    `;
    container.appendChild(newRow);
  };

  window.removePunchRow = function(index) {
    const container = document.getElementById('edit-punch-rows');
    if (!container || container.children.length <= 1) return;

    if (container.children[index]) {
      container.removeChild(container.children[index]);

      // Update labels and IDs
      Array.from(container.children).forEach((row, i) => {
        const labels = row.querySelectorAll('label');
        const inputs = row.querySelectorAll('input');
        const button = row.querySelector('button');

        if (labels[0]) labels[0].textContent = `Punch ${i + 1} In`;
        if (labels[1]) labels[1].textContent = `Punch ${i + 1} Out`;
        if (inputs[0]) inputs[0].id = `edit-punch-${i}-in`;
        if (inputs[1]) inputs[1].id = `edit-punch-${i}-out`;
        if (button) button.setAttribute('onclick', `removePunchRow(${i})`);
      });
    }
  };

  function saveDefaultFromModal() {
    const nameInput = document.getElementById('default-name');
    const name = nameInput ? nameInput.value.trim() : '';
    const saveBtn = document.getElementById('btn-save-default');

    if (!name) {
      setStatus('Please enter a name for the default', 'warn');
      return;
    }

    const type = state_defaults.currentDefaultType;
    const formData = state_defaults.currentFormData;

    if (!type || !formData) {
      setStatus('Invalid default data', 'error');
      return;
    }

    const hourTypeId = defaultHourTypeSelect ? defaultHourTypeSelect.value : '';
    const payload = { ...formData, hour_type_id: hourTypeId };

    const previousDefaults = JSON.parse(JSON.stringify(state_defaults.entryDefaults || { basic: [], advanced: [] }));
    const optimisticDefault = {
      name,
      hour_type_id: hourTypeId || ''
    };
    if (type === 'basic') {
      optimisticDefault.duration_minutes = payload.duration_minutes || 0;
    } else {
      optimisticDefault.punches = (payload.punches || []).map((punch) => ({ in: punch.in, out: punch.out }));
    }

    const optimisticState = JSON.parse(JSON.stringify(state_defaults.entryDefaults || { basic: [], advanced: [] }));
    if (!Array.isArray(optimisticState[type])) optimisticState[type] = [];
    optimisticState[type].push(optimisticDefault);
    state_defaults.entryDefaults = optimisticState;

    updateDefaultButtonsVisibility();
    renderEditDefaultsList();
    hideCalendarContextMenu();
    hideModal(createDefaultModal);

    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }
    setStatus('Saving default...', 'warn');

    const revertCreate = () => {
      state_defaults.entryDefaults = previousDefaults;
      updateDefaultButtonsVisibility();
      renderEditDefaultsList();
    };

    const restoreCreateModal = () => {
      if (!createDefaultModal) return;
      showModal(createDefaultModal);
      if (nameInput) nameInput.value = name;
      if (defaultHourTypeSelect) defaultHourTypeSelect.value = hourTypeId || '';
    };

    google.script.run
      .withSuccessHandler((result) => {
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Default';
        }

        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          renderEditDefaultsList();
          setStatus(`Default "${name}" created`, 'success');
        } else {
          revertCreate();
          setStatus('Failed to create default', 'error');
          restoreCreateModal();
        }
      })
      .withFailureHandler((error) => {
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Default';
        }
        revertCreate();
        setStatus('Failed to create default: ' + error.message, 'error');
        restoreCreateModal();
      })
      .api_saveEntryDefault(type, name, payload);
  }

  function saveDefaultDetails() {
    const nameInput = document.getElementById('edit-default-name');
    const newName = nameInput ? nameInput.value.trim() : '';

    if (!newName) {
      setStatus('Please enter a name for the default', 'warn');
      return;
    }

    const type = state_defaults.currentDefaultType;
    const oldName = state_defaults.editingDefaultName;

    let formData;
    if (type === 'basic') {
      const hoursInput = document.getElementById('edit-default-hours');
      const hours = Number(hoursInput ? hoursInput.value : '');

      if (!Number.isFinite(hours) || hours <= 0) {
        setStatus('Please enter valid hours', 'warn');
        return;
      }

      formData = {
        duration_minutes: Math.round(hours * 60)
      };
    } else {
      const container = document.getElementById('edit-punch-rows');
      if (!container) return;

      const punches = [];
      Array.from(container.children).forEach((row, i) => {
        const inInput = document.getElementById(`edit-punch-${i}-in`);
        const outInput = document.getElementById(`edit-punch-${i}-out`);
        const inTime = inInput ? inInput.value : '';
        const outTime = outInput ? outInput.value : '';

        if (inTime && outTime) {
          punches.push({ in: inTime, out: outTime });
        }
      });

      if (punches.length === 0) {
        setStatus('Please add at least one complete punch range', 'warn');
        return;
      }

      formData = { punches };
    }

    const hourTypeId = editDefaultHourTypeSelect ? editDefaultHourTypeSelect.value : '';
    formData.hour_type_id = hourTypeId;

    const previousDefaults = JSON.parse(JSON.stringify(state_defaults.entryDefaults || { basic: [], advanced: [] }));
    const listForType = state_defaults.entryDefaults[type] || [];
    const existingIndex = listForType.findIndex((d) => d && d.name === oldName);
    if (existingIndex === -1) {
      setStatus('Default not found.', 'error');
      return;
    }

    const optimisticDefault = {
      name: newName,
      hour_type_id: hourTypeId || ''
    };
    if (type === 'basic') {
      optimisticDefault.duration_minutes = formData.duration_minutes || 0;
    } else {
      optimisticDefault.punches = (formData.punches || []).slice();
    }

    const optimisticState = JSON.parse(JSON.stringify(state_defaults.entryDefaults || { basic: [], advanced: [] }));
    optimisticState[type][existingIndex] = optimisticDefault;
    state_defaults.entryDefaults = optimisticState;
    state_defaults.editingDefaultName = newName;

    renderEditDefaultsList();
    updateDefaultButtonsVisibility();
    const shouldRestoreEditList = editDefaultDetailsModal && editDefaultDetailsModal.dataset.returnToList === 'true';
    hideModal(editDefaultDetailsModal);
    if (editDefaultDetailsModal) editDefaultDetailsModal.dataset.returnToList = 'false';
    if (shouldRestoreEditList && editDefaultsModal) showModal(editDefaultsModal);
    hideCalendarContextMenu();
    setStatus('Updating default...', 'warn');

    const reopenEditModal = () => {
      if (previousDefaults[type] && previousDefaults[type][existingIndex]) {
        openEditDefaultDetails(previousDefaults[type][existingIndex]);
      }
    };

    const revertOptimisticUpdate = () => {
      state_defaults.entryDefaults = previousDefaults;
      updateDefaultButtonsVisibility();
      renderEditDefaultsList();
    };

    google.script.run
      .withSuccessHandler((result) => {
        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          renderEditDefaultsList();
          setStatus(`Default "${newName}" updated`, 'success');
        } else {
          revertOptimisticUpdate();
          setStatus('Failed to update default', 'error');
          reopenEditModal();
        }
      })
      .withFailureHandler((error) => {
        revertOptimisticUpdate();
        setStatus('Failed to update default: ' + error.message, 'error');
        reopenEditModal();
      })
      .api_updateEntryDefault(type, oldName, newName, formData);
  }

  function deleteEntryDefault(name, deleteBtn) {
    const type = state_defaults.currentDefaultType;

    const previousDefaults = JSON.parse(JSON.stringify(state_defaults.entryDefaults || { basic: [], advanced: [] }));
    const optimisticState = JSON.parse(JSON.stringify(state_defaults.entryDefaults || { basic: [], advanced: [] }));
    optimisticState[type] = (optimisticState[type] || []).filter((d) => d && d.name !== name);
    state_defaults.entryDefaults = optimisticState;

    updateDefaultButtonsVisibility();
    renderEditDefaultsList();
    hideCalendarContextMenu();

    if (deleteBtn) {
      deleteBtn.disabled = true;
      deleteBtn.textContent = 'Deleting...';
    }
    setStatus('Deleting default...', 'warn');

    const revertDelete = () => {
      state_defaults.entryDefaults = previousDefaults;
      updateDefaultButtonsVisibility();
      renderEditDefaultsList();
    };

    google.script.run
      .withSuccessHandler((result) => {
        if (deleteBtn) {
          deleteBtn.disabled = false;
          deleteBtn.textContent = 'Delete';
        }

        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          renderEditDefaultsList();
          setStatus(`Default "${name}" deleted`, 'success');
        } else {
          revertDelete();
          setStatus('Failed to delete default', 'error');
        }
      })
      .withFailureHandler((error) => {
        if (deleteBtn) {
          deleteBtn.disabled = false;
          deleteBtn.textContent = 'Delete';
        }
        revertDelete();
        setStatus('Failed to delete default: ' + error.message, 'error');
      })
      .api_deleteEntryDefault(type, name);
  }

  function renderCalendarContextList(listEl, defaults, type) {
    if (!listEl) return;
    listEl.innerHTML = '';
    if (!Array.isArray(defaults) || !defaults.length) return;

    defaults.forEach((defaultData) => {
      const item = document.createElement('button');
      item.type = 'button';
      item.className = 'ts-calendar-context-item';
      item.textContent = defaultData.name || '(untitled)';
      item.addEventListener('click', () => handleCalendarDefaultSelection(type, defaultData));
      listEl.appendChild(item);
    });
  }

  function renderCalendarContextMenuSections() {
    if (!calendarContextMenu) return;
    const defaults = state_defaults.entryDefaults || { basic: [], advanced: [] };
    const basicDefaults = Array.isArray(defaults.basic) ? defaults.basic : [];
    const advancedDefaults = Array.isArray(defaults.advanced) ? defaults.advanced : [];

    renderCalendarContextList(calendarContextBasicList, basicDefaults, 'basic');
    renderCalendarContextList(calendarContextAdvancedList, advancedDefaults, 'advanced');

    const hasBasic = basicDefaults.length > 0;
    const hasAdvanced = advancedDefaults.length > 0;

    if (calendarContextBasicSection) {
      calendarContextBasicSection.style.display = hasBasic ? 'block' : 'none';
    }
    if (calendarContextAdvancedSection) {
      calendarContextAdvancedSection.style.display = hasAdvanced ? 'block' : 'none';
    }
    if (calendarContextEmptyState) {
      const shouldShowEmpty = !hasBasic && !hasAdvanced;
      calendarContextEmptyState.style.display = shouldShowEmpty ? 'block' : 'none';
    }
  }

  function positionCalendarContextMenu(x, y) {
    if (!calendarContextMenu) return;
    calendarContextMenu.style.display = 'block';
    calendarContextMenu.style.left = '0px';
    calendarContextMenu.style.top = '0px';
    const rect = calendarContextMenu.getBoundingClientRect();
    const padding = 8;
    let left = x;
    let top = y;
    if (left + rect.width > window.innerWidth - padding) {
      left = window.innerWidth - rect.width - padding;
    }
    if (top + rect.height > window.innerHeight - padding) {
      top = window.innerHeight - rect.height - padding;
    }
    left = Math.max(padding, left);
    top = Math.max(padding, top);
    calendarContextMenu.style.left = left + 'px';
    calendarContextMenu.style.top = top + 'px';
  }

  function hideCalendarContextMenu() {
    if (!calendarContextMenu) return;
    calendarContextMenu.style.display = 'none';
    calendarContextMenuDate = null;
  }

  function handleCalendarContextMenu(event) {
    if (!calendarContextMenu || !calendarGridEl) return;
    const featureEnabled = state.featureFlags.default_inputs && state.featureFlags.default_inputs.enabled;
    if (!featureEnabled) return;
    const cell = event.target.closest('.ts-calendar-cell');
    if (!cell || !cell.dataset.date) return;
    ensureCalendarState();
    event.preventDefault();
    calendarContextMenuDate = cell.dataset.date;
    renderCalendarContextMenuSections();
    positionCalendarContextMenu(event.clientX, event.clientY);
  }

  function handleCalendarDefaultSelection(type, defaultData) {
    if (!calendarContextMenuDate || !defaultData) return;
    const targetDate = calendarContextMenuDate;
    hideCalendarContextMenu();
    insertDefaultEntryForDate(targetDate, defaultData, type);
  }

  function insertDefaultEntryForDate(dateIso, defaultData, type) {
    if (!dateIso || !defaultData) return;
    withEntryFocusSuppressed(() => {
      ensureCalendarState();
      state.selectedCalendarDate = dateIso;
      renderCalendar();

      if (type === 'basic') {
        if (state.editingEntryId) clearManualEditing();
        setManualDate(dateIso);
        applyDefaultToForm(defaultData, 'basic');
        if (!manualSaveBtn) {
          setStatus('Manual entry form is unavailable.', 'error');
          return;
        }
        if (!manualSaveBtn.disabled) {
          manualSaveBtn.click();
        } else {
          setStatus('Select a contract before applying this default.', 'warn');
        }
      } else {
        setPunchDate(dateIso);
        ensurePunchDraft();
        applyDefaultToForm(defaultData, 'advanced');
        if (!punchSaveBtn) {
          setStatus('Advanced entry form is unavailable.', 'error');
          return;
        }
        if (!punchSaveBtn.disabled) {
          punchSaveBtn.click();
        } else {
          setStatus('Select a contract before applying this default.', 'warn');
        }
      }
    });
  }

  if (calendarGridEl) {
    calendarGridEl.addEventListener('contextmenu', handleCalendarContextMenu);
  }
  if (calendarContextMenu) {
    calendarContextMenu.addEventListener('contextmenu', (event) => event.preventDefault());
  }
  document.addEventListener('click', (event) => {
    if (!calendarContextMenu || calendarContextMenu.style.display !== 'block') return;
    if (calendarContextMenu.contains(event.target)) return;
    hideCalendarContextMenu();
  });
  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') hideCalendarContextMenu();
  });
  window.addEventListener('resize', hideCalendarContextMenu);
  window.addEventListener('scroll', hideCalendarContextMenu, true);

  // Event handlers for default entry buttons
  if (createManualDefaultBtn) {
    createManualDefaultBtn.addEventListener('click', () => handleCreateDefault('basic'));
  }

  if (enterManualDefaultBtn) {
    enterManualDefaultBtn.addEventListener('click', () => handleEnterDefault('basic'));
  }

  if (editManualDefaultsBtn) {
    editManualDefaultsBtn.addEventListener('click', () => handleEditDefaults('basic'));
  }

  if (createPunchDefaultBtn) {
    createPunchDefaultBtn.addEventListener('click', () => handleCreateDefault('advanced'));
  }

  if (enterPunchDefaultBtn) {
    enterPunchDefaultBtn.addEventListener('click', () => handleEnterDefault('advanced'));
  }

  if (editPunchDefaultsBtn) {
    editPunchDefaultsBtn.addEventListener('click', () => handleEditDefaults('advanced'));
  }

  // Modal event handlers
  function setupModalHandlers() {
    // Close buttons
    document.querySelectorAll('.ts-modal-close').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const modal = e.target.closest('.ts-modal');
        if (modal === deductionFormModal) {
          closeDeductionForm();
        } else if (modal === actualIncomeModal) {
          closeActualIncomeModal();
        } else if (modal === printViewConfigModal) {
          closePrintViewConfigModal();
        } else if (modal === recurringModal) {
          closeRecurringModal();
        } else if (modal === bulkModal) {
          closeBulkModal();
        } else {
          hideModal(modal);
        }
      });
    });

    // Click outside to close
    document.querySelectorAll('.ts-modal').forEach(modal => {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          if (modal === deductionFormModal) {
            closeDeductionForm();
          } else if (modal === actualIncomeModal) {
            closeActualIncomeModal();
          } else if (modal === printViewConfigModal) {
            closePrintViewConfigModal();
          } else if (modal === recurringModal) {
            closeRecurringModal();
          } else if (modal === bulkModal) {
            closeBulkModal();
          } else {
            hideModal(modal);
          }
        }
      });
    });

    // Specific button handlers
    const cancelCreateBtn = document.getElementById('btn-cancel-create-default');
    if (cancelCreateBtn) {
      cancelCreateBtn.addEventListener('click', () => hideModal(createDefaultModal));
    }

    const closeXeroHelperBtn = document.getElementById('btn-close-xero-helper');
    if (closeXeroHelperBtn && xeroHelperModal) {
      closeXeroHelperBtn.addEventListener('click', () => hideModal(xeroHelperModal));
    }

    const closeMyobHelperBtn = document.getElementById('btn-close-myob-helper');
    if (closeMyobHelperBtn && myobHelperModal) {
      closeMyobHelperBtn.addEventListener('click', () => hideModal(myobHelperModal));
    }

    if (btnCloseMonthlyDeductions && modalMonthlyDeductions) {
      btnCloseMonthlyDeductions.addEventListener('click', () => hideModal(modalMonthlyDeductions));
    }

    if (btnCompanyExpensesDetails) {
      btnCompanyExpensesDetails.addEventListener('click', () => showMonthlyDeductionsModal('company'));
    }

    if (btnDeductionsDetails) {
      btnDeductionsDetails.addEventListener('click', () => showMonthlyDeductionsModal('personal'));
    }

    if (btnCancelAdjust && modalAdjustOccurrence) {
      btnCancelAdjust.addEventListener('click', () => hideModal(modalAdjustOccurrence));
    }

    if (btnSaveException) {
      btnSaveException.addEventListener('click', handleSaveException);
    }

    if (btnDeleteException) {
      btnDeleteException.addEventListener('click', handleDeleteException);
    }

    const saveDefaultBtn = document.getElementById('btn-save-default');
    if (saveDefaultBtn) {
      saveDefaultBtn.addEventListener('click', saveDefaultFromModal);
    }

    const cancelSelectBtn = document.getElementById('btn-cancel-select-default');
    if (cancelSelectBtn) {
      cancelSelectBtn.addEventListener('click', () => hideModal(selectDefaultModal));
    }

    const closeEditBtn = document.getElementById('btn-close-edit-defaults');
    if (closeEditBtn) {
      closeEditBtn.addEventListener('click', () => hideModal(editDefaultsModal));
    }

    const cancelEditDetailsBtn = document.getElementById('btn-cancel-edit-default-details');
    if (cancelEditDetailsBtn) {
      cancelEditDetailsBtn.addEventListener('click', () => {
        hideModal(editDefaultDetailsModal);
        if (editDefaultDetailsModal) editDefaultDetailsModal.dataset.returnToList = 'false';
        if (editDefaultsModal) showModal(editDefaultsModal);
      });
    }

    const saveDetailsBtn = document.getElementById('btn-save-default-details');
    if (saveDetailsBtn) {
      saveDetailsBtn.addEventListener('click', saveDefaultDetails);
    }

    // Enter key handlers
    const defaultNameInput = document.getElementById('default-name');
    if (defaultNameInput) {
      defaultNameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          saveDefaultFromModal();
        }
      });
    }
  }

  // Recurring entry management
  function renderRecurringEntriesList() {
    if (!recurringList) return;
    recurringList.innerHTML = '';
    const entries = (state.recurringTimeEntries || []).slice().sort((a, b) => {
      const aDate = a && a.start_date ? a.start_date : '';
      const bDate = b && b.start_date ? b.start_date : '';
      if (aDate && bDate && aDate !== bDate) {
        return aDate.localeCompare(bDate);
      }
      const aName = (a && a.label) ? a.label.toLowerCase() : '';
      const bName = (b && b.label) ? b.label.toLowerCase() : '';
      return aName.localeCompare(bName);
    });
    if (recurringEmpty) recurringEmpty.style.display = entries.length ? 'none' : 'block';
    entries.forEach((entry) => {
      const sanitized = sanitizeRecurringEntry(entry);
      if (!sanitized) return;
      const card = document.createElement('div');
      card.className = 'ts-card recurring-entry-card';
      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      const title = document.createElement('strong');
      title.textContent = sanitized.label || 'Untitled schedule';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'ghost';
      editBtn.textContent = 'Edit';
      editBtn.addEventListener('click', () => {
        setRecurringFormDraft(sanitized);
      });
      header.appendChild(title);
      header.appendChild(editBtn);
      const summary = document.createElement('p');
      summary.className = 'ts-note';
      summary.textContent = describeRecurringEntry(sanitized);
      const meta = document.createElement('p');
      meta.className = 'ts-note';
      const hoursText = sanitized.distribution_mode === 'monthly'
        ? `${formatDecimalHours((sanitized.monthly_total_minutes || 0) / 60)} hrs / month`
        : `${formatDecimalHours((sanitized.duration_minutes || 0) / 60)} hrs / day`;
      const contractName = getContractName(sanitized.contract_id) || 'No contract';
      const hourTypeName = sanitized.hour_type_id ? getHourTypeName(sanitized.hour_type_id) : 'Default hour type';
      meta.textContent = `${hoursText}  ${contractName}  ${hourTypeName}`;
      const generated = document.createElement('p');
      generated.className = 'ts-note';
      generated.textContent = sanitized.generated_until
        ? `Synced through ${sanitized.generated_until}`
        : 'Not generated yet';
      card.append(header, summary, meta, generated);
      if (sanitized.warning_message) {
        const warn = document.createElement('div');
        warn.className = 'ts-warning';
        warn.textContent = sanitized.warning_message;
        card.appendChild(warn);
      }

      const actions = document.createElement('div');
      actions.className = 'ts-gap-sm';
      actions.style.display = 'flex';
      actions.style.justifyContent = 'space-between';
      actions.style.alignItems = 'center';
      actions.style.marginTop = '8px';

      const hasFuture = hasFutureRecurringEntries(sanitized.id);
      const statusEl = document.createElement('div');
      statusEl.className = 'recurring-entry-status ts-note';
      statusEl.style.flex = '1';
      statusEl.style.display = state.recurringEntriesSyncing ? 'block' : 'none';
      statusEl.textContent = state.recurringEntriesSyncing ? 'Syncing' : '';

      const deleteFutureBtn = document.createElement('button');
      deleteFutureBtn.type = 'button';
      deleteFutureBtn.className = 'ghost';
      deleteFutureBtn.textContent = 'Delete Future Entries';
      deleteFutureBtn.disabled = !hasFuture;
      deleteFutureBtn.title = hasFuture ? 'Remove upcoming entries created by this schedule' : 'No future entries to delete';
      deleteFutureBtn.addEventListener('click', async (event) => {
        event.stopPropagation();
        if (deleteFutureBtn.disabled) return;
        await promptDeleteFutureEntries(sanitized.id);
      });

      actions.appendChild(statusEl);
      actions.appendChild(deleteFutureBtn);
      card.appendChild(actions);

      recurringList.appendChild(card);
    });
    updateRecurringSyncStatus();
  }

  async function promptDeleteFutureEntries(recurrenceId) {
    if (!recurrenceId) return;
    const confirmed = await customConfirm(
      'Delete all future entries generated by this schedule? This cannot be undone.',
      { danger: true, okText: 'Delete Future Entries', cancelText: 'Cancel' }
    );
    if (!confirmed) return;
    try {
      await deleteFutureEntriesForSchedule(recurrenceId);
      setStatus('Future entries deleted', 'success');
    } catch (error) {
      // deleteFutureEntriesForSchedule already handles error status
    }
  }

  function updateRecurringSyncStatus() {
    if (!recurringList) return;
    const cards = recurringList.querySelectorAll('.recurring-entry-card');
    cards.forEach((card) => {
      const statusEl = card.querySelector('.recurring-entry-status');
      if (statusEl) {
        statusEl.textContent = state.recurringEntriesSyncing ? 'Syncing' : '';
        statusEl.style.display = state.recurringEntriesSyncing ? 'block' : 'none';
      }
    });
  }

  function renderBulkEntriesList() {
    if (!bulkList) return;
    bulkList.innerHTML = '';
    const entries = (state.bulkEntries || []).slice().sort((a, b) => {
      const aDate = a && a.start_date ? a.start_date : '';
      const bDate = b && b.start_date ? b.start_date : '';
      if (aDate && bDate && aDate !== bDate) {
        return aDate.localeCompare(bDate);
      }
      const aName = (a && a.label) ? a.label.toLowerCase() : '';
      const bName = (b && b.label) ? b.label.toLowerCase() : '';
      return aName.localeCompare(bName);
    });
    if (bulkEmpty) bulkEmpty.style.display = entries.length ? 'none' : 'block';
    entries.forEach((entry) => {
      const sanitized = sanitizeBulkEntry(entry);
      if (!sanitized) return;
      const card = document.createElement('div');
      card.className = 'ts-card bulk-entry-card';
      const header = document.createElement('div');
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      const title = document.createElement('strong');
      title.textContent = sanitized.label || 'Untitled range';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'ghost';
      editBtn.textContent = 'Edit';
      editBtn.addEventListener('click', () => setBulkFormDraft(sanitized));
      header.appendChild(title);
      header.appendChild(editBtn);

      const summary = document.createElement('p');
      summary.className = 'ts-note';
      summary.textContent = describeBulkEntry(sanitized);
      const meta = document.createElement('p');
      meta.className = 'ts-note';
      const hoursText = sanitized.distribution_mode === 'monthly'
        ? `${formatDecimalHours((sanitized.monthly_total_minutes || 0) / 60)} hrs / month`
        : `${formatDecimalHours((sanitized.duration_minutes || 0) / 60)} hrs / day`;
      const contractName = getContractName(sanitized.contract_id) || 'No contract';
      const hourTypeName = sanitized.hour_type_id ? getHourTypeName(sanitized.hour_type_id) : 'Default hour type';
      const weekendText = sanitized.include_weekends ? 'Includes weekends' : 'Skips weekends';
      const holidayText = sanitized.skip_public_holidays ? 'Skips public holidays' : 'Includes public holidays';
      meta.textContent = `${hoursText}  ${contractName}  ${hourTypeName}  ${weekendText}, ${holidayText}`;

      const generated = document.createElement('p');
      generated.className = 'ts-note';
      generated.textContent = sanitized.last_synced_at
        ? `Synced ${sanitized.last_synced_count || 0} days on ${formatFriendlyDate(sanitized.last_synced_at.split('T')[0])}`
        : 'Not synced yet';

      card.append(header, summary, meta, generated);
      if (sanitized.warning_message) {
        const warn = document.createElement('div');
        warn.className = 'ts-warning';
        warn.textContent = sanitized.warning_message;
        card.appendChild(warn);
      }

      const actions = document.createElement('div');
      actions.className = 'ts-gap-sm';
      actions.style.display = 'flex';
      actions.style.justifyContent = 'space-between';
      actions.style.alignItems = 'center';
      actions.style.marginTop = '8px';

      const statusEl = document.createElement('div');
      statusEl.className = 'recurring-entry-status ts-note';
      statusEl.style.flex = '1';
      statusEl.style.display = state.bulkEntriesSyncing ? 'block' : 'none';
      statusEl.dataset.entryId = sanitized.id || '';
      statusEl.textContent = state.bulkEntriesSyncing ? 'Syncing' : '';

      const syncBtn = document.createElement('button');
      syncBtn.type = 'button';
      syncBtn.className = 'ghost';
      syncBtn.textContent = 'Resync Range';
      syncBtn.addEventListener('click', (event) => {
        event.stopPropagation();
        runBulkSync('Bulk entries synced', sanitized.id).catch(() => {});
      });

      actions.appendChild(statusEl);
      actions.appendChild(syncBtn);
      card.appendChild(actions);
      bulkList.appendChild(card);
    });
    updateBulkSyncStatus();
  }

  function updateBulkSyncStatus() {
    if (!bulkList) return;
    const cards = bulkList.querySelectorAll('.bulk-entry-card .recurring-entry-status');
    const syncingId = state.bulkEntriesSyncingEntryId || '';
    cards.forEach((statusEl) => {
      if (!statusEl) return;
      const entryId = statusEl.dataset.entryId || '';
      const shouldShow = state.bulkEntriesSyncing && (!syncingId || syncingId === entryId);
      statusEl.textContent = shouldShow ? 'Syncing' : '';
      statusEl.style.display = shouldShow ? 'block' : 'none';
    });
  }

  function populateRecurringContractOptions(selectedId) {
    if (!recurringContractSelect) return;
    recurringContractSelect.innerHTML = '';
    const contracts = (state.contracts || []).slice().sort((a, b) => a.name.localeCompare(b.name));
    if (!contracts.length) {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'Add a contract first';
      recurringContractSelect.appendChild(opt);
      recurringContractSelect.disabled = true;
      return;
    }
    recurringContractSelect.disabled = false;
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select contract';
    recurringContractSelect.appendChild(placeholder);
    contracts.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      recurringContractSelect.appendChild(opt);
    });
    const resolved = selectedId && state.contractMap[selectedId] ? selectedId : '';
    recurringContractSelect.value = resolved;
  }

  function populateRecurringHourTypeOptions(selectedId) {
    if (!recurringHourTypeSelect) return;
    recurringHourTypeSelect.innerHTML = '';
    const hourTypes = (state.hourTypes || []).slice();
    if (!hourTypes.length) {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'Default hour type';
      recurringHourTypeSelect.appendChild(opt);
      recurringHourTypeSelect.value = '';
      return;
    }
    hourTypes.forEach((type) => {
      const opt = document.createElement('option');
      opt.value = type.id;
      opt.textContent = type.name;
      recurringHourTypeSelect.appendChild(opt);
    });
    const resolved = selectedId && state.hourTypeMap[selectedId]
      ? selectedId
      : (hourTypes.find((type) => type.is_default) || hourTypes[0]).id;
    recurringHourTypeSelect.value = resolved || '';
  }

  function populateBulkContractOptions(selectedId) {
    if (!bulkContractSelect) return;
    bulkContractSelect.innerHTML = '';
    const range = getCurrentBulkRange();
    const contracts = getContractsCoveringRange(range);
    if (!contracts.length) {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = range ? 'No contracts cover selected range' : 'Add a contract first';
      bulkContractSelect.appendChild(opt);
      bulkContractSelect.disabled = true;
      bulkContractSelect.value = '';
      if (state.bulkEntryForm && state.bulkEntryForm.draft) {
        state.bulkEntryForm.draft.contract_id = '';
      }
      return;
    }
    bulkContractSelect.disabled = false;
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select contract';
    bulkContractSelect.appendChild(placeholder);
    contracts.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      bulkContractSelect.appendChild(opt);
    });
    let resolved = '';
    if (contracts.length === 1) {
      resolved = contracts[0].id;
    } else if (selectedId && contracts.some((contract) => contract.id === selectedId)) {
      resolved = selectedId;
    }
    bulkContractSelect.value = resolved;
    if (state.bulkEntryForm && state.bulkEntryForm.draft) {
      state.bulkEntryForm.draft.contract_id = bulkContractSelect.value || '';
    }
    evaluateBulkContractWarning();
  }

  function populateBulkHourTypeOptions(selectedId) {
    if (!bulkHourTypeSelect) return;
    bulkHourTypeSelect.innerHTML = '';
    const hourTypes = (state.hourTypes || []).slice();
    if (!hourTypes.length) {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = 'Default hour type';
      bulkHourTypeSelect.appendChild(opt);
      bulkHourTypeSelect.value = '';
      return;
    }
    hourTypes.forEach((type) => {
      const opt = document.createElement('option');
      opt.value = type.id;
      opt.textContent = type.name;
      bulkHourTypeSelect.appendChild(opt);
    });
    const resolved = selectedId && state.hourTypeMap[selectedId]
      ? selectedId
      : (hourTypes.find((type) => type.is_default) || hourTypes[0]).id;
    bulkHourTypeSelect.value = resolved || '';
  }

  function updateBulkHourTypeVisibility() {
    if (!bulkHourTypeRow) return;
    const hourTypesEnabled = !!(getFeatureFlag('hour_types') && state.hourTypes.length > 1);
    bulkHourTypeRow.style.display = hourTypesEnabled ? 'block' : 'none';
    if (bulkHourTypeSelect) bulkHourTypeSelect.disabled = !hourTypesEnabled;
  }

  function getCurrentBulkRange() {
    const start = bulkStartDateInput ? bulkStartDateInput.value : '';
    const end = bulkEndDateInput ? bulkEndDateInput.value : '';
    if (!start || !end) return null;
    if (end < start) return null;
    return { start, end };
  }

  function contractCoversRange(contract, rangeStart, rangeEnd) {
    if (!contract || !rangeStart || !rangeEnd) return false;
    if (!contract.start_date || contract.start_date > rangeStart) return false;
    if (!contract.end_date || contract.end_date < rangeEnd) return false;
    return true;
  }

  function getContractsCoveringRange(range) {
    const contracts = (state.contracts || []).slice().sort((a, b) => a.name.localeCompare(b.name));
    if (!range) return contracts;
    return contracts.filter((contract) => contractCoversRange(contract, range.start, range.end));
  }

  function handleBulkRangeChange() {
    if (!state.bulkEntryForm.draft) return;
    if (bulkStartDateInput) state.bulkEntryForm.draft.start_date = bulkStartDateInput.value || '';
    if (bulkEndDateInput) state.bulkEntryForm.draft.end_date = bulkEndDateInput.value || '';
    populateBulkContractOptions(bulkContractSelect ? bulkContractSelect.value : '');
  }

  function evaluateBulkContractWarning() {
    const range = getCurrentBulkRange();
    const selectedId = bulkContractSelect ? bulkContractSelect.value : '';
    let message = '';
    if (selectedId && range) {
      const contract = state.contractMap[selectedId];
      if (!contract || !contractCoversRange(contract, range.start, range.end)) {
        message = 'Selected contract does not cover the entire date range.';
        if (bulkContractSelect) bulkContractSelect.value = '';
        if (state.bulkEntryForm.draft) state.bulkEntryForm.draft.contract_id = '';
      }
    }
    if ((!selectedId || message) && range) {
      const validContracts = getContractsCoveringRange(range);
      if (!validContracts.length) {
        message = 'No contracts cover the selected date range.';
      }
    }
    setBulkUiWarning(message);
  }

  function setBulkFormDraft(draft) {
    const sanitized = sanitizeBulkEntry(draft || defaultBulkDraft());
    if (sanitized.distribution_mode === 'monthly') {
      if (!sanitized.monthly_total_minutes || sanitized.monthly_total_minutes <= 0) {
        sanitized.monthly_total_minutes = BULK_DEFAULT_MONTHLY_MINUTES;
      }
      sanitized.duration_minutes = 0;
    } else {
      sanitized.distribution_mode = 'daily';
      if (!sanitized.duration_minutes || sanitized.duration_minutes <= 0) {
        sanitized.duration_minutes = BULK_DEFAULT_DAILY_MINUTES;
      }
      sanitized.monthly_total_minutes = 0;
    }
    const seedDate = sanitized.start_date ? parseIsoDate(sanitized.start_date) : parseIsoDate(todayIso());
    if (seedDate && !Number.isNaN(seedDate.getTime())) {
      bulkMonthPickerState.year = seedDate.getFullYear();
    }
    state.bulkEntryForm.draft = sanitized;
    state.bulkEntryForm.editingId = sanitized.id || '';
    state.bulkEntryForm.deleteConfirm = false;
    if (bulkFormTitle) bulkFormTitle.textContent = sanitized.id ? 'Edit Bulk Range' : 'New Bulk Range';
    if (bulkFormSubtitle) bulkFormSubtitle.textContent = sanitized.id
      ? describeBulkEntry(sanitized)
      : 'Fill a date range with matching entries.';
    if (bulkDeleteBtn) bulkDeleteBtn.style.display = sanitized.id ? 'inline-flex' : 'none';
    if (bulkSaveBtn) bulkSaveBtn.textContent = sanitized.id ? 'Update Range' : 'Save Range';
    if (bulkNameInput) bulkNameInput.value = sanitized.label || '';
    if (bulkHoursModeSelect) bulkHoursModeSelect.value = sanitized.distribution_mode || 'daily';
    const isMonthlyMode = sanitized.distribution_mode === 'monthly';
    const minutesSource = isMonthlyMode ? sanitized.monthly_total_minutes : sanitized.duration_minutes;
    if (bulkHoursInput) {
      bulkHoursInput.value = minutesSource
        ? formatDecimalHours((minutesSource || 0) / 60)
        : formatDecimalHours(isMonthlyMode ? BULK_DEFAULT_MONTHLY_HOURS : BULK_DEFAULT_DAILY_HOURS);
    }
    if (bulkStartDateInput) bulkStartDateInput.value = sanitized.start_date || todayIso();
    if (bulkEndDateInput) bulkEndDateInput.value = sanitized.end_date || sanitized.start_date || todayIso();
    if (bulkMonthInput) {
      bulkMonthInput.value = isMonthlyMode && sanitized.start_date ? sanitized.start_date.slice(0, 7) : '';
    }
    populateBulkHourTypeOptions(sanitized.hour_type_id);
    updateBulkHourTypeVisibility();
    if (bulkSkipWeekendsToggle) bulkSkipWeekendsToggle.checked = !sanitized.include_weekends;
    if (bulkSkipHolidaysToggle) bulkSkipHolidaysToggle.checked = sanitized.skip_public_holidays !== false;
    setBulkUiWarning('');
    setBulkWarning(sanitized.warning_message || '');
    updateBulkGeneratedSummary(sanitized);
    updateBulkDistributionUI(sanitized);
    renderBulkMonthPicker(bulkMonthInput ? bulkMonthInput.value : '');
    toggleBulkDeleteConfirm(false);
    setBulkFormError('');
  }

  function getBulkFormValues() {
    const hoursValue = bulkHoursInput ? Number(bulkHoursInput.value) : 0;
    const rawMinutes = Number.isFinite(hoursValue) && hoursValue > 0 ? Math.round(hoursValue * 60) : 0;
    const roundedMinutes = rawMinutes > 0 ? roundDuration(rawMinutes) : 0;
    const mode = bulkHoursModeSelect ? bulkHoursModeSelect.value : 'daily';
    const monthValue = bulkMonthInput ? bulkMonthInput.value : '';
    let startDate = bulkStartDateInput ? bulkStartDateInput.value : '';
    let endDate = bulkEndDateInput ? bulkEndDateInput.value : '';
    let durationMinutes = roundedMinutes;
    let monthlyTotalMinutes = 0;
    if (mode === 'monthly') {
      monthlyTotalMinutes = roundedMinutes;
      durationMinutes = 0;
      if (monthValue) {
        const bounds = getMonthBoundsFromValue(monthValue);
        if (bounds) {
          startDate = bounds.start;
          endDate = bounds.end;
        } else {
          startDate = '';
          endDate = '';
        }
      }
    }
    return {
      id: state.bulkEntryForm.editingId || '',
      label: bulkNameInput ? bulkNameInput.value : '',
      duration_minutes: durationMinutes,
      monthly_total_minutes: monthlyTotalMinutes,
      distribution_mode: mode,
      contract_id: bulkContractSelect ? bulkContractSelect.value : '',
      hour_type_id: bulkHourTypeSelect ? bulkHourTypeSelect.value : '',
      start_date: startDate,
      end_date: endDate,
      include_weekends: bulkSkipWeekendsToggle ? !bulkSkipWeekendsToggle.checked : false,
      skip_public_holidays: bulkSkipHolidaysToggle ? !!bulkSkipHolidaysToggle.checked : true,
      last_synced_at: state.bulkEntryForm.draft ? state.bulkEntryForm.draft.last_synced_at : '',
      last_synced_count: state.bulkEntryForm.draft ? state.bulkEntryForm.draft.last_synced_count : 0,
      warning_message: state.bulkEntryForm.draft ? state.bulkEntryForm.draft.warning_message : ''
    };
  }

  let bulkServerWarning = '';
  let bulkUiWarning = '';

  function updateBulkWarningMessage() {
    if (!bulkFormWarning) return;
    const message = [bulkServerWarning, bulkUiWarning].filter(Boolean).join(' ');
    bulkFormWarning.style.display = message ? 'block' : 'none';
    bulkFormWarning.textContent = message || '';
  }

  function setBulkWarning(message) {
    bulkServerWarning = message || '';
    updateBulkWarningMessage();
  }

  function setBulkUiWarning(message) {
    bulkUiWarning = message || '';
    updateBulkWarningMessage();
  }

  function setBulkFormError(message) {
    if (!bulkFormError) return;
    bulkFormError.style.display = message ? 'block' : 'none';
    bulkFormError.textContent = message || '';
  }

  function updateBulkGeneratedSummary(entry) {
    if (!bulkGeneratedSummary) return;
    const hasSync = entry && entry.last_synced_at;
    bulkGeneratedSummary.style.display = 'block';
    bulkGeneratedSummary.textContent = hasSync
      ? `Last synced ${entry.last_synced_count || 0} days on ${formatFriendlyDate(entry.last_synced_at.split('T')[0])}`
      : 'No entries generated yet.';
  }

  function toggleBulkDeleteConfirm(show) {
    if (!bulkDeleteConfirm) return;
    state.bulkEntryForm.deleteConfirm = !!show;
    bulkDeleteConfirm.style.display = show ? 'block' : 'none';
    if (bulkDeleteBtn) bulkDeleteBtn.style.display = show ? 'none' : (state.bulkEntryForm.editingId ? 'inline-flex' : 'none');
    if (bulkSaveBtn) bulkSaveBtn.disabled = !!show;
    if (bulkCancelBtn) bulkCancelBtn.disabled = !!show;
  }

  function handleBulkFormBusy(isBusy, label) {
    if (!bulkSaveBtn) return;
    bulkSaveBtn.disabled = isBusy;
    bulkSaveBtn.textContent = isBusy ? 'Working' : label;
  }

  function validateBulkForm(draft) {
    if (!draft.label) return 'Name is required.';
    if (draft.distribution_mode === 'monthly') {
      if (!draft.monthly_total_minutes || draft.monthly_total_minutes <= 0) {
        return 'Monthly hours must be greater than zero.';
      }
    } else if (!draft.duration_minutes || draft.duration_minutes <= 0) {
      return 'Hours must be greater than zero.';
    }
    if (!draft.contract_id) return 'Select a contract.';
    if (!draft.start_date) return 'Start date is required.';
    if (!draft.end_date) return 'End date is required.';
    if (draft.end_date < draft.start_date) return 'End date must be on or after the start date.';
    return '';
  }

  function openBulkModal() {
    if (!bulkModal) return;
    showModal(bulkModal);
    renderBulkEntriesList();
    if (!state.bulkEntriesInitialized && !state.bulkEntriesSyncing) {
      syncBulkEntries({ silent: true });
    }
  }

  function closeBulkModal() {
    if (!bulkModal) return;
    hideModal(bulkModal);
    toggleBulkDeleteConfirm(false);
    setBulkFormError('');
  }

  function syncBulkEntries(options) {
    const opts = options || {};
    if (!state.featureFlags.bulk_time_entries || !state.featureFlags.bulk_time_entries.enabled) return;
    if (state.bulkEntriesSyncing) return;
    state.bulkEntriesSyncing = true;
    updateBulkSyncStatus();
    if (!opts.silent) setStatus('Syncing bulk entries...', 'warn');
    const payload = opts.entryId ? { entryId: opts.entryId } : {};
    state.bulkEntriesSyncingEntryId = payload.entryId || '';
    google.script.run
      .withSuccessHandler((res) => {
        state.bulkEntriesSyncing = false;
        state.bulkEntriesSyncingEntryId = '';
        updateBulkSyncStatus();
        const entries = Array.isArray(res && res.entries) ? res.entries.map(sanitizeBulkEntry).filter((item) => item) : [];
        state.bulkEntries = entries;
        state.bulkEntriesInitialized = true;
        saveCache();
        renderBulkEntriesList();
        if (state.bulkEntryForm.editingId) {
          const match = entries.find((item) => item.id === state.bulkEntryForm.editingId);
          if (match) {
            setBulkFormDraft(match);
          }
        }
        const finish = () => {
          if (typeof opts.onComplete === 'function') {
            opts.onComplete();
          } else if (!opts.silent) {
            setStatus('Bulk entries refreshed', 'success');
          }
        };
        if (res && Number(res.totalChanges) > 0) {
          refreshEntriesFromServer(finish);
        } else {
          finish();
        }
      })
      .withFailureHandler((error) => {
        state.bulkEntriesSyncing = false;
        state.bulkEntriesSyncingEntryId = '';
        updateBulkSyncStatus();
        const message = error && error.message ? error.message : 'Failed to sync bulk entries.';
        if (typeof opts.onError === 'function') {
          opts.onError(message);
        } else if (!opts.silent) {
          setStatus(message, 'error');
        }
      })
      .api_syncBulkTimeEntries(payload);
  }

  function runBulkSync(successMessage, entryId) {
    const cleanupNeeded = !!entryId;
    return new Promise((resolve, reject) => {
      syncBulkEntries({
        silent: !successMessage,
        entryId: cleanupNeeded ? entryId : '',
        onComplete: () => {
          if (successMessage) setStatus(successMessage, 'success');
          resolve();
        },
        onError: (message) => {
          const errorMessage = message || 'Failed to sync bulk entries.';
          if (successMessage) setStatus(errorMessage, 'error');
          reject(new Error(errorMessage));
        }
      });
    });
  }

  async function handleBulkSave() {
    const draft = getBulkFormValues();
    const error = validateBulkForm(draft);
    if (error) {
      setBulkFormError(error);
      return;
    }
    setBulkFormError('');
    const isEdit = !!draft.id;
    const previousEntries = cloneBulkEntries(state.bulkEntries);
    const previousDraft = state.bulkEntryForm.draft ? { ...state.bulkEntryForm.draft } : null;
    const previousEditingId = state.bulkEntryForm.editingId;
    let optimisticId = draft.id;
    if (!isEdit) {
      optimisticId = `temp_bulk_${Date.now()}`;
    }
    const optimisticEntry = { ...draft, id: optimisticId };
    upsertBulkEntryLocal(optimisticEntry);
    state.bulkEntriesInitialized = true;
    renderBulkEntriesList();
    setBulkFormDraft(optimisticEntry);
    const baseLabel = draft.id ? 'Update Range' : 'Save Range';
    handleBulkFormBusy(true, baseLabel);
    setStatus(isEdit ? 'Updating bulk range...' : 'Saving bulk range...', 'warn');
    google.script.run
      .withSuccessHandler(async (res) => {
        handleBulkFormBusy(false, baseLabel);
        if (res && res.success) {
          const entries = Array.isArray(res.entries) ? res.entries.map(sanitizeBulkEntry).filter((item) => item) : [];
          state.bulkEntries = entries;
          state.bulkEntriesInitialized = true;
          saveCache();
          renderBulkEntriesList();
          const updated = res.entry ? sanitizeBulkEntry(res.entry) : defaultBulkDraft();
          if (updated) {
            setBulkFormDraft(updated);
          } else {
            setBulkFormDraft(defaultBulkDraft());
          }
          const entryId = (res.entry && res.entry.id) || draft.id || '';
          try {
            await runBulkSync(isEdit ? 'Bulk range updated' : 'Bulk range saved', entryId);
          } catch (e) {
            // sync errors already surfaced
          }
        } else {
          const message = res && res.error ? res.error : 'Failed to save bulk range.';
          state.bulkEntries = previousEntries;
          renderBulkEntriesList();
          if (previousDraft) {
            setBulkFormDraft(previousDraft);
            state.bulkEntryForm.editingId = previousEditingId;
          }
          setBulkFormError(message);
          setStatus('Bulk range save failed', 'error');
        }
      })
      .withFailureHandler((error) => {
        handleBulkFormBusy(false, baseLabel);
        state.bulkEntries = previousEntries;
        renderBulkEntriesList();
        if (previousDraft) {
          setBulkFormDraft(previousDraft);
          state.bulkEntryForm.editingId = previousEditingId;
        }
        const message = error && error.message ? error.message : 'Failed to save bulk range.';
        setBulkFormError(message);
        setStatus('Bulk range save failed', 'error');
      })
      .api_upsertBulkTimeEntry({
        ...draft
      });
  }

  async function handleBulkDelete() {
    const id = state.bulkEntryForm.editingId;
    if (!id) return;
    if (bulkDeleteConfirmBtn) bulkDeleteConfirmBtn.disabled = true;
    const previousEntries = cloneBulkEntries(state.bulkEntries);
    const previousDraft = state.bulkEntryForm.draft ? { ...state.bulkEntryForm.draft } : null;
    const previousEditingId = state.bulkEntryForm.editingId;
    removeBulkEntryLocal(id);
    renderBulkEntriesList();
    setBulkFormDraft(defaultBulkDraft());
    setStatus('Deleting bulk range...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (bulkDeleteConfirmBtn) bulkDeleteConfirmBtn.disabled = false;
        toggleBulkDeleteConfirm(false);
        const entries = Array.isArray(res.entries) ? res.entries.map(sanitizeBulkEntry).filter((item) => item) : [];
        state.bulkEntries = entries;
        saveCache();
        renderBulkEntriesList();
        setBulkFormDraft(defaultBulkDraft());
        refreshEntriesFromServer(() => {
          setStatus('Bulk range deleted', 'success');
        });
      })
      .withFailureHandler((error) => {
        if (bulkDeleteConfirmBtn) bulkDeleteConfirmBtn.disabled = false;
        state.bulkEntries = previousEntries;
        renderBulkEntriesList();
        if (previousDraft) {
          setBulkFormDraft(previousDraft);
          state.bulkEntryForm.editingId = previousEditingId;
        }
        const message = error && error.message ? error.message : 'Failed to delete bulk range.';
        setBulkFormError(message);
        setStatus('Failed to delete bulk range', 'error');
      })
      .api_deleteBulkTimeEntry(id);
  }

  function cloneBulkEntries(list) {
    return Array.isArray(list) ? list.map((item) => ({ ...item })) : [];
  }

  function upsertBulkEntryLocal(entry) {
    const sanitized = sanitizeBulkEntry(entry);
    if (!sanitized || !sanitized.id) return;
    const idx = state.bulkEntries.findIndex((item) => item.id === sanitized.id);
    if (idx === -1) {
      state.bulkEntries = [...state.bulkEntries, sanitized];
    } else {
      state.bulkEntries[idx] = sanitized;
    }
  }

  function removeBulkEntryLocal(id) {
    if (!id) return;
    state.bulkEntries = state.bulkEntries.filter((item) => item.id !== id);
  }

  function updateRecurringHourTypeVisibility() {
    if (!recurringHourTypeRow) return;
    const hourTypesEnabled = !!(getFeatureFlag('hour_types') && state.hourTypes.length > 1);
    recurringHourTypeRow.style.display = hourTypesEnabled ? 'block' : 'none';
    if (recurringHourTypeSelect) recurringHourTypeSelect.disabled = !hourTypesEnabled;
  }


  function setRecurringFormDraft(draft) {
    const sanitized = sanitizeRecurringEntry(draft || defaultRecurringDraft());
    state.recurringEntryForm.draft = sanitized;
    state.recurringEntryForm.editingId = sanitized.id || '';
    state.recurringEntryForm.deleteConfirm = false;
    if (recurringFormTitle) recurringFormTitle.textContent = sanitized.id ? 'Edit Schedule' : 'New Schedule';
    if (recurringFormSubtitle) recurringFormSubtitle.textContent = describeRecurringEntry(sanitized);
    if (recurringDeleteBtn) recurringDeleteBtn.style.display = sanitized.id ? 'inline-flex' : 'none';
    if (recurringSaveBtn) recurringSaveBtn.textContent = sanitized.id ? 'Edit Schedule' : 'Add Schedule';
    if (recurringNameInput) recurringNameInput.value = sanitized.label || '';
    if (recurringHoursInput) {
      recurringHoursInput.value = sanitized.duration_minutes ? formatDecimalHours(sanitized.duration_minutes / 60) : '';
    }
    if (recurringStartDateInput) recurringStartDateInput.value = sanitized.start_date || todayIso();
    if (recurringEndDateInput) recurringEndDateInput.value = sanitized.end_date || '';
    if (recurringFrequencySelect) recurringFrequencySelect.value = sanitized.recurrence_type;
    if (recurringWeeklyIntervalInput) recurringWeeklyIntervalInput.value = sanitized.weekly_interval || 1;
    if (recurringMonthlyIntervalInput) recurringMonthlyIntervalInput.value = sanitized.monthly_interval || 1;
    if (recurringMonthlyDayInput) recurringMonthlyDayInput.value = sanitized.monthly_day || 1;
    if (recurringMonthlyWeekSelect) recurringMonthlyWeekSelect.value = sanitized.monthly_week || 1;
    if (recurringMonthlyWeekdaySelect) recurringMonthlyWeekdaySelect.value = sanitized.monthly_weekday || 1;
    if (recurringMonthlyModeSelect) recurringMonthlyModeSelect.value = sanitized.monthly_mode || 'day_of_month';
    populateRecurringContractOptions(sanitized.contract_id);
    populateRecurringHourTypeOptions(sanitized.hour_type_id);
    const weekdays = (sanitized.weekly_weekdays && sanitized.weekly_weekdays.length) ? sanitized.weekly_weekdays : [1];
    sanitized.weekly_weekdays = weekdays;
    updateRecurringFrequencyVisibility();
    updateRecurringMonthlyModeVisibility();
    setRecurringWarning(sanitized.warning_message || '');
    updateRecurringGeneratedSummary(sanitized.generated_until);
    toggleRecurringDeleteConfirm(false);
    updateRecurringFormFromInputs();
    setRecurringFormError('');
  }

  function getRecurringFormValues() {
    const recurrenceType = recurringFrequencySelect ? recurringFrequencySelect.value : 'weekly';
    const weeklyInterval = recurringWeeklyIntervalInput ? Number(recurringWeeklyIntervalInput.value) : 1;
    const monthlyInterval = recurringMonthlyIntervalInput ? Number(recurringMonthlyIntervalInput.value) : 1;
    const weeklyDays = [];
    const hoursValue = recurringHoursInput ? Number(recurringHoursInput.value) : 0;
    const durationMinutes = Number.isFinite(hoursValue) && hoursValue > 0 ? Math.round(hoursValue * 60) : 0;
    const monthlyMode = recurringMonthlyModeSelect ? recurringMonthlyModeSelect.value : 'day_of_month';
    const values = {
      id: state.recurringEntryForm.editingId || '',
      label: recurringNameInput ? recurringNameInput.value : '',
      recurrence_type: recurrenceType,
      weekly_interval: weeklyInterval,
      weekly_weekdays: weeklyDays,
      monthly_interval: monthlyInterval,
      monthly_mode: monthlyMode,
      monthly_day: recurringMonthlyDayInput ? Number(recurringMonthlyDayInput.value) : 1,
      monthly_week: recurringMonthlyWeekSelect ? Number(recurringMonthlyWeekSelect.value) : 1,
      monthly_weekday: recurringMonthlyWeekdaySelect ? Number(recurringMonthlyWeekdaySelect.value) : 1,
      duration_minutes: durationMinutes,
      contract_id: recurringContractSelect ? recurringContractSelect.value : '',
      hour_type_id: recurringHourTypeSelect ? recurringHourTypeSelect.value : '',
      start_date: recurringStartDateInput ? recurringStartDateInput.value : '',
      end_date: recurringEndDateInput ? recurringEndDateInput.value : '',
      generated_until: state.recurringEntryForm.draft ? state.recurringEntryForm.draft.generated_until : '',
      warning_message: state.recurringEntryForm.draft ? state.recurringEntryForm.draft.warning_message : ''
    };
    if (recurrenceType === 'weekly') {
      const startIso = isoDate(recurringStartDateInput ? recurringStartDateInput.value : '');
      const startDate = parseIsoDate(startIso);
      const weekday = startDate && Number.isFinite(startDate.getTime())
        ? startDate.getDay()
        : ((state.recurringEntryForm.draft && state.recurringEntryForm.draft.weekly_weekdays && state.recurringEntryForm.draft.weekly_weekdays[0]) || 1);
      values.weekly_weekdays = [weekday];
    } else if (!values.weekly_weekdays.length && state.recurringEntryForm.draft && Array.isArray(state.recurringEntryForm.draft.weekly_weekdays)) {
      values.weekly_weekdays = state.recurringEntryForm.draft.weekly_weekdays.slice();
    }
    return sanitizeRecurringEntry(values);
  }

  function updateRecurringFormFromInputs() {
    const values = getRecurringFormValues();
    state.recurringEntryForm.draft = values;
    if (recurringFormSubtitle) recurringFormSubtitle.textContent = describeRecurringEntry(values);
    renderRecurringPreview(values);
    setRecurringFormError('');
  }

  function updateRecurringFrequencyVisibility() {
    if (recurringWeeklyFields) recurringWeeklyFields.style.display = (recurringFrequencySelect && recurringFrequencySelect.value === 'weekly') ? 'block' : 'none';
    if (recurringMonthlyFields) recurringMonthlyFields.style.display = (recurringFrequencySelect && recurringFrequencySelect.value === 'monthly') ? 'block' : 'none';
  }

  function updateRecurringMonthlyModeVisibility() {
    const mode = recurringMonthlyModeSelect ? recurringMonthlyModeSelect.value : 'day_of_month';
    if (recurringMonthlyDayWrapper) recurringMonthlyDayWrapper.style.display = mode === 'day_of_month' ? 'block' : 'none';
    if (recurringMonthlyWeekWrapper) recurringMonthlyWeekWrapper.style.display = mode === 'weekday_of_month' ? 'block' : 'none';
  }

  function renderRecurringPreview(values) {
    if (!recurringPreviewNote || !recurringPreviewList) return;
    const preview = buildRecurringPreview(values, 5);
    if (!preview.length) {
      recurringPreviewNote.style.display = 'none';
      recurringPreviewList.innerHTML = '';
      return;
    }
    recurringPreviewNote.style.display = 'block';
    recurringPreviewList.innerHTML = '';
    preview.forEach((iso) => {
      const li = document.createElement('li');
      li.textContent = formatFriendlyDate(iso);
      recurringPreviewList.appendChild(li);
    });
  }

  function formatFriendlyDate(dateIso) {
    const date = parseIsoDate(dateIso);
    if (!date) return dateIso || '';
    return date.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' });
  }

  function setRecurringWarning(message) {
    if (!recurringFormWarning) return;
    recurringFormWarning.style.display = message ? 'block' : 'none';
    recurringFormWarning.textContent = message || '';
  }

  function updateRecurringGeneratedSummary(dateIso) {
    if (!recurringGeneratedSummary) return;
    recurringGeneratedSummary.style.display = 'block';
    recurringGeneratedSummary.textContent = dateIso
      ? `Synced through ${dateIso}`
      : 'No entries generated yet.';
  }

  function toggleRecurringDeleteConfirm(show) {
    if (!recurringDeleteConfirm) return;
    state.recurringEntryForm.deleteConfirm = !!show;
    recurringDeleteConfirm.style.display = show ? 'block' : 'none';
    if (recurringDeleteBtn) recurringDeleteBtn.style.display = show ? 'none' : (state.recurringEntryForm.editingId ? 'inline-flex' : 'none');
    if (recurringSaveBtn) recurringSaveBtn.disabled = !!show;
    if (recurringCancelBtn) recurringCancelBtn.disabled = !!show;
  }

  function handleRecurringFormBusy(isBusy, label) {
    if (!recurringSaveBtn) return;
    recurringSaveBtn.disabled = isBusy;
    recurringSaveBtn.textContent = isBusy ? 'Working' : label;
  }

  function runRecurringSync(successMessage, shouldDeleteFutureEntries, recurrenceIdForCleanup) {
    const cleanupNeeded = !!(shouldDeleteFutureEntries && recurrenceIdForCleanup);
    const cleanup = cleanupNeeded
      ? deleteFutureEntriesForSchedule(recurrenceIdForCleanup, { silent: true }).catch((error) => {
        const message = (error && error.message) || 'Failed to delete future entries';
        setStatus(message, 'error');
        throw error;
      })
      : Promise.resolve();
    return cleanup.then(() => new Promise((resolve, reject) => {
      syncRecurringEntries({
        silent: !successMessage,
        onComplete: () => {
          if (successMessage) {
            setStatus(successMessage, 'success');
          }
          resolve();
        },
        onError: (message) => {
          const errorMessage = message || 'Failed to sync reoccurring entries.';
          if (successMessage) {
            setStatus(errorMessage, 'error');
          }
          reject(new Error(errorMessage));
        }
      });
    }));
  }

  function openRecurringModal() {
    if (!recurringModal) return;
    showModal(recurringModal);
    renderRecurringEntriesList();
    if (!state.recurringEntriesInitialized && !state.recurringEntriesSyncing) {
      syncRecurringEntries({ silent: true });
    }
  }

  function closeRecurringModal() {
    if (!recurringModal) return;
    hideModal(recurringModal);
    toggleRecurringDeleteConfirm(false);
    setRecurringFormError('');
  }

  function validateRecurringForm(draft) {
    if (!draft.label) return 'Name is required.';
    if (!draft.duration_minutes || draft.duration_minutes <= 0) return 'Hours must be greater than zero.';
    if (!draft.contract_id) return 'Select a contract.';
    if (!draft.start_date) return 'Start date is required.';
    if (draft.end_date && draft.end_date < draft.start_date) return 'End date must be on or after the start date.';
    if (draft.recurrence_type === 'weekly' && (!draft.weekly_weekdays || !draft.weekly_weekdays.length)) {
      return 'Choose at least one weekday.';
    }
    return '';
  }

  function setRecurringFormError(message) {
    if (!recurringFormError) return;
    recurringFormError.style.display = message ? 'block' : 'none';
    recurringFormError.textContent = message || '';
  }

  function syncRecurringEntries(options) {
    const opts = options || {};
    if (!state.featureFlags.recurring_time_entries || !state.featureFlags.recurring_time_entries.enabled) return;
    if (state.recurringEntriesSyncing) return;
    state.recurringEntriesSyncing = true;
    updateRecurringSyncStatus();
    if (!opts.silent) setStatus('Syncing reoccurring entries...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        state.recurringEntriesSyncing = false;
        updateRecurringSyncStatus();
        const entries = Array.isArray(res && res.entries) ? res.entries.map(sanitizeRecurringEntry).filter((item) => item) : [];
        state.recurringTimeEntries = entries;
        state.recurringEntriesInitialized = true;
        saveCache();
        renderRecurringEntriesList();
        if (state.recurringEntryForm.editingId) {
          const match = entries.find((item) => item.id === state.recurringEntryForm.editingId);
          if (match) {
            setRecurringFormDraft(match);
          }
        }
        const finish = () => {
          if (typeof opts.onComplete === 'function') {
            opts.onComplete();
          } else if (!opts.silent) {
            setStatus('Reoccurring entries refreshed', 'success');
          }
        };
        if (res && Number(res.generatedEntries) > 0) {
          refreshEntriesFromServer(finish);
        } else {
          finish();
        }
      })
      .withFailureHandler((error) => {
        state.recurringEntriesSyncing = false;
        updateRecurringSyncStatus();
        const message = error && error.message ? error.message : 'Failed to sync reoccurring entries.';
        if (typeof opts.onError === 'function') {
          opts.onError(message);
        } else if (!opts.silent) {
          setStatus(message, 'error');
        }
      })
      .api_syncRecurringTimeEntries({});
  }

  function refreshEntriesFromServer(onComplete) {
    entriesSyncInFlight = true;
    google.script.run
      .withSuccessHandler((entries) => {
        entriesSyncInFlight = false;
        const sanitized = (entries || []).map(sanitizeEntry);
        mergeEntriesWithServerEntries(sanitized);
        state.entriesLoaded = true;
        markAllIncomeSummariesDirty();
        // Force annual data to rebuild on next load
        state.annualData = null;
        saveCache();
        renderEntries();
        if (state.currentPage === 'annual-views') {
          loadAnnualData();
        }
        if (typeof onComplete === 'function') onComplete();
      })
      .withFailureHandler(() => {
        entriesSyncInFlight = false;
        if (typeof onComplete === 'function') onComplete();
        setStatus('Entries sync failed', 'error');
      })
      .api_getEntries({});
  }

  async function handleRecurringSave() {
    const draft = getRecurringFormValues();
    const error = validateRecurringForm(draft);
    if (error) {
      setRecurringFormError(error);
      return;
    }
    setRecurringFormError('');
    const isEdit = !!draft.id;
    let deleteFutureEntries = false;
    if (isEdit && hasFutureRecurringEntries(draft.id)) {
      deleteFutureEntries = await customConfirm(
        'Delete future entries generated by this schedule?',
        {
          okText: 'Delete Future Entries',
          cancelText: 'Keep entries',
          danger: true
        }
      );
    }
    const previousEntries = cloneRecurringEntries(state.recurringTimeEntries);
    const previousDraft = state.recurringEntryForm.draft ? { ...state.recurringEntryForm.draft } : null;
    const previousEditingId = state.recurringEntryForm.editingId;
    let optimisticId = draft.id;
    if (!isEdit) {
      optimisticId = `temp_schedule_${Date.now()}`;
    }
    const optimisticEntry = { ...draft, id: optimisticId };
    upsertRecurringEntryLocal(optimisticEntry);
    state.recurringEntriesInitialized = true;
    renderRecurringEntriesList();
    setRecurringFormDraft(optimisticEntry);
    const baseLabel = isEdit ? 'Edit Schedule' : 'Add Schedule';
    handleRecurringFormBusy(true, baseLabel);
    setStatus(isEdit ? 'Updating schedule...' : 'Saving schedule...', 'warn');
    google.script.run
      .withSuccessHandler(async (res) => {
        handleRecurringFormBusy(false, baseLabel);
        if (res && res.success) {
          const entries = Array.isArray(res.entries) ? res.entries.map(sanitizeRecurringEntry).filter((item) => item) : [];
          state.recurringTimeEntries = entries;
          state.recurringEntriesInitialized = true;
          saveCache();
          renderRecurringEntriesList();
          const updated = res.entry ? sanitizeRecurringEntry(res.entry) : defaultRecurringDraft();
          if (updated) {
            setRecurringFormDraft(updated);
          } else {
            setRecurringFormDraft(defaultRecurringDraft());
          }
          const recurrenceId = (res.entry && res.entry.id) || draft.id || '';
          try {
            await runRecurringSync(
              isEdit ? 'Schedule updated' : 'Schedule saved',
              deleteFutureEntries,
              recurrenceId
            );
          } catch (e) {
            // runRecurringSync already surfaced an error message
          }
        } else {
          const message = res && res.error ? res.error : 'Failed to save schedule.';
          state.recurringTimeEntries = previousEntries;
          renderRecurringEntriesList();
          if (previousDraft) {
            setRecurringFormDraft(previousDraft);
            state.recurringEntryForm.editingId = previousEditingId;
          }
          setRecurringFormError(message);
          setStatus('Schedule save failed', 'error');
        }
      })
      .withFailureHandler((error) => {
        handleRecurringFormBusy(false, baseLabel);
        state.recurringTimeEntries = previousEntries;
        renderRecurringEntriesList();
        if (previousDraft) {
          setRecurringFormDraft(previousDraft);
          state.recurringEntryForm.editingId = previousEditingId;
        }
        const message = error && error.message ? error.message : 'Failed to save schedule.';
        setRecurringFormError(message);
        setStatus('Schedule save failed', 'error');
      })
      .api_upsertRecurringTimeEntry({
        ...draft
      });
  }

  async function handleRecurringDelete() {
    const id = state.recurringEntryForm.editingId;
    if (!id) return;
    let deleteFutureEntries = false;
    if (hasFutureRecurringEntries(id)) {
      deleteFutureEntries = await customConfirm(
        'Delete future entries generated by this schedule?',
        {
          okText: 'Delete Future Entries',
          cancelText: 'Keep entries',
          danger: true
        }
      );
    }
    if (recurringDeleteConfirmBtn) recurringDeleteConfirmBtn.disabled = true;
    const previousEntries = cloneRecurringEntries(state.recurringTimeEntries);
    const previousDraft = state.recurringEntryForm.draft ? { ...state.recurringEntryForm.draft } : null;
    const previousEditingId = state.recurringEntryForm.editingId;
    removeRecurringEntryLocal(id);
    renderRecurringEntriesList();
    setRecurringFormDraft(defaultRecurringDraft());
    setStatus('Deleting schedule...', 'warn');
    google.script.run
      .withSuccessHandler(async (res) => {
        if (recurringDeleteConfirmBtn) recurringDeleteConfirmBtn.disabled = false;
        toggleRecurringDeleteConfirm(false);
        state.recurringTimeEntries = Array.isArray(res.entries) ? res.entries.map(sanitizeRecurringEntry).filter((item) => item) : [];
        saveCache();
        renderRecurringEntriesList();
        setRecurringFormDraft(defaultRecurringDraft());
        try {
          await runRecurringSync('Schedule deleted', deleteFutureEntries, id);
        } catch (e) {
          // Already surfaced
        }
      })
      .withFailureHandler((error) => {
        if (recurringDeleteConfirmBtn) recurringDeleteConfirmBtn.disabled = false;
        state.recurringTimeEntries = previousEntries;
        renderRecurringEntriesList();
        if (previousDraft) {
          setRecurringFormDraft(previousDraft);
          state.recurringEntryForm.editingId = previousEditingId;
        }
        const message = error && error.message ? error.message : 'Failed to delete schedule.';
        setRecurringFormError(message);
        setStatus('Failed to delete schedule', 'error');
      })
      .api_deleteRecurringTimeEntry(id);
  }

  function editRecurringEntry(entryId) {
    if (!entryId) return;
    const match = state.recurringTimeEntries.find((item) => item.id === entryId);
    if (match) {
      setRecurringFormDraft(match);
    }
  }

  setupModalHandlers();

  // Initialize default entries after all functions are defined
  updateDefaultButtonsVisibility();
  loadEntryDefaults();

  // Hour Types Management
  function generateRandomColor() {
    const colors = [
      '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16', '#22c55e',
      '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', '#3b82f6', '#6366f1',
      '#8b5cf6', '#a855f7', '#d946ef', '#ec4899', '#f43f5e'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  function loadHourTypes() {
    if (!state.featureFlags.hour_types) return Promise.resolve(false);

    setStatus('Loading hour types...', 'warn');
    return new Promise((resolve) => {
      google.script.run
        .withSuccessHandler((hourTypes) => {
          state.hourTypes = Array.isArray(hourTypes) ? hourTypes.map(sanitizeHourType) : [];
          updateHourTypeMap();
          populateRecurringHourTypeOptions(state.recurringEntryForm.draft ? state.recurringEntryForm.draft.hour_type_id : '');
          updateRecurringHourTypeVisibility();
          populateBulkHourTypeOptions(state.bulkEntryForm.draft ? state.bulkEntryForm.draft.hour_type_id : '');
          updateBulkHourTypeVisibility();
          ensureInvoiceFormOptions();
          if (getFeatureFlag('enable_invoices')) {
            renderInvoiceDefaults();
            renderInvoiceDetail();
          }
          renderHourTypes();
          updateHourTypeFormVisibility();
        renderCalendarFilters();
        renderCalendar();
        saveCache();
        setStatus('Idle');
        maybeAutoPopulatePublicHolidayEntries();
        if (state.annualData) {
          loadAnnualData();
        }
          resolve(true);
        })
        .withFailureHandler((error) => {
          console.error('Failed to load hour types:', error);
          setStatus('Error loading hour types', 'error');
          resolve(false);
        })
        .api_getHourTypes();
    });
  }

  function renderHourTypes() {
    const container = document.getElementById('hour-types-list');
    if (!container) return;

    if (state.hourTypes.length === 0) {
      container.innerHTML = '<div class="ts-note">No hour types configured. Click "Add Hour Type" to create your first one.</div>';
      return;
    }

    const sortedHourTypes = [...state.hourTypes].sort((a, b) => compareByDisplayOrder(a, b));

    const html = sortedHourTypes.map(hourType => {
      const badges = [];
      if (hourType.is_default) badges.push('<span class="ts-hour-type-badge default">Default</span>');
      if (hourType.contributes_to_income) badges.push('<span class="ts-hour-type-badge income">Income</span>');
      if (hourType.use_for_rate_calculation) badges.push('<span class="ts-hour-type-badge rate-calc">Rate calculation</span>');
      if (hourType.auto_populate_public_holidays) {
        const hoursValue = Number(hourType.auto_populate_hours) || 0;
        const hoursLabel = hoursValue % 1 === 0 ? hoursValue.toFixed(0) : hoursValue.toFixed(2).replace(/0$/, '');
        badges.push(`<span class="ts-hour-type-badge holiday">Public holiday auto (${hoursLabel}h)</span>`);
      }

      const isWork = hourType.slug === 'work';

      return `
        <div class="ts-hour-type-item ${isWork ? 'work' : ''}" data-id="${hourType.id}">
          <div class="ts-hour-type-color" style="background-color: ${hourType.color}"></div>
          <div class="ts-hour-type-info">
            <h4 class="ts-hour-type-name">${hourType.name}${isWork ? ' (Built-in)' : ''}</h4>
            <p class="ts-hour-type-details">Slug: ${hourType.slug}</p>
            <div class="ts-hour-type-badges">${badges.join('')}</div>
          </div>
          <div class="ts-hour-type-actions">
            <button class="ghost small" onclick="editHourType('${hourType.id}')">Edit</button>
            <button class="ghost small danger" onclick="deleteHourType('${hourType.id}')" ${isWork ? 'style="display:none;"' : ''}>Delete</button>
          </div>
        </div>
      `;
    }).join('');

    container.innerHTML = html;
    hourTypesContainerElement = container;
    ensureHourTypeReorderHandlers(container);
    container.querySelectorAll('.ts-hour-type-item[data-id]').forEach((item) => {
      item.setAttribute('draggable', 'true');
      item.addEventListener('dragstart', handleHourTypeDragStart);
      item.addEventListener('dragend', handleHourTypeDragEnd);
    });
  }

  let hourTypeOrderInFlight = false;
  let hourTypesContainerElement = null;
  const hourTypeDragState = { dragging: null };

  function ensureHourTypeReorderHandlers(container) {
    if (!container || container.dataset.hourReorderAttached === 'true') return;
    container.dataset.hourReorderAttached = 'true';
    container.addEventListener('dragover', handleHourTypeDragOver);
    container.addEventListener('drop', handleHourTypeDrop);
  }

  function handleHourTypeDragStart(event) {
    const target = event.target.closest('.ts-hour-type-item[data-id]');
    if (!target || hourTypeOrderInFlight) {
      event.preventDefault();
      return;
    }
    hourTypeDragState.dragging = target;
    target.classList.add('ts-dragging');
    if (event.dataTransfer) {
      event.dataTransfer.effectAllowed = 'move';
    }
  }

  function handleHourTypeDragEnd() {
    if (hourTypeDragState.dragging) {
      hourTypeDragState.dragging.classList.remove('ts-dragging');
    }
    hourTypeDragState.dragging = null;
  }

  function handleHourTypeDragOver(event) {
    if (!hourTypeDragState.dragging || !hourTypesContainerElement) return;
    event.preventDefault();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = 'move';
    }
    const target = event.target.closest('.ts-hour-type-item[data-id]');
    if (!target || target === hourTypeDragState.dragging) return;
    const rect = target.getBoundingClientRect();
    const midpoint = rect.top + rect.height / 2;
    const insertBefore = event.clientY < midpoint ? target : target.nextElementSibling;
    hourTypesContainerElement.insertBefore(hourTypeDragState.dragging, insertBefore);
  }

  function handleHourTypeDrop(event) {
    if (!hourTypeDragState.dragging || !hourTypesContainerElement) return;
    event.preventDefault();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = 'move';
    }
    const container = hourTypesContainerElement;
    if (hourTypeDragState.dragging.parentElement !== container) {
      container.appendChild(hourTypeDragState.dragging);
    }
    const orderIds = Array.from(container.querySelectorAll('.ts-hour-type-item[data-id]')).map(el => el.dataset.id);
    finalizeHourTypeOrder(orderIds);
    hourTypeDragState.dragging.classList.remove('ts-dragging');
    hourTypeDragState.dragging = null;
  }

  function finalizeHourTypeOrder(orderIds) {
    if (!orderIds || !orderIds.length) return;
    const previousOrder = state.hourTypes.map((item) => item.id);
    if (previousOrder.length === orderIds.length && orderIds.every((id, idx) => id === previousOrder[idx])) {
      return;
    }
    state.hourTypes = reorderByIds(state.hourTypes, orderIds);
    state.hourTypes.forEach((item, idx) => {
      item.display_order = idx + 1;
    });
    persistHourTypeOrder(orderIds, previousOrder);
  }

  function persistHourTypeOrder(orderIds, previousOrder) {
    if (hourTypeOrderInFlight || !orderIds.length) return;
    hourTypeOrderInFlight = true;
    setStatus('Saving hour type order...', 'warn');
    const previousCopy = previousOrder.slice();
    google.script.run
      .withSuccessHandler(() => {
        hourTypeOrderInFlight = false;
        setStatus('Hour type order saved', 'success');
        saveCache();
        renderHourTypes();

        // Refresh all hour type dropdowns immediately
        populateHourTypeOptions();
        if (defaultHourTypeSelect) populateDefaultHourTypeOptions(defaultHourTypeSelect);
        if (editDefaultHourTypeSelect) populateDefaultHourTypeOptions(editDefaultHourTypeSelect);
        if (invoiceLineHourTypeSelect) populateInvoiceHourTypeOptions(invoiceLineHourTypeSelect);
        if (invoiceDefaultHourTypeSelect) populateInvoiceHourTypeOptions(invoiceDefaultHourTypeSelect);
        if (recurringHourTypeSelect) populateRecurringHourTypeOptions();
      })
      .withFailureHandler(() => {
        hourTypeOrderInFlight = false;
        state.hourTypes = reorderByIds(state.hourTypes, previousCopy);
        state.hourTypes.forEach((item, idx) => {
          item.display_order = idx + 1;
        });
        saveCache();
        renderHourTypes();
        setStatus('Failed to save hour type order', 'error');
      })
      .api_reorderHourTypes({ order: orderIds });
  }

  function loadPublicHolidays(renderAfterLoad = false) {
    if (!state.featureFlags.enable_public_holidays || !state.featureFlags.enable_public_holidays.enabled) {
      return Promise.resolve(false);
    }

    ensureCalendarState();
    const year = state.calendar.year;

    return new Promise((resolve) => {
      google.script.run
        .withSuccessHandler((holidays) => {
          const newHolidays = Array.isArray(holidays) ? holidays : [];
          // Only update and re-render if data actually changed
          const oldJson = JSON.stringify(state.publicHolidays);
          const newJson = JSON.stringify(newHolidays);

          if (oldJson !== newJson) {
            state.publicHolidays = newHolidays;
            updatePublicHolidayMap();
            saveCache();
            renderCalendar();
          } else if (renderAfterLoad) {
            renderCalendar();
          }
          maybeAutoPopulatePublicHolidayEntries();
          resolve(true);
        })
        .withFailureHandler((error) => {
          console.error('Failed to load public holidays:', error);
          resolve(false);
        })
        .api_getPublicHolidays({ year });
    });
  }

  function updatePublicHolidayMap() {
    const map = {};
    state.publicHolidays.forEach(holiday => {
      const normalizedDate = normalizeHolidayDate(holiday.date);
      if (!normalizedDate) return;
      if (holiday.date !== normalizedDate) holiday.date = normalizedDate;
      map[normalizedDate] = holiday;
    });
    state.publicHolidayMap = map;
  }

  function maybeAutoPopulatePublicHolidayEntries() {
    if (state.isAutoPopulatingPublicHolidays) return;
    if (!state.entriesLoaded) return;
    const publicHolidayFeature = getFeatureFlag('enable_public_holidays');
    const hourTypesFeature = getFeatureFlag('hour_types');
    if (!publicHolidayFeature || !hourTypesFeature) return;
    if (!state.publicHolidays.length || !state.hourTypes.length) return;

    const eligibleHourTypes = state.hourTypes.filter(ht => ht.auto_populate_public_holidays && Number(ht.auto_populate_hours) > 0);
    if (!eligibleHourTypes.length) return;

    const entryKeys = new Set(state.entries.map(entry => `${entry.date}__${entry.hour_type_id || getDefaultHourTypeId()}`));

    const queue = [];
    state.publicHolidays.forEach(holiday => {
      const iso = normalizeHolidayDate(holiday.date);
      if (!iso) return;
      const dateObj = parseIsoDate(iso);
      if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) return;
      const day = dateObj.getDay();
      if (day === 0 || day === 6) return; // Skip weekends

      eligibleHourTypes.forEach(hourType => {
        if (hourType.requires_contract) return;
        const key = `${iso}__${hourType.id}`;
        if (entryKeys.has(key)) return;
        entryKeys.add(key);
        queue.push({
          date: iso,
          hourTypeId: hourType.id,
          hours: Number(hourType.auto_populate_hours) || 0
        });
      });
    });

    if (!queue.length) return;

    state.isAutoPopulatingPublicHolidays = true;
    processHolidayAutoPopulateQueue(queue, []);
  }

  function buildHolidayPunches(minutes) {
    const total = Math.max(0, Math.round(Number(minutes) || 0));
    if (!total) return [];
    const capped = Math.min(total, (24 * 60) - 1); // stay within day
    const hours = Math.floor(capped / 60);
    const mins = capped % 60;
    const pad = (n) => (n < 10 ? `0${n}` : String(n));
    return [{ in: '00:00', out: `${pad(hours)}:${pad(mins)}` }];
  }

  function processHolidayAutoPopulateQueue(queue, createdEntries) {
    if (!queue.length) {
      if (createdEntries.length) {
        createdEntries.forEach(entry => {
          state.entries.push(entry);
          recordPendingEntryAdd(entry);
          if (!entriesSyncInFlight) resolvePendingEntryAdd(entry.id);
        });
        state.entries.sort(entrySort);
        saveCache();
        renderEntries();
        updateTabStates();
      }
      state.isAutoPopulatingPublicHolidays = false;
      return;
    }

    const next = queue.shift();
    const minutes = Math.round(next.hours * 60);
    if (!minutes || minutes <= 0) {
      processHolidayAutoPopulateQueue(queue, createdEntries);
      return;
    }

    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success && res.entry) {
          const sanitized = sanitizeEntry(res.entry);
          createdEntries.push(sanitized);
        }
        processHolidayAutoPopulateQueue(queue, createdEntries);
      })
      .withFailureHandler((error) => {
        processHolidayAutoPopulateQueue(queue, createdEntries);
      })
      .api_addEntry({
        date: next.date,
        duration_minutes: minutes,
        entry_type: 'basic',
        hour_type_id: next.hourTypeId,
        contract_id: '',
        punches: buildHolidayPunches(minutes)
      });
  }

  function showHourTypeModal(hourType = null) {
    const modal = document.getElementById('modal-hour-type');
    const title = document.getElementById('hour-type-modal-title');
    const nameInput = document.getElementById('hour-type-name');
    const slugInput = document.getElementById('hour-type-slug');
    const colorInput = document.getElementById('hour-type-color');
    const contributesInput = document.getElementById('hour-type-contributes-income');
    const defaultInput = document.getElementById('hour-type-is-default');
    const rateCalcInput = document.getElementById('hour-type-use-for-rate-calc');

    if (!modal) return;

    state.editingHourTypeId = hourType ? hourType.id : null;
    const isWork = hourType && hourType.slug === 'work';
    const publicHolidayFlag = getFeatureFlag('enable_public_holidays');

    title.textContent = isWork ? 'Work Hour Type Settings' : (hourType ? 'Edit Hour Type' : 'Add Hour Type');
    nameInput.value = hourType ? hourType.name : '';
    slugInput.value = hourType ? hourType.slug : '';
    colorInput.value = hourType ? hourType.color : generateRandomColor();
    contributesInput.checked = hourType ? hourType.contributes_to_income : false;
    defaultInput.checked = hourType ? hourType.is_default : false;
    if (rateCalcInput) rateCalcInput.checked = hourType ? hourType.use_for_rate_calculation : false;

    if (hourTypeAutoHolidayToggle) {
      hourTypeAutoHolidayToggle.checked = hourType ? !!hourType.auto_populate_public_holidays : false;
      hourTypeAutoHolidayToggle.disabled = !publicHolidayFlag;
    }
    if (hourTypeAutoHolidayHoursInput) {
      const hoursValue = hourType && Number(hourType.auto_populate_hours) > 0 ? Number(hourType.auto_populate_hours) : 7.5;
      hourTypeAutoHolidayHoursInput.value = hoursValue;
    }
    if (hourTypeAutoHolidayRow) {
      hourTypeAutoHolidayRow.style.display = publicHolidayFlag ? 'flex' : 'none';
    }
    if (!publicHolidayFlag && hourTypeAutoHolidayHoursRow) {
      hourTypeAutoHolidayHoursRow.style.display = 'none';
    } else {
      syncHourTypeHolidayHoursVisibility();
    }

    // Disable editing core properties of work hour type
    nameInput.disabled = isWork;
    slugInput.disabled = isWork;
    contributesInput.disabled = isWork;

    // For work hour type, only allow changing default status and color
    if (isWork) {
      nameInput.style.opacity = '0.6';
      slugInput.style.opacity = '0.6';
      contributesInput.parentElement.style.opacity = '0.6';
    } else {
      nameInput.style.opacity = '1';
      slugInput.style.opacity = '1';
      contributesInput.parentElement.style.opacity = '1';
    }

    modal.style.display = 'flex';

    // Validate color when modal opens
    setTimeout(function() {
      if (typeof validateHourTypeColor === 'function') {
        validateHourTypeColor();
      }
    }, 50);
  }

  function hideHourTypeModal() {
    const modal = document.getElementById('modal-hour-type');
    if (modal) modal.style.display = 'none';
    state.editingHourTypeId = null;
  }

  function saveHourType() {
    const nameInput = document.getElementById('hour-type-name');
    const slugInput = document.getElementById('hour-type-slug');
    const colorInput = document.getElementById('hour-type-color');
    const contributesInput = document.getElementById('hour-type-contributes-income');
    const defaultInput = document.getElementById('hour-type-is-default');
    const rateCalcInput = document.getElementById('hour-type-use-for-rate-calc');
    const saveBtn = document.getElementById('btn-save-hour-type');

    const name = nameInput.value.trim();
    const slug = slugInput.value.trim().toLowerCase();
    const color = colorInput.value;
    const contributesToIncome = contributesInput.checked;
    const isDefault = defaultInput.checked;
    const useForRateCalc = rateCalcInput ? rateCalcInput.checked : false;

    if (!name || !slug) {
      customAlert('Name and slug are required');
      return;
    }

    // Check slug uniqueness
    const existingType = state.hourTypes.find(ht => ht.slug === slug && ht.id !== state.editingHourTypeId);
    if (existingType) {
      customAlert('A hour type with this slug already exists');
      return;
    }

    const publicHolidayFeatureEnabled = getFeatureFlag('enable_public_holidays');
    const autoPopulateHolidays = publicHolidayFeatureEnabled && hourTypeAutoHolidayToggle && hourTypeAutoHolidayToggle.checked;
    let autoHolidayHours = hourTypeAutoHolidayHoursInput ? parseFloat(hourTypeAutoHolidayHoursInput.value) : 7.5;
    if (Number.isNaN(autoHolidayHours) || autoHolidayHours < 0) autoHolidayHours = 0;
    if (autoPopulateHolidays && autoHolidayHours <= 0) {
      customAlert('Please enter a positive number of hours to apply on public holidays.');
      return;
    }

    saveBtn.textContent = 'Saving...';
    saveBtn.disabled = true;

    const data = {
      name,
      slug,
      color,
      contributes_to_income: contributesToIncome,
      is_default: isDefault,
      use_for_rate_calculation: useForRateCalc,
      auto_populate_public_holidays: autoPopulateHolidays,
      auto_populate_hours: autoPopulateHolidays ? autoHolidayHours : 0
    };

    if (state.editingHourTypeId) {
      // Optimistically update the UI if setting as default
      if (isDefault) {
        // Unset default on all other hour types if setting as default
        state.hourTypes.forEach(ht => {
          if (ht.id !== state.editingHourTypeId) {
            ht.is_default = false;
          }
        });
        // Update this hour type
        const index = state.hourTypes.findIndex(ht => ht.id === state.editingHourTypeId);
        if (index !== -1) {
          state.hourTypes[index] = {
            ...state.hourTypes[index],
            name,
            slug,
            color,
            contributes_to_income: contributesToIncome,
            is_default: isDefault,
            use_for_rate_calculation: useForRateCalc,
            auto_populate_public_holidays: autoPopulateHolidays,
            auto_populate_hours: autoPopulateHolidays ? autoHolidayHours : 0
          };
        }
        updateHourTypeMap();
        renderHourTypes();
      }

      // Update existing
      google.script.run
        .withSuccessHandler((result) => {
          const index = state.hourTypes.findIndex(ht => ht.id === state.editingHourTypeId);
          if (index !== -1) {
            state.hourTypes[index] = sanitizeHourType(result);
          }
          updateHourTypeMap();
          renderHourTypes();
          updateHourTypeFormVisibility();
          renderCalendarFilters();
          renderCalendar();
          saveCache();
          maybeAutoPopulatePublicHolidayEntries();
          hideHourTypeModal();
          setStatus('Hour type updated');
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .withFailureHandler((error) => {
          console.error('Failed to update hour type:', error);
          customAlert('Failed to update hour type: ' + error.message, { title: 'Error' });
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
          // Reload hour types to revert optimistic update
          loadHourTypes();
        })
        .api_updateHourType(state.editingHourTypeId, data);
    } else {
      // Create new
      google.script.run
        .withSuccessHandler((result) => {
          const newHourType = sanitizeHourType(result);
          state.hourTypes.push(newHourType);

          // Add new hour type to calendar filter so it's immediately visible
          if (state.calendarFilteredHourTypes) {
            state.calendarFilteredHourTypes.push(newHourType.id);
          }

          updateHourTypeMap();
          renderHourTypes();
          updateHourTypeFormVisibility();
          renderCalendarFilters();
          renderCalendar();
          saveCache();
          maybeAutoPopulatePublicHolidayEntries();
          hideHourTypeModal();
          setStatus('Hour type created');
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .withFailureHandler((error) => {
          console.error('Failed to create hour type:', error);
          customAlert('Failed to create hour type: ' + error.message, { title: 'Error' });
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .api_createHourType(data);
    }
  }

  function editHourType(id) {
    const hourType = state.hourTypes.find(ht => ht.id === id);
    if (hourType) {
      showHourTypeModal(hourType);
    }
  }

  function deleteHourType(id) {
    const hourType = state.hourTypes.find(ht => ht.id === id);
    if (!hourType) return;

    const modal = document.getElementById('modal-delete-hour-type');
    const nameSpan = document.getElementById('delete-hour-type-name');

    if (!modal || !nameSpan) return;

    nameSpan.textContent = hourType.name;
    modal.style.display = 'flex';

    // Store the ID for the confirm handler
    modal.dataset.hourTypeId = id;
  }

  function confirmDeleteHourType() {
    const modal = document.getElementById('modal-delete-hour-type');
    const confirmBtn = document.getElementById('btn-confirm-delete-hour-type');
    const id = modal.dataset.hourTypeId;

    if (!id) return;

    confirmBtn.textContent = 'Deleting...';
    confirmBtn.disabled = true;

    google.script.run
      .withSuccessHandler(() => {
        state.hourTypes = state.hourTypes.filter(ht => ht.id !== id);

        // Remove from calendar filter
        if (state.calendarFilteredHourTypes) {
          state.calendarFilteredHourTypes = state.calendarFilteredHourTypes.filter(htId => htId !== id);
        }

        updateHourTypeMap();
        renderHourTypes();
        updateHourTypeFormVisibility();
        renderCalendarFilters();
        renderCalendar();
        saveCache();
        modal.style.display = 'none';
        setStatus('Hour type deleted');
        confirmBtn.textContent = 'Delete Hour Type';
        confirmBtn.disabled = false;
      })
      .withFailureHandler((error) => {
        console.error('Failed to delete hour type:', error);
        customAlert('Failed to delete hour type: ' + error.message, { title: 'Error' });
        confirmBtn.textContent = 'Delete Hour Type';
        confirmBtn.disabled = false;
      })
      .api_deleteHourType(id);
  }

  // Hour Types Event Listeners
  const btnAddHourType = document.getElementById('btn-add-hour-type');
  const btnSaveHourType = document.getElementById('btn-save-hour-type');
  const btnCancelHourType = document.getElementById('btn-cancel-hour-type');
  const btnConfirmDeleteHourType = document.getElementById('btn-confirm-delete-hour-type');
  const btnCancelDeleteHourType = document.getElementById('btn-cancel-delete-hour-type');

  if (btnAddHourType) {
    btnAddHourType.addEventListener('click', () => showHourTypeModal());
  }

  if (btnSaveHourType) {
    btnSaveHourType.addEventListener('click', saveHourType);
  }

  if (btnCancelHourType) {
    btnCancelHourType.addEventListener('click', hideHourTypeModal);
  }

  if (btnConfirmDeleteHourType) {
    btnConfirmDeleteHourType.addEventListener('click', confirmDeleteHourType);
  }

  if (btnCancelDeleteHourType) {
    btnCancelDeleteHourType.addEventListener('click', () => {
      document.getElementById('modal-delete-hour-type').style.display = 'none';
    });
  }

  // Custom Theme Event Listeners
  const btnConfigureTheme = document.getElementById('btn-configure-theme');
  const btnSaveCustomTheme = document.getElementById('btn-save-custom-theme');
  const btnCancelCustomTheme = document.getElementById('btn-cancel-custom-theme');
  const modalCustomTheme = document.getElementById('modal-custom-theme');
  const customThemeInputs = {
    bg: document.getElementById('custom-theme-bg'),
    panel: document.getElementById('custom-theme-panel'),
    primary: document.getElementById('custom-theme-primary'),
    success: document.getElementById('custom-theme-success'),
    warning: document.getElementById('custom-theme-warning'),
    danger: document.getElementById('custom-theme-danger'),
    text: document.getElementById('custom-theme-text'),
    muted: document.getElementById('custom-theme-muted')
  };
  const customThemePreview = document.getElementById('custom-theme-preview');
  const customThemeValidation = document.getElementById('custom-theme-validation');

  function readCustomThemeInputs() {
    return {
      bg: customThemeInputs.bg ? customThemeInputs.bg.value : CUSTOM_THEME_DEFAULTS.bg,
      panel: customThemeInputs.panel ? customThemeInputs.panel.value : '',
      primary: customThemeInputs.primary ? customThemeInputs.primary.value : '',
      success: customThemeInputs.success ? customThemeInputs.success.value : '',
      warning: customThemeInputs.warning ? customThemeInputs.warning.value : '',
      danger: customThemeInputs.danger ? customThemeInputs.danger.value : '',
      text: customThemeInputs.text ? customThemeInputs.text.value : '',
      muted: customThemeInputs.muted ? customThemeInputs.muted.value : ''
    };
  }

  function validateCustomThemeConfig(config) {
    var normalized = normalizeCustomThemeConfig(config);
    var issues = [];

    var bgContrast = getContrastRatio(normalized.bg, normalized.text);
    if (bgContrast < 4.5) {
      issues.push({
        level: 'error',
        message: 'Background and text contrast is ' + formatContrast(bgContrast) + ':1 (needs 4.5:1).'
      });
    }

    var panelContrast = getContrastRatio(normalized.panel, normalized.text);
    if (panelContrast < 4.5) {
      issues.push({
        level: 'error',
        message: 'Surface and text contrast is ' + formatContrast(panelContrast) + ':1 (needs 4.5:1).'
      });
    }

    var primaryContrast = getContrastRatio(normalized.primary, '#ffffff');
    if (primaryContrast < 4.5) {
      issues.push({
        level: primaryContrast < 3 ? 'error' : 'warning',
        message: 'Primary buttons contrast with white text is ' + formatContrast(primaryContrast) + ':1.'
      });
    }

    var successContrast = getContrastRatio(normalized.success, normalized.panel);
    if (successContrast < 3) {
      issues.push({
        level: 'warning',
        message: 'Success text on surfaces may be low contrast (' + formatContrast(successContrast) + ':1).'
      });
    }

    var warningContrast = getContrastRatio(normalized.warning, normalized.panel);
    if (warningContrast < 3) {
      issues.push({
        level: 'warning',
        message: 'Warning text on surfaces may be low contrast (' + formatContrast(warningContrast) + ':1).'
      });
    }

    var dangerContrast = getContrastRatio(normalized.danger, normalized.panel);
    if (dangerContrast < 3) {
      issues.push({
        level: 'warning',
        message: 'Danger text on surfaces may be low contrast (' + formatContrast(dangerContrast) + ':1).'
      });
    }

    return {
      normalized,
      issues,
      hasErrors: issues.some(function(issue) { return issue.level === 'error'; })
    };
  }

  function renderCustomThemeValidation(validation) {
    if (!customThemeValidation) return;
    if (!validation.issues.length) {
      customThemeValidation.style.display = 'none';
      customThemeValidation.textContent = '';
      return;
    }

    customThemeValidation.style.display = 'block';
    customThemeValidation.style.color = validation.hasErrors ? 'var(--danger)' : 'var(--warning)';
    customThemeValidation.innerHTML = validation.issues.map(function(issue) {
      return issue.message;
    }).join('<br/>');
  }

  function updateCustomThemePreview() {
    var inputConfig = readCustomThemeInputs();
    var validation = validateCustomThemeConfig(inputConfig);

    if (customThemePreview) {
      var themeVars = generateCustomTheme(validation.normalized);
      Object.keys(themeVars).forEach(function(token) {
        customThemePreview.style.setProperty(token, themeVars[token]);
      });
    }

    renderCustomThemeValidation(validation);

    if (btnSaveCustomTheme) {
      btnSaveCustomTheme.disabled = validation.hasErrors;
    }

    return validation;
  }

  function showCustomThemeModal() {
    if (!modalCustomTheme) return;

    var config = normalizeCustomThemeConfig(state.settings.custom_theme_config);

    Object.keys(customThemeInputs).forEach(function(key) {
      var input = customThemeInputs[key];
      if (input && config[key]) {
        input.value = config[key];
      } else if (input && CUSTOM_THEME_DEFAULTS[key]) {
        input.value = CUSTOM_THEME_DEFAULTS[key];
      }
    });

    if (btnSaveCustomTheme) {
      btnSaveCustomTheme.disabled = false;
    }

    updateCustomThemePreview();
    modalCustomTheme.style.display = 'flex';
  }

  function hideCustomThemeModal() {
    if (modalCustomTheme) {
      modalCustomTheme.style.display = 'none';
    }
    if (btnSaveCustomTheme) {
      btnSaveCustomTheme.disabled = false;
    }
  }

  function saveCustomTheme() {
    var validation = updateCustomThemePreview() || { normalized: readCustomThemeInputs(), hasErrors: false };
    if (validation.hasErrors) {
      showNotification('Fix the highlighted contrast issues before saving.', 'danger');
      return;
    }

    var normalized = validation.normalized;
    state.settings.custom_theme_config = normalized;
    applyCustomTheme();

    google.script.run
      .withSuccessHandler(function() {
        showNotification('Custom theme saved successfully', 'success');
        hideCustomThemeModal();
      })
      .withFailureHandler(function(error) {
        showNotification('Failed to save custom theme: ' + error.message, 'danger');
      })
      .api_updateSettings({
        custom_theme_config: JSON.stringify(normalized)
      });
  }

  if (btnConfigureTheme) {
    btnConfigureTheme.addEventListener('click', showCustomThemeModal);
  }

  if (btnSaveCustomTheme) {
    btnSaveCustomTheme.addEventListener('click', saveCustomTheme);
  }

  if (btnCancelCustomTheme) {
    btnCancelCustomTheme.addEventListener('click', hideCustomThemeModal);
  }

  Object.keys(customThemeInputs).forEach(function(key) {
    var input = customThemeInputs[key];
    if (input) {
      input.addEventListener('input', updateCustomThemePreview);
    }
  });

  if (modalCustomTheme) {
    modalCustomTheme.addEventListener('click', function(e) {
      if (e.target === modalCustomTheme) {
        hideCustomThemeModal();
      }
    });

    const closeBtn = modalCustomTheme.querySelector('.ts-modal-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', hideCustomThemeModal);
    }
  }

  // Super Guarantee Rates Modal
  const btnSuperGuaranteeRates = document.getElementById('btn-super-guarantee-rates');
  const btnSaveSuperRates = document.getElementById('btn-save-super-rates');
  const btnCancelSuperRates = document.getElementById('btn-cancel-super-rates');
  const btnAddSuperRate = document.getElementById('btn-add-super-rate');
  const modalSuperGuaranteeRates = document.getElementById('modal-super-guarantee-rates');
  const superRatesList = document.getElementById('super-rates-list');

  let superRatesWorkingCopy = [];

  function loadSuperGuaranteeRates() {
    google.script.run
      .withSuccessHandler(function(rates) {
        superRatesWorkingCopy = JSON.parse(JSON.stringify(rates || []));
        cacheSuperGuaranteeRates(rates);
        renderSuperRatesList();
      })
      .withFailureHandler(function(error) {
        showNotification('Failed to load super guarantee rates: ' + error.message, 'danger');
      })
      .api_getSuperGuaranteeRates();
  }

  function detectOverlappingRates(rates) {
    const overlapping = new Set();
    for (let i = 0; i < rates.length; i++) {
      for (let j = i + 1; j < rates.length; j++) {
        const rate1 = rates[i];
        const rate2 = rates[j];
        const start1 = rate1.start_date;
        const end1 = rate1.end_date || '9999-12-31';
        const start2 = rate2.start_date;
        const end2 = rate2.end_date || '9999-12-31';

        // Check if date ranges overlap
        if (start1 <= end2 && start2 <= end1) {
          overlapping.add(i);
          overlapping.add(j);
        }
      }
    }
    return overlapping;
  }

  function renderSuperRatesList() {
    if (!superRatesList) return;

    // Sort by start date descending (most recent first)
    const sorted = [...superRatesWorkingCopy].sort((a, b) => {
      return (b.start_date || '').localeCompare(a.start_date || '');
    });

    const overlapping = detectOverlappingRates(sorted);
    const noEndDateCount = sorted.filter(r => !r.end_date).length;

    superRatesList.innerHTML = '';

    sorted.forEach((rate, index) => {
      const hasOverlap = overlapping.has(index);
      const rateDiv = document.createElement('div');
      rateDiv.style.cssText = 'display:grid; grid-template-columns: auto 1fr 1fr 1fr auto; gap:8px; align-items:center; padding:8px; border:1px solid var(--border-color); border-radius:4px;';

      // Warning icon
      const warnIcon = document.createElement('span');
      if (hasOverlap) {
        warnIcon.textContent = '';
        warnIcon.title = 'This rate overlaps with another rate';
        warnIcon.style.cursor = 'help';
      }
      rateDiv.appendChild(warnIcon);

      // Start date
      const startInput = document.createElement('input');
      startInput.type = 'date';
      startInput.value = rate.start_date || '';
      startInput.style.cssText = 'padding:4px;';
      startInput.addEventListener('change', function() {
        rate.start_date = this.value;
        renderSuperRatesList(); // Re-render to update overlaps and sorting
      });
      rateDiv.appendChild(startInput);

      // End date
      const endInput = document.createElement('input');
      endInput.type = 'date';
      endInput.value = rate.end_date || '';
      endInput.placeholder = 'No end date';
      endInput.style.cssText = 'padding:4px;';
      endInput.addEventListener('change', function() {
        rate.end_date = this.value || null;
        renderSuperRatesList(); // Re-render to check if multiple rates have no end date
      });
      rateDiv.appendChild(endInput);

      // Percentage
      const percentInput = document.createElement('input');
      percentInput.type = 'number';
      percentInput.value = rate.percentage ? rate.percentage.toFixed(2) : '';
      percentInput.placeholder = '12.00';
      percentInput.step = '0.01';
      percentInput.min = '0';
      percentInput.style.cssText = 'padding:4px;';
      percentInput.addEventListener('change', function() {
        const val = parseFloat(this.value) || 0;
        rate.percentage = parseFloat(val.toFixed(2));
        this.value = rate.percentage.toFixed(2);
      });
      rateDiv.appendChild(percentInput);

      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.className = 'ghost';
      deleteBtn.style.cssText = 'padding:4px 8px; white-space:nowrap;';
      deleteBtn.addEventListener('click', function() {
        superRatesWorkingCopy = superRatesWorkingCopy.filter(r => r !== rate);
        renderSuperRatesList();
      });
      rateDiv.appendChild(deleteBtn);

      superRatesList.appendChild(rateDiv);
    });

    // Show warning if multiple rates have no end date
    if (noEndDateCount > 1) {
      const warningDiv = document.createElement('div');
      warningDiv.style.cssText = 'padding:8px; background:var(--danger-bg); color:var(--danger-text); border-radius:4px; margin-top:8px;';
      warningDiv.textContent = ` Warning: ${noEndDateCount} rates have no end date. Only one rate should be open-ended (the current rate).`;
      superRatesList.appendChild(warningDiv);
    }
  }

  function showSuperGuaranteeRatesModal() {
    if (!modalSuperGuaranteeRates) return;

    // Load rates (from cache first, then server)
    const cached = getCachedSuperGuaranteeRates();
    if (cached) {
      superRatesWorkingCopy = JSON.parse(JSON.stringify(cached));
      renderSuperRatesList();
    }

    loadSuperGuaranteeRates();
    modalSuperGuaranteeRates.style.display = 'flex';
  }

  function hideSuperGuaranteeRatesModal() {
    if (modalSuperGuaranteeRates) {
      modalSuperGuaranteeRates.style.display = 'none';
    }
  }

  function saveSuperGuaranteeRates() {
    // Validate rates
    for (const rate of superRatesWorkingCopy) {
      if (!rate.start_date) {
        showNotification('All rates must have a start date', 'danger');
        return;
      }
      if (typeof rate.percentage !== 'number' || rate.percentage < 0) {
        showNotification('All rates must have a valid percentage', 'danger');
        return;
      }
    }

    btnSaveSuperRates.disabled = true;
    btnSaveSuperRates.textContent = 'Saving...';

    google.script.run
      .withSuccessHandler(function(response) {
        btnSaveSuperRates.disabled = false;
        btnSaveSuperRates.textContent = 'Save Rates';
        showNotification('Super guarantee rates saved successfully', 'success');
        cacheSuperGuaranteeRates(response.rates);
        hideSuperGuaranteeRatesModal();
      })
      .withFailureHandler(function(error) {
        btnSaveSuperRates.disabled = false;
        btnSaveSuperRates.textContent = 'Save Rates';
        showNotification('Failed to save super guarantee rates: ' + error.message, 'danger');
      })
      .api_setSuperGuaranteeRates(superRatesWorkingCopy);
  }

  function addNewSuperRate() {
    const today = new Date().toISOString().substring(0, 10);
    const newRate = {
      start_date: today,
      end_date: null,
      percentage: 12.00
    };
    superRatesWorkingCopy.push(newRate);
    renderSuperRatesList();
  }

  if (btnSuperGuaranteeRates) {
    btnSuperGuaranteeRates.addEventListener('click', showSuperGuaranteeRatesModal);
  }

  if (btnAddSuperRate) {
    btnAddSuperRate.addEventListener('click', addNewSuperRate);
  }

  if (btnSaveSuperRates) {
    btnSaveSuperRates.addEventListener('click', saveSuperGuaranteeRates);
  }

  if (btnCancelSuperRates) {
    btnCancelSuperRates.addEventListener('click', hideSuperGuaranteeRatesModal);
  }

  // Close modal when clicking outside
  if (modalSuperGuaranteeRates) {
    modalSuperGuaranteeRates.addEventListener('click', function(e) {
      if (e.target === modalSuperGuaranteeRates) {
        hideSuperGuaranteeRatesModal();
      }
    });

    // Close modal on X button
    const closeBtnSuper = modalSuperGuaranteeRates.querySelector('.ts-modal-close');
    if (closeBtnSuper) {
      closeBtnSuper.addEventListener('click', hideSuperGuaranteeRatesModal);
    }
  }

  // Auto-generate slug from name
  const hourTypeNameInput = document.getElementById('hour-type-name');
  const hourTypeSlugInput = document.getElementById('hour-type-slug');
  const hourTypeAutoHolidayRow = document.getElementById('hour-type-holiday-toggle-row');
  const hourTypeAutoHolidayHoursRow = document.getElementById('hour-type-holiday-hours-row');
  const hourTypeAutoHolidayToggle = document.getElementById('hour-type-auto-public-holidays');
  const hourTypeAutoHolidayHoursInput = document.getElementById('hour-type-holiday-hours');

  function syncHourTypeHolidayHoursVisibility() {
    if (!hourTypeAutoHolidayHoursRow) return;
    const shouldShow = hourTypeAutoHolidayToggle && hourTypeAutoHolidayToggle.checked;
    hourTypeAutoHolidayHoursRow.style.display = shouldShow ? 'flex' : 'none';
  }

  if (hourTypeNameInput && hourTypeSlugInput) {
    hourTypeNameInput.addEventListener('input', () => {
      if (!state.editingHourTypeId) { // Only auto-generate for new hour types
        const slug = hourTypeNameInput.value
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .replace(/^-|-$/g, '');
        hourTypeSlugInput.value = slug;
      }
    });
  }

  if (hourTypeAutoHolidayToggle) {
    hourTypeAutoHolidayToggle.addEventListener('change', syncHourTypeHolidayHoursVisibility);
  }

  // Colorblind color validation
  function isColorProblematicForColorblindness(hexColor) {
    // Convert hex to RGB
    var r = parseInt(hexColor.substr(1, 2), 16);
    var g = parseInt(hexColor.substr(3, 2), 16);
    var b = parseInt(hexColor.substr(5, 2), 16);

    // Problematic colors for colorblindness are typically:
    // 1. Pure or near-pure reds (high R, low G and B)
    // 2. Pure or near-pure greens (high G, low R and B)
    // 3. Red-green combinations or similar values for R and G with low B
    // 4. Browns and muddy colors (R and G similar, relatively low B)

    var maxComponent = Math.max(r, g, b);
    var minComponent = Math.min(r, g, b);
    var range = maxComponent - minComponent;

    // Pure or near-pure red
    if (r > 150 && g < 100 && b < 100) return true;

    // Pure or near-pure green
    if (g > 150 && r < 100 && b < 100) return true;

    // Red-green similar with low blue (brown/muddy colors)
    if (Math.abs(r - g) < 50 && r > 80 && g > 80 && b < 100) return true;

    // Low saturation colors in the red-green range
    if (range < 60 && r > 60 && g > 60 && Math.abs(r - g) < 40) return true;

    return false;
  }

  function validateHourTypeColor() {
    var colorblindFlag = state.featureFlags.enable_colorblind_themes || DEFAULT_FEATURE_FLAGS.enable_colorblind_themes || { enabled: false };
    if (!colorblindFlag.enabled) return;

    var colorInput = document.getElementById('hour-type-color');
    var warningEl = document.getElementById('hour-type-color-warning');

    if (!colorInput || !warningEl) return;

    var color = colorInput.value;
    var isProblematic = isColorProblematicForColorblindness(color);

    warningEl.style.display = isProblematic ? 'flex' : 'none';
  }

  var hourTypeColorInput = document.getElementById('hour-type-color');
  if (hourTypeColorInput) {
    hourTypeColorInput.addEventListener('input', validateHourTypeColor);
    hourTypeColorInput.addEventListener('change', validateHourTypeColor);
  }

  // Close modals when clicking close button or outside
  document.addEventListener('click', (event) => {
    if (event.target.classList.contains('ts-modal-close')) {
      const modal = event.target.closest('.ts-modal');
      if (modal) {
        modal.style.display = 'none';
        if (modal === modalDeductionCategories) hideDeductionCategoryForm();
      }
    }
    if (event.target.classList.contains('ts-modal')) {
      event.target.style.display = 'none';
      if (event.target === modalDeductionCategories) hideDeductionCategoryForm();
    }
  });

  // Hour Type Form Management
  function updateHourTypeFormVisibility() {
    const hourTypesEnabled = !!(state.featureFlags.hour_types && state.featureFlags.hour_types.enabled);
    const hasMultipleTypes = state.hourTypes.length > 1;
    const shouldShow = hourTypesEnabled && hasMultipleTypes;

    if (manualHourTypeCol) {
      manualHourTypeCol.style.display = shouldShow ? 'block' : 'none';
    }
    if (punchHourTypeCol) {
      punchHourTypeCol.style.display = shouldShow ? 'block' : 'none';
    }

    if (shouldShow) {
      populateHourTypeOptions();
    }
    updateRecurringHourTypeVisibility();
    refreshDefaultHourTypeControls();
  }

  function populateHourTypeOptions() {
    if (!state.hourTypes.length) return;

    [manualHourType, punchHourType].forEach(select => {
      if (!select) return;

      const currentValue = select.value;
      select.innerHTML = '';

      state.hourTypes.forEach(hourType => {
        const option = document.createElement('option');
        option.value = hourType.id;
        option.textContent = hourType.name;
        if (hourType.is_default && !currentValue) {
          option.selected = true;
        }
        select.appendChild(option);
      });

      // Restore previous selection if it still exists
      if (currentValue && state.hourTypeMap[currentValue]) {
        select.value = currentValue;
      }

      // Update contract visibility when hour type changes
      if (select === manualHourType) {
        updateManualContractVisibility();
      } else if (select === punchHourType) {
        updatePunchContractVisibility();
      }
    });
  }

  function updateManualContractVisibility() {
    if (!manualHourType || !manualContract) return;

    const selectedHourType = state.hourTypeMap[manualHourType.value];
    if (selectedHourType && !selectedHourType.requires_contract) {
      // Show "Not required" for non-contract hour types
      manualContract.innerHTML = '<option value="">Not required (optional)</option>';
      const validContracts = validContractsForDate(manualDate ? manualDate.value : todayIso());
      validContracts.forEach(contract => {
        const option = document.createElement('option');
        option.value = contract.id;
        option.textContent = contract.name;
        manualContract.appendChild(option);
      });
      manualContract.value = '';
      manualContract.disabled = false;
      manualContract.style.fontStyle = 'italic';
      manualContract.style.opacity = '0.8';
      if (manualContractWarning) manualContractWarning.style.display = 'none';
    } else {
      // Normal contract requirement
      manualContract.style.fontStyle = 'normal';
      manualContract.style.opacity = '1';
      updateManualContractOptions();
    }
    updateBasicSaveEnabled();
  }

  function updatePunchContractVisibility() {
    if (!punchHourType || !punchContract) return;

    const selectedHourType = state.hourTypeMap[punchHourType.value];
    if (selectedHourType && !selectedHourType.requires_contract) {
      // Show "Not required" for non-contract hour types
      punchContract.innerHTML = '<option value="">Not required (optional)</option>';
      const validContracts = validContractsForDate(punchDate ? punchDate.value : todayIso());
      validContracts.forEach(contract => {
        const option = document.createElement('option');
        option.value = contract.id;
        option.textContent = contract.name;
        punchContract.appendChild(option);
      });
      punchContract.value = '';
      punchContract.disabled = false;
      punchContract.style.fontStyle = 'italic';
      punchContract.style.opacity = '0.8';
      if (punchContractWarning) punchContractWarning.style.display = 'none';
    } else {
      // Normal contract requirement
      punchContract.style.fontStyle = 'normal';
      punchContract.style.opacity = '1';
      updatePunchContractOptions();
    }
  }

  function getDefaultHourTypeId() {
    if (!state.hourTypes.length) return null;
    const defaultType = state.hourTypes.find(ht => ht.is_default);
    return defaultType ? defaultType.id : state.hourTypes[0].id;
  }

  function findEntryForDateAndHourType(dateIso, hourTypeId) {
    if (!dateIso) return null;
    const fallbackHourTypeId = getDefaultHourTypeId();
    const targetHourTypeId = hourTypeId || fallbackHourTypeId;
    return state.entries.find(entry => {
      if (entry.date !== dateIso) return false;
      const entryHourTypeId = entry.hour_type_id || fallbackHourTypeId;
      return entryHourTypeId === targetHourTypeId;
    }) || null;
  }

  // Event listeners for hour type changes
  if (manualHourType) {
    manualHourType.addEventListener('change', () => {
      updateManualContractVisibility();
      handleManualHourTypeChange();
    });
  }

  if (punchHourType) {
    punchHourType.addEventListener('change', () => {
      updatePunchContractVisibility();
      handlePunchHourTypeChange();
    });
  }

  function handleManualHourTypeChange() {
    if (!manualHourType || !manualDate) return;

    const selectedHourTypeId = manualHourType.value || getDefaultHourTypeId();
    const currentDate = manualDate.value;

    if (!currentDate) return;

    const existingEntry = findEntryForDateAndHourType(currentDate, selectedHourTypeId);

    if (existingEntry) {
      const entryType = resolveEntryType(existingEntry);

      if (entryType === 'advanced') {
        if (punchHourType) punchHourType.value = selectedHourTypeId;
        if (punchDate) punchDate.value = currentDate;
        state.selectedCalendarDate = currentDate;
        activateTab('punch');
        return;
      }

      populateManualForm(existingEntry, true);
    } else {
      // Clear the form for new entry but keep date and hour type
      const currentHourType = manualHourType.value;
      clearManualEditing();
      if (manualDate) manualDate.value = currentDate;
      if (manualHourType) manualHourType.value = currentHourType;
      updateManualContractVisibility();
    }

    // Update tab states to enable/disable the other tab
    updateTabStates();
  }

  function handlePunchHourTypeChange() {
    if (!punchHourType || !punchDate || !punchContract) return;

    const selectedHourTypeId = punchHourType.value || getDefaultHourTypeId();
    const currentDate = punchDate.value;

    if (!currentDate) return;

    const existingEntry = findEntryForDateAndHourType(currentDate, selectedHourTypeId);

    if (existingEntry) {
      const entryType = resolveEntryType(existingEntry);

      if (entryType === 'basic') {
        if (manualDate) manualDate.value = currentDate;
        if (manualHourType) manualHourType.value = selectedHourTypeId;
        state.selectedCalendarDate = currentDate;
        activateTab('manual');
        return;
      }

      // Load the existing advanced entry
      state.editingEntryId = existingEntry.id;
      state.editingEntryType = entryType;

      if (punchContract) {
        updatePunchContractOptions(existingEntry.contract_id);
        punchContract.value = existingEntry.contract_id || '';
      }

      state.punchDraft = {
        entryId: existingEntry.id,
        contractId: existingEntry.contract_id || '',
        date: existingEntry.date,
        punches: clonePunches(existingEntry.punches || []),
        dirty: false
      };

      renderPunchDraft();
      updatePunchSummary();
    } else {
      // Clear for new entry but keep date and hour type
      const currentHourType = punchHourType.value;
      state.editingEntryId = null;
      state.editingEntryType = null;

      updatePunchContractOptions();

      state.punchDraft = {
        entryId: null,
        contractId: punchContract.value || '',
        date: currentDate,
        punches: [{ in: '', out: '' }],
        dirty: false
      };

      if (punchHourType) punchHourType.value = currentHourType;
      renderPunchDraft();
      updatePunchSummary();
    }

    updatePunchContractVisibility();

    // Update tab states to enable/disable the other tab
    updateTabStates();
  }

  // Call the main init function
  init();
</script>
