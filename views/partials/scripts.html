<script>
  // Layout navigation
  const pageTime = document.getElementById('page-time');
  const pageContracts = document.getElementById('page-contracts');
  const pageHourTypes = document.getElementById('page-hour-types');
  const pageDeductions = document.getElementById('page-deductions');
  const pageBas = document.getElementById('page-bas');
  const pageAnnualViews = document.getElementById('page-annual-views');
  const pageSettings = document.getElementById('page-settings');
  const navToggle = document.getElementById('nav-toggle');
  const navHomeBtn = document.getElementById('nav-home');
  const navMenu = document.getElementById('nav-menu');
  const navTimeBtn = document.getElementById('nav-time');
  const navContractsBtn = document.getElementById('nav-contracts');
  const navHourTypesBtn = document.getElementById('nav-hour-types');
  const navDeductionsBtn = document.getElementById('nav-deductions');
  const navBasBtn = document.getElementById('nav-bas');
  const navAnnualViewsBtn = document.getElementById('nav-annual-views');
  const navSettingsBtn = document.getElementById('nav-settings');
  const deductionsListEl = document.getElementById('deductions-list');
  const deductionsEmptyEl = document.getElementById('deductions-empty');
  const deductionCompanyDisabledNote = document.getElementById('deduction-company-disabled-note');
  const btnAddDeduction = document.getElementById('btn-add-deduction');
  const deductionCategoryReadonly = document.getElementById('deduction-category-readonly');
  const deductionFormModal = document.getElementById('modal-deduction-form');
  const deductionFormTitle = document.getElementById('deduction-form-title');
  const deductionNameInput = document.getElementById('deduction-name');
  const deductionCategorySelect = document.getElementById('deduction-category');
  const deductionTypeSelect = document.getElementById('deduction-type');
  const deductionAmountInput = document.getElementById('deduction-amount');
  const deductionPercentInput = document.getElementById('deduction-percent');
  const deductionAmountModeWrapper = document.getElementById('deduction-amount-mode-wrapper');
  const deductionAmountModeSelect = document.getElementById('deduction-amount-mode');
  const deductionAmountWrapper = document.getElementById('deduction-amount-wrapper');
  const deductionPercentWrapper = document.getElementById('deduction-percent-wrapper');
  const deductionGstWrapper = document.getElementById('deduction-gst-wrapper');
  const deductionGstToggle = document.getElementById('deduction-gst');
  const deductionCompanyGstNote = document.getElementById('deduction-company-gst-note');
  const deductionFrequencySelect = document.getElementById('deduction-frequency');
  const deductionStartDateInput = document.getElementById('deduction-start-date');
  const deductionEndDateInput = document.getElementById('deduction-end-date');
  const deductionEndDateWrapper = document.getElementById('deduction-end-date-wrapper');
  const deductionNotesInput = document.getElementById('deduction-notes');
  const deductionOccurrencePreview = document.getElementById('deduction-occurrence-preview');
  const btnCancelDeduction = document.getElementById('btn-cancel-deduction');
  const btnSaveDeduction = document.getElementById('btn-save-deduction');
  const basFySelect = document.getElementById('bas-fy-select');
  const basTableBody = document.getElementById('bas-table-body');
  const basQuarterlyNote = document.getElementById('bas-quarterly-note');
  const basEmptyNote = document.getElementById('bas-empty');

  const state = {
    cacheKey: 'ts_cache',
    entries: [],
    settings: {},
    contracts: [],
    contractMap: {},
    hourTypes: [],
    hourTypeMap: {},
    deductions: [],
    actualIncome: [],
    actualIncomeMap: {},
    editingActualIncomeId: null,
    featureFlags: {},
    publicHolidays: [],
    publicHolidayMap: {},
    editingEntryId: null,
    editingEntryType: null,
    editingContractId: null,
    editingHourTypeId: null,
    editingDeductionId: null,
    contractFormMode: 'hidden',
    calendar: null,
    selectedCalendarDate: null,
    showZeroHours: false,
    currentPage: 'time',
    incomeSummary: null,
    pendingTaxRequest: null,
    selectedContractId: '',
    punchDraft: null,
    currentTab: 'manual',
    calendarFilteredHourTypes: null,
    expectedHoursSummary: null,
    companyTrackingEnabled: false,
    companyBasQuarterly: false,
    basCurrentFy: null,
    basSubmissions: [],
    entriesLoaded: false,
    isAutoPopulatingPublicHolidays: false,
    annualYearType: 'financial',
    annualCurrentYear: null,
    annualFilteredContracts: [],
    annualData: null,
    annualCharts: {
      income: null,
      incomePie: null,
      contractPie: null,
      hourTypesPie: null,
      totalHoursPie: null,
      totalHoursByTypePie: null
    }
  };

  const deductionFormState = {
    mode: 'create',
    editingId: null,
    original: null
  };

  const PAGE_KEYS = ['time', 'contracts', 'hour-types', 'deductions', 'bas', 'annual-views', 'settings'];
  const LAST_PAGE_KEY = 'ts_last_page';

  function persistLastPage(page) {
    if (!PAGE_KEYS.includes(page)) return;
    try {
      if (state.featureFlags.remember_last_page) {
        localStorage.setItem(LAST_PAGE_KEY, page);
      } else {
        localStorage.removeItem(LAST_PAGE_KEY);
      }
    } catch (e) {}
  }

  async function showPage(target, options) {
    const opts = options || {};
    const normalized = PAGE_KEYS.includes(target) ? target : 'time';

    // Check if leaving settings page with unsaved changes
    if (state.currentPage === 'settings' && normalized !== 'settings') {
      if (typeof checkSettingsDirty === 'function' && checkSettingsDirty()) {
        const confirmed = await customConfirm(
          'You have unsaved changes in Settings. Do you want to discard them and continue?',
          {
            title: 'Unsaved Changes',
            okText: 'Discard and Continue',
            cancelText: 'Stay on Settings',
            danger: true
          }
        );
        if (!confirmed) {
          return; // Stay on settings page
        }
        // Discard changes and continue
        if (typeof resetSettingsToInitial === 'function') {
          resetSettingsToInitial();
        }
      }
    }

    const pages = {
      time: pageTime,
      contracts: pageContracts,
      'hour-types': pageHourTypes,
      deductions: pageDeductions,
      bas: pageBas,
      'annual-views': pageAnnualViews,
      settings: pageSettings
    };
    Object.keys(pages).forEach((key) => {
      const page = pages[key];
      if (page) page.style.display = key === normalized ? 'block' : 'none';
    });
    state.currentPage = normalized;
    if (normalized === 'bas') {
      renderBasReporting();
    }
    if (normalized === 'annual-views') {
      renderAnnualViews();
    }
    if (!opts.skipRemember) {
      persistLastPage(normalized);
    }
  }

  function closeNavMenu() {
    if (!navMenu) return;
    navMenu.hidden = true;
    if (navToggle) navToggle.setAttribute('aria-expanded', 'false');
  }

  function openNavMenu() {
    if (!navMenu) return;
    navMenu.hidden = false;
    if (navToggle) navToggle.setAttribute('aria-expanded', 'true');
  }

  function toggleNavMenu() {
    if (!navMenu) return;
    const expanded = navToggle && navToggle.getAttribute('aria-expanded') === 'true';
    if (expanded) {
      closeNavMenu();
    } else {
      openNavMenu();
    }
  }

  if (navToggle && navMenu) {
    navToggle.addEventListener('click', (event) => {
      event.stopPropagation();
      toggleNavMenu();
    });
  }

  if (navMenu) {
    navMenu.addEventListener('click', (event) => {
      if ((event.target instanceof HTMLElement) && event.target.tagName === 'BUTTON') {
        closeNavMenu();
      }
    });
  }

  document.addEventListener('click', (event) => {
    if (!navMenu || navMenu.hidden) return;
    if (navToggle && (event.target === navToggle || navToggle.contains(event.target))) return;
    if (navMenu.contains(event.target)) return;
    closeNavMenu();
  });

  document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') closeNavMenu();
  });

  if (navHomeBtn) {
    navHomeBtn.addEventListener('click', async () => {
      closeNavMenu();
      await showPage('time');
      if (state.currentPage !== 'time') return;

      ensureCalendarState();
      const now = new Date();
      const previousYear = state.calendar.year;
      const targetYear = now.getFullYear();
      const targetMonth = now.getMonth();
      const yearChanged = previousYear !== targetYear;
      state.calendar.year = targetYear;
      state.calendar.month = targetMonth;

      const today = todayIso();
      if (yearChanged && getFeatureFlag('enable_public_holidays')) {
        loadPublicHolidays(true);
      }
      handleCalendarClick(today);
    });
  }

  if (navTimeBtn) navTimeBtn.onclick = () => { closeNavMenu(); showPage('time'); };
  if (navContractsBtn) navContractsBtn.onclick = () => { closeNavMenu(); showPage('contracts'); };
  if (navHourTypesBtn) navHourTypesBtn.onclick = () => { closeNavMenu(); showPage('hour-types'); };
  if (navDeductionsBtn) navDeductionsBtn.onclick = () => { closeNavMenu(); showPage('deductions'); };
  if (navBasBtn) navBasBtn.onclick = () => { closeNavMenu(); showPage('bas'); };
  if (navAnnualViewsBtn) navAnnualViewsBtn.onclick = () => { closeNavMenu(); showPage('annual-views'); };
  if (navSettingsBtn) navSettingsBtn.onclick = () => { closeNavMenu(); showPage('settings'); };
  closeNavMenu();
  showPage('time', { skipRemember: true });

  if (btnAddDeduction) {
    btnAddDeduction.addEventListener('click', () => openDeductionForm('create'));
  }
  if (btnCancelDeduction) {
    btnCancelDeduction.addEventListener('click', (event) => {
      event.preventDefault();
      closeDeductionForm();
    });
  }
  if (btnSaveDeduction) {
    btnSaveDeduction.addEventListener('click', (event) => {
      event.preventDefault();
      handleSaveDeduction();
    });
  }
  if (deductionTypeSelect) deductionTypeSelect.addEventListener('change', updateDeductionFormVisibility);
  if (deductionCategorySelect) deductionCategorySelect.addEventListener('change', () => {
    updateDeductionCompanyOptions();
    updateDeductionFormVisibility();
  });
  if (deductionAmountModeSelect) deductionAmountModeSelect.addEventListener('change', updateDeductionFormVisibility);
  if (deductionFrequencySelect) deductionFrequencySelect.addEventListener('change', updateDeductionFormVisibility);
  if (deductionStartDateInput) deductionStartDateInput.addEventListener('change', updateDeductionOccurrencePreview);
  if (deductionEndDateInput) deductionEndDateInput.addEventListener('change', updateDeductionOccurrencePreview);
  if (basFySelect) {
    basFySelect.addEventListener('change', () => {
      state.basCurrentFy = Number(basFySelect.value);
      renderBasReporting();
    });
  }

  // Helpers

  const $ = (selector) => document.querySelector(selector);
  const $$ = (selector) => Array.from(document.querySelectorAll(selector));
  const fmt = (minutes) => {
    const total = Number(minutes) || 0;
    const h = Math.floor(total / 60);
    const mm = total % 60;
    return (h > 0 ? h + ':' : '') + String(mm).padStart(2, '0');
  };
  const setStatus = (text, cls) => {
    const el = document.getElementById('status');
    el.textContent = text;
    el.className = 'ts-badge ' + (cls || '');
  };
  const isoDate = (date) => {
    const d = new Date(date);
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };
  const normalizeHolidayDate = (value) => {
    if (!value && value !== 0) return '';
    if (value instanceof Date) return isoDate(value);
    if (typeof value === 'number') {
      return isoDate(new Date(value));
    }
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (trimmed === '') return '';
      if (!trimmed.includes('T')) return trimmed;
      const parsed = new Date(trimmed);
      if (!Number.isNaN(parsed.getTime())) {
        return isoDate(parsed);
      }
      return trimmed.split('T')[0];
    }
    return '';
  };
  const isoDateTime = (date) => new Date(date).toISOString().replace(/\.\d{3}Z$/, 'Z');
  const parseIsoDate = (value) => {
    const [y, m, d] = value.split('-').map(Number);
    return new Date(y, m - 1, d);
  };
  const todayIso = () => isoDate(new Date());
  const MONTH_ABBREVIATIONS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  const formatMonthShortYear = (dateObj) => {
    if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) return '';
    const month = MONTH_ABBREVIATIONS[dateObj.getMonth()] || '';
    const year = dateObj.getFullYear();
    return `${month} ${String(year).slice(-2)}`;
  };
  const formatHours = (minutes) => {
    const hrs = (Number(minutes) || 0) / 60;
    let out = (Math.round(hrs * 100) / 100).toFixed(2);
    out = out.replace(/\.00$/, '');
    out = out.replace(/(\.\d)0$/, '$1');
    return out === '' ? '0' : out;
  };
  const startOfDay = (date) => new Date(date.getFullYear(), date.getMonth(), date.getDate());
  const isWeekendDate = (date) => {
    const day = date.getDay();
    return day === 0 || day === 6;
  };
  function collectBusinessDays(startDate, endDate, includeWeekends) {
    if (!(startDate instanceof Date) || Number.isNaN(startDate.getTime())) return [];
    if (!(endDate instanceof Date) || Number.isNaN(endDate.getTime())) return [];
    const start = startOfDay(startDate);
    const end = startOfDay(endDate);
    if (end < start) return [];
    const days = [];
    const cursor = new Date(start);
    while (cursor <= end) {
      if (includeWeekends || !isWeekendDate(cursor)) {
        days.push(isoDate(cursor));
      }
      cursor.setDate(cursor.getDate() + 1);
    }
    return days;
  }
  const minutesToTime = (minutes) => {
    const mins = Math.max(0, Math.round(Number(minutes) || 0));
    if (mins >= 24 * 60) return '23:59';
    const h = Math.floor(mins / 60);
    const m = mins % 60;
    return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
  };
  const DEFAULT_SUPER_RATE = 0.12;
  const GST_RATE = 0.1;
  const currencyFormatter = new Intl.NumberFormat(undefined, {
    style: 'currency',
    currency: 'AUD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  });
  const formatCurrency = (value) => {
    const num = Number(value);
    if (!Number.isFinite(num)) return '--';
    return currencyFormatter.format(num);
  };
  const addDays = (date, amount) => {
    const next = new Date(date.getTime());
    next.setDate(next.getDate() + amount);
    return next;
  };
  const addMonthsClamped = (date, amount) => {
    const year = date.getFullYear();
    const month = date.getMonth();
    const day = date.getDate();
    const target = new Date(year, month + amount + 1, 0);
    const maxDay = target.getDate();
    target.setDate(Math.min(day, maxDay));
    return startOfDay(target);
  };
  const getSuperRateSetting = () => {
    const raw = state.settings ? state.settings.superannuation_rate : undefined;
    const num = Number(raw);
    if (Number.isFinite(num) && num >= 0) {
      return num > 1 ? num / 100 : num;
    }
    return DEFAULT_SUPER_RATE;
  };
  const getSuperRatePercentage = () => Math.round(getSuperRateSetting() * 1000) / 10;
  const sanitizeSuperRateInputValue = (value) => {
    const num = Number(value);
    if (Number.isFinite(num) && num >= 0) return Math.round(num * 10) / 10;
    return Math.round(DEFAULT_SUPER_RATE * 1000) / 10;
  };

  const getRoundInterval = () => {
    const value = Number(state.settings.round_to_nearest);
    return Number.isFinite(value) && value > 1 ? value : 0;
  };
  const roundDuration = (minutes) => {
    const base = Math.max(0, Math.round(Number(minutes) || 0));
    const interval = getRoundInterval();
    if (!interval) return Math.max(1, base);
    const rounded = Math.round(base / interval) * interval;
    return Math.max(interval, rounded);
  };

  const TIME_PATTERN = /^\d{2}:\d{2}$/;
  const normalizeTimeValue = (value) => {
    if (!value && value !== 0) return '';
    if (typeof value === 'string') {
      const trimmed = value.trim();
      if (TIME_PATTERN.test(trimmed)) return trimmed;
      const parsed = new Date(`1970-01-01T${trimmed}:00`);
      if (!Number.isNaN(parsed.getTime())) return parsed.toTimeString().slice(0, 5);
    } else if (value instanceof Date) {
      return value.toTimeString().slice(0, 5);
    }
    const coerced = new Date(value);
    if (!Number.isNaN(coerced.getTime())) return coerced.toTimeString().slice(0, 5);
    return '';
  };
  const timeToMinutes = (time) => {
    if (!time || !TIME_PATTERN.test(time)) return null;
    const parts = time.split(':');
    return Number(parts[0]) * 60 + Number(parts[1]);
  };
  const clonePunches = (punches) => (Array.isArray(punches) ? punches.map((p) => ({ in: p.in || '', out: p.out || '' })) : []);
  const normalizePunchList = (value) => {
    if (!value) return [];
    let source = value;
    if (typeof source === 'string') {
      try {
        source = JSON.parse(source);
      } catch (e) {
        source = [];
      }
    }
    if (!Array.isArray(source)) source = source ? [source] : [];
    const punches = source.reduce((acc, raw) => {
      if (!raw) return acc;
      const start = normalizeTimeValue(raw.in || raw.start || raw.start_time || raw.startTime);
      if (!start) return acc;
      let end = normalizeTimeValue(raw.out || raw.stop || raw.end || raw.end_time || raw.endTime);
      if (end && timeToMinutes(end) !== null && timeToMinutes(start) !== null && timeToMinutes(end) < timeToMinutes(start)) {
        end = '';
      }
      acc.push({ in: start, out: end || '' });
      return acc;
    }, []);
    punches.sort((a, b) => {
      if (a.in === b.in) return (a.out || '').localeCompare(b.out || '');
      return a.in.localeCompare(b.in);
    });
    return punches;
  };
  const summarizePunches = (punches) => {
    if (!Array.isArray(punches) || !punches.length) {
      return { totalMinutes: 0, earliest: '', latest: '', openCount: 0 };
    }
    let earliest = '';
    let latest = '';
    let total = 0;
    let openCount = 0;
    punches.forEach((punch) => {
      if (!punch || !punch.in) return;
      if (!earliest || punch.in < earliest) earliest = punch.in;
      if (punch.out) {
        if (!latest || punch.out > latest) latest = punch.out;
        const startMinutes = timeToMinutes(punch.in);
        const endMinutes = timeToMinutes(punch.out);
        if (startMinutes !== null && endMinutes !== null && endMinutes > startMinutes) {
          total += endMinutes - startMinutes;
        }
      } else {
        openCount += 1;
      }
    });
    return { totalMinutes: total, earliest, latest, openCount };
  };
  const validatePunches = (punches, options = {}) => {
    const { allowOpen = true, requireClosed = false } = options;
    const sorted = normalizePunchList(punches);
    let lastEnd = null;
    let openCount = 0;
    for (let idx = 0; idx < sorted.length; idx += 1) {
      const punch = sorted[idx];
      const startMinutes = timeToMinutes(punch.in);
      if (startMinutes === null) {
        return 'Each punch needs a valid start time.';
      }
      if (!punch.out) {
        openCount += 1;
        if (requireClosed) {
          return 'Please enter an end time for each punch.';
        }
        if (!allowOpen && openCount > 0) {
          return 'Close any open punches before saving.';
        }
        if (lastEnd !== null && startMinutes < lastEnd) {
          return 'Punch ranges cannot overlap.';
        }
        lastEnd = startMinutes;
        continue;
      }
      const endMinutes = timeToMinutes(punch.out);
      if (endMinutes === null || endMinutes <= startMinutes) {
        return 'Punch out must be later than punch in.';
      }
      if (lastEnd !== null && startMinutes < lastEnd) {
        return 'Punch ranges cannot overlap.';
      }
      lastEnd = endMinutes;
    }
    return null;
  };

  const entryPunches = (entry) => {
    if (entry && Array.isArray(entry.punches) && entry.punches.length) {
      return entry.punches.map((punch) => ({ in: punch.in || '', out: punch.out || '' }));
    }
    if (entry && entry.start_time && entry.end_time) {
      return [{ in: entry.start_time, out: entry.end_time }];
    }
    return [];
  };
  function resolveEntryType(entry) {
    if (!entry) return null;
    if (entry.entry_type) return entry.entry_type;
    const punches = entryPunches(entry);
    if (!punches.length) return 'basic';
    if (punches.length === 1 && punches[0].in === '00:00') {
      return 'basic';
    }
    return 'advanced';
  }
  const entryFirstPunchMinutes = (entry) => {
    const punches = entryPunches(entry);
    if (punches.length) {
      const mins = timeToMinutes(punches[0].in);
      if (mins !== null) return mins;
    }
    const fallback = timeToMinutes(entry && entry.start_time ? entry.start_time : '');
    return fallback !== null ? fallback : 24 * 60;
  };
  const getEntryPunchSummary = (entry) => {
    const punches = entryPunches(entry);
    if (!punches.length) {
      const start = entry && entry.start_time ? entry.start_time : '--:--';
      const end = entry && entry.end_time ? entry.end_time : '--:--';
      return `${start} - ${end}`;
    }
    const summary = summarizePunches(punches);
    const start = summary.earliest || '--:--';
    const end = summary.openCount > 0 ? 'Open' : (summary.latest || '--:--');
    return `${start} - ${end}`;
  };
  const getEntryPunchDetail = (entry) => {
    const punches = entryPunches(entry);
    if (!punches.length) return '';
    return punches.map((punch) => `${punch.in || '--:--'} - ${punch.out || 'Open'}`).join(', ');
  };

  const sanitizeEntry = (entry) => {
    if (!entry) return entry;
    const clone = { ...entry };
    const punches = normalizePunchList(clone.punches != null ? clone.punches : clone.punches_json);
    clone.punches = clonePunches(punches);
    clone.punches_json = JSON.stringify(clone.punches);
    const summary = summarizePunches(clone.punches);
    if (clone.punches.length) {
      let worked = summary.totalMinutes;
      if (clone.duration_minutes != null && Number.isFinite(Number(clone.duration_minutes))) {
        clone.duration_minutes = Math.max(0, Math.round(Number(clone.duration_minutes)));
      } else {
        clone.duration_minutes = Math.max(0, Math.round(worked));
      }
    } else {
      clone.duration_minutes = Math.max(0, Math.round(Number(clone.duration_minutes) || 0));
    }
    clone.open_punch_count = summary.openCount || 0;
    delete clone.break;
    delete clone.description;
    const contractId = clone.contract_id || clone.contractId || clone.project || '';
    clone.contract_id = contractId ? String(contractId).trim() : '';
    delete clone.project;
    delete clone.contractId;
    // Preserve entry_type if it exists
    if (clone.entry_type) {
      clone.entry_type = String(clone.entry_type).trim();
    }
    return clone;
  };

  const sanitizeContract = (contract) => {
    if (!contract) return contract;
    const clone = { ...contract };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.start_date = clone.start_date || clone.startDate || '';
    clone.end_date = clone.end_date || clone.endDate || '';
    clone.hourly_rate = Number(clone.hourly_rate != null ? clone.hourly_rate : 0);
    if (Number.isNaN(clone.hourly_rate)) clone.hourly_rate = 0;
    clone.total_hours = Number(clone.total_hours != null ? clone.total_hours : (clone.totalHours != null ? clone.totalHours : 0));
    if (Number.isNaN(clone.total_hours) || clone.total_hours < 0) clone.total_hours = 0;
    clone.include_weekends = Boolean(
      clone.include_weekends === true ||
      clone.include_weekends === 'TRUE' ||
      String(clone.include_weekends != null ? clone.include_weekends : '').toLowerCase() === 'true'
    );
    delete clone.startDate;
    delete clone.endDate;
    delete clone.hourlyRate;
    delete clone.totalHours;
    return clone;
  };

  const sanitizeHourType = (hourType) => {
    if (!hourType) return hourType;
    const clone = { ...hourType };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.slug = clone.slug ? String(clone.slug).trim() : '';
    clone.color = clone.color ? String(clone.color).trim() : '#6b7280';
    clone.contributes_to_income = Boolean(clone.contributes_to_income === 'TRUE' || clone.contributes_to_income === true);
    clone.requires_contract = Boolean(clone.requires_contract === 'TRUE' || clone.requires_contract === true);
    clone.is_default = Boolean(clone.is_default === 'TRUE' || clone.is_default === true);
    clone.auto_populate_public_holidays = Boolean(
      clone.auto_populate_public_holidays === 'TRUE' || clone.auto_populate_public_holidays === true
    );
    const autoHours = Number(clone.auto_populate_hours != null ? clone.auto_populate_hours : 0);
    clone.auto_populate_hours = Number.isFinite(autoHours) && autoHours > 0 ? autoHours : 0;
    clone.created_at = clone.created_at || '';
    return clone;
  };

  const sanitizeDeduction = (deduction) => {
    if (!deduction) return deduction;
    const clone = { ...deduction };
    clone.id = clone.id ? String(clone.id) : '';
    clone.name = clone.name ? String(clone.name).trim() : '';
    clone.category = clone.category === 'company' ? 'company' : 'personal';
    clone.deduction_type = clone.deduction_type === 'extra_super' ? 'extra_super' : 'standard';
    clone.amount_type = clone.amount_type === 'percent' ? 'percent' : 'flat';
    let amountValue = Number(clone.amount_value);
    if (!Number.isFinite(amountValue) || amountValue < 0) amountValue = 0;
    if (clone.amount_type === 'percent' && amountValue > 1) {
      amountValue = amountValue / 100;
    }
    clone.amount_value = amountValue;
    clone.gst_inclusive = !!clone.gst_inclusive;
    clone.gst_amount = Number(clone.gst_amount) || 0;
    clone.frequency = DEDUCTION_FREQUENCIES.includes(clone.frequency) ? clone.frequency : 'once';
    clone.start_date = clone.start_date ? String(clone.start_date) : '';
    clone.end_date = clone.end_date ? String(clone.end_date) : '';
    clone.notes = clone.notes ? String(clone.notes) : '';
    clone.active = clone.active !== false;
    clone.created_at = clone.created_at || '';
    clone.updated_at = clone.updated_at || '';
    return clone;
  };

  function nextOccurrenceDate(current, frequency) {
    if (!current) return null;
    switch (frequency) {
      case 'weekly':
        return addDays(current, 7);
      case 'fortnightly':
        return addDays(current, 14);
      case 'monthly':
        return addMonthsClamped(current, 1);
      case 'quarterly':
        return addMonthsClamped(current, 3);
      case 'yearly':
        return addMonthsClamped(current, 12);
      default:
        return null;
    }
  }

  function advanceOccurrenceTo(startDate, frequency, targetDate, endDate) {
    if (!startDate) return null;
    if (frequency === 'once') {
      return startDate;
    }
    var current = startDate;
    var safety = 0;
    while (current < targetDate && safety < 1000) {
      var next = nextOccurrenceDate(current, frequency);
      if (!next) return current;
      if (endDate && next > endDate) return next;
      if (next.getTime() === current.getTime()) return next;
      current = next;
      safety++;
    }
    return current;
  }

  function getDeductionOccurrencesBetween(deduction, rangeStart, rangeEnd, limit) {
    const occurrences = [];
    if (!deduction || !deduction.start_date) return occurrences;
    const startSource = parseIsoDate(deduction.start_date);
    if (!startSource || Number.isNaN(startSource.getTime())) return occurrences;
    let current = startOfDay(startSource);
    const endBoundary = deduction.end_date ? parseIsoDate(deduction.end_date) : null;
    const endDate = endBoundary ? startOfDay(endBoundary) : null;
    const frequency = deduction.frequency || 'once';
    const hasRangeStart = !!rangeStart;
    const hasRangeEnd = !!rangeEnd;
    const rangeStartDate = hasRangeStart ? startOfDay(rangeStart) : null;
    const rangeEndDate = hasRangeEnd ? startOfDay(rangeEnd) : null;

    if (rangeStartDate && current < rangeStartDate && frequency !== 'once') {
      current = advanceOccurrenceTo(current, frequency, rangeStartDate, endDate);
    }

    const maxIterations = 1000;
    let iterations = 0;
    while (current && iterations < maxIterations) {
      if (rangeStartDate && current < rangeStartDate) {
        // Occurrence is before range start; skip but continue advancing unless once
      } else if (!rangeEndDate || current <= rangeEndDate) {
        occurrences.push(startOfDay(current));
      } else {
        break;
      }

      if (limit && occurrences.length >= limit) break;
      if (frequency === 'once') break;

      const next = nextOccurrenceDate(current, frequency);
      if (!next) break;
      if (endDate && next > endDate) break;
      if (next.getTime() === current.getTime()) break;
      current = next;
      iterations++;
    }

    return occurrences;
  }

  function getDeductionPreviewDates(deduction, limit) {
    const occurrences = getDeductionOccurrencesBetween(
      deduction,
      parseIsoDate(deduction.start_date),
      deduction.end_date ? parseIsoDate(deduction.end_date) : null,
      limit || 5
    );
    return occurrences.map((occ) => isoDate(occ));
  }

  function getUpcomingDeductionDates(deduction, limit) {
    const today = startOfDay(new Date());
    const occurrences = getDeductionOccurrencesBetween(
      deduction,
      today,
      deduction.end_date ? parseIsoDate(deduction.end_date) : null,
      limit || 5
    );
    return occurrences.map((occ) => isoDate(occ));
  }

  function formatFrequencyLabel(frequency) {
    switch (frequency) {
      case 'weekly':
        return 'Weekly';
      case 'fortnightly':
        return 'Fortnightly';
      case 'monthly':
        return 'Monthly';
      case 'quarterly':
        return 'Quarterly';
      case 'yearly':
        return 'Yearly';
      case 'once':
      default:
        return 'One-off';
    }
  }

  function formatDeductionAmount(deduction) {
    if (deduction.amount_type === 'percent') {
      const pct = Math.round((deduction.amount_value * 100) * 100) / 100;
      return `${pct}% of gross income`;
    }
    const value = deduction.gst_inclusive
      ? deduction.amount_value / (1 + GST_RATE)
      : deduction.amount_value;
    const rounded = Math.round((Number(value) || 0) * 100) / 100;
    return formatCurrency(rounded);
  }

  function computeMonthlyDeductionTotals(year, month) {
    const result = {
      standardTotal: 0,
      personalStandardTotal: 0,
      companyStandardTotal: 0,
      companyGstTotal: 0,
      extraSuperFlat: 0,
      extraSuperPercentRate: 0
    };
    if (!Array.isArray(state.deductions) || !state.deductions.length) return result;
    const monthStart = startOfDay(new Date(year, month, 1));
    const monthEnd = startOfDay(new Date(year, month + 1, 0));
    state.deductions.forEach((deduction) => {
      if (!deduction || deduction.active === false) return;
      const occurrences = getDeductionOccurrencesBetween(deduction, monthStart, monthEnd);
      if (!occurrences.length) return;
      if (deduction.deduction_type === 'extra_super') {
        if (deduction.amount_type === 'percent') {
          result.extraSuperPercentRate += deduction.amount_value * occurrences.length;
        } else {
          result.extraSuperFlat += deduction.amount_value * occurrences.length;
        }
        return;
      }
      if (deduction.amount_type === 'percent') {
        return;
      }
      let netAmount = deduction.amount_value;
      if (deduction.gst_inclusive) {
        netAmount = deduction.amount_value / (1 + GST_RATE);
      }
      const totalAmount = netAmount * occurrences.length;
      result.standardTotal += totalAmount;
      if (deduction.category === 'company') {
        result.companyStandardTotal += totalAmount;
        if (deduction.gst_inclusive) {
          const inclusive = deduction.amount_value;
          const gstComponent = inclusive - (inclusive / (1 + GST_RATE));
          result.companyGstTotal += gstComponent * occurrences.length;
        }
      } else {
        result.personalStandardTotal += totalAmount;
      }
    });
    return result;
  }

  function collectFinancialYears() {
    const allYears = collectAllYears();
    const years = Array.isArray(allYears.financial) ? [...allYears.financial] : [];
    if (!years.length) {
      years.push(financialYearStartYear(new Date()));
    }
    return years;
  }

  function formatBasRow(label, values, fyYear, quarter, month) {
    const submittedIndicator = values.submitted ? '<span style="color:var(--success); font-weight:600;">\u2713</span>' : '';
    const rowClass = values.hasActivity ? 'bas-row-clickable' : '';
    const dataAttrs = [];
    if (fyYear) dataAttrs.push(`data-fy="${fyYear}"`);
    if (quarter) dataAttrs.push(`data-quarter="${quarter}"`);
    if (month) dataAttrs.push(`data-month="${month}"`);
    const dataAttrsStr = dataAttrs.length ? dataAttrs.join(' ') : '';

    return `
      <tr class="${rowClass}" ${dataAttrsStr} style="${rowClass ? 'cursor:pointer;' : ''}">
        <td>${label}</td>
        <td style="text-align:center;">${submittedIndicator}</td>
        <td>${formatCurrency(values.invoiceTotal)}</td>
        <td>${formatCurrency(values.invoiceGst)}</td>
        <td>${formatCurrency(values.companyIncome)}</td>
        <td>${formatCurrency(values.companyExpenses)}</td>
        <td>${formatCurrency(values.companyExpensesGst)}</td>
        <td>${formatCurrency(values.employeeGrossIncome)}</td>
        <td>${formatCurrency(values.employeeSuper)}</td>
        <td>${formatCurrency(values.employeeDeductions)}</td>
        <td>${formatCurrency(values.employeeTax)}</td>
        <td>${formatCurrency(values.employeeNetIncome)}</td>
      </tr>
    `;
  }

  function buildMonthlyBasRows(fyStartYear) {
    const months = getFinancialYearMonths(fyStartYear);
    return months.map(({ year, month }) => {
      const summary = buildIncomeSummary(year, month);
      const companyIncome = summary.companyIncome || 0;
      const invoiceTotal = summary.invoiceTotal || 0;
      const companyExpenses = summary.companyExpenses || 0;
      const companyExpensesGst = summary.companyExpensesGst || 0;
      const employeeGross = summary.grossIncome || 0;
      const employeeSuper = (summary.superGuarantee || 0) + (summary.extraSuper || 0);
      const employeeDeductions = summary.otherDeductions || 0;
      const tax = summary.tax != null ? summary.tax : 0;
      const netIncome = summary.netIncome != null ? summary.netIncome : Math.max(0, (summary.taxableIncome || 0) - tax);
      const invoiceGst = invoiceTotal - companyIncome;
      return {
        label: MONTH_YEAR_FORMATTER.format(new Date(year, month, 1)),
        year,
        month,
        invoiceTotal,
        invoiceGst,
        companyIncome,
        companyExpenses,
        companyExpensesGst,
        employeeGrossIncome: employeeGross,
        employeeSuper,
        employeeDeductions,
        employeeTax: tax,
        employeeNetIncome: netIncome,
        hasActivity: invoiceTotal > 0.01 || companyExpenses > 0.01 || employeeGross > 0.01 || employeeDeductions > 0.01 || employeeSuper > 0.01
      };
    });
  }

  function buildQuarterlyBasRows(monthRows) {
    const labels = ['Q1 (Jul–Sep)', 'Q2 (Oct–Dec)', 'Q3 (Jan–Mar)', 'Q4 (Apr–Jun)'];
    const quarters = [];
    for (let i = 0; i < 4; i += 1) {
      const slice = monthRows.slice(i * 3, i * 3 + 3);
      const totals = slice.reduce((acc, row) => {
        acc.invoiceTotal += row.invoiceTotal;
        acc.invoiceGst += row.invoiceGst;
        acc.companyIncome += row.companyIncome;
        acc.companyExpenses += row.companyExpenses;
        acc.companyExpensesGst += row.companyExpensesGst;
        acc.employeeGrossIncome += row.employeeGrossIncome;
        acc.employeeSuper += row.employeeSuper;
        acc.employeeDeductions += row.employeeDeductions;
        acc.employeeTax += row.employeeTax;
        acc.employeeNetIncome += row.employeeNetIncome;
        acc.hasActivity = acc.hasActivity || row.hasActivity;
        return acc;
      }, {
        invoiceTotal: 0,
        invoiceGst: 0,
        companyIncome: 0,
        companyExpenses: 0,
        companyExpensesGst: 0,
        employeeGrossIncome: 0,
        employeeSuper: 0,
        employeeDeductions: 0,
        employeeTax: 0,
        employeeNetIncome: 0,
        hasActivity: false
      });
      totals.label = labels[i] || `Q${i + 1}`;
      totals.quarter = i + 1; // Add quarter number for identification
      quarters.push(totals);
    }
    return quarters;
  }

  function renderBasReporting() {
    if (!pageBas) return;
    if (!state.companyTrackingEnabled) {
      if (basTableBody) basTableBody.innerHTML = '';
      if (basEmptyNote) basEmptyNote.style.display = 'none';
      if (basQuarterlyNote) basQuarterlyNote.style.display = 'none';
      return;
    }

    const years = collectFinancialYears();
    if (!years.length) years.push(financialYearStartYear(new Date()));
    years.sort((a, b) => a - b);
    const latestYear = years[years.length - 1];
    if (!state.basCurrentFy || !years.includes(state.basCurrentFy)) {
      state.basCurrentFy = latestYear;
    }

    if (basFySelect) {
      basFySelect.innerHTML = years.map((year) => `<option value="${year}">${financialYearLabel(year)}</option>`).join('');
      basFySelect.value = String(state.basCurrentFy);
    }

    const monthRows = buildMonthlyBasRows(state.basCurrentFy);
    const dataset = state.companyBasQuarterly ? buildQuarterlyBasRows(monthRows) : monthRows;
    const hasActivity = dataset.some((row) => row.hasActivity);

    // Merge BAS submission data into dataset
    dataset.forEach((row) => {
      const submission = state.basSubmissions.find(s => {
        if (s.financial_year !== state.basCurrentFy) return false;
        if (state.companyBasQuarterly) {
          return s.period_type === 'quarterly' && s.quarter === row.quarter;
        } else {
          return s.period_type === 'monthly' && s.month === row.month;
        }
      });
      if (submission) {
        row.submitted = submission.submitted;
      }
    });

    if (basQuarterlyNote) basQuarterlyNote.style.display = state.companyBasQuarterly ? 'block' : 'none';
    if (basEmptyNote) basEmptyNote.style.display = hasActivity ? 'none' : 'block';

    if (basTableBody) {
      const bodyHtml = dataset
        .filter((row) => row.hasActivity || hasActivity) // keep blank rows when overall activity exists
        .map((row) => {
          const fyYear = state.basCurrentFy;
          const quarter = state.companyBasQuarterly ? row.quarter : null;
          const month = !state.companyBasQuarterly ? row.month : null;
          return formatBasRow(row.label, row, fyYear, quarter, month);
        })
        .join('');
      basTableBody.innerHTML = bodyHtml || '<tr><td colspan="12" style="text-align:center; padding:16px;">No company activity recorded.</td></tr>';

      // Add click handlers to clickable rows
      attachBasRowClickHandlers();
    }
  }

  function attachBasRowClickHandlers() {
    if (!basTableBody) return;
    const clickableRows = basTableBody.querySelectorAll('.bas-row-clickable');
    clickableRows.forEach(row => {
      row.addEventListener('click', () => {
        const fyYear = row.getAttribute('data-fy');
        const quarter = row.getAttribute('data-quarter');
        const month = row.getAttribute('data-month');
        if (fyYear && quarter) {
          openBasDetailModal(Number(fyYear), Number(quarter), null);
        } else if (fyYear && month) {
          openBasDetailModal(Number(fyYear), null, Number(month));
        }
      });
    });
  }

  // Annual Views
  const annualYearTypeToggle = document.getElementById('annual-year-type-toggle');
  const annualYearTypeLabel = document.getElementById('annual-year-type-label');
  const annualYearSelect = document.getElementById('annual-year-select');
  const annualContractFilterToggle = document.getElementById('annual-contract-filter-toggle');
  const annualContractFilterPanel = document.getElementById('annual-contract-filter-panel');
  const annualContractFilterList = document.getElementById('annual-contract-filter-list');
  const annualFilterSelectAll = document.getElementById('annual-filter-select-all');
  const annualEmpty = document.getElementById('annual-empty');

  function getThemeColors() {
    const computedStyle = getComputedStyle(document.body);
    return {
      text: computedStyle.getPropertyValue('--text').trim(),
      muted: computedStyle.getPropertyValue('--muted').trim(),
      border: computedStyle.getPropertyValue('--border').trim(),
      primary: computedStyle.getPropertyValue('--primary').trim(),
      danger: computedStyle.getPropertyValue('--danger').trim(),
      success: computedStyle.getPropertyValue('--success').trim(),
      warning: '#facc15'
    };
  }

  function destroyAnnualCharts() {
    if (state.annualCharts.income) {
      state.annualCharts.income.destroy();
      state.annualCharts.income = null;
    }
    if (state.annualCharts.incomePie) {
      state.annualCharts.incomePie.destroy();
      state.annualCharts.incomePie = null;
    }
    if (state.annualCharts.contractPie) {
      state.annualCharts.contractPie.destroy();
      state.annualCharts.contractPie = null;
    }
    if (state.annualCharts.hourTypesPie) {
      state.annualCharts.hourTypesPie.destroy();
      state.annualCharts.hourTypesPie = null;
    }
    if (state.annualCharts.totalHoursPie) {
      state.annualCharts.totalHoursPie.destroy();
      state.annualCharts.totalHoursPie = null;
    }
    if (state.annualCharts.totalHoursByTypePie) {
      state.annualCharts.totalHoursByTypePie.destroy();
      state.annualCharts.totalHoursByTypePie = null;
    }
  }

  function showAnnualLoadingState() {
    if (!pageAnnualViews) return;

    // Add loading overlay
    let overlay = document.getElementById('annual-loading-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'annual-loading-overlay';
      overlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg);
        opacity: 0.7;
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100;
        border-radius: 12px;
      `;
      overlay.innerHTML = '<div style="font-size: 14px; color: var(--muted);">Loading data...</div>';
      pageAnnualViews.style.position = 'relative';
      pageAnnualViews.appendChild(overlay);
    }
    overlay.style.display = 'flex';
  }

  function hideAnnualLoadingState() {
    const overlay = document.getElementById('annual-loading-overlay');
    if (overlay) {
      overlay.style.display = 'none';
    }
  }

  function loadAnnualData() {
    const payload = {
      yearType: state.annualYearType,
      startYear: state.annualCurrentYear,
      contractIds: state.annualFilteredContracts
    };

    // Check if we have any cached annual data at all
    const hasAnyCachedData = state.annualData !== null;

    // Show cached data immediately if available (optimistic UI)
    if (hasAnyCachedData) {
      renderAnnualData();
    } else {
      // Show loading state only on very first load
      showAnnualLoadingState();
    }

    // Then fetch fresh data in background
    const statusMsg = hasAnyCachedData ? 'Updating annual data...' : 'Loading annual data...';
    setStatus(statusMsg, 'info');
    google.script.run
      .withSuccessHandler((data) => {
        state.annualData = data;
        saveCache();
        hideAnnualLoadingState();
        renderAnnualData();
        setStatus('Ready', 'success');
      })
      .withFailureHandler((error) => {
        console.error('Failed to load annual data:', error);
        hideAnnualLoadingState();
        setStatus('Error loading annual data', 'error');
      })
      .api_getAnnualSummary(payload);
  }

  function renderAnnualViews() {
    if (!pageAnnualViews) return;

    // Get years based on current type
    const allYears = collectAllYears();
    const years = state.annualYearType === 'financial' ? allYears.financial : allYears.calendar;

    if (years.length === 0) {
      years.push(new Date().getFullYear());
    }

    if (!state.annualCurrentYear || !years.includes(state.annualCurrentYear)) {
      state.annualCurrentYear = years[0];
    }

    // Initialize year selector
    if (annualYearSelect) {
      const options = years.map(year => {
        const fy = financialYearLabel(year);
        return `<option value="${year}">${state.annualYearType === 'financial' ? fy : year}</option>`;
      }).join('');
      annualYearSelect.innerHTML = options;
      annualYearSelect.value = String(state.annualCurrentYear);
    }

    // Initialize year type toggle
    if (annualYearTypeToggle) {
      annualYearTypeToggle.checked = state.annualYearType === 'calendar';
    }
    if (annualYearTypeLabel) {
      annualYearTypeLabel.textContent = state.annualYearType === 'financial' ? 'Financial Year' : 'Calendar Year';
    }

    // Initialize contract filter
    renderAnnualContractFilter();

    // Load data
    loadAnnualData();
  }

  function renderAnnualContractFilter() {
    if (!annualContractFilterList) return;

    // Get year range based on year type
    let yearStart, yearEnd;
    if (state.annualYearType === 'financial') {
      yearStart = new Date(state.annualCurrentYear, 6, 1); // July 1st
      yearEnd = new Date(state.annualCurrentYear + 1, 5, 30, 23, 59, 59); // June 30th
    } else {
      yearStart = new Date(state.annualCurrentYear, 0, 1); // Jan 1st
      yearEnd = new Date(state.annualCurrentYear, 11, 31, 23, 59, 59); // Dec 31st
    }

    // Filter contracts that overlap with the selected year
    const relevantContracts = state.contracts.filter(c => {
      if (!c || !c.id || !c.name) return false;

      const contractStart = c.start_date ? new Date(c.start_date) : new Date(0);
      const contractEnd = c.end_date ? new Date(c.end_date) : new Date(9999, 11, 31);

      // Contract overlaps if it starts before year ends AND ends after year starts
      return contractStart <= yearEnd && contractEnd >= yearStart;
    });

    if (relevantContracts.length <= 1) {
      if (annualContractFilterToggle) annualContractFilterToggle.style.display = 'none';
      if (annualContractFilterPanel) annualContractFilterPanel.style.display = 'none';
      state.annualFilteredContracts = relevantContracts.map(c => c.id);
      return;
    }

    // Show the filter toggle button
    if (annualContractFilterToggle) annualContractFilterToggle.style.display = 'block';

    // Panel starts hidden (user can click toggle to show)
    if (!annualContractFilterPanel.dataset.initialized) {
      if (annualContractFilterPanel) annualContractFilterPanel.style.display = 'none';
      if (annualContractFilterPanel) annualContractFilterPanel.dataset.initialized = 'true';
    }

    // Initialize with all relevant contracts if not set or if filtered contracts are not relevant
    const currentFilteredAreRelevant = state.annualFilteredContracts.every(id =>
      relevantContracts.some(c => c.id === id)
    );
    if (state.annualFilteredContracts.length === 0 || !currentFilteredAreRelevant) {
      state.annualFilteredContracts = relevantContracts.map(c => c.id);
    }

    const html = relevantContracts.map(contract => {
      const isActive = state.annualFilteredContracts.includes(contract.id);
      return `
        <div class="ts-calendar-filter-item ${isActive ? 'active' : ''}" data-contract-id="${contract.id}">
          <input type="checkbox" class="ts-calendar-filter-checkbox" ${isActive ? 'checked' : ''} />
          <span class="ts-calendar-filter-name">${contract.name}</span>
        </div>
      `;
    }).join('');

    annualContractFilterList.innerHTML = html;

    // Add click handlers
    annualContractFilterList.querySelectorAll('.ts-calendar-filter-item').forEach(item => {
      item.addEventListener('click', () => {
        const contractId = item.dataset.contractId;
        const idx = state.annualFilteredContracts.indexOf(contractId);
        if (idx >= 0) {
          state.annualFilteredContracts.splice(idx, 1);
        } else {
          state.annualFilteredContracts.push(contractId);
        }
        saveCache();
        renderAnnualContractFilter();
        loadAnnualData();
      });
    });
  }

  function collectAllYears() {
    // Get list of public holiday hour type IDs
    const publicHolidayHourTypeIds = state.hourTypes
      .filter(ht => ht.auto_populate_public_holidays === true || ht.auto_populate_public_holidays === 'TRUE')
      .map(ht => ht.id);

    // Group entries by year to check if year has non-public-holiday entries
    const calendarYearEntries = {};
    const financialYearEntries = {};

    state.entries.forEach(entry => {
      if (entry && entry.date) {
        const duration = entry.duration_minutes || 0;
        if (duration > 0) {
          const date = new Date(entry.date);
          const calendarYear = date.getFullYear();
          const fyStart = financialYearStartYear(date);
          const hourTypeId = entry.hour_type_id || '';
          const isPublicHoliday = publicHolidayHourTypeIds.includes(hourTypeId);

          // Track calendar year entries
          if (!calendarYearEntries[calendarYear]) {
            calendarYearEntries[calendarYear] = { total: 0, publicHolidays: 0 };
          }
          calendarYearEntries[calendarYear].total++;
          if (isPublicHoliday) {
            calendarYearEntries[calendarYear].publicHolidays++;
          }

          // Track financial year entries
          if (!financialYearEntries[fyStart]) {
            financialYearEntries[fyStart] = { total: 0, publicHolidays: 0 };
          }
          financialYearEntries[fyStart].total++;
          if (isPublicHoliday) {
            financialYearEntries[fyStart].publicHolidays++;
          }
        }
      }
    });

    // Only include years that have at least one non-public-holiday entry
    const calendarYears = Object.keys(calendarYearEntries)
      .filter(year => {
        const stats = calendarYearEntries[year];
        return stats.total > stats.publicHolidays; // Has at least one non-PH entry
      })
      .map(y => parseInt(y))
      .sort((a, b) => b - a);

    const financialYears = Object.keys(financialYearEntries)
      .filter(year => {
        const stats = financialYearEntries[year];
        return stats.total > stats.publicHolidays; // Has at least one non-PH entry
      })
      .map(y => parseInt(y))
      .sort((a, b) => b - a);

    return {
      calendar: calendarYears,
      financial: financialYears
    };
  }

  function getCorrespondingYear(year, fromType, toType) {
    if (fromType === toType) return year;

    if (fromType === 'financial' && toType === 'calendar') {
      // FY 2024 (Jul 2024 - Jun 2025) -> Calendar 2024
      return year;
    } else if (fromType === 'calendar' && toType === 'financial') {
      // Calendar 2024 -> FY 2024 (Jul 2024 - Jun 2025)
      return year;
    }
    return year;
  }

  function renderAnnualData() {
    if (!state.annualData) return;

    const data = state.annualData;
    const totals = data.yearTotals;

    // Update summary stats
    const grossEl = document.getElementById('annual-stat-gross');
    const superEl = document.getElementById('annual-stat-super');
    const taxEl = document.getElementById('annual-stat-tax');
    const netEl = document.getElementById('annual-stat-net');
    const hoursEl = document.getElementById('annual-stat-hours');
    const taxRateEl = document.getElementById('annual-stat-tax-rate');
    const avgMonthlyEl = document.getElementById('annual-stat-avg-monthly');
    const hourlyRateEl = document.getElementById('annual-stat-hourly-rate');

    if (grossEl) grossEl.textContent = formatCurrency(totals.grossIncome);
    if (superEl) superEl.textContent = formatCurrency(totals.superGuarantee + totals.extraSuper);
    if (taxEl) taxEl.textContent = formatCurrency(totals.tax);
    if (netEl) netEl.textContent = formatCurrency(totals.netIncome);
    if (hoursEl) hoursEl.textContent = totals.totalHours.toFixed(1) + ' hrs';

    // Calculate and display new metrics
    const effectiveTaxRate = totals.grossIncome > 0 ? (totals.tax / totals.grossIncome) * 100 : 0;
    const avgMonthlyIncome = totals.grossIncome / 12;
    const effectiveHourlyRate = totals.totalHours > 0 ? totals.grossIncome / totals.totalHours : 0;

    if (taxRateEl) taxRateEl.textContent = effectiveTaxRate.toFixed(1) + '%';
    if (avgMonthlyEl) avgMonthlyEl.textContent = formatCurrency(avgMonthlyIncome);
    if (hourlyRateEl) hourlyRateEl.textContent = formatCurrency(effectiveHourlyRate) + '/hr';

    // Update breakdown table
    updateAnnualBreakdownTable();

    // Render charts
    destroyAnnualCharts();
    renderAnnualIncomeChart();
    renderAnnualIncomePieChart();
    renderAnnualContractPieChart();
    renderAnnualHourTypesPieChart();
    renderAnnualTotalHoursPieChart();
    renderAnnualTotalHoursByTypePieChart();

    // Update tax analysis
    renderAnnualTaxAnalysis();

    // Show/hide empty state
    const hasData = data.monthlyData.some(m => m.grossIncome > 0 || m.totalHours > 0);
    if (annualEmpty) annualEmpty.style.display = hasData ? 'none' : 'block';
  }

  function updateAnnualBreakdownTable() {
    if (!state.annualData) return;
    const totals = state.annualData.yearTotals;
    const totalSuper = totals.superGuarantee + totals.extraSuper;
    const gross = totals.grossIncome;

    // Gross Income (always 100%)
    document.getElementById('annual-breakdown-gross').textContent = formatCurrency(gross);
    document.getElementById('annual-breakdown-gross-pct').textContent = '100%';
    document.getElementById('annual-breakdown-gross-bar').style.width = '100%';

    // Superannuation
    const superPct = gross > 0 ? (totalSuper / gross) * 100 : 0;
    document.getElementById('annual-breakdown-super').textContent = formatCurrency(totalSuper);
    document.getElementById('annual-breakdown-super-pct').textContent = superPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-super-bar').style.width = superPct.toFixed(1) + '%';

    // Superannuation Lost
    const superLostRow = document.getElementById('annual-breakdown-super-lost-row');
    if (totals.superLost > 0.01) {
      if (superLostRow) superLostRow.style.display = '';
      const superLostPct = gross > 0 ? (totals.superLost / gross) * 100 : 0;
      document.getElementById('annual-breakdown-super-lost').textContent = formatCurrency(totals.superLost);
      document.getElementById('annual-breakdown-super-lost-pct').textContent = superLostPct.toFixed(1) + '%';
      document.getElementById('annual-breakdown-super-lost-bar').style.width = superLostPct.toFixed(1) + '%';
    } else {
      if (superLostRow) superLostRow.style.display = 'none';
    }

    // Deductions
    const deductionsPct = gross > 0 ? (totals.otherDeductions / gross) * 100 : 0;
    document.getElementById('annual-breakdown-deductions').textContent = formatCurrency(totals.otherDeductions);
    document.getElementById('annual-breakdown-deductions-pct').textContent = deductionsPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-deductions-bar').style.width = deductionsPct.toFixed(1) + '%';

    // Tax
    const taxPct = gross > 0 ? (totals.tax / gross) * 100 : 0;
    document.getElementById('annual-breakdown-tax').textContent = formatCurrency(totals.tax);
    document.getElementById('annual-breakdown-tax-pct').textContent = taxPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-tax-bar').style.width = taxPct.toFixed(1) + '%';

    // Net Income
    const netPct = gross > 0 ? (totals.netIncome / gross) * 100 : 0;
    document.getElementById('annual-breakdown-net').textContent = formatCurrency(totals.netIncome);
    document.getElementById('annual-breakdown-net-pct').textContent = netPct.toFixed(1) + '%';
    document.getElementById('annual-breakdown-net-bar').style.width = netPct.toFixed(1) + '%';
  }

  // Chart.js plugin for center text in donut charts
  const centerTextPlugin = {
    id: 'centerText',
    beforeDraw: (chart) => {
      if (!chart.config.options.plugins.centerText) return;

      const { ctx, chartArea: { left, top, right, bottom, width, height } } = chart;
      const centerX = left + width / 2;
      const centerY = top + height / 2;

      ctx.save();

      const text = chart.config.options.plugins.centerText.text || '';
      const color = chart.config.options.plugins.centerText.color || '#ffffff';

      // Main text (large, centered)
      ctx.font = 'bold 26px Inter, system-ui, sans-serif';
      ctx.fillStyle = color;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, centerX, centerY);

      ctx.restore();
    }
  };

  function renderAnnualIncomeChart() {
    const canvas = document.getElementById('annual-income-chart');
    if (!canvas || !state.annualData) return;

    const monthlyData = state.annualData.monthlyData;
    const labels = monthlyData.map(m => m.label);
    const colors = getThemeColors();

    const ctx = canvas.getContext('2d');
    state.annualCharts.income = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [
          {
            label: 'Tax',
            data: monthlyData.map(m => m.tax),
            backgroundColor: colors.danger,
            borderWidth: 0
          },
          {
            label: 'Deductions',
            data: monthlyData.map(m => m.otherDeductions),
            backgroundColor: colors.warning,
            borderWidth: 0
          },
          {
            label: 'Superannuation',
            data: monthlyData.map(m => m.superGuarantee + m.extraSuper),
            backgroundColor: colors.success,
            borderWidth: 0
          },
          {
            label: 'Net Income',
            data: monthlyData.map(m => m.netIncome),
            backgroundColor: colors.primary,
            borderWidth: 0
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
          mode: 'dataset',
          intersect: true
        },
        plugins: {
          datalabels: {
            color: '#fff',
            font: { size: 10, weight: '600' },
            formatter: (value) => {
              if (value < 500) return ''; // Hide labels for small segments
              return '$' + (value / 1000).toFixed(1) + 'k';
            },
            anchor: 'center',
            align: 'center'
          },
          legend: {
            position: 'top',
            align: 'start',
            labels: {
              color: colors.text,
              font: { size: 12, weight: '500' },
              padding: 16,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            bodySpacing: 6,
            cornerRadius: 8,
            mode: 'index',
            intersect: false,
            callbacks: {
              label: (context) => {
                return '  ' + context.dataset.label + ': ' + formatCurrency(context.parsed.y);
              },
              footer: (items) => {
                const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                return '\n  Gross Total: ' + formatCurrency(total);
              }
            }
          }
        },
        scales: {
          x: {
            stacked: true,
            grid: {
              display: false
            },
            ticks: {
              color: colors.muted,
              font: { size: 11 },
              padding: 8
            },
            border: {
              display: false
            }
          },
          y: {
            stacked: true,
            grid: {
              color: colors.border,
              drawBorder: false,
              lineWidth: 1
            },
            ticks: {
              color: colors.muted,
              font: { size: 11 },
              padding: 8,
              callback: (value) => '$' + (value / 1000).toFixed(0) + 'k'
            },
            border: {
              display: false
            }
          }
        },
        layout: {
          padding: {
            top: 10,
            right: 10,
            bottom: 0,
            left: 0
          }
        }
      }
    });
  }

  function renderAnnualIncomePieChart() {
    const canvas = document.getElementById('annual-income-pie-chart');
    if (!canvas || !state.annualData) return;

    const totals = state.annualData.yearTotals;
    const colors = getThemeColors();

    const grossIncome = totals.grossIncome;

    const ctx = canvas.getContext('2d');
    state.annualCharts.incomePie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: ['Net Income', 'Tax', 'Deductions', 'Superannuation'],
        datasets: [{
          data: [
            totals.netIncome,
            totals.tax,
            totals.otherDeductions,
            totals.superGuarantee + totals.extraSuper
          ],
          backgroundColor: [colors.primary, colors.danger, colors.warning, colors.success],
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: formatCurrency(grossIncome),
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const value = formatCurrency(context.parsed);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + value + ' (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function renderAnnualContractPieChart() {
    const container = document.getElementById('annual-contract-pie-container');
    const canvas = document.getElementById('annual-contract-pie-chart');
    if (!canvas || !state.annualData || !container) return;

    const contractBreakdown = state.annualData.contractBreakdown;
    if (contractBreakdown.length <= 1) {
      container.style.display = 'none';
      return;
    }

    container.style.display = 'block';
    const colors = getThemeColors();
    const chartColors = [colors.primary, colors.success, colors.warning, colors.danger, '#8b5cf6', '#ec4899', '#14b8a6', '#f59e0b'];

    const totalIncome = contractBreakdown.reduce((sum, c) => sum + c.grossIncome, 0);

    const ctx = canvas.getContext('2d');
    state.annualCharts.contractPie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: contractBreakdown.map(c => c.contractName),
        datasets: [{
          data: contractBreakdown.map(c => c.grossIncome),
          backgroundColor: chartColors.slice(0, contractBreakdown.length),
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: formatCurrency(totalIncome),
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const value = formatCurrency(context.parsed);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + value + ' (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function renderAnnualHourTypesPieChart() {
    const container = document.getElementById('annual-hour-types-pie-container');
    const canvas = document.getElementById('annual-hour-types-pie-chart');
    if (!canvas || !state.annualData || !container) return;

    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
    if (!hourTypesEnabled) {
      container.style.display = 'none';
      return;
    }

    const hourTypeBreakdown = state.annualData.hourTypeBreakdown;
    if (hourTypeBreakdown.length === 0) {
      container.style.display = 'none';
      return;
    }

    container.style.display = 'block';
    const colors = getThemeColors();

    const ctx = canvas.getContext('2d');
    state.annualCharts.hourTypesPie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: hourTypeBreakdown.map(ht => ht.hourTypeName),
        datasets: [{
          data: hourTypeBreakdown.map(ht => ht.hours),
          backgroundColor: hourTypeBreakdown.map(ht => ht.hourTypeColor || colors.muted),
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '45%',
        plugins: {
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const hours = context.parsed.toFixed(1);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + hours + ' hrs (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      }
    });
  }

  function renderAnnualTotalHoursPieChart() {
    const canvas = document.getElementById('annual-total-hours-pie-chart');
    if (!canvas || !state.annualData) return;

    const monthlyData = state.annualData.monthlyData;
    const labels = monthlyData.map(m => m.label);
    const hours = monthlyData.map(m => m.totalHours);
    const colors = getThemeColors();

    const totalHours = hours.reduce((sum, h) => sum + h, 0);

    // Use rainbow gradient for 12 months (ordered visually)
    const monthColors = hours.map((_, index) => {
      const hue = (index * 30) % 360; // 0, 30, 60, 90, 120... (full spectrum)
      return `hsl(${hue}, 70%, 60%)`;
    });

    const ctx = canvas.getContext('2d');
    state.annualCharts.totalHoursPie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: labels,
        datasets: [{
          data: hours,
          backgroundColor: monthColors,
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: totalHours.toFixed(1) + ' hrs',
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const hoursVal = context.parsed.toFixed(1);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + hoursVal + ' hrs (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function renderAnnualTotalHoursByTypePieChart() {
    const canvas = document.getElementById('annual-total-hours-by-type-pie-chart');
    if (!canvas || !state.annualData) return;

    const hourTypeBreakdown = state.annualData.hourTypeBreakdown;
    if (!hourTypeBreakdown || hourTypeBreakdown.length === 0) {
      console.log('No hour type breakdown data available', state.annualData);
      return;
    }

    console.log('Rendering hour types pie chart with data:', hourTypeBreakdown);

    const labels = hourTypeBreakdown.map(ht => ht.hourTypeName);
    const hours = hourTypeBreakdown.map(ht => ht.hours);
    const hourColors = hourTypeBreakdown.map(ht => ht.hourTypeColor);
    const colors = getThemeColors();

    const totalHours = hours.reduce((sum, h) => sum + h, 0);

    const ctx = canvas.getContext('2d');
    state.annualCharts.totalHoursByTypePie = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: labels,
        datasets: [{
          data: hours,
          backgroundColor: hourColors,
          borderWidth: 3,
          borderColor: getComputedStyle(document.body).getPropertyValue('--panel').trim(),
          hoverBorderWidth: 4,
          hoverBorderColor: '#fff',
          hoverOffset: 8
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '65%',
        plugins: {
          centerText: {
            text: totalHours.toFixed(1) + ' hrs',
            color: colors.text
          },
          datalabels: {
            display: false
          },
          legend: {
            position: 'bottom',
            labels: {
              color: colors.text,
              font: { size: 11, weight: '500' },
              padding: 12,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            backgroundColor: 'rgba(0, 0, 0, 0.9)',
            padding: 12,
            titleFont: { size: 13, weight: 'bold' },
            bodyFont: { size: 12 },
            cornerRadius: 8,
            callbacks: {
              label: (context) => {
                const label = context.label || '';
                const hoursVal = context.parsed.toFixed(1);
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const pct = ((context.parsed / total) * 100).toFixed(1);
                return '  ' + label + ': ' + hoursVal + ' hrs (' + pct + '%)';
              }
            }
          }
        },
        layout: {
          padding: 20
        }
      },
      plugins: [centerTextPlugin]
    });
  }

  function calculateAustralianTax(annualTaxableIncome) {
    // Australian tax brackets 2024/2025
    let tax = 0;

    if (annualTaxableIncome <= 18200) {
      tax = 0;
    } else if (annualTaxableIncome <= 45000) {
      tax = (annualTaxableIncome - 18200) * 0.16;
    } else if (annualTaxableIncome <= 135000) {
      tax = 4288 + (annualTaxableIncome - 45000) * 0.30;
    } else if (annualTaxableIncome <= 190000) {
      tax = 31288 + (annualTaxableIncome - 135000) * 0.37;
    } else {
      tax = 51638 + (annualTaxableIncome - 190000) * 0.45;
    }

    // Add Medicare levy (2%)
    const medicareLevy = annualTaxableIncome * 0.02;

    return tax + medicareLevy;
  }

  function renderAnnualTaxAnalysis() {
    if (!state.annualData) return;

    const monthlyData = state.annualData.monthlyData;
    const totals = state.annualData.yearTotals;
    const paidTax = totals.tax;

    // Calculate annual taxable income by summing monthly taxable incomes
    const annualTaxableIncome = monthlyData.reduce((sum, m) => sum + m.taxableIncome, 0);

    // Calculate expected ATO tax with Medicare levy
    const expectedTax = calculateAustralianTax(annualTaxableIncome);
    const difference = paidTax - expectedTax;

    document.getElementById('annual-tax-paid').textContent = formatCurrency(paidTax);
    document.getElementById('annual-tax-expected').textContent = formatCurrency(expectedTax);

    const diffEl = document.getElementById('annual-tax-difference');
    if (diffEl) {
      diffEl.textContent = formatCurrency(Math.abs(difference));
      diffEl.style.color = difference > 0 ? 'var(--danger)' : 'var(--success)';
    }
  }

  // Event listeners for annual views
  if (annualYearTypeToggle) {
    annualYearTypeToggle.addEventListener('change', () => {
      const oldType = state.annualYearType;
      state.annualYearType = annualYearTypeToggle.checked ? 'calendar' : 'financial';

      if (annualYearTypeLabel) {
        annualYearTypeLabel.textContent = state.annualYearType === 'financial' ? 'Financial Year' : 'Calendar Year';
      }

      // Get corresponding year for new type
      const correspondingYear = getCorrespondingYear(state.annualCurrentYear, oldType, state.annualYearType);

      // Update year selector with new type's years
      const allYears = collectAllYears();
      const years = state.annualYearType === 'financial' ? allYears.financial : allYears.calendar;

      if (years.length === 0) {
        years.push(new Date().getFullYear());
      }

      // Set year to corresponding year if it exists, otherwise use first available
      if (years.includes(correspondingYear)) {
        state.annualCurrentYear = correspondingYear;
      } else {
        state.annualCurrentYear = years[0];
      }

      if (annualYearSelect) {
        const options = years.map(year => {
          const fy = financialYearLabel(year);
          return `<option value="${year}">${state.annualYearType === 'financial' ? fy : year}</option>`;
        }).join('');
        annualYearSelect.innerHTML = options;
        annualYearSelect.value = String(state.annualCurrentYear);
      }

      saveCache();
      renderAnnualContractFilter();
      loadAnnualData();
    });
  }

  if (annualYearSelect) {
    annualYearSelect.addEventListener('change', () => {
      state.annualCurrentYear = Number(annualYearSelect.value);
      saveCache();
      loadAnnualData();
    });
  }

  if (annualContractFilterToggle) {
    annualContractFilterToggle.addEventListener('click', () => {
      if (annualContractFilterPanel) {
        const isHidden = annualContractFilterPanel.style.display === 'none';
        annualContractFilterPanel.style.display = isHidden ? 'block' : 'none';
      }
    });
  }

  if (annualFilterSelectAll) {
    annualFilterSelectAll.addEventListener('click', () => {
      // Get year range based on year type
      let yearStart, yearEnd;
      if (state.annualYearType === 'financial') {
        yearStart = new Date(state.annualCurrentYear, 6, 1);
        yearEnd = new Date(state.annualCurrentYear + 1, 5, 30, 23, 59, 59);
      } else {
        yearStart = new Date(state.annualCurrentYear, 0, 1);
        yearEnd = new Date(state.annualCurrentYear, 11, 31, 23, 59, 59);
      }

      // Select only relevant contracts for this year
      const relevantContracts = state.contracts.filter(c => {
        if (!c || !c.id) return false;
        const contractStart = c.start_date ? new Date(c.start_date) : new Date(0);
        const contractEnd = c.end_date ? new Date(c.end_date) : new Date(9999, 11, 31);
        return contractStart <= yearEnd && contractEnd >= yearStart;
      });

      state.annualFilteredContracts = relevantContracts.map(c => c.id);
      saveCache();
      renderAnnualContractFilter();
      loadAnnualData();
    });
  }


  function updateDeductionCompanyOptions() {
    if (!deductionCategorySelect) return;
    const options = Array.from(deductionCategorySelect.options);
    const companyOption = options.find((opt) => opt.value === 'company');
    if (!companyOption) return;

    if (state.companyTrackingEnabled) {
      companyOption.disabled = false;
      if (deductionCategoryReadonly) deductionCategoryReadonly.style.display = 'none';
      deductionCategorySelect.style.display = '';
      deductionCategorySelect.disabled = false;
    } else {
      companyOption.disabled = true;
      if (deductionCategorySelect.value === 'company') {
        deductionCategorySelect.value = 'personal';
      }
      deductionCategorySelect.style.display = 'none';
      deductionCategorySelect.disabled = true;
      if (deductionCategoryReadonly) {
        deductionCategoryReadonly.style.display = 'block';
        deductionCategoryReadonly.value = 'Salary sacrifice';
      }
    }
  }

  function renderDeductionsList() {
    if (!deductionsListEl) return;
    const list = Array.isArray(state.deductions) ? [...state.deductions] : [];
    list.sort((a, b) => {
      if (a.active !== b.active) return a.active ? -1 : 1;
      return a.name.localeCompare(b.name);
    });
    const hasItems = list.length > 0;
    if (deductionsEmptyEl) {
      deductionsEmptyEl.style.display = hasItems ? 'none' : 'block';
    }
    deductionsListEl.innerHTML = '';
    const showReadonlyNote = !state.companyTrackingEnabled && list.some((item) => item.category === 'company');
    if (deductionCompanyDisabledNote) {
      deductionCompanyDisabledNote.style.display = showReadonlyNote ? 'inline-flex' : 'none';
    }
    list.forEach((deduction) => {
      const card = createDeductionCard(deduction);
      deductionsListEl.appendChild(card);
    });
  }

  function createDeductionCard(deduction) {
    const wrapper = document.createElement('div');
    wrapper.className = 'ts-item';
    if (!deduction.active || (deduction.category === 'company' && !state.companyTrackingEnabled)) {
      wrapper.classList.add('ts-deduction-readonly');
    }

    const details = document.createElement('div');
    details.className = 'ts-deduction-details';

    const header = document.createElement('div');
    header.className = 'ts-deduction-header';

    const title = document.createElement('div');
    title.style.fontWeight = '600';
    title.textContent = deduction.name || 'Untitled deduction';
    header.appendChild(title);

    const categoryBadge = document.createElement('span');
    categoryBadge.className = 'ts-badge';
    categoryBadge.textContent = deduction.category === 'company' ? 'Company expense' : 'Salary sacrifice';
    header.appendChild(categoryBadge);

    if (deduction.deduction_type === 'extra_super') {
      const typeBadge = document.createElement('span');
      typeBadge.className = 'ts-badge';
      typeBadge.textContent = 'Extra super';
      header.appendChild(typeBadge);
    }

    details.appendChild(header);

    const meta = document.createElement('div');
    meta.className = 'ts-deduction-meta';
    const amountSpan = document.createElement('span');
    amountSpan.textContent = formatDeductionAmount(deduction);
    if (deduction.gst_inclusive && deduction.amount_type !== 'percent') {
      amountSpan.textContent += ' (GST excl.)';
      amountSpan.title = `Entered ${formatCurrency(deduction.amount_value)} incl. GST`;
    }
    meta.appendChild(amountSpan);

    const freqSpan = document.createElement('span');
    freqSpan.textContent = formatFrequencyLabel(deduction.frequency);
    meta.appendChild(freqSpan);

    const startSpan = document.createElement('span');
    startSpan.textContent = `Starts ${deduction.start_date ? DATE_FULL_FORMATTER.format(parseIsoDate(deduction.start_date)) : '—'}`;
    meta.appendChild(startSpan);

    if (deduction.end_date) {
      const endSpan = document.createElement('span');
      endSpan.textContent = `Ends ${DATE_FULL_FORMATTER.format(parseIsoDate(deduction.end_date))}`;
      meta.appendChild(endSpan);
    }
    details.appendChild(meta);

    const upcomingDates = getUpcomingDeductionDates(deduction, 5);
    if (deduction.frequency !== 'once') {
      const occurrenceEl = document.createElement('span');
      occurrenceEl.className = 'ts-deduction-occurrences';
      if (upcomingDates.length) {
        occurrenceEl.textContent = `Next deduction on ${DATE_FULL_FORMATTER.format(parseIsoDate(upcomingDates[0]))}`;
      } else {
        occurrenceEl.textContent = 'No upcoming deductions scheduled.';
      }
      meta.appendChild(occurrenceEl);
    }

    if (deduction.notes) {
      const noteEl = document.createElement('div');
      noteEl.className = 'ts-deduction-note';
      noteEl.textContent = deduction.notes;
      details.appendChild(noteEl);
    }

    const actions = document.createElement('div');
    actions.className = 'ts-deduction-actions';

    const editBtn = document.createElement('button');
    editBtn.className = 'ghost small';
    editBtn.textContent = 'Edit';
    editBtn.addEventListener('click', () => openDeductionForm('edit', deduction));

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'ghost small danger';
    deleteBtn.textContent = 'Delete';
    deleteBtn.addEventListener('click', () => handleDeleteDeduction(deduction));

    const readOnly = (!deduction.active) || (deduction.category === 'company' && !state.companyTrackingEnabled);
    if (readOnly) {
      editBtn.disabled = true;
      deleteBtn.disabled = true;
      editBtn.title = 'Company tracking is disabled; this deduction is read-only.';
      deleteBtn.title = editBtn.title;
    }

    actions.appendChild(editBtn);
    actions.appendChild(deleteBtn);

    wrapper.appendChild(details);
    wrapper.appendChild(actions);
    return wrapper;
  }

  function resetDeductionForm() {
    if (!deductionNameInput) return;
    deductionFormState.mode = 'create';
    deductionFormState.editingId = null;
    deductionFormState.original = null;
    deductionNameInput.value = '';
    if (deductionCategorySelect) deductionCategorySelect.value = 'personal';
    if (deductionCategoryReadonly) deductionCategoryReadonly.value = 'Salary sacrifice';
    if (deductionTypeSelect) deductionTypeSelect.value = 'standard';
    if (deductionAmountInput) deductionAmountInput.value = '';
    if (deductionPercentInput) deductionPercentInput.value = '';
    if (deductionAmountModeSelect) deductionAmountModeSelect.value = 'flat';
    if (deductionGstToggle) deductionGstToggle.checked = false;
    if (deductionFrequencySelect) deductionFrequencySelect.value = 'once';
    if (deductionStartDateInput) deductionStartDateInput.value = todayIso();
    if (deductionEndDateInput) deductionEndDateInput.value = '';
    if (deductionNotesInput) deductionNotesInput.value = '';
    if (deductionOccurrencePreview) deductionOccurrencePreview.textContent = '';
    updateDeductionCompanyOptions();
    updateDeductionFormVisibility();
  }

  function closeDeductionForm() {
    deductionFormState.mode = 'create';
    deductionFormState.editingId = null;
    deductionFormState.original = null;
    hideModal(deductionFormModal);
  }

  function openDeductionForm(mode, deduction) {
    if (!deductionFormModal) return;
    if (mode === 'edit' && deduction && deduction.category === 'company' && !state.companyTrackingEnabled) {
      setStatus('Enable company tracking features to edit company deductions.', 'warn');
      return;
    }
    resetDeductionForm();
    deductionFormState.mode = mode;
    deductionFormState.editingId = deduction ? deduction.id : null;
    deductionFormState.original = deduction || null;
    if (deductionFormTitle) {
      deductionFormTitle.textContent = mode === 'edit' ? 'Edit deduction' : 'Add deduction';
    }
    if (mode === 'edit' && deduction) {
      if (deductionNameInput) deductionNameInput.value = deduction.name || '';
      if (deductionCategorySelect) deductionCategorySelect.value = deduction.category === 'company' ? 'company' : 'personal';
      if (deductionTypeSelect) deductionTypeSelect.value = deduction.deduction_type === 'extra_super' ? 'extra_super' : 'standard';
      const amountMode = deduction.amount_type === 'percent' ? 'percent' : 'flat';
      if (deductionAmountModeSelect) deductionAmountModeSelect.value = amountMode;
      if (amountMode === 'percent') {
        if (deductionPercentInput) {
          deductionPercentInput.value = Math.round(deduction.amount_value * 10000) / 100;
        }
      } else if (deductionAmountInput) {
        deductionAmountInput.value = Number(deduction.amount_value).toFixed(2);
      }
      if (deductionGstToggle) deductionGstToggle.checked = !!deduction.gst_inclusive;
      if (deductionFrequencySelect) deductionFrequencySelect.value = deduction.frequency || 'once';
      if (deductionStartDateInput) deductionStartDateInput.value = deduction.start_date || '';
      if (deductionEndDateInput) deductionEndDateInput.value = deduction.end_date || '';
      if (deductionNotesInput) deductionNotesInput.value = deduction.notes || '';
    }
    updateDeductionCompanyOptions();
    updateDeductionFormVisibility();
    updateDeductionOccurrencePreview();
    showModal(deductionFormModal);
    if (deductionNameInput) deductionNameInput.focus();
  }

  function updateDeductionFormVisibility() {
    if (!deductionTypeSelect) return;
    const type = deductionTypeSelect.value === 'extra_super' ? 'extra_super' : 'standard';
    let rawCategory = deductionCategorySelect ? deductionCategorySelect.value : 'personal';
    if (type === 'extra_super' && rawCategory === 'company') {
      rawCategory = 'personal';
      if (deductionCategorySelect) deductionCategorySelect.value = 'personal';
    }
    const category = (rawCategory === 'company' && state.companyTrackingEnabled) ? 'company' : 'personal';
    const amountMode = type === 'extra_super' && deductionAmountModeSelect ? deductionAmountModeSelect.value : 'flat';

    if (deductionAmountModeWrapper) {
      deductionAmountModeWrapper.style.display = type === 'extra_super' ? 'block' : 'none';
    }
    if (deductionPercentWrapper) {
      deductionPercentWrapper.style.display = type === 'extra_super' && amountMode === 'percent' ? 'block' : 'none';
    }
    if (deductionAmountWrapper) {
      deductionAmountWrapper.style.display = !(type === 'extra_super' && amountMode === 'percent') ? 'block' : 'none';
    }

    const showGstToggle = type === 'standard';
    if (deductionGstWrapper) {
      deductionGstWrapper.style.display = showGstToggle ? 'flex' : 'none';
    }
    if (deductionCompanyGstNote) {
      if (showGstToggle) {
        deductionCompanyGstNote.style.display = 'block';
        deductionCompanyGstNote.textContent = category === 'company'
          ? 'GST component is tracked for company deductions and excluded from totals.'
          : 'If the amount includes GST, the GST portion is excluded before applying the deduction.';
      } else {
        deductionCompanyGstNote.style.display = 'none';
      }
    }
    if (deductionGstToggle) {
      if (!showGstToggle) {
        deductionGstToggle.checked = false;
      }
      deductionGstToggle.disabled = !showGstToggle;
    }

    const restrictToMonthly = type === 'extra_super' && amountMode === 'percent';
    if (deductionFrequencySelect) {
      Array.from(deductionFrequencySelect.options).forEach((option) => {
        if (restrictToMonthly && option.value !== 'monthly') {
          option.disabled = true;
        } else {
          option.disabled = false;
        }
      });
      if (restrictToMonthly) {
        deductionFrequencySelect.value = 'monthly';
      }
    }

    if (deductionFrequencySelect && deductionFrequencySelect.value === 'once') {
      if (deductionEndDateWrapper) deductionEndDateWrapper.style.display = 'none';
      if (deductionEndDateInput) deductionEndDateInput.value = '';
    } else if (deductionEndDateWrapper) {
      deductionEndDateWrapper.style.display = 'block';
    }

    updateDeductionCompanyOptions();
    updateDeductionOccurrencePreview();
  }

  function updateDeductionOccurrencePreview() {
    if (!deductionOccurrencePreview || !deductionStartDateInput) return;
    const startDateValue = deductionStartDateInput.value;
    const frequency = deductionFrequencySelect ? deductionFrequencySelect.value : 'once';
    const endDateValue = deductionEndDateInput ? deductionEndDateInput.value : '';
    if (!startDateValue) {
      deductionOccurrencePreview.textContent = 'Select a start date to preview the schedule.';
      return;
    }
    const preview = {
      start_date: startDateValue,
      end_date: frequency === 'once' ? '' : endDateValue,
      frequency: frequency
    };
    const previewDates = getDeductionPreviewDates(preview, 5);
    if (!previewDates.length) {
      if (frequency === 'once') {
      deductionOccurrencePreview.textContent = `Occurs on ${DATE_FULL_FORMATTER.format(parseIsoDate(startDateValue))}.`;
      } else {
        deductionOccurrencePreview.textContent = 'No future occurrences within the configured range.';
      }
      return;
    }
    const labels = previewDates.map((iso) => DATE_FULL_FORMATTER.format(parseIsoDate(iso)));
    deductionOccurrencePreview.textContent = `Next ${labels.length > 1 ? labels.length : 1} deduction${labels.length > 1 ? 's' : ''}: ${labels.join(', ')}`;
  }

  function collectDeductionPayload() {
    if (!deductionNameInput) return null;
    const name = deductionNameInput.value.trim();
    if (!name) {
      setStatus('Deduction name is required.', 'warn');
      return null;
    }
    const category = deductionCategorySelect ? deductionCategorySelect.value : 'personal';
    const type = deductionTypeSelect ? deductionTypeSelect.value : 'standard';
    const amountMode = type === 'extra_super' && deductionAmountModeSelect ? deductionAmountModeSelect.value : 'flat';
    let amountValue;
    if (amountMode === 'percent') {
      amountValue = Number(deductionPercentInput ? deductionPercentInput.value : '');
      if (!Number.isFinite(amountValue) || amountValue <= 0) {
        setStatus('Enter a valid percentage for the deduction.', 'warn');
        return null;
      }
      if (amountValue > 50) {
        setStatus('Percentage deductions must be 50% or less.', 'warn');
        return null;
      }
    } else {
      amountValue = Number(deductionAmountInput ? deductionAmountInput.value : '');
      if (!Number.isFinite(amountValue) || amountValue < 0) {
        setStatus('Enter a valid amount for the deduction.', 'warn');
        return null;
      }
    }
    const frequency = deductionFrequencySelect ? deductionFrequencySelect.value : 'once';
    const startDateValue = deductionStartDateInput ? deductionStartDateInput.value : '';
    if (!startDateValue) {
      setStatus('Select a start date for the deduction.', 'warn');
      return null;
    }
    let endDateValue = deductionEndDateInput ? deductionEndDateInput.value : '';
    if (frequency === 'once') {
      endDateValue = '';
    } else if (endDateValue && endDateValue < startDateValue) {
      setStatus('End date must be on or after the start date.', 'warn');
      return null;
    }
    const payload = {
      id: deductionFormState.mode === 'edit' ? deductionFormState.editingId : undefined,
      name,
      category,
      deduction_type: type,
      amount_type: amountMode,
      amount_value: amountValue,
      gst_inclusive: type === 'standard' ? (deductionGstToggle ? deductionGstToggle.checked : false) : false,
      frequency,
      start_date: startDateValue,
      end_date: endDateValue,
      notes: deductionNotesInput ? deductionNotesInput.value.trim() : '',
      active: true
    };
    if (payload.deduction_type === 'extra_super') {
      payload.category = 'personal';
      payload.gst_inclusive = false;
    }
    if (type === 'extra_super' && amountMode === 'percent') {
      payload.frequency = 'monthly';
    }
    return payload;
  }

  function buildOptimisticDeduction(payload, existing) {
    const nowIso = new Date().toISOString();
    const id = payload.id || `temp_${Date.now()}`;
    const amountDecimal = payload.amount_type === 'percent'
      ? (Number(payload.amount_value) / 100)
      : Number(payload.amount_value);
    const base = {
      id,
      name: payload.name,
      category: payload.category,
      deduction_type: payload.deduction_type,
      amount_type: payload.amount_type,
      amount_value: payload.amount_type === 'percent' ? amountDecimal : amountDecimal,
      gst_inclusive: !!payload.gst_inclusive,
      gst_amount: payload.category === 'company' && payload.deduction_type === 'standard' && payload.gst_inclusive
        ? Math.round((Number(payload.amount_value) - (Number(payload.amount_value) / (1 + GST_RATE))) * 100) / 100
        : 0,
      frequency: payload.frequency,
      start_date: payload.start_date,
      end_date: payload.frequency === 'once' ? '' : payload.end_date,
      notes: payload.notes || '',
      active: true,
      created_at: existing && existing.created_at ? existing.created_at : nowIso,
      updated_at: nowIso
    };
    return sanitizeDeduction(base);
  }

  function handleSaveDeduction() {
    const payload = collectDeductionPayload();
    if (!payload) return;
    const isEdit = deductionFormState.mode === 'edit' && deductionFormState.editingId;
    if (isEdit) {
      payload.id = deductionFormState.editingId;
    }
    const previousList = state.deductions.slice();
    const existingIndex = isEdit ? state.deductions.findIndex((item) => item.id === payload.id) : -1;
    const existing = existingIndex !== -1 ? state.deductions[existingIndex] : null;
    const optimisticId = isEdit ? payload.id : `temp_${Date.now()}`;
    const optimisticDeduction = buildOptimisticDeduction({ ...payload, id: optimisticId }, existing);

    if (isEdit && existingIndex !== -1) {
      state.deductions.splice(existingIndex, 1, optimisticDeduction);
    } else {
      state.deductions.push(optimisticDeduction);
    }

    saveCache();
    renderDeductionsList();
    renderIncomeSummary();
    closeDeductionForm();
    setStatus('Saving deduction...', 'warn');

    const serverPayload = { ...payload };

    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success && res.deduction) {
          const updated = sanitizeDeduction(res.deduction);
          const matchIndex = state.deductions.findIndex((item) => item.id === optimisticId);
          if (matchIndex !== -1) {
            state.deductions.splice(matchIndex, 1, updated);
          } else if (isEdit) {
            const editIndex = state.deductions.findIndex((item) => item.id === payload.id);
            if (editIndex !== -1) state.deductions.splice(editIndex, 1, updated);
          } else {
            state.deductions.push(updated);
          }
          saveCache();
          renderDeductionsList();
          renderIncomeSummary();
          setStatus('Deduction saved', 'success');
        } else {
          state.deductions = previousList;
          saveCache();
          renderDeductionsList();
          renderIncomeSummary();
          setStatus('Deduction save failed', 'error');
        }
      })
      .withFailureHandler(() => {
        state.deductions = previousList;
        saveCache();
        renderDeductionsList();
        renderIncomeSummary();
        setStatus('Deduction save failed', 'error');
      })
      .api_upsertDeduction(serverPayload);
  }

  async function handleDeleteDeduction(deduction) {
    if (!deduction || !deduction.id) return;
    const confirmed = await customConfirm('Delete this deduction?', { danger: true });
    if (!confirmed) return;
    if (deduction.category === 'company' && !state.companyTrackingEnabled) {
      setStatus('Enable company tracking to modify company deductions.', 'warn');
      return;
    }
    const previousList = state.deductions.slice();
    state.deductions = state.deductions.filter((item) => item.id !== deduction.id);
    saveCache();
    renderDeductionsList();
    renderIncomeSummary();
    setStatus('Deleting deduction...', 'warn');
    google.script.run
      .withSuccessHandler(() => {
        setStatus('Deduction deleted', 'success');
      })
      .withFailureHandler(() => {
        state.deductions = previousList;
        saveCache();
        renderDeductionsList();
        renderIncomeSummary();
        setStatus('Failed to delete deduction', 'error');
      })
      .api_deleteDeduction(deduction.id);
  }

  const DEFAULT_FEATURE_FLAGS = {
    remember_last_page: {
      name: 'Remember last page on refresh',
      description: 'When enabled, the app reopens on the most recently viewed page.',
      order: 100
    },
    show_clear_cache: {
      name: 'Show cache clear button',
      description: 'Displays a button that lets you clear cached entries and settings from this browser.',
      order: 110
    },
    show_zero_hours: {
      name: 'Show zero hours on empty days',
      description: 'When enabled, days without logged time display a 0 instead of being blank.',
      order: 120
    },
    hour_types: {
      name: 'Hour Types',
      description: 'Enables tracking different types of hours (work, annual, sick, training, etc.) with configurable income contribution and visualization.',
      order: 130
    },
    expected_monthly_hours: {
      name: 'Expected monthly hours insights',
      description: 'Adds a badge that breaks down projected contract hours for the active month.',
      order: 140
    },
    suggest_end_time: {
      name: 'Suggest End Time',
      description: 'Shows a helpful suggestion for when to clock out to achieve nicely rounded daily hours.',
      order: 145
    },
    xero_payroll_helper: {
      name: 'Xero payroll helper',
      description: 'Adds a modal with week-by-week totals formatted for Xero payroll entry.',
      order: 150
    },
    myob_payroll_helper: {
      name: 'MYOB payroll helper',
      description: 'Adds a modal with weekly totals formatted for MYOB payroll entry.',
      order: 160
    },
    enable_actual_income: {
      name: 'Enable Actual Income Tracking',
      description: 'Enables tracking of actual income received, allowing comparison between estimated and actual earnings with variance indicators.',
      order: 165
    },
    enable_company_tracking_features: {
      name: 'Enable Company Tracking Features',
      description: 'Unlocks company-focused fields such as company deduction categories and BAS reporting.',
      order: 200
    },
    enable_company_quarterly_bas: {
      name: 'Enable Company BAS quarterly reporting',
      description: 'Displays BAS reporting in quarterly totals instead of monthly.',
      order: 201
    },
    is_sole_trader: {
      name: 'Sole Trader mode',
      description: 'Indicates the business is a sole trader. Affects PAYG income calculations in BAS reporting.',
      order: 202
    },
    enable_public_holidays: {
      name: 'Australian Public Holidays',
      description: 'Displays Australian public holidays in the calendar view with automatic API sync.',
      order: 170
    },
    enable_colorblind_themes: {
      name: 'Enable Colour Blind Themes',
      description: 'Adds colorblind-friendly theme options to the settings dropdown and warns about problematic hour type colors.',
      order: 180
    },
    custom_theme: {
      name: 'Custom Theme',
      description: 'Enables a custom theme where you can configure your own colors. The theme dropdown will be locked to "Custom" when enabled.',
      order: 190
    }
  };

  const DEDUCTION_FREQUENCIES = ['once', 'weekly', 'fortnightly', 'monthly', 'quarterly', 'yearly'];

  const THEME_KEYS = ['dark', 'light', 'og', 'rose', 'sierra117', 'protanopia', 'deuteranopia', 'tritanopia', 'monochrome', 'custom'];

  function applyTheme(theme) {
    const normalized = THEME_KEYS.includes(theme) ? theme : 'dark';
    const body = document.body;
    THEME_KEYS.forEach((key) => body.classList.remove('ts-theme-' + key));
    body.classList.add('ts-theme-' + normalized);
    state.settings = { ...state.settings, theme: normalized };
    if (themeSelect) themeSelect.value = normalized;

    // Apply custom theme if selected
    if (normalized === 'custom') {
      applyCustomTheme();
    }
  }

  // Color manipulation helpers
  function hexToRgb(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }

  function lighten(hex, amount) {
    var rgb = hexToRgb(hex);
    if (!rgb) return hex;
    var r = Math.min(255, Math.floor(rgb.r + (255 - rgb.r) * amount));
    var g = Math.min(255, Math.floor(rgb.g + (255 - rgb.g) * amount));
    var b = Math.min(255, Math.floor(rgb.b + (255 - rgb.b) * amount));
    return rgbToHex(r, g, b);
  }

  function darken(hex, amount) {
    var rgb = hexToRgb(hex);
    if (!rgb) return hex;
    var r = Math.floor(rgb.r * (1 - amount));
    var g = Math.floor(rgb.g * (1 - amount));
    var b = Math.floor(rgb.b * (1 - amount));
    return rgbToHex(r, g, b);
  }

  function adjustHue(hex, degrees) {
    var rgb = hexToRgb(hex);
    if (!rgb) return hex;

    // Convert to HSL
    var r = rgb.r / 255;
    var g = rgb.g / 255;
    var b = rgb.b / 255;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h, s, l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      if (max === r) h = (g - b) / d + (g < b ? 6 : 0);
      else if (max === g) h = (b - r) / d + 2;
      else h = (r - g) / d + 4;
      h /= 6;
    }

    // Adjust hue
    h = (h * 360 + degrees) % 360;
    if (h < 0) h += 360;
    h = h / 360;

    // Convert back to RGB
    function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1/6) return p + (q - p) * 6 * t;
      if (t < 1/2) return q;
      if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    }

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);

    return rgbToHex(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255));
  }

  function generateCustomTheme(bgColor, primaryColor, textColor, successColor) {
    var bg = bgColor;
    var panel = lighten(bg, 0.06);
    var border = lighten(bg, 0.12);
    var text = textColor;
    var primary = primaryColor;
    var primaryDark = darken(primary, 0.15);
    var success = successColor;
    var danger = adjustHue(primary, 15);

    // Calculate muted text (between bg and text)
    var bgRgb = hexToRgb(bg);
    var textRgb = hexToRgb(text);
    var muted = rgbToHex(
      Math.floor((bgRgb.r + textRgb.r * 2) / 3),
      Math.floor((bgRgb.g + textRgb.g * 2) / 3),
      Math.floor((bgRgb.b + textRgb.b * 2) / 3)
    );

    var primaryRgb = hexToRgb(primary);
    var successRgb = hexToRgb(success);
    var dangerRgb = hexToRgb(danger);

    return {
      '--bg': bg,
      '--panel': panel,
      '--muted': muted,
      '--text': text,
      '--primary': primary,
      '--primary-600': primaryDark,
      '--danger': danger,
      '--success': success,
      '--border': border,
      '--badge-bg': panel,
      '--badge-border': border,
      '--badge-text': text,
      '--badge-success-bg': 'rgba(' + successRgb.r + ', ' + successRgb.g + ', ' + successRgb.b + ', 0.2)',
      '--badge-success-border': 'rgba(' + successRgb.r + ', ' + successRgb.g + ', ' + successRgb.b + ', 0.65)',
      '--badge-success-text': success,
      '--badge-warn-bg': 'rgba(' + primaryRgb.r + ', ' + primaryRgb.g + ', ' + primaryRgb.b + ', 0.22)',
      '--badge-warn-border': 'rgba(' + primaryRgb.r + ', ' + primaryRgb.g + ', ' + primaryRgb.b + ', 0.65)',
      '--badge-warn-text': lighten(primary, 0.15),
      '--badge-error-bg': 'rgba(' + dangerRgb.r + ', ' + dangerRgb.g + ', ' + dangerRgb.b + ', 0.2)',
      '--badge-error-border': 'rgba(' + dangerRgb.r + ', ' + dangerRgb.g + ', ' + dangerRgb.b + ', 0.65)',
      '--badge-error-text': danger,
      '--primary-soft-bg': 'rgba(' + primaryRgb.r + ', ' + primaryRgb.g + ', ' + primaryRgb.b + ', 0.2)',
      '--primary-soft-border': 'rgba(' + primaryRgb.r + ', ' + primaryRgb.g + ', ' + primaryRgb.b + ', 0.75)',
      '--primary-soft-text': lighten(primary, 0.2),
      '--primary-glow': 'rgba(' + primaryRgb.r + ', ' + primaryRgb.g + ', ' + primaryRgb.b + ', 0.4)',
      '--primary-hint-bg': 'rgba(' + primaryRgb.r + ', ' + primaryRgb.g + ', ' + primaryRgb.b + ', 0.16)',
      '--primary-hint-border': 'rgba(' + primaryRgb.r + ', ' + primaryRgb.g + ', ' + primaryRgb.b + ', 0.6)',
      '--hover-bg': 'rgba(' + primaryRgb.r + ', ' + primaryRgb.g + ', ' + primaryRgb.b + ', 0.12)',
      '--border-color': border,
      '--text-secondary': muted,
      '--holiday-bg': 'rgba(' + successRgb.r + ', ' + successRgb.g + ', ' + successRgb.b + ', 0.2)',
      '--holiday-border': 'rgba(' + successRgb.r + ', ' + successRgb.g + ', ' + successRgb.b + ', 0.55)',
      '--holiday-hover': 'rgba(' + successRgb.r + ', ' + successRgb.g + ', ' + successRgb.b + ', 0.8)',
      '--calendar-selected-border': primary,
      '--calendar-selected-glow': 'rgba(' + primaryRgb.r + ', ' + primaryRgb.g + ', ' + primaryRgb.b + ', 0.4)',
      '--calendar-selected-bg': 'rgba(' + primaryRgb.r + ', ' + primaryRgb.g + ', ' + primaryRgb.b + ', 0.2)'
    };
  }

  function applyCustomTheme() {
    var customThemeConfig = state.settings.custom_theme_config;
    if (!customThemeConfig) {
      customThemeConfig = {
        bg: '#0b1220',
        primary: '#3b82f6',
        text: '#e2e8f0',
        success: '#10b981'
      };
    }

    var themeVars = generateCustomTheme(
      customThemeConfig.bg,
      customThemeConfig.primary,
      customThemeConfig.text,
      customThemeConfig.success
    );

    // Find or create style element for custom theme
    var styleId = 'custom-theme-style';
    var styleEl = document.getElementById(styleId);
    if (!styleEl) {
      styleEl = document.createElement('style');
      styleEl.id = styleId;
      document.head.appendChild(styleEl);
    }

    var css = '.ts-theme-custom {';
    Object.keys(themeVars).forEach(function(key) {
      css += key + ': ' + themeVars[key] + ';';
    });
    css += '}';
    styleEl.textContent = css;
  }

  const normalizeFeatureFlags = (raw) => {
    const out = {};
    if (raw && typeof raw === 'object') {
      Object.keys(raw).forEach((key) => {
        const value = raw[key];
        const enabled = value && typeof value === 'object' ? !!value.enabled : !!value;
        const name = value && typeof value === 'object' && value.name ? String(value.name) : '';
        const description = value && typeof value === 'object' && value.description ? String(value.description) : '';
        out[key] = {
          enabled,
          name,
          description
        };
      });
    }
    Object.keys(DEFAULT_FEATURE_FLAGS).forEach((key) => {
      if (!out[key]) {
        out[key] = {
          enabled: false,
          name: DEFAULT_FEATURE_FLAGS[key].name,
          description: DEFAULT_FEATURE_FLAGS[key].description
        };
      } else {
        out[key].name = out[key].name || DEFAULT_FEATURE_FLAGS[key].name;
        out[key].description = out[key].description || DEFAULT_FEATURE_FLAGS[key].description;
      }
    });
    return out;
  };

  function updateContractMap() {
    state.contractMap = state.contracts.reduce((map, contract) => {
      map[contract.id] = contract;
      return map;
    }, {});
  }

  function updateHourTypeMap() {
    state.hourTypeMap = state.hourTypes.reduce((map, hourType) => {
      map[hourType.id] = hourType;
      return map;
    }, {});
  }

  const contractIsValid = (contract, dateIso) => {
    if (!contract || !dateIso) return false;
    if (contract.start_date && contract.start_date > dateIso) return false;
    if (contract.end_date && contract.end_date !== '' && contract.end_date < dateIso) return false;
    return true;
  };

  function validContractsForDate(dateIso) {
    if (!dateIso) return [];
    return state.contracts.filter((contract) => contractIsValid(contract, dateIso));
  }

  function getContractName(id) {
    if (!id) return '';
    const match = state.contractMap[id];
    if (match) return match.name;
    return '';
  }

  const contractBadge = (entry) => {
    const name = getContractName(entry.contract_id);
    if (name) return `<span class="ts-badge">${name}</span>`;
    if (entry.contract_id) return `<span class="ts-badge warn">Unknown contract</span>`;
    return `<span class="ts-badge warn">No contract</span>`;
  };

  function loadCache() {
    try {
      const raw = localStorage.getItem(state.cacheKey);
      if (!raw) return;
      const obj = JSON.parse(raw);
      state.entries = Array.isArray(obj.entries) ? obj.entries.map(sanitizeEntry) : [];
      state.settings = obj.settings || {};
      state.contracts = Array.isArray(obj.contracts) ? obj.contracts.map(sanitizeContract) : [];
      state.hourTypes = Array.isArray(obj.hourTypes) ? obj.hourTypes.map(sanitizeHourType) : [];
      state.deductions = Array.isArray(obj.deductions) ? obj.deductions.map(sanitizeDeduction) : [];
      if (obj.basCurrentFy != null) state.basCurrentFy = Number(obj.basCurrentFy);
      state.featureFlags = normalizeFeatureFlags(obj.featureFlags);
      state.publicHolidays = Array.isArray(obj.publicHolidays) ? obj.publicHolidays : [];
      state.actualIncome = Array.isArray(obj.actualIncome) ? obj.actualIncome : [];
      updatePublicHolidayMap();
      refreshActualIncomeMap();

      // Set initial tab based on today's entry type
      const today = todayIso();
      const todayEntry = state.entries.find(entry => entry.date === today);
      if (resolveEntryType(todayEntry) === 'advanced') {
        activateTab('punch');
        if (punchDate) punchDate.value = today;
        ensurePunchDraft(todayEntry.contract_id);
      }
      updateTabStates();
      updateContractMap();
      updateHourTypeMap();
      applyTheme((state.settings && state.settings.theme) || 'dark');
    } catch (e) {}
  }
  function saveCache() {
    try {
      const payload = {
        entries: state.entries.map(sanitizeEntry),
        settings: state.settings,
        contracts: state.contracts.map(sanitizeContract),
        hourTypes: state.hourTypes.map(sanitizeHourType),
        deductions: state.deductions.map(sanitizeDeduction),
        featureFlags: normalizeFeatureFlags(state.featureFlags),
        basCurrentFy: state.basCurrentFy,
        publicHolidays: state.publicHolidays,
        actualIncome: state.actualIncome
      };
      localStorage.setItem(state.cacheKey, JSON.stringify(payload));
    } catch (e) {}
  }

  // Tabs
  function activateTab(id) {
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;

    // With hour types enabled, allow switching between tabs to create entries for different hour types
    if (!hourTypesEnabled) {
      // Original validation logic when hour types are disabled
      const isEditingEntry = state.editingEntryId && state.currentTab !== id;
      const isEditingPunch = state.punchDraft && state.punchDraft.dirty && state.currentTab !== id;

      const isWrongEntryType = state.editingEntryId && (
        (state.editingEntryType === 'basic' && id === 'punch') ||
        (state.editingEntryType === 'advanced' && id === 'manual')
      );

      const hasConflictingData = (() => {
        if (!state.selectedCalendarDate) return false;
        const existingEntry = state.entries.find(entry => entry.date === state.selectedCalendarDate);
        if (!existingEntry) return false;

        const entryType = resolveEntryType(existingEntry);
        if (id === 'manual' && entryType === 'advanced') return true;
        if (id === 'punch' && entryType === 'basic') return true;

        return false;
      })();

      if (isEditingEntry || isEditingPunch || isWrongEntryType || hasConflictingData) {
        return;
      }
    } else {
      // With hour types enabled, only prevent switching if the current entry has unsaved changes
      const hasUnsavedChanges = state.punchDraft && state.punchDraft.dirty && state.currentTab !== id;
      if (hasUnsavedChanges) {
        return;
      }
    }
    
    // Update tab visual states
    $$('.ts-tab').forEach((tab) => {
      const target = tab.getAttribute('data-tab');
      tab.classList.toggle('active', target === id);
    });
    updateTabStates();
    ['manual', 'punch'].forEach((pane) => {
      const el = document.getElementById('tab-' + pane);
      if (el) el.style.display = pane === id ? 'block' : 'none';
    });

    const previousTab = state.currentTab;
    const switchingTabs = previousTab && previousTab !== id;

    // When switching tabs with hour types enabled, preserve hour type and date
    if (hourTypesEnabled && switchingTabs) {
      let currentDate = null;
      let currentHourType = null;

      // Get current values from the previous tab
      if (previousTab === 'manual' && manualDate && manualHourType) {
        currentDate = manualDate.value;
        currentHourType = manualHourType.value;
      } else if (previousTab === 'punch' && punchDate && punchHourType) {
        currentDate = punchDate.value;
        currentHourType = punchHourType.value;
      }

      // Apply to the new tab
      if (id === 'punch' && currentDate && currentHourType) {
        if (punchDate) punchDate.value = currentDate;
        if (punchHourType) punchHourType.value = currentHourType;

        // Check if there's ANY entry (basic or advanced) for this date + hour type
        const anyEntry = state.entries.find(e =>
          e.date === currentDate &&
          (e.hour_type_id || getDefaultHourTypeId()) === currentHourType
        );
        const anyEntryType = anyEntry ? resolveEntryType(anyEntry) : null;

        if (anyEntryType === 'basic') {
          // Hour type exists as basic entry - prevent switching to advanced
          // Switch back to the original tab
          state.currentTab = previousTab;
          $$('.ts-tab').forEach((tab) => {
            const target = tab.getAttribute('data-tab');
            tab.classList.toggle('active', target === previousTab);
          });
          ['manual', 'punch'].forEach((pane) => {
            const el = document.getElementById('tab-' + pane);
            if (el) el.style.display = pane === previousTab ? 'block' : 'none';
          });
          customAlert('This hour type already has a basic entry for this date. Please use the hour type dropdown to switch between different hour types.');
          return;
        }

        if (anyEntryType === 'advanced') {
          const existingEntry = anyEntry;
          // Load existing entry
          state.editingEntryId = existingEntry.id;
          state.editingEntryType = anyEntryType;
          updatePunchContractOptions(existingEntry.contract_id);
          if (punchContract) punchContract.value = existingEntry.contract_id || '';
          state.punchDraft = {
            entryId: existingEntry.id,
            contractId: existingEntry.contract_id || '',
            date: existingEntry.date,
            punches: clonePunches(existingEntry.punches || []),
            dirty: false
          };
          renderPunchDraft();
          updatePunchSummary();
        } else {
          // Create new entry
          state.editingEntryId = null;
          state.editingEntryType = null;
          updatePunchContractOptions();
          state.punchDraft = {
            entryId: null,
            contractId: punchContract ? punchContract.value : '',
            date: currentDate,
            punches: [{ in: '', out: '' }],
            dirty: false
          };
          renderPunchDraft();
          updatePunchSummary();
        }
        updatePunchContractVisibility();
      } else if (id === 'manual' && currentDate && currentHourType) {
        if (manualDate) manualDate.value = currentDate;
        if (manualHourType) manualHourType.value = currentHourType;

        // Check if there's ANY entry (basic or advanced) for this date + hour type
        const anyEntry = state.entries.find(e =>
          e.date === currentDate &&
          (e.hour_type_id || getDefaultHourTypeId()) === currentHourType
        );
        const anyEntryType = anyEntry ? resolveEntryType(anyEntry) : null;

        if (anyEntryType === 'advanced') {
          // Hour type exists as advanced entry - prevent switching to basic
          // Switch back to the original tab
          state.currentTab = previousTab;
          $$('.ts-tab').forEach((tab) => {
            const target = tab.getAttribute('data-tab');
            tab.classList.toggle('active', target === previousTab);
          });
          ['manual', 'punch'].forEach((pane) => {
            const el = document.getElementById('tab-' + pane);
            if (el) el.style.display = pane === previousTab ? 'block' : 'none';
          });
          customAlert('This hour type already has an advanced entry for this date. Please use the hour type dropdown to switch between different hour types.');
          return;
        }

        if (anyEntryType === 'basic') {
          // Load existing entry
          populateManualForm(anyEntry, true);
        } else {
          // Create new entry
          clearManualEditing();
          if (manualDate) manualDate.value = currentDate;
          if (manualHourType) manualHourType.value = currentHourType;
          updateManualContractVisibility();
        }
      }
    } else if (id === 'punch' && state.selectedCalendarDate && punchDate) {
      // Original behavior when hour types disabled
      punchDate.value = state.selectedCalendarDate;
      state.punchDraft = null;
      ensurePunchDraft();
    }

    state.currentTab = id;
  }
  $$('.ts-tab').forEach((tab) => {
    tab.addEventListener('click', () => activateTab(tab.getAttribute('data-tab')));
  });

  // Function to update tab disabled states
  function updateTabStates() {
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;

    $$('.ts-tab').forEach((tab) => {
      const target = tab.getAttribute('data-tab');

      // Check if this tab should be disabled
      let isDisabled = false;
      let disabledReason = '';

      if (hourTypesEnabled && state.selectedCalendarDate) {
        // With hour types enabled, check if the CURRENT hour type has an entry in the opposite format
        const currentHourType = state.currentTab === 'manual'
          ? (manualHourType ? manualHourType.value : getDefaultHourTypeId())
          : (punchHourType ? punchHourType.value : getDefaultHourTypeId());

        const existingEntry = state.entries.find(entry =>
          entry.date === state.selectedCalendarDate &&
          (entry.hour_type_id || getDefaultHourTypeId()) === currentHourType
        );

        if (existingEntry) {
          const entryType = resolveEntryType(existingEntry);
          // Disable basic tab if current hour type has advanced entry
          if (target === 'manual' && entryType === 'advanced') {
            isDisabled = true;
            disabledReason = 'This hour type has an advanced entry for this date';
          }
          // Disable advanced tab if current hour type has basic entry
          if (target === 'punch' && entryType === 'basic') {
            isDisabled = true;
            disabledReason = 'This hour type has a basic entry for this date';
          }
        }
      } else if (!hourTypesEnabled && state.selectedCalendarDate) {
        // Original behavior when hour types disabled
        const existingEntry = state.entries.find(entry => entry.date === state.selectedCalendarDate);
        if (existingEntry) {
          const entryType = resolveEntryType(existingEntry);
          // Disable basic tab if date has advanced entry
          if (target === 'manual' && entryType === 'advanced') {
            isDisabled = true;
            disabledReason = 'This date already has an advanced entry';
          }
          // Disable advanced tab if date has basic entry
          if (target === 'punch' && entryType === 'basic') {
            isDisabled = true;
            disabledReason = 'This date already has a basic entry';
          }
        }
      }

      tab.style.opacity = isDisabled ? '0.4' : '1';
      tab.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
      tab.title = disabledReason;
    });
  }

  // Default to manual tab initially (will be updated after cache loads)
  activateTab('manual');

  // Punch controls
  const punchDate = document.getElementById('punch-date');
  const punchHourType = document.getElementById('punch-hour-type');
  const punchHourTypeCol = document.getElementById('punch-hour-type-col');
  const punchContract = document.getElementById('punch-contract');
  const punchContractWarning = document.getElementById('punch-contract-warning');
  const punchToggleBtn = document.getElementById('btn-punch-toggle');
  const punchSaveBtn = document.getElementById('btn-punch-save');
  const punchCancelBtn = document.getElementById('btn-punch-cancel');
  const punchDeleteBtn = document.getElementById('btn-delete-punch');
  const punchList = document.getElementById('punch-range-list');
  const punchOpenWarning = document.getElementById('punch-open-warning');
  const punchSummary = document.getElementById('punch-summary');
  const punchSuggestion = document.getElementById('punch-suggestion');

  function currentPunchDate() {
    return punchDate && punchDate.value ? punchDate.value : todayIso();
  }

  function updatePunchContractOptions(preferredContractId) {
    if (!punchContract) return '';
    const dateIso = currentPunchDate();
    const valid = validContractsForDate(dateIso);
    const currentValue = preferredContractId != null ? preferredContractId : punchContract.value;
    const options = [...valid];
    if (currentValue && !options.some((contract) => contract.id === currentValue)) {
      const fallback = state.contractMap[currentValue];
      if (fallback) options.push(fallback);
    }
    options.sort((a, b) => a.name.localeCompare(b.name));
    punchContract.innerHTML = '';
    if (!options.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts';
      punchContract.appendChild(placeholder);
      punchContract.value = '';
      punchContract.disabled = true;
      if (punchContractWarning) punchContractWarning.style.display = 'block';
      return '';
    }
    if (options.length > 1) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select contract';
      punchContract.appendChild(placeholder);
    }
    options.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      punchContract.appendChild(opt);
    });
    let selected = currentValue && options.some((contract) => contract.id === currentValue) ? currentValue : '';
    if (!selected && valid.length === 1) {
      selected = valid[0].id;
    }
    punchContract.value = selected;
    punchContract.disabled = valid.length === 1 && options.length === valid.length;
    if (punchContractWarning) punchContractWarning.style.display = selected ? 'none' : 'block';
    return punchContract.value;
  }

  function setPunchDate(dateIso, preferredContractId) {
    if (!punchDate) return;
    punchDate.value = dateIso || todayIso();
    updatePunchContractOptions(preferredContractId != null ? preferredContractId : (punchContract ? punchContract.value : ''));
  }

  function ensurePunchDraft(preferredContractId) {
    const selected = updatePunchContractOptions(preferredContractId);
    const contractId = selected || '';
    const dateIso = currentPunchDate();
    
    // If we're switching dates and there's no contract selected, start fresh
    if (!contractId) {
      state.punchDraft = {
        entryId: null,
        contractId: '',
        date: dateIso,
        punches: [{ in: '', out: '' }],
        dirty: false
      };
      renderPunchDraft();
      return;
    }
    
    // Look for existing entry for this specific date and contract
    const entry = state.entries.find((e) => e.date === dateIso && e.contract_id === contractId) || null;
    state.punchDraft = {
      entryId: entry ? entry.id : null,
      contractId,
      date: dateIso,
      punches: entry ? clonePunches(entry.punches || []) : [{ in: '', out: '' }],
      dirty: false
    };

    // Set hour type if editing existing entry
    if (punchHourType && entry && entry.hour_type_id) {
      punchHourType.value = entry.hour_type_id;
      updatePunchContractVisibility();
    }

    renderPunchDraft();
  }

  function setPunchDraftDirty() {
    if (!state.punchDraft) return;
    state.punchDraft.dirty = true;
  }

  function renderPunchDraft() {
    if (!punchList) return;
    punchList.innerHTML = '';
    const draft = state.punchDraft || { punches: [], contractId: '' };
    const punches = draft.punches || [];
    if (!draft.contractId) {
      const note = document.createElement('div');
      note.className = 'ts-note';
      note.textContent = 'Select a contract to view today\'s punches.';
      punchList.appendChild(note);
    } else if (!punches.length || (punches.length === 1 && !punches[0].in)) {
      // Show an empty range for new entries
      const emptyRange = document.createElement('div');
      emptyRange.className = 'ts-punch-row';
      const startInput = document.createElement('input');
      startInput.type = 'time';
      startInput.value = punches.length > 0 ? (punches[0].in || '') : '';
      startInput.className = 'ts-punch-input';
      startInput.onchange = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches[0].in = startInput.value;
        setPunchDraftDirty();
        updatePunchSummary();
      };
      const endInput = document.createElement('input');
      endInput.type = 'time';
      endInput.value = punches.length > 0 ? (punches[0].out || '') : '';
      endInput.className = 'ts-punch-input';
      endInput.onchange = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches[0].out = endInput.value;
        setPunchDraftDirty();
        updatePunchSummary();
      };
      const addBtn = document.createElement('button');
      addBtn.type = 'button';
      addBtn.className = 'ghost';
      addBtn.textContent = 'Add';
      addBtn.onclick = () => {
        if (!draft.punches.length) draft.punches.push({ in: '', out: '' });
        draft.punches.push({ in: '', out: '' });
        setPunchDraftDirty();
        renderPunchDraft();
        // Focus on the new row's start input
        setTimeout(() => {
          const newRow = punchList.children[punchList.children.length - 1];
          const newStartInput = newRow.querySelector('input[type="time"]');
          if (newStartInput) newStartInput.focus();
        }, 0);
      };
      const removeBtn = document.createElement('button');
      removeBtn.type = 'button';
      removeBtn.className = 'ghost';
      removeBtn.textContent = 'Remove';
      removeBtn.onclick = () => {
        if (draft.punches.length) draft.punches.splice(0, 1);
        setPunchDraftDirty();
        renderPunchDraft();
      };
      emptyRange.appendChild(startInput);
      emptyRange.appendChild(document.createTextNode(' to '));
      emptyRange.appendChild(endInput);
      emptyRange.appendChild(addBtn);
      emptyRange.appendChild(removeBtn);
      punchList.appendChild(emptyRange);
    } else {
      punches.forEach((punch, index) => {
        const row = document.createElement('div');
        row.className = 'ts-punch-row';
        const startInput = document.createElement('input');
        startInput.type = 'time';
        startInput.value = punch.in || '';
        startInput.className = 'ts-punch-input';
        startInput.onchange = () => {
          draft.punches[index].in = startInput.value;
          setPunchDraftDirty();
          updatePunchSummary();
        };
        const endInput = document.createElement('input');
        endInput.type = 'time';
        endInput.value = punch.out || '';
        endInput.className = 'ts-punch-input';
        endInput.onchange = () => {
          draft.punches[index].out = endInput.value;
          setPunchDraftDirty();
          updatePunchSummary();
        };
        const addBtn = document.createElement('button');
        addBtn.type = 'button';
        addBtn.className = 'ghost';
        addBtn.textContent = 'Add';
        addBtn.onclick = () => {
          // Insert new punch after current index
          draft.punches.splice(index + 1, 0, { in: '', out: '' });
          setPunchDraftDirty();
          renderPunchDraft();
          // Focus on the new row's start input
          setTimeout(() => {
            const allRows = punchList.children;
            const newRowIndex = index + 1;
            if (allRows[newRowIndex]) {
              const newStartInput = allRows[newRowIndex].querySelector('input[type="time"]');
              if (newStartInput) newStartInput.focus();
            }
          }, 0);
        };
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'ghost';
        removeBtn.textContent = 'Remove';
        removeBtn.onclick = () => {
          draft.punches.splice(index, 1);
          setPunchDraftDirty();
          renderPunchDraft();
        };
        row.appendChild(startInput);
        row.appendChild(document.createTextNode(' to '));
        row.appendChild(endInput);
        row.appendChild(addBtn);
        row.appendChild(removeBtn);
        punchList.appendChild(row);
      });
    }
    updatePunchSummary();
    const hasContract = !!draft.contractId;
    const hasPunches = punches.length > 0;
    const openCount = summarizePunches(punches).openCount;
    if (punchToggleBtn) {
      punchToggleBtn.textContent = openCount > 0 ? 'Punch Out' : 'Punch In';
      punchToggleBtn.disabled = !hasContract;
    }
    if (punchSaveBtn) {
      punchSaveBtn.disabled = !hasContract || !hasPunches;
      punchSaveBtn.textContent = draft.entryId ? 'Update Entry' : 'Add Entry';
    }
    if (punchCancelBtn) {
      punchCancelBtn.disabled = !hasContract || !draft.dirty;
      punchCancelBtn.style.display = draft.dirty ? 'inline-flex' : 'none';
    }
    if (punchDeleteBtn) {
      punchDeleteBtn.style.display = draft.entryId ? 'inline-flex' : 'none';
    }
  }

  function calculateEndTimeSuggestion(punches, openPunch, roundingMinutes, minimumEndTime) {
    // Calculate total minutes from closed punches
    var closedMinutes = 0;
    for (var i = 0; i < punches.length; i++) {
      if (punches[i].in && punches[i].out) {
        var inParts = punches[i].in.split(':');
        var outParts = punches[i].out.split(':');
        var inMinutes = parseInt(inParts[0], 10) * 60 + parseInt(inParts[1], 10);
        var outMinutes = parseInt(outParts[0], 10) * 60 + parseInt(outParts[1], 10);
        closedMinutes += (outMinutes - inMinutes);
      }
    }

    // Calculate minutes from open punch to current time
    var inParts = openPunch.in.split(':');
    var inMinutes = parseInt(inParts[0], 10) * 60 + parseInt(inParts[1], 10);

    // Parse minimum end time
    var minEndParts = minimumEndTime.split(':');
    var minEndMinutes = parseInt(minEndParts[0], 10) * 60 + parseInt(minEndParts[1], 10);

    // Calculate current total if we were to clock out at minimum end time
    var currentTotal = closedMinutes + (minEndMinutes - inMinutes);

    // If the open punch hasn't reached minimum end time yet, no suggestion
    if (minEndMinutes < inMinutes) {
      return null;
    }

    // Calculate what the rounded total should be
    var roundedTotal = Math.ceil(currentTotal / roundingMinutes) * roundingMinutes;

    // Calculate suggested clock-out time
    var suggestedMinutes = inMinutes + (roundedTotal - closedMinutes);

    // Make sure it's within the valid range
    var maxEndMinutes = minEndMinutes + roundingMinutes;
    if (suggestedMinutes < minEndMinutes || suggestedMinutes > maxEndMinutes) {
      return null;
    }

    // Format the suggested time
    var suggestedHours = Math.floor(suggestedMinutes / 60);
    var suggestedMins = suggestedMinutes % 60;
    var suggestedTime = String(suggestedHours).padStart(2, '0') + ':' + String(suggestedMins).padStart(2, '0');

    // Format the total hours
    var totalHours = roundedTotal / 60;
    var formattedTotal = formatHours(roundedTotal);

    // Determine AM/PM
    var period = suggestedHours >= 12 ? 'pm' : 'am';
    var displayHours = suggestedHours > 12 ? suggestedHours - 12 : (suggestedHours === 0 ? 12 : suggestedHours);
    var displayTime = displayHours + ':' + String(suggestedMins).padStart(2, '0') + ' ' + period;

    return {
      time: suggestedTime,
      total: formattedTotal,
      message: 'Clock out at ' + displayTime + ' to round out your hours nicely to ' + formattedTotal
    };
  }

  function updatePunchSummary() {
    if (!punchSummary || !punchOpenWarning || !punchSuggestion) return;
    const draft = state.punchDraft || { punches: [] };
    const punches = normalizePunchList(draft.punches || []);
    const summary = summarizePunches(punches);
    if (punches.length) {
      const rounded = summary.totalMinutes > 0 ? roundDuration(summary.totalMinutes) : 0;
      punchSummary.textContent = `Recorded: ${formatHours(rounded)} hours`;
    } else {
      punchSummary.textContent = '';
    }
    if (summary.openCount > 0) {
      const lastOpen = punches.find((p) => !p.out);
      punchOpenWarning.textContent = lastOpen && lastOpen.in ? `Open punch since ${lastOpen.in}. Remember to punch out.` : 'Open punch detected. Please punch out when you finish.';
      punchOpenWarning.style.display = 'block';
    } else {
      punchOpenWarning.style.display = 'none';
    }

    // Calculate and display end time suggestion
    const suggestEndTimeEnabled = getFeatureFlag('suggest_end_time');
    if (suggestEndTimeEnabled && punches.length > 1 && summary.openCount > 0) {
      const lastOpen = punches.find((p) => !p.out);
      if (lastOpen && lastOpen.in) {
        const roundingMinutes = parseInt(state.settings.round_to_nearest, 10) || 0;
        const minimumEndTime = state.settings.minimum_end_time || '17:00';

        if (roundingMinutes > 0) {
          const suggestion = calculateEndTimeSuggestion(punches, lastOpen, roundingMinutes, minimumEndTime);
          if (suggestion) {
            punchSuggestion.textContent = suggestion.message;
            punchSuggestion.style.display = 'block';
          } else {
            punchSuggestion.style.display = 'none';
          }
        } else {
          punchSuggestion.style.display = 'none';
        }
      } else {
        punchSuggestion.style.display = 'none';
      }
    } else {
      punchSuggestion.style.display = 'none';
    }
  }

  function addPunchRow() {
    if (!state.punchDraft) return;
    state.punchDraft.punches.push({ in: '', out: '' });
    setPunchDraftDirty();
    renderPunchDraft();
  }

  function persistPunchDraft(options = {}) {
    const { requireClosed = false } = options;
    const draft = state.punchDraft;

    // Get hour type
    const hourTypeId = punchHourType ? punchHourType.value : getDefaultHourTypeId();
    const selectedHourType = state.hourTypeMap[hourTypeId];

    // Check for duplicate hour type on the same date (when not editing)
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
    if (hourTypesEnabled && draft && !draft.entryId) {
      const duplicateEntry = state.entries.find(e =>
        e.date === draft.date &&
        (e.hour_type_id || getDefaultHourTypeId()) === hourTypeId &&
        e.id !== draft.entryId
      );
      if (duplicateEntry) {
        const hourTypeName = selectedHourType?.name || 'Work';
        customAlert(`An entry with hour type "${hourTypeName}" already exists for ${draft.date}. Please switch to that hour type to edit it.`);
        return;
      }
    }

    // Validate contract based on hour type
    if (selectedHourType && selectedHourType.requires_contract) {
      if (!draft || !draft.contractId) {
        customAlert('Select a contract before saving punches.');
        return;
      }
    }

    const punches = normalizePunchList(draft.punches || []);
    const validationError = validatePunches(punches, { allowOpen: !requireClosed, requireClosed });
    if (validationError) {
      customAlert(validationError);
      return;
    }
    const summary = summarizePunches(punches);
    const roundedMinutes = summary.totalMinutes > 0 ? roundDuration(summary.totalMinutes) : 0;
    const payload = {
      date: draft.date,
      contract_id: draft.contractId || '',
      hour_type_id: hourTypeId,
      punches,
      duration_minutes: roundedMinutes,
      round_interval: getRoundInterval(),
      entry_type: 'advanced'
    };
    if (draft.entryId) payload.id = draft.entryId;

    // Optimistic update: Add entry to UI immediately for new entries
    let optimisticEntry = null;
    if (!draft.entryId) {
      optimisticEntry = {
        id: 'temp_' + Date.now(),
        ...payload,
        created_at: isoDateTime(new Date())
      };
      state.entries.unshift(sanitizeEntry(optimisticEntry));
      saveCache();
      renderEntries();
    }

    setStatus('Saving punches...', 'warn');
    renderPunchDraft();

    const onSuccess = (res) => {
      if (res && res.success && res.entry) {
        const sanitized = sanitizeEntry(res.entry);
        if (optimisticEntry) {
          // Replace optimistic entry with real one
          const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
          if (idx > -1) {
            state.entries[idx] = sanitized;
          }
        } else {
          // Update existing entry
          const idx = state.entries.findIndex((e) => e.id === sanitized.id);
          if (idx > -1) {
            state.entries[idx] = sanitized;
          } else {
            state.entries.push(sanitized);
          }
        }
        state.punchDraft = {
          entryId: sanitized.id,
          contractId: sanitized.contract_id,
          date: sanitized.date,
          punches: clonePunches(sanitized.punches || []),
          dirty: false
        };
        saveCache();
        renderEntries();
        setStatus('Punches saved', 'success');
      } else {
        // Remove optimistic entry on failure
        if (optimisticEntry) {
          const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
          if (idx > -1) {
            state.entries.splice(idx, 1);
            saveCache();
            renderEntries();
          }
        }
        setStatus('Punch save failed', 'error');
      }
      renderPunchDraft();
    };

    const onFailure = () => {
      // Remove optimistic entry on failure
      if (optimisticEntry) {
        const idx = state.entries.findIndex((e) => e.id === optimisticEntry.id);
        if (idx > -1) {
          state.entries.splice(idx, 1);
          saveCache();
          renderEntries();
        }
      }
      setStatus('Punch save failed', 'error');
      renderPunchDraft();
    };

    if (draft.entryId) {
      google.script.run
        .withSuccessHandler(onSuccess)
        .withFailureHandler(onFailure)
        .api_updateEntry(payload);
    } else {
      google.script.run
        .withSuccessHandler(onSuccess)
        .withFailureHandler(onFailure)
        .api_addEntry(payload);
    }
  }

  function handlePunchToggle() {
    const draft = state.punchDraft;
    if (!draft || !draft.contractId) {
      customAlert('Select a contract before punching in.');
      return;
    }
    const now = new Date();
    const currentTime = now.toTimeString().slice(0, 5);
    const punches = draft.punches || [];
    
    // Look for an open punch (has in but no out)
    const openIndex = punches.findIndex((punch) => punch && punch.in && !punch.out);
    if (openIndex !== -1) {
      // Punch out - close the open punch
      draft.punches[openIndex].out = currentTime;
    } else {
      // Punch in - add a new punch or populate the first empty range
      if (punches.length === 0) {
        draft.punches.push({ in: currentTime, out: '' });
      } else {
        // Find the first empty range (no in time) and populate it
        const firstEmpty = punches.findIndex(punch => !punch.in);
        if (firstEmpty !== -1) {
          draft.punches[firstEmpty].in = currentTime;
        } else {
          draft.punches.push({ in: currentTime, out: '' });
        }
      }
    }
    setPunchDraftDirty();
    renderPunchDraft();
    persistPunchDraft({ requireClosed: false });
  }

  function handlePunchSave() {
    persistPunchDraft({ requireClosed: false });
  }

  function handlePunchDiscard() {
    if (!state.punchDraft) return;
    ensurePunchDraft(state.punchDraft.contractId);
  }

  async function handlePunchDelete() {
    if (!state.punchDraft || !state.punchDraft.entryId) return;

    const confirmed = await customConfirm(
      'Are you sure you want to delete this entry? This action cannot be undone.',
      { danger: true }
    );
    if (!confirmed) return;

    const entryId = state.punchDraft.entryId;
    const currentDate = state.punchDraft.date;

    setStatus('Deleting entry...', 'warn');

    google.script.run
      .withSuccessHandler(() => {
        // Remove from local state
        const idx = state.entries.findIndex(e => e.id === entryId);
        if (idx > -1) {
          state.entries.splice(idx, 1);
        }

        // Clear punch draft and start fresh
        state.punchDraft = null;
        if (punchDate) punchDate.value = currentDate;
        ensurePunchDraft();

        saveCache();
        renderEntries();
        updateTabStates();
        setStatus('Entry deleted', 'success');
      })
      .withFailureHandler(() => {
        setStatus('Delete failed', 'error');
      })
      .api_deleteEntry(entryId);
  }

  if (punchToggleBtn) punchToggleBtn.onclick = handlePunchToggle;
  if (punchSaveBtn) punchSaveBtn.onclick = handlePunchSave;
  if (punchCancelBtn) punchCancelBtn.onclick = handlePunchDiscard;
  if (punchDeleteBtn) punchDeleteBtn.onclick = handlePunchDelete;
  if (punchDate) {
    punchDate.addEventListener('change', () => {
      state.selectedCalendarDate = punchDate.value;
      // Clear any existing draft when date changes
      state.punchDraft = null;
      updatePunchContractOptions();
      ensurePunchDraft();
    });
  }
  if (punchContract) {
    punchContract.addEventListener('change', () => {
      ensurePunchDraft(punchContract.value);
    });
  }

  // Manual form helpers
  const manualDate = document.getElementById('manual-date');
  const manualHourType = document.getElementById('manual-hour-type');
  const manualHourTypeCol = document.getElementById('manual-hour-type-col');
  const manualContract = document.getElementById('manual-contract');
  const manualContractWarning = document.getElementById('manual-contract-warning');
  const manualHoursInput = document.getElementById('manual-hours');
  const manualSaveBtn = document.getElementById('btn-add-manual');
  const manualCancelBtn = document.getElementById('btn-cancel-edit');
  const manualDeleteBtn = document.getElementById('btn-delete-manual');

  function updateBasicSaveEnabled() {
    if (!manualSaveBtn) return;

    const hours = Number(manualHoursInput ? manualHoursInput.value : '');
    const validHours = Number.isFinite(hours) && hours > 0;

    // Check if contract is required based on hour type
    let contractValid = true;
    if (manualHourType && manualHourType.value) {
      const selectedHourType = state.hourTypeMap[manualHourType.value];
      if (selectedHourType && selectedHourType.requires_contract) {
        contractValid = !!(manualContract && manualContract.value);
      }
    } else {
      // Default behavior when no hour type selected or feature disabled
      contractValid = !!(manualContract && manualContract.value);
    }

    manualSaveBtn.disabled = !(contractValid && validHours);
  }

  function updateManualContractOptions(preferredContractId) {
    if (!manualContract) return '';
    const dateIso = manualDate && manualDate.value ? manualDate.value : todayIso();
    const valid = validContractsForDate(dateIso);
    const currentValue = preferredContractId != null ? preferredContractId : manualContract.value;
    const options = [...valid];
    if (currentValue && !options.some((contract) => contract.id === currentValue)) {
      const fallback = state.contractMap[currentValue];
      if (fallback) options.push(fallback);
    }
    options.sort((a, b) => a.name.localeCompare(b.name));
    manualContract.innerHTML = '';
    if (!options.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts';
      manualContract.appendChild(placeholder);
      manualContract.value = '';
      manualContract.disabled = true;
      if (manualContractWarning) manualContractWarning.style.display = 'block';
      updateBasicSaveEnabled();
      return '';
    }
    if (options.length > 1) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select contract';
      manualContract.appendChild(placeholder);
    }
    options.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name;
      manualContract.appendChild(opt);
    });
    let selected = currentValue && options.some((contract) => contract.id === currentValue) ? currentValue : '';
    if (!selected && valid.length === 1) {
      selected = valid[0].id;
    }
    manualContract.value = selected;
    manualContract.disabled = valid.length === 1 && options.length === valid.length;
    if (manualContractWarning) manualContractWarning.style.display = manualContract.value ? 'none' : 'block';
    updateBasicSaveEnabled();
    return manualContract.value;
  }

  function refreshContractBindings(preferredManualContractId, preferredPunchContractId) {
    updateContractMap();
    const manualDateIso = manualDate && manualDate.value ? manualDate.value : todayIso();
    const manualPreferred = preferredManualContractId && contractIsValid(state.contractMap[preferredManualContractId], manualDateIso)
      ? preferredManualContractId
      : undefined;
    const punchPreferred = preferredPunchContractId && contractIsValid(state.contractMap[preferredPunchContractId], currentPunchDate())
      ? preferredPunchContractId
      : undefined;
    updateManualContractOptions(manualPreferred);
    ensurePunchDraft(punchPreferred);
    renderContractsUI();
  }

  function setManualDate(dateIso, preferredContractId) {
    if (!manualDate) return;
    manualDate.value = dateIso || todayIso();
    updateManualContractOptions(preferredContractId != null ? preferredContractId : (manualContract ? manualContract.value : ''));
  }

  function setManualMode(isEdit) {
    if (manualSaveBtn) manualSaveBtn.textContent = isEdit ? 'Update Entry' : 'Add Entry';
    if (manualCancelBtn) manualCancelBtn.style.display = isEdit ? 'inline-flex' : 'none';
    if (manualDeleteBtn) manualDeleteBtn.style.display = isEdit ? 'inline-flex' : 'none';
  }

  function populateManualForm(entry, isEdit) {
    showPage('time');
    state.currentTab = 'manual';
    activateTab('manual');
    const preferredDate = entry.date || todayIso();
    const preferredContractId = entry.contract_id || '';
    setManualDate(preferredDate, preferredContractId);
    const punches = entryPunches(entry);
    let totalMinutes = punches.reduce((acc, punch) => {
      const start = timeToMinutes(punch.in);
      const end = timeToMinutes(punch.out);
      if (start === null || end === null || end <= start) return acc;
      return acc + (end - start);
    }, 0);
    if (!totalMinutes && entry.duration_minutes != null) {
      totalMinutes = Number(entry.duration_minutes);
    }
    if (manualHoursInput) {
      const hoursValue = totalMinutes > 0 ? formatDecimalHours(totalMinutes / 60) : '';
      manualHoursInput.value = hoursValue ? hoursValue : '';
    }
    // Set hour type
    if (manualHourType && entry.hour_type_id) {
      manualHourType.value = entry.hour_type_id;
      updateManualContractVisibility();
    }

    state.editingEntryId = isEdit ? entry.id : null;
    state.editingEntryType = isEdit ? (entry.entry_type || 'basic') : null;
    setManualMode(!!isEdit);
    if (isEdit && manualHoursInput) manualHoursInput.focus();
    updateBasicSaveEnabled();
  }

  function clearManualEditing() {
    state.editingEntryId = null;
    state.editingEntryType = null;
    state.currentTab = 'manual';
    setManualMode(false);
    if (manualHoursInput) manualHoursInput.value = '';
    updateManualContractOptions();
    updateBasicSaveEnabled();
  }

  function getManualPayload() {
    const date = manualDate.value || todayIso();
    if (!date) {
      customAlert('Date is required.');
      return null;
    }
    const hoursRaw = manualHoursInput ? manualHoursInput.value.trim() : '';
    const totalHours = Number(hoursRaw);
    if (!Number.isFinite(totalHours) || totalHours <= 0) {
      customAlert('Enter the total number of hours worked.');
      return null;
    }
    const totalMinutes = Math.round(totalHours * 60);
    if (totalMinutes > 24 * 60) {
      customAlert('Total hours must be within a single day (24 hours or less).');
      return null;
    }
    if (totalMinutes <= 0) {
      customAlert('Total hours must be greater than zero.');
      return null;
    }
    // Get hour type
    const hourTypeId = manualHourType ? manualHourType.value : getDefaultHourTypeId();
    const selectedHourType = state.hourTypeMap[hourTypeId];

    // Check for duplicate hour type on the same date (when not editing)
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
    if (hourTypesEnabled && !state.editingEntryId) {
      const duplicateEntry = state.entries.find(e =>
        e.date === date &&
        (e.hour_type_id || getDefaultHourTypeId()) === hourTypeId &&
        e.id !== state.editingEntryId
      );
      if (duplicateEntry) {
        const hourTypeName = selectedHourType?.name || 'Work';
        customAlert(`An entry with hour type "${hourTypeName}" already exists for ${date}. Please switch to that hour type to edit it.`);
        return null;
      }
    }

    // Validate contract based on hour type
    const contractId = manualContract ? manualContract.value : '';
    if (selectedHourType && selectedHourType.requires_contract) {
      if (!contractId) {
        customAlert('Select a contract for this date.');
        return null;
      }
      const contract = state.contractMap[contractId];
      if (!contract) {
        customAlert('Selected contract is no longer available.');
        return null;
      }
      if (!contractIsValid(contract, date) && !state.editingEntryId) {
        customAlert('Selected contract is not valid for this date.');
        return null;
      }
    }

    const punches = [{ in: '00:00', out: minutesToTime(totalMinutes) }];
    const roundedMinutes = roundDuration(totalMinutes);
    return {
      date,
      punches,
      duration_minutes: roundedMinutes,
      contract_id: contractId,
      hour_type_id: hourTypeId,
      round_interval: getRoundInterval(),
      entry_type: 'basic'
    };
  }

  manualSaveBtn.onclick = function () {
    const payload = getManualPayload();
    if (!payload) return;
    if (state.editingEntryId) {
      const idx = state.entries.findIndex((e) => e.id === state.editingEntryId);
      if (idx === -1) return;
      const backup = { ...state.entries[idx] };
      const update = { id: state.editingEntryId, ...payload };
      state.entries[idx] = sanitizeEntry({ ...backup, ...update });
      saveCache();
      renderEntries();
      setStatus('Saving...', 'warn');
      google.script.run
        .withSuccessHandler((res) => {
          if (res && res.success) {
            state.entries[idx] = sanitizeEntry(res.entry);
            clearManualEditing();
            saveCache();
            renderEntries();
            ensurePunchDraft(payload.contract_id);
            setStatus('Saved', 'success');
          } else {
            state.entries[idx] = backup;
            saveCache();
            renderEntries();
            setStatus('Save failed', 'error');
          }
        })
        .withFailureHandler(() => {
          state.entries[idx] = backup;
          saveCache();
          renderEntries();
          setStatus('Save failed', 'error');
        })
        .api_updateEntry(update);
    } else {
      const now = new Date();
      const entry = {
        id: 'temp_' + Date.now(),
        ...payload,
        created_at: isoDateTime(now)
      };
      state.entries.unshift(sanitizeEntry(entry));
      saveCache();
      renderEntries();
      clearManualEditing();
      setStatus('Saving...', 'warn');
      google.script.run
        .withSuccessHandler((res) => {
          if (res && res.success) {
            const idx = state.entries.findIndex((e) => e.id === entry.id);
            if (idx > -1) state.entries[idx] = sanitizeEntry(res.entry);
            saveCache();
            renderEntries();
            ensurePunchDraft(payload.contract_id);
            setStatus('Saved', 'success');
          } else {
            setStatus('Save failed', 'error');
          }
        })
        .withFailureHandler(() => setStatus('Save failed (offline?)', 'error'))
        .api_addEntry(entry);
    }
    state.selectedCalendarDate = payload.date;
    setManualDate(state.selectedCalendarDate, payload.contract_id);
    renderCalendar();
  };
  manualCancelBtn.onclick = function () {
    clearManualEditing();
    activateTab('manual');
  };

  if (manualDeleteBtn) {
    manualDeleteBtn.onclick = async function () {
      if (!state.editingEntryId) return;

      const confirmed = await customConfirm(
        'Are you sure you want to delete this entry? This action cannot be undone.',
        { danger: true }
      );
      if (!confirmed) return;

      const entryId = state.editingEntryId;
      const currentDate = manualDate ? manualDate.value : todayIso();

      setStatus('Deleting entry...', 'warn');

      google.script.run
        .withSuccessHandler(() => {
          // Remove from local state
          const idx = state.entries.findIndex(e => e.id === entryId);
          if (idx > -1) {
            state.entries.splice(idx, 1);
          }

          // Clear editing state and reset form
          clearManualEditing();
          setManualDate(currentDate);

          saveCache();
          renderEntries();
          updateTabStates();
          setStatus('Entry deleted', 'success');
        })
        .withFailureHandler(() => {
          setStatus('Delete failed', 'error');
        })
        .api_deleteEntry(entryId);
    };
  }

  if (manualDate) {
    manualDate.addEventListener('change', () => {
      const newDate = manualDate.value;
      const oldDate = state.selectedCalendarDate;
      
      // If we're editing an entry and the date changed, assume changes were discarded
      if (state.editingEntryId && newDate !== oldDate) {
        clearManualEditing();
        state.selectedCalendarDate = newDate;
        setManualDate(newDate);
        updateManualContractOptions();
        renderCalendar();
        return;
      }
      
      state.selectedCalendarDate = newDate;
      updateManualContractOptions();
      renderCalendar();
    });
  }

  if (manualContract) {
    manualContract.addEventListener('change', updateBasicSaveEnabled);
  }

  if (manualHoursInput) manualHoursInput.addEventListener('input', updateBasicSaveEnabled);

  if (manualHourType) {
    manualHourType.addEventListener('change', updateBasicSaveEnabled);
  }

  if (manualHoursInput) manualHoursInput.value = '';
  updateBasicSaveEnabled();
  setManualDate(todayIso());

  const incomeNetBadge = document.getElementById('calendar-net-income');
  const incomeToggleBtn = incomeNetBadge;
  const incomeBreakdownEl = document.getElementById('income-breakdown');
  const incomeInvoiceTotalRow = document.getElementById('income-invoice-total-row');
  const incomeInvoiceTotalEl = document.getElementById('income-invoice-total');
  const incomeCompanyIncomeRow = document.getElementById('income-company-income-row');
  const incomeCompanyIncomeEl = document.getElementById('income-company-income');
  const incomeCompanyExpensesRow = document.getElementById('income-company-expenses-row');
  const incomeCompanyExpensesEl = document.getElementById('income-company-expenses');
  const incomeGrossEl = document.getElementById('income-gross');
  const incomeSuperGuaranteeEl = document.getElementById('income-super-guarantee');
  const incomeSuperLostRow = document.getElementById('income-super-lost-row');
  const incomeSuperLostEl = document.getElementById('income-super-lost');
  const incomeExtraSuperEl = document.getElementById('income-extra-super');
  const incomeSuperTotalEl = document.getElementById('income-super-total');
  const incomeOtherDeductionsEl = document.getElementById('income-other-deductions');
  const incomeTaxableEl = document.getElementById('income-taxable');
  const incomeTaxEl = document.getElementById('income-tax');
  const incomeNetDetailEl = document.getElementById('income-net');
  const incomeActualGrossValueEl = document.getElementById('income-actual-gross-value');
  const incomeActualSuperValueEl = document.getElementById('income-actual-super-value');
  const incomeActualTaxValueEl = document.getElementById('income-actual-tax-value');
  const incomeActualNetValueEl = document.getElementById('income-actual-net-value');
  let incomeBreakdownExpanded = false;
  if (incomeToggleBtn) {
    incomeToggleBtn.addEventListener('click', () => {
      incomeBreakdownExpanded = !incomeBreakdownExpanded;
      applyIncomeBreakdownVisibility();
    });
  }
  applyIncomeBreakdownVisibility();

  // Hour types breakdown toggle
  const hourTypesToggleBtn = document.getElementById('calendar-month-total');
  const hourTypesBreakdownEl = document.getElementById('hour-types-breakdown');
  const hourTypesBreakdownListEl = document.getElementById('hour-types-breakdown-list');
  let hourTypesBreakdownExpanded = false;

  function applyHourTypesBreakdownVisibility() {
    if (!hourTypesBreakdownEl || !hourTypesToggleBtn) return;

    if (hourTypesBreakdownExpanded) {
      hourTypesBreakdownEl.hidden = false;
      hourTypesToggleBtn.setAttribute('data-expanded', 'true');
      hourTypesToggleBtn.setAttribute('aria-expanded', 'true');
    } else {
      hourTypesBreakdownEl.hidden = true;
      hourTypesToggleBtn.setAttribute('data-expanded', 'false');
      hourTypesToggleBtn.setAttribute('aria-expanded', 'false');
    }
  }

  if (hourTypesToggleBtn) {
    hourTypesToggleBtn.addEventListener('click', () => {
      hourTypesBreakdownExpanded = !hourTypesBreakdownExpanded;
      applyHourTypesBreakdownVisibility();
    });
  }
  applyHourTypesBreakdownVisibility();

  const expectedHoursBadge = document.getElementById('calendar-expected-hours');
  const expectedHoursBreakdownEl = document.getElementById('expected-hours-breakdown');
  const expectedHoursContentEl = document.getElementById('expected-hours-content');
  let expectedHoursExpanded = false;

  function applyExpectedHoursVisibility() {
    if (!expectedHoursBadge || !expectedHoursBreakdownEl) return;
    expectedHoursBadge.setAttribute('data-expanded', expectedHoursExpanded ? 'true' : 'false');
    expectedHoursBadge.setAttribute('aria-expanded', expectedHoursExpanded ? 'true' : 'false');
    expectedHoursBreakdownEl.hidden = !expectedHoursExpanded;
  }

  if (expectedHoursBadge) {
    expectedHoursBadge.addEventListener('click', () => {
      expectedHoursExpanded = !expectedHoursExpanded;
      renderExpectedHoursSummary();
    });
  }
  applyExpectedHoursVisibility();

  const featureFlagsListEl = document.getElementById('feature-flags-list');
  const roundInput = document.getElementById('set-round');
  const themeSelect = document.getElementById('set-theme');
  const superRateInput = document.getElementById('set-super-rate');
  const paygRateInput = document.getElementById('set-payg-rate');
  const paygRateCol = document.getElementById('payg-rate-col');
  const publicHolidayStateSelect = document.getElementById('set-public-holiday-state');
  const publicHolidayStateCol = document.getElementById('public-holiday-state-col');
  const minimumEndTimeInput = document.getElementById('set-minimum-end-time');
  const minimumEndTimeCol = document.getElementById('minimum-end-time-col');
  const saveSettingsBtn = document.getElementById('btn-save-settings');
  const discardSettingsBtn = document.getElementById('btn-discard-settings');
  const contractNameInput = document.getElementById('contract-name');
  const contractStartInput = document.getElementById('contract-start');
  const contractEndInput = document.getElementById('contract-end');
  const contractRateInput = document.getElementById('contract-rate');
  const contractTotalHoursInput = document.getElementById('contract-total-hours');
  const contractIncludeWeekendsRow = document.getElementById('contract-weekends-row');
  const contractIncludeWeekendsInput = document.getElementById('contract-include-weekends');
  const contractSaveBtn = document.getElementById('contract-save');
  const contractCancelBtn = document.getElementById('contract-cancel');
  const contractAddToggle = document.getElementById('contract-toggle-add');
  const contractFormContainer = document.getElementById('contract-form-container');
  const contractSelector = document.getElementById('contract-selector');
  const contractDetailEl = document.getElementById('contract-detail');
  const contractBurndownEl = document.getElementById('contract-burndown');
  const contractUnlimitedNote = document.getElementById('contract-unlimited-note');
  const contractFormDefaultParent = contractFormContainer ? contractFormContainer.parentElement : null;
  const contractFormPlaceholder = contractFormContainer && contractFormDefaultParent
    ? (function () {
        const placeholder = document.createComment('contract-form-home');
        contractFormDefaultParent.insertBefore(placeholder, contractFormContainer.nextSibling);
        return placeholder;
      })()
    : null;
  const clearCacheWrapper = document.getElementById('clear-cache-wrapper');
  const clearCacheBtn = document.getElementById('btn-clear-cache');
  const payrollXeroBtn = document.getElementById('calendar-xero-helper');
  const payrollMyobBtn = document.getElementById('calendar-myob-helper');
  const xeroHelperModal = document.getElementById('modal-xero-helper');
  const myobHelperModal = document.getElementById('modal-myob-helper');
  const xeroHelperContent = document.getElementById('xero-helper-content');
  const myobHelperContent = document.getElementById('myob-helper-content');
  const actualIncomeBtn = document.getElementById('calendar-actual-income-btn');
  const actualIncomeModal = document.getElementById('modal-actual-income');
  const actualIncomeTitle = document.getElementById('actual-income-title');
  const actualIncomeMonthInput = document.getElementById('actual-income-month');
  const actualIncomeMonthDisplay = document.getElementById('actual-income-month-display');
  const actualIncomeGrossInput = document.getElementById('actual-income-gross');
  const actualIncomeSuperInput = document.getElementById('actual-income-super');
  const actualIncomeTaxInput = document.getElementById('actual-income-tax');
  const actualIncomeNetInput = document.getElementById('actual-income-net');
  const btnSaveActualIncome = document.getElementById('btn-save-actual-income');
  const btnCancelActualIncome = document.getElementById('btn-cancel-actual-income');
  const btnDeleteActualIncome = document.getElementById('btn-delete-actual-income');

  const DECIMAL_HOURS_FORMATTER = new Intl.NumberFormat(undefined, {
    minimumFractionDigits: 0,
    maximumFractionDigits: 2
  });
  const MONTH_DAY_FORMATTER = new Intl.DateTimeFormat(undefined, {
    month: 'short',
    day: 'numeric'
  });
  const DATE_FULL_FORMATTER = new Intl.DateTimeFormat(undefined, {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
  const MONTH_YEAR_FORMATTER = new Intl.DateTimeFormat(undefined, {
    month: 'short',
    year: 'numeric'
  });
  const FINANCIAL_YEAR_START_MONTH = 6; // July (0-indexed)

  function financialYearLabel(startYear) {
    const endYear = startYear + 1;
    return `FY ${startYear}-${String(endYear).slice(-2)}`;
  }

  function financialYearStartYear(date) {
    if (!(date instanceof Date) || Number.isNaN(date.getTime())) return new Date().getFullYear();
    return date.getMonth() >= FINANCIAL_YEAR_START_MONTH ? date.getFullYear() : date.getFullYear() - 1;
  }

  function getFinancialYearMonths(startYear) {
    const months = [];
    for (let i = 0; i < 12; i += 1) {
      const monthIndex = (FINANCIAL_YEAR_START_MONTH + i) % 12;
      const yearOffset = Math.floor((FINANCIAL_YEAR_START_MONTH + i) / 12);
      months.push({ year: startYear + yearOffset, month: monthIndex });
    }
    return months;
  }

  function startOfFinancialYear(startYear) {
    return startOfDay(new Date(startYear, FINANCIAL_YEAR_START_MONTH, 1));
  }
  const WEEKDAY_FORMATTER = new Intl.DateTimeFormat(undefined, {
    weekday: 'short'
  });

  function formatDecimalHours(value) {
    return DECIMAL_HOURS_FORMATTER.format(Math.max(0, Math.round((Number(value) || 0) * 100) / 100));
  }

  function formatSignedHours(value) {
    const num = Math.round((Number(value) || 0) * 100) / 100;
    if (num === 0) return '0';
    const prefix = num > 0 ? '+' : '-';
    return prefix + DECIMAL_HOURS_FORMATTER.format(Math.abs(num));
  }

  function resetContractFormFields() {
    if (contractNameInput) contractNameInput.value = '';
    if (contractStartInput) contractStartInput.value = '';
    if (contractEndInput) contractEndInput.value = '';
    if (contractRateInput) contractRateInput.value = '';
    if (contractTotalHoursInput) contractTotalHoursInput.value = '';
    if (contractIncludeWeekendsInput) contractIncludeWeekendsInput.checked = false;
  }

  function placeContractFormAtDefault() {
    if (!contractFormContainer || !contractFormPlaceholder || !contractFormPlaceholder.parentNode) return;
    if (contractFormContainer.parentElement !== contractFormPlaceholder.parentNode) {
      contractFormPlaceholder.parentNode.insertBefore(contractFormContainer, contractFormPlaceholder);
    }
  }

  function placeContractFormInDetail() {
    if (!contractFormContainer || !contractDetailEl) return;
    if (contractFormContainer.parentElement !== contractDetailEl) {
      contractDetailEl.appendChild(contractFormContainer);
    }
  }

  function setContractFormMode(mode) {
    state.contractFormMode = mode;
    const visible = mode === 'create' || mode === 'edit';
    if (contractFormContainer) contractFormContainer.style.display = visible ? 'block' : 'none';
    if (contractSaveBtn) contractSaveBtn.textContent = mode === 'edit' ? 'Save Changes' : 'Save';
    if (contractCancelBtn) contractCancelBtn.style.display = visible ? 'inline-flex' : 'none';
  }

  function showContractForm(mode) {
    if (mode === 'create') {
      state.editingContractId = null;
      resetContractFormFields();
      placeContractFormInDetail();
      if (contractAddToggle) contractAddToggle.textContent = 'Close';
    }
    setContractFormMode(mode);
    if (mode === 'create' && contractNameInput) contractNameInput.focus();
    renderContractDetail();
  }

  function hideContractForm() {
    resetContractFormFields();
    state.editingContractId = null;
    setContractFormMode('hidden');
    placeContractFormAtDefault();
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
  }

  function getContractFormPayload() {
    const name = contractNameInput ? contractNameInput.value.trim() : '';
    const startDate = contractStartInput ? contractStartInput.value : '';
    const endDate = contractEndInput ? contractEndInput.value : '';
    const hourlyRateRaw = contractRateInput ? contractRateInput.value : '';
    const hourlyRate = Number(hourlyRateRaw || 0);
    const totalHoursRaw = contractTotalHoursInput ? contractTotalHoursInput.value : '';
    const totalHoursValue = totalHoursRaw === '' ? 0 : Number(totalHoursRaw);
    if (!name) {
      customAlert('Contract name is required.');
      return null;
    }
    if (!startDate) {
      customAlert('Contract start date is required.');
      return null;
    }
    if (endDate && endDate < startDate) {
      customAlert('End date must be on or after the start date.');
      return null;
    }
    if (hourlyRate < 0) {
      customAlert('Hourly rate must be zero or greater.');
      return null;
    }
    if (Number.isNaN(totalHoursValue) || totalHoursValue < 0) {
      customAlert('Total hours must be zero or greater.');
      return null;
    }
    const totalHours = Math.round(Number(totalHoursValue || 0) * 100) / 100;
    const includeWeekends = contractIncludeWeekendsInput ? contractIncludeWeekendsInput.checked : false;
    return {
      name,
      start_date: startDate,
      end_date: endDate,
      hourly_rate: Math.round(hourlyRate * 100) / 100,
      total_hours: totalHours,
      include_weekends: includeWeekends
    };
  }

  function populateContractForm(contract) {
    state.editingContractId = contract.id;
    if (contractNameInput) contractNameInput.value = contract.name || '';
    if (contractStartInput) contractStartInput.value = contract.start_date || '';
    if (contractEndInput) contractEndInput.value = contract.end_date || '';
    if (contractRateInput) contractRateInput.value = contract.hourly_rate != null ? Number(contract.hourly_rate).toFixed(2) : '';
    if (contractTotalHoursInput) {
      const totalHours = Number(contract.total_hours || 0);
      contractTotalHoursInput.value = totalHours > 0 ? String(totalHours) : '';
    }
    if (contractIncludeWeekendsInput) contractIncludeWeekendsInput.checked = !!contract.include_weekends;
    placeContractFormInDetail();
    setContractFormMode('edit');
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
    if (contractNameInput) contractNameInput.focus();
    renderContractDetail();
  }

  function getContractById(id) {
    return id ? state.contractMap[id] : undefined;
  }

  function contractEndSortValue(contract) {
    return contract.end_date && contract.end_date !== '' ? contract.end_date : '9999-12-31';
  }

  function renderContractSelectorOptions() {
    if (!contractSelector) return;
    const previousSelection = state.selectedContractId;
    contractSelector.innerHTML = '';
    if (!state.contracts.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No contracts yet';
      contractSelector.appendChild(placeholder);
      contractSelector.disabled = true;
      state.selectedContractId = '';
      return;
    }
    contractSelector.disabled = false;
    const sorted = [...state.contracts].sort((a, b) => {
      const endA = contractEndSortValue(a);
      const endB = contractEndSortValue(b);
      if (endA !== endB) return endB.localeCompare(endA);
      const startA = a.start_date || '';
      const startB = b.start_date || '';
      if (startA !== startB) return startB.localeCompare(startA);
      return a.name.localeCompare(b.name);
    });
    const todayContracts = validContractsForDate(todayIso());
    const soleCurrentContractId = (!state.editingContractId && todayContracts.length === 1)
      ? todayContracts[0].id
      : '';
    if (!state.selectedContractId || !getContractById(state.selectedContractId)) {
      state.selectedContractId = soleCurrentContractId
        || (previousSelection && getContractById(previousSelection) ? previousSelection : '')
        || (sorted.length ? sorted[0].id : '');
    }
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Select a contract...';
    contractSelector.appendChild(placeholder);
    sorted.forEach((contract) => {
      const opt = document.createElement('option');
      opt.value = contract.id;
      opt.textContent = contract.name || 'Untitled contract';
      contractSelector.appendChild(opt);
    });
    contractSelector.value = state.selectedContractId || '';
  }

  function computeContractUsage(contract) {
    const monthlyHours = {};
    let total = 0;
    if (contract) {
      state.entries.forEach((entry) => {
        if (entry.contract_id !== contract.id || !entry.date) return;
        const monthKey = entry.date.slice(0, 7);
        const hours = (Number(entry.duration_minutes) || 0) / 60;
        total += hours;
        monthlyHours[monthKey] = (monthlyHours[monthKey] || 0) + hours;
      });
    }
    return { totalHours: total, monthlyHours };
  }

  function contractMonthRange(contract) {
    if (!contract) return [];
    const startDate = contract.start_date ? parseIsoDate(contract.start_date) : parseIsoDate(todayIso());
    if (!startDate || Number.isNaN(startDate.getTime())) return [];
    const start = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
    const today = new Date();
    const endSource = contract.end_date ? parseIsoDate(contract.end_date) : today;
    const effectiveEndDate = (!endSource || Number.isNaN(endSource.getTime())) ? today : endSource;
    const end = new Date(effectiveEndDate.getFullYear(), effectiveEndDate.getMonth(), 1);
    const months = [];
    const cursor = new Date(start.getFullYear(), start.getMonth(), 1);
    if (cursor > end) {
      months.push(new Date(cursor));
      return months;
    }
    while (cursor <= end) {
      months.push(new Date(cursor));
      cursor.setMonth(cursor.getMonth() + 1);
    }
    if (!months.length) months.push(new Date(start));
    return months;
  }

  function renderContractDetail() {
    if (!contractDetailEl) return;
    contractDetailEl.innerHTML = '';
    if (state.contractFormMode === 'create') {
      if (contractSelector) contractSelector.value = '';
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (contractAddToggle) contractAddToggle.textContent = 'Close';
      const heading = document.createElement('div');
      heading.className = 'ts-note';
      heading.textContent = 'Creating new contract';
      contractDetailEl.appendChild(heading);
      placeContractFormInDetail();
      return;
    }
    if (contractAddToggle) contractAddToggle.textContent = 'Add Contract';
    if (contractSelector) contractSelector.value = state.selectedContractId || '';
    if (!state.selectedContractId) {
      const note = document.createElement('div');
      note.className = 'ts-note';
      note.textContent = state.contracts.length ? 'Select a contract to see its detail and burndown.' : 'Add a contract to get started.';
      contractDetailEl.appendChild(note);
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (!state.editingContractId) placeContractFormAtDefault();
      return;
    }
    const contract = getContractById(state.selectedContractId);
    if (!contract) {
      state.selectedContractId = '';
      if (contractSelector) contractSelector.value = '';
      renderContractDetail();
      return;
    }
    const isEditing = state.editingContractId === contract.id;
    if (!isEditing) {
      placeContractFormAtDefault();
      if (contractFormContainer && contractFormContainer.style.display === 'block' && !state.editingContractId) {
        // create mode already visible in default location
      }
    }
    const usage = computeContractUsage(contract);
    if (isEditing) {
      if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';
      if (contractBurndownEl) contractBurndownEl.innerHTML = '';
      placeContractFormInDetail();
      setContractFormMode('edit');
      const heading = document.createElement('div');
      heading.className = 'ts-note';
      heading.textContent = 'Editing contract';
      contractDetailEl.appendChild(heading);
      contractDetailEl.appendChild(contractFormContainer);
      renderContractBurndown(contract, usage);
      return;
    }

    const grid = document.createElement('div');
    grid.className = 'contract-detail-grid';

    const addDetail = (label, value) => {
      const item = document.createElement('div');
      item.className = 'contract-detail-item';
      const labelEl = document.createElement('div');
      labelEl.className = 'contract-detail-label';
      labelEl.textContent = label;
      const valueEl = document.createElement('div');
      valueEl.className = 'contract-detail-value';
      valueEl.textContent = value || '—';
      item.append(labelEl, valueEl);
      grid.appendChild(item);
    };

    const rangeLabel = contract.end_date
      ? `${contract.start_date || '—'} → ${contract.end_date}`
      : `${contract.start_date || '—'} → Present`;
    const totalHoursValue = Number(contract.total_hours || 0);
    addDetail('Contract name', contract.name || 'Untitled contract');
    addDetail('Date range', rangeLabel);
    addDetail('Hourly rate', `${Number(contract.hourly_rate || 0).toFixed(2)} / hr`);
    addDetail('Total hours', totalHoursValue > 0 ? `${formatDecimalHours(totalHoursValue)} hrs` : 'Unlimited');
    addDetail('Weekends counted', contract.include_weekends ? 'Yes (all days)' : 'No (Mon-Fri)');
    addDetail('Hours logged', `${formatDecimalHours(usage.totalHours)} hrs`);

    contractDetailEl.appendChild(grid);

    const actions = document.createElement('div');
    actions.className = 'contract-detail-actions';
    const editBtn = document.createElement('button');
    editBtn.textContent = 'Edit';
    editBtn.className = 'ghost';
    editBtn.onclick = () => handleContractEdit(contract.id);
    const deleteBtn = document.createElement('button');
    deleteBtn.textContent = 'Delete';
    deleteBtn.className = 'danger';
    deleteBtn.onclick = () => handleContractDelete(contract.id);
    actions.append(editBtn, deleteBtn);
    contractDetailEl.appendChild(actions);

    renderContractBurndown(contract, usage);
  }

  function renderContractBurndown(contract, usage) {
    if (!contractBurndownEl) return;
    contractBurndownEl.innerHTML = '';
    const totalHours = Number(contract.total_hours || 0);
    if (!usage) usage = computeContractUsage(contract);
    if (totalHours <= 0) {
      if (contractUnlimitedNote) {
        contractUnlimitedNote.style.display = 'block';
        contractUnlimitedNote.textContent = `This contract is unlimited. Hours logged so far: ${formatDecimalHours(usage.totalHours)} hrs. Burndown charts require a total hour cap.`;
      }
      const monthsEntries = Object.keys(usage.monthlyHours).sort();
      if (usage.totalHours > 0 && monthsEntries.length) {
        const heading = document.createElement('div');
        heading.className = 'ts-note';
        heading.textContent = 'Monthly hours logged';
        contractBurndownEl.appendChild(heading);
        const table = document.createElement('table');
        table.className = 'contract-burndown-table';
        table.innerHTML = '<thead><tr><th>Month</th><th>Hours logged</th></tr></thead>';
        const tbody = document.createElement('tbody');
        monthsEntries.forEach((monthKey) => {
          const tr = document.createElement('tr');
          const monthCell = document.createElement('td');
          const parts = monthKey.split('-');
          const dateObj = new Date(Number(parts[0]), Number(parts[1]) - 1, 1);
          monthCell.textContent = formatMonthShortYear(dateObj);
          const valueCell = document.createElement('td');
          valueCell.textContent = `${formatDecimalHours(usage.monthlyHours[monthKey])} hrs`;
          tr.append(monthCell, valueCell);
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        contractBurndownEl.appendChild(table);
      } else {
        const empty = document.createElement('div');
        empty.className = 'contract-burndown-empty';
        empty.textContent = 'No time has been logged for this contract yet.';
        contractBurndownEl.appendChild(empty);
      }
      return;
    }
    if (contractUnlimitedNote) contractUnlimitedNote.style.display = 'none';

    const months = contractMonthRange(contract);
    if (!months.length) {
      const empty = document.createElement('div');
      empty.className = 'contract-burndown-empty';
      empty.textContent = 'Not enough data to build a burndown chart.';
      contractBurndownEl.appendChild(empty);
      return;
    }

    const avgBurn = totalHours / months.length;
    const expectedPoints = [{ label: 'Start', value: totalHours }];
    const actualPathPoints = [{ label: 'Start', value: totalHours }];
    const tableRows = [];
    const today = new Date();
    const todayIsoString = todayIso();
    const contractStarted = !contract.start_date || contract.start_date <= todayIsoString;
    const contractActive = contractStarted && (!contract.end_date || contract.end_date >= todayIsoString);
    const currentMonthKey = monthKeyFor(today.getFullYear(), today.getMonth());
    const currentIdx = months.findIndex((monthDate) => monthKeyFor(monthDate.getFullYear(), monthDate.getMonth()) === currentMonthKey);
    let latestDataIdx = -1;
    months.forEach((monthDate, idx) => {
      const key = monthKeyFor(monthDate.getFullYear(), monthDate.getMonth());
      if ((usage.monthlyHours[key] || 0) > 0) latestDataIdx = idx;
    });
    let actualEndIndex = months.length - 1;
    if (contractActive && currentIdx !== -1) {
      actualEndIndex = Math.max(latestDataIdx, currentIdx);
      if (actualEndIndex < 0) actualEndIndex = currentIdx;
      actualEndIndex = Math.min(actualEndIndex, months.length - 1);
    }
    if (actualEndIndex < 0) actualEndIndex = months.length - 1;

    const monthContributions = months.map((monthDate, idx) => {
      if (idx === currentIdx && contractActive && latestDataIdx <= currentIdx) {
        const daysInMonth = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0).getDate();
        const daysElapsed = Math.min(daysInMonth, Math.max(1, today.getDate()));
        return Math.min(1, daysElapsed / daysInMonth);
      }
      return 1;
    });

    let actualConsumedForAverage = 0;
    let monthsContributionUsed = 0;
    let cumulativeConsumed = 0;
    months.forEach((monthDate, idx) => {
      const key = monthKeyFor(monthDate.getFullYear(), monthDate.getMonth());
      const expectedRemaining = Math.max(0, totalHours - avgBurn * (idx + 1));
      const hoursThisMonth = usage.monthlyHours[key] || 0;
      cumulativeConsumed += hoursThisMonth;
      const actualRemaining = Math.max(0, totalHours - cumulativeConsumed);
      expectedPoints.push({ label: monthDate, value: expectedRemaining });
      if (idx <= actualEndIndex) {
        actualPathPoints.push({ label: monthDate, value: actualRemaining });
        actualConsumedForAverage += hoursThisMonth;
        monthsContributionUsed += monthContributions[idx];
      }
      tableRows.push({
        monthLabel: formatMonthShortYear(monthDate),
        hoursLogged: hoursThisMonth,
        expectedRemaining,
        actualRemaining
      });
    });

    const avgActualMonthlyBurn = monthsContributionUsed > 0 ? actualConsumedForAverage / monthsContributionUsed : 0;
    const totalContribution = monthContributions.reduce((sum, value) => sum + value, 0);
    const actualAveragePoints = [{ label: 'Start', value: totalHours }];
    if (avgActualMonthlyBurn > 0) {
      let cumulativeContribution = 0;
      months.forEach((monthDate, idx) => {
        cumulativeContribution += monthContributions[idx];
        const projectedRemaining = Math.max(0, totalHours - avgActualMonthlyBurn * cumulativeContribution);
        actualAveragePoints.push({ label: monthDate, value: projectedRemaining });
      });
    }

    const pointGroups = [expectedPoints, actualPathPoints];
    if (actualAveragePoints.length > 1) pointGroups.push(actualAveragePoints);
    const maxValue = Math.max(totalHours, ...pointGroups.flat().map((p) => p.value));
    const containerRect = contractBurndownEl.getBoundingClientRect();
    const detailRect = contractDetailEl ? contractDetailEl.getBoundingClientRect() : null;
    const measuredWidth = containerRect.width || (detailRect && detailRect.width) || 720;
    const width = Math.max(480, Math.floor(measuredWidth));
    const height = 320;
    const margin = { top: 20, right: 28, bottom: 44, left: 56 };
    const plotWidth = width - margin.left - margin.right;
    const plotHeight = height - margin.top - margin.bottom;
    const stepX = expectedPoints.length > 1 ? plotWidth / (expectedPoints.length - 1) : 0;
    const scaleX = (index) => margin.left + stepX * index;
    const scaleY = (value) => {
      if (maxValue === 0) return margin.top + plotHeight;
      return margin.top + plotHeight - (value / maxValue) * plotHeight;
    };
    const buildPath = (points) => points.map((point, idx) => {
      const x = scaleX(idx).toFixed(2);
      const y = scaleY(point.value).toFixed(2);
      return `${idx === 0 ? 'M' : 'L'}${x},${y}`;
    }).join(' ');

    const styles = getComputedStyle(document.body);
    const borderColor = (styles.getPropertyValue('--border') || '#1e293b').trim();
    const mutedColor = (styles.getPropertyValue('--muted') || '#94a3b8').trim();
    const primaryColor = (styles.getPropertyValue('--primary') || '#3b82f6').trim();
    const successColor = (styles.getPropertyValue('--success') || '#10b981').trim();
    const textColor = mutedColor || '#94a3b8';

    const expectedPath = buildPath(expectedPoints);
    const actualPath = buildPath(actualPathPoints);
    const actualAveragePath = actualAveragePoints.length > 1 ? buildPath(actualAveragePoints) : '';
    const xAxisY = margin.top + plotHeight;
    const svgParts = [];
    svgParts.push(`<path d="M${margin.left},${xAxisY} L${margin.left + plotWidth},${xAxisY}" stroke="${borderColor}" stroke-width="1" fill="none" />`);
    svgParts.push(`<path d="M${margin.left},${margin.top} L${margin.left},${xAxisY}" stroke="${borderColor}" stroke-width="1" fill="none" />`);
    svgParts.push(`<path d="${expectedPath}" stroke="${mutedColor}" stroke-width="2" fill="none" />`);
    svgParts.push(`<path d="${actualPath}" stroke="${primaryColor}" stroke-width="2" fill="none" />`);
    if (actualAveragePath) svgParts.push(`<path d="${actualAveragePath}" stroke="${successColor}" stroke-width="2" fill="none" stroke-dasharray="6 4" />`);

    expectedPoints.forEach((point, idx) => {
      const x = scaleX(idx);
      const y = scaleY(point.value);
      svgParts.push(`<circle cx="${x}" cy="${y}" r="3" fill="${mutedColor}" />`);
    });
    actualPathPoints.forEach((point, idx) => {
      const x = scaleX(idx);
      const y = scaleY(point.value);
      svgParts.push(`<circle cx="${x}" cy="${y}" r="3" fill="${primaryColor}" />`);
    });
    if (actualAveragePath) {
      actualAveragePoints.forEach((point, idx) => {
        const x = scaleX(idx);
        const y = scaleY(point.value);
        svgParts.push(`<circle cx="${x}" cy="${y}" r="3" fill="${successColor}" />`);
      });
    }

    const labelGroup = months.map((monthDate, idx) => {
      const x = scaleX(idx + 1);
      const label = formatMonthShortYear(monthDate);
      return `<text x="${x}" y="${xAxisY + 18}" text-anchor="middle" font-size="11" fill="${textColor}">${label}</text>`;
    }).join('');

    const svg = `<svg viewBox="0 0 ${width} ${height}" role="img" aria-label="Contract burndown chart"><g>${svgParts.join('')} ${labelGroup}</g></svg>`;

    const avgSummary = document.createElement('div');
    avgSummary.className = 'ts-note contract-burndown-summary';
    const summaryParts = [`Average burn required: ${formatDecimalHours(avgBurn)} hrs/month.`];
    if (avgActualMonthlyBurn > 0) {
      summaryParts.push(`Actual average to date: ${formatDecimalHours(avgActualMonthlyBurn)} hrs/month (${monthsContributionUsed.toFixed(2)} months measured).`);
    }
    avgSummary.textContent = summaryParts.join(' ');
    contractBurndownEl.appendChild(avgSummary);

    if (contractActive && avgActualMonthlyBurn > avgBurn + 0.01 && monthsContributionUsed > 0) {
      const projectedTotalUsage = avgActualMonthlyBurn * totalContribution;
      const overageHours = projectedTotalUsage - totalHours;
      if (overageHours > 0.5) {
        const warning = document.createElement('div');
        warning.className = 'ts-warning contract-burndown-warning';
        warning.textContent = `At the current pace you're on track to exceed this contract by approximately ${formatDecimalHours(overageHours)} hrs.`;
        contractBurndownEl.appendChild(warning);
      }
    }

    const plotWrapper = document.createElement('div');
    plotWrapper.className = 'contract-burndown-plot';
    plotWrapper.innerHTML = svg;
    contractBurndownEl.appendChild(plotWrapper);

    const legend = document.createElement('div');
    legend.className = 'contract-burndown-legend';
    legend.innerHTML = `<span><span class="line" style="background:${mutedColor};"></span>Expected remaining</span><span><span class="line" style="background:${primaryColor};"></span>Actual remaining</span>${actualAveragePath ? `<span><span class="line" style="background:transparent; border-bottom:2px dashed ${successColor}; height:0;"></span>Actual average (projection)</span>` : ''}`;
    contractBurndownEl.appendChild(legend);

    const table = document.createElement('table');
    table.className = 'contract-burndown-table';
    table.innerHTML = '<thead><tr><th>Month</th><th>Hours logged</th><th>Expected remaining</th><th>Actual remaining</th></tr></thead>';
    const tbody = document.createElement('tbody');
    tableRows.forEach((row) => {
      const tr = document.createElement('tr');
      const monthCell = document.createElement('td');
      monthCell.textContent = row.monthLabel;
      const loggedCell = document.createElement('td');
      loggedCell.textContent = `${formatDecimalHours(row.hoursLogged)} hrs`;
      const expectedCell = document.createElement('td');
      expectedCell.textContent = `${formatDecimalHours(row.expectedRemaining)} hrs`;
      const actualCell = document.createElement('td');
      actualCell.textContent = `${formatDecimalHours(row.actualRemaining)} hrs`;
      tr.append(monthCell, loggedCell, expectedCell, actualCell);
      tbody.appendChild(tr);
    });
    table.appendChild(tbody);
    contractBurndownEl.appendChild(table);
  }

  function renderContractsUI() {
    renderContractSelectorOptions();
    renderContractDetail();
  }

  function handleContractSave() {
    if (!contractSaveBtn) return;
    const payload = getContractFormPayload();
    if (!payload) return;
    contractSaveBtn.disabled = true;
    const isEdit = !!state.editingContractId;
    setStatus(isEdit ? 'Updating contract...' : 'Saving contract...', 'warn');
    const handler = (res) => {
      contractSaveBtn.disabled = false;
      if (res && res.success && res.contract) {
        const normalized = sanitizeContract(res.contract);
        state.contracts = [...state.contracts.filter((c) => c.id !== normalized.id), normalized];
        state.selectedContractId = normalized.id;
        refreshContractBindings(normalized.id, normalized.id);
        saveCache();
        hideContractForm();
        renderContractDetail();
        setStatus(isEdit ? 'Contract updated' : 'Contract saved', 'success');
      } else {
        setStatus('Contract save failed', 'error');
      }
    };
    const failure = () => {
      contractSaveBtn.disabled = false;
      setStatus('Contract save failed', 'error');
    };
    if (isEdit) {
      google.script.run
        .withSuccessHandler(handler)
        .withFailureHandler(failure)
        .api_updateContract({ id: state.editingContractId, ...payload });
    } else {
      google.script.run
        .withSuccessHandler(handler)
        .withFailureHandler(failure)
        .api_addContract(payload);
    }
  }

  function handleContractEdit(id) {
    const contract = state.contracts.find((c) => c.id === id);
    if (!contract) return;
    populateContractForm(contract);
    showPage('contracts');
  }

  async function handleContractDelete(id) {
    if (!id) return;
    const hasEntries = state.entries.some((entry) => entry.contract_id === id);
    if (hasEntries) {
      customAlert('This contract already has time entries and cannot be deleted.');
      return;
    }
    const confirmed = await customConfirm('Delete this contract?', { danger: true });
    if (!confirmed) return;
    setStatus('Deleting contract...', 'warn');
    google.script.run
      .withSuccessHandler(() => {
        state.contracts = state.contracts.filter((contract) => contract.id !== id);
        if (state.editingContractId === id) {
          hideContractForm();
        }
        if (state.selectedContractId === id) {
          state.selectedContractId = '';
        }
        refreshContractBindings();
        saveCache();
        setStatus('Contract deleted', 'success');
      })
      .withFailureHandler(() => setStatus('Contract delete failed', 'error'))
      .api_deleteContract(id);
  }

  function renderFeatureFlags() {
    if (!featureFlagsListEl) return;
    featureFlagsListEl.innerHTML = '';
    const entries = Object.keys(state.featureFlags)
      .filter((key) => {
        if (key === 'enable_company_quarterly_bas' || key === 'is_sole_trader') {
          return !!state.featureFlags.enable_company_tracking_features?.enabled;
        }
        return true;
      })
      .map((key) => ({
      key,
      enabled: !!state.featureFlags[key].enabled,
      name: state.featureFlags[key].name || key,
      description: state.featureFlags[key].description || '',
      order: (DEFAULT_FEATURE_FLAGS[key] && DEFAULT_FEATURE_FLAGS[key].order) || 0
    })).sort((a, b) => {
      if (a.order !== b.order) return a.order - b.order;
      return a.name.localeCompare(b.name);
    });
    if (!entries.length) {
      const empty = document.createElement('div');
      empty.className = 'ts-note';
      empty.textContent = 'No feature flags configured.';
      featureFlagsListEl.appendChild(empty);
      return;
    }
    entries.forEach((flag) => {
      const row = document.createElement('div');
      row.className = 'ts-flag-row';

      const meta = document.createElement('div');
      meta.className = 'ts-flag-meta';
      meta.innerHTML = `<div class="ts-flag-title">${flag.name}</div>` + (flag.description ? `<div class="ts-flag-desc">${flag.description}</div>` : '');

      const toggleLabel = document.createElement('label');
      toggleLabel.className = 'ts-toggle';
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.checked = flag.enabled;
      input.dataset.flag = flag.key;
      input.setAttribute('aria-label', flag.name);
      const track = document.createElement('span');
      track.className = 'ts-toggle-track';
      const thumb = document.createElement('span');
      thumb.className = 'ts-toggle-thumb';
      track.appendChild(thumb);
      toggleLabel.appendChild(input);
      toggleLabel.appendChild(track);

      input.addEventListener('change', () => {
        if (!!state.featureFlags[flag.key]?.enabled === input.checked) return;
        updateFeatureFlag(flag.key, input.checked);
      });

      row.append(meta, toggleLabel);
      featureFlagsListEl.appendChild(row);
    });
  }

  function updateFeatureFlag(featureKey, enabled) {
    const toggleInput = featureFlagsListEl ? featureFlagsListEl.querySelector(`input[data-flag="${featureKey}"]`) : null;
    if (toggleInput) toggleInput.disabled = true;
    const currentMeta = state.featureFlags[featureKey] || DEFAULT_FEATURE_FLAGS[featureKey] || { name: featureKey, description: '' };
    setStatus('Updating feature flags...', 'warn');
    google.script.run
      .withSuccessHandler((res) => {
        if (toggleInput) toggleInput.disabled = false;
        if (res && res.success && res.flags) {
          state.featureFlags = normalizeFeatureFlags(res.flags);
          saveCache();
          renderFeatureFlags();
          applyFeatureFlags();
          setStatus('Feature flags updated', 'success');
        } else {
          if (toggleInput) toggleInput.checked = !!currentMeta.enabled;
          setStatus('Feature flag update failed', 'error');
        }
      })
      .withFailureHandler(() => {
        if (toggleInput) {
          toggleInput.disabled = false;
          toggleInput.checked = !!currentMeta.enabled;
        }
        setStatus('Feature flag update failed', 'error');
      })
      .api_setFeatureFlag({
        feature: featureKey,
        enabled: enabled,
        name: currentMeta.name || featureKey,
        description: currentMeta.description || ''
      });
  }

  function applyFeatureFlags() {
    const rememberFlag = state.featureFlags.remember_last_page || DEFAULT_FEATURE_FLAGS.remember_last_page || { enabled: false };
    if (rememberFlag.enabled) {
      let stored = null;
      try {
        stored = localStorage.getItem(LAST_PAGE_KEY);
      } catch (e) {}
      if (!stored) {
        persistLastPage(state.currentPage);
      } else if (stored && PAGE_KEYS.includes(stored) && stored !== state.currentPage) {
        showPage(stored);
      }
    } else {
      try {
        localStorage.removeItem(LAST_PAGE_KEY);
      } catch (e) {}
    }
    const zeroFlag = state.featureFlags.show_zero_hours || DEFAULT_FEATURE_FLAGS.show_zero_hours || { enabled: false };
    state.showZeroHours = !!zeroFlag.enabled;
    renderCalendar();
    updateClearCacheVisibility();

    const expectedMonthlyFlag = state.featureFlags.expected_monthly_hours || DEFAULT_FEATURE_FLAGS.expected_monthly_hours || { enabled: false };
    if (contractIncludeWeekendsRow) {
      contractIncludeWeekendsRow.style.display = expectedMonthlyFlag.enabled ? 'flex' : 'none';
    }

    const companyFlag = state.featureFlags.enable_company_tracking_features || DEFAULT_FEATURE_FLAGS.enable_company_tracking_features || { enabled: false };
    state.companyTrackingEnabled = !!companyFlag.enabled;
    updateDeductionCompanyOptions();
    updateDeductionFormVisibility();
    renderDeductionsList();
    renderIncomeSummary();

    const quarterlyFlag = state.featureFlags.enable_company_quarterly_bas || DEFAULT_FEATURE_FLAGS.enable_company_quarterly_bas || { enabled: false };
    state.companyBasQuarterly = state.companyTrackingEnabled && !!quarterlyFlag.enabled;
    if (navBasBtn) {
      navBasBtn.style.display = state.companyTrackingEnabled ? 'block' : 'none';
    }
    if (!state.companyTrackingEnabled && state.currentPage === 'bas') {
      showPage('time');
    }
    renderBasReporting();

    updatePayrollHelperButtons();

    // Show/hide hour types navigation
    const hourTypesFlag = state.featureFlags.hour_types || DEFAULT_FEATURE_FLAGS.hour_types || { enabled: false };
    if (navHourTypesBtn) {
      navHourTypesBtn.style.display = hourTypesFlag.enabled ? 'block' : 'none';
    }
    if (hourTypesFlag.enabled) {
      loadHourTypes();
    }
    updateHourTypeFormVisibility();

    // Show/hide public holidays state setting
    const publicHolidaysFlag = state.featureFlags.enable_public_holidays || DEFAULT_FEATURE_FLAGS.enable_public_holidays || { enabled: false };
    if (publicHolidayStateCol) {
      publicHolidayStateCol.style.display = publicHolidaysFlag.enabled ? 'block' : 'none';
    }
    if (publicHolidaysFlag.enabled) {
      loadPublicHolidays();
    }

    // Show/hide PAYG rate setting (only when company tracking is enabled)
    if (paygRateCol) {
      paygRateCol.style.display = state.companyTrackingEnabled ? 'block' : 'none';
    }

    // Show/hide minimum end time setting
    const suggestEndTimeFlag = state.featureFlags.suggest_end_time || DEFAULT_FEATURE_FLAGS.suggest_end_time || { enabled: false };
    if (minimumEndTimeCol) {
      minimumEndTimeCol.style.display = suggestEndTimeFlag.enabled ? 'block' : 'none';
    }

    // Show/hide colorblind theme options
    const colorblindThemesFlag = state.featureFlags.enable_colorblind_themes || DEFAULT_FEATURE_FLAGS.enable_colorblind_themes || { enabled: false };
    const colorblindThemeOptions = document.querySelectorAll('.ts-colorblind-theme');
    colorblindThemeOptions.forEach(function(option) {
      option.style.display = colorblindThemesFlag.enabled ? 'block' : 'none';
    });

    // Show/hide custom theme option and configure button
    const customThemeFlag = state.featureFlags.custom_theme || DEFAULT_FEATURE_FLAGS.custom_theme || { enabled: false };
    const customThemeOption = document.querySelector('.ts-custom-theme');
    if (customThemeOption) {
      customThemeOption.style.display = customThemeFlag.enabled ? 'block' : 'none';
    }

    const btnConfigureTheme = document.getElementById('btn-configure-theme');
    if (btnConfigureTheme) {
      btnConfigureTheme.style.display = customThemeFlag.enabled ? 'inline-block' : 'none';
    }

    // Lock theme dropdown to "custom" when custom theme flag is enabled
    if (themeSelect && customThemeFlag.enabled) {
      themeSelect.value = 'custom';
      state.settings.theme = 'custom';
      applyTheme('custom');
    }
  }

  if (contractSaveBtn) {
    contractSaveBtn.onclick = handleContractSave;
  }
  if (contractCancelBtn) {
    contractCancelBtn.onclick = () => {
      hideContractForm();
      renderContractDetail();
    };
  }
  if (contractAddToggle) {
    contractAddToggle.addEventListener('click', () => {
      showPage('contracts');
      if (state.contractFormMode === 'create') {
        hideContractForm();
        renderContractDetail();
        return;
      }
      if (state.contractFormMode === 'edit') {
        hideContractForm();
      }
      showContractForm('create');
    });
  }
  if (contractSelector) {
    contractSelector.addEventListener('change', () => {
      const nextId = contractSelector.value || '';
      if (state.contractFormMode === 'create' || (state.contractFormMode === 'edit' && state.editingContractId && state.editingContractId !== nextId)) {
        hideContractForm();
      }
      state.selectedContractId = nextId;
      renderContractDetail();
    });
  }
  setContractFormMode('hidden');

  function updateClearCacheVisibility() {
    if (!clearCacheWrapper) return;
    const enabled = !!(state.featureFlags.show_clear_cache && state.featureFlags.show_clear_cache.enabled);
    clearCacheWrapper.style.display = enabled ? 'block' : 'none';
  }

  if (clearCacheBtn) {
    clearCacheBtn.addEventListener('click', async () => {
      const confirmed = await customConfirm('Clear cached entries and settings from this browser?', {
        title: 'Clear Cache',
        danger: true
      });
      if (!confirmed) return;
      try {
        localStorage.removeItem(state.cacheKey);
        localStorage.removeItem(LAST_PAGE_KEY);
      } catch (e) {}
      setStatus('Local cache cleared. Data will be reloaded from the server on next sync.', 'success');
    });
  }

  if (payrollXeroBtn) {
    payrollXeroBtn.addEventListener('click', () => {
      renderXeroPayrollHelper();
      showModal(xeroHelperModal);
    });
  }

  if (payrollMyobBtn) {
    payrollMyobBtn.addEventListener('click', () => {
      renderMyobPayrollHelper();
      showModal(myobHelperModal);
    });
  }

  // Actual Income Modal Event Listeners
  if (actualIncomeBtn) {
    actualIncomeBtn.addEventListener('click', openActualIncomeModal);
  }
  if (btnSaveActualIncome) {
    btnSaveActualIncome.addEventListener('click', saveActualIncome);
  }
  if (btnCancelActualIncome) {
    btnCancelActualIncome.addEventListener('click', closeActualIncomeModal);
  }
  if (btnDeleteActualIncome) {
    btnDeleteActualIncome.addEventListener('click', deleteActualIncome);
  }

  // Entries & KPIs
  function minutesForDate(date) {
    return state.entries
      .filter((e) => e.date === date)
      .reduce((acc, entry) => acc + (Number(entry.duration_minutes) || 0), 0);
  }
  const monthKeyFor = (year, month) => `${year}-${String(month + 1).padStart(2, '0')}`;
  function entriesForMonth(year, month) {
    const prefix = monthKeyFor(year, month);
    return state.entries.filter((entry) => entry.date && entry.date.startsWith(prefix));
  }
  function payrollEligibleEntries(year, month) {
    return entriesForMonth(year, month).filter((entry) => entry && entry.date && entryContributesToIncome(entry));
  }
  function formatRangeLabel(startDate, endDate) {
    const startLabel = MONTH_DAY_FORMATTER.format(startDate);
    const endLabel = MONTH_DAY_FORMATTER.format(endDate);
    return startLabel === endLabel ? startLabel : `${startLabel} - ${endLabel}`;
  }
  function buildXeroPayrollReport(year, month) {
    const eligibleEntries = payrollEligibleEntries(year, month);
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const minutesByDay = Array.from({ length: daysInMonth + 1 }, () => 0);
    eligibleEntries.forEach((entry) => {
      const dayString = entry.date ? entry.date.slice(-2) : '';
      const day = Number(dayString);
      if (!Number.isFinite(day)) return;
      minutesByDay[day] += Number(entry.duration_minutes) || 0;
    });
    const weeks = [];
    let cumulativeMinutes = 0;
    for (let start = 1; start <= daysInMonth; start += 7) {
      const end = Math.min(start + 6, daysInMonth);
      let weekMinutes = 0;
      const days = [];
      for (let offset = 0; offset < 7; offset += 1) {
        const day = start + offset;
        const existsInMonth = day <= daysInMonth;
        const dateObj = new Date(year, month, day);
        const minutes = existsInMonth ? (minutesByDay[day] || 0) : 0;
        if (existsInMonth) weekMinutes += minutes;
        days.push({
          date: dateObj,
          minutes,
          inMonth: existsInMonth
        });
      }
      cumulativeMinutes += weekMinutes;
      weeks.push({
        startDay: start,
        endDay: end,
        days,
        weekMinutes,
        cumulativeMinutes
      });
    }
    return {
      weeks,
      totalMinutes: cumulativeMinutes,
      hasEntries: eligibleEntries.length > 0
    };
  }
  function buildMyobPayrollReport(year, month) {
    const eligibleEntries = payrollEligibleEntries(year, month);
    const minutesByDate = eligibleEntries.reduce((map, entry) => {
      if (!entry.date) return map;
      map[entry.date] = (map[entry.date] || 0) + (Number(entry.duration_minutes) || 0);
      return map;
    }, {});
    const monthStart = startOfDay(new Date(year, month, 1));
    const monthEnd = startOfDay(new Date(year, month + 1, 0));
    const firstWeekStart = (() => {
      const first = new Date(monthStart);
      const offset = (first.getDay() + 6) % 7; // shift Sunday to 6, Monday to 0
      first.setDate(first.getDate() - offset);
      return startOfDay(first);
    })();
    const weeks = [];
    for (let cursor = new Date(firstWeekStart); cursor <= monthEnd; cursor.setDate(cursor.getDate() + 7)) {
      const weekStart = startOfDay(new Date(cursor));
      const weekEnd = startOfDay(new Date(cursor));
      weekEnd.setDate(weekEnd.getDate() + 6);
      const days = [];
      let weekMinutes = 0;
      for (let i = 0; i < 7; i += 1) {
        const dayDate = new Date(weekStart);
        dayDate.setDate(dayDate.getDate() + i);
        const key = isoDate(dayDate);
        const inMonth = dayDate >= monthStart && dayDate <= monthEnd;
        const minutes = inMonth ? (minutesByDate[key] || 0) : 0;
        if (inMonth) weekMinutes += minutes;
        days.push({
          date: dayDate,
          minutes,
          inMonth
        });
      }
      weeks.push({
        weekStart,
        weekEnd,
        days,
        weekMinutes
      });
      if (weekEnd >= monthEnd) break;
    }
    const totalMinutes = weeks.reduce((acc, week) => acc + week.weekMinutes, 0);
    return {
      weeks,
      totalMinutes,
      hasEntries: eligibleEntries.length > 0
    };
  }
  function entryContributesToIncome(entry) {
    if (!entry) return false;
    const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
    const hourType = hourTypeId ? state.hourTypeMap[hourTypeId] : null;
    if (hourType && Object.prototype.hasOwnProperty.call(hourType, 'contributes_to_income')) {
      return !!hourType.contributes_to_income;
    }
    return true;
  }
  function renderXeroPayrollHelper() {
    if (!xeroHelperContent) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const report = buildXeroPayrollReport(year, month);
    xeroHelperContent.innerHTML = '';

    report.weeks.forEach((week) => {
      const section = document.createElement('section');
      section.className = 'ts-payroll-week ts-payroll-xero';
      const rangeStart = new Date(year, month, week.startDay);
      const rangeEnd = new Date(year, month, week.endDay);

      const heading = document.createElement('div');
      heading.className = 'ts-payroll-week-header';
      const title = document.createElement('h4');
      title.textContent = `Week ending ${MONTH_DAY_FORMATTER.format(rangeEnd)}`;
      heading.appendChild(title);
      section.appendChild(heading);

      const table = document.createElement('table');
      table.className = 'ts-payroll-table ts-payroll-table-grid';
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      week.days.forEach((day) => {
        const th = document.createElement('th');
        const label = `${WEEKDAY_FORMATTER.format(day.date)} ${MONTH_DAY_FORMATTER.format(day.date)}`;
        th.textContent = label;
        if (!day.inMonth) th.classList.add('ts-payroll-outside');
        headRow.appendChild(th);
      });
      const totalHead = document.createElement('th');
      totalHead.textContent = 'Month-to-date total';
      headRow.appendChild(totalHead);
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      const row = document.createElement('tr');
      week.days.forEach((day) => {
        const td = document.createElement('td');
        if (!day.inMonth) {
          td.classList.add('ts-payroll-outside');
          td.textContent = '—';
        } else {
          const rounded = roundDuration(day.minutes || 0);
          td.textContent = formatDecimalHours(rounded / 60);
        }
        row.appendChild(td);
      });
      const totalCell = document.createElement('td');
      const roundedTotal = roundDuration(week.cumulativeMinutes || 0);
      totalCell.textContent = formatDecimalHours(roundedTotal / 60);
      row.appendChild(totalCell);
      tbody.appendChild(row);
      table.appendChild(tbody);

      section.appendChild(table);
      xeroHelperContent.appendChild(section);
    });

    const total = document.createElement('div');
    total.className = 'ts-payroll-total';
    const roundedMonthlyTotal = roundDuration(report.totalMinutes || 0);
    total.textContent = `Monthly total across all weeks: ${formatDecimalHours(roundedMonthlyTotal / 60)} hrs`;
    xeroHelperContent.appendChild(total);

    if (!report.hasEntries) {
      const empty = document.createElement('p');
      empty.className = 'ts-note';
      empty.textContent = 'No income-contributing hours logged for this month yet. Week ranges are shown with zero values so you can prepare entries ahead of time.';
      xeroHelperContent.appendChild(empty);
    }
  }
  function renderMyobPayrollHelper() {
    if (!myobHelperContent) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const report = buildMyobPayrollReport(year, month);
    myobHelperContent.innerHTML = '';

    report.weeks.forEach((week) => {
      const section = document.createElement('section');
      section.className = 'ts-payroll-week ts-payroll-myob';

      const heading = document.createElement('div');
      heading.className = 'ts-payroll-week-header';
      const title = document.createElement('h4');
      title.textContent = `Week of ${MONTH_DAY_FORMATTER.format(week.weekStart)}`;
      heading.appendChild(title);
      section.appendChild(heading);

      const table = document.createElement('table');
      table.className = 'ts-payroll-table ts-myob-table';
      const thead = document.createElement('thead');
      const headRow = document.createElement('tr');
      week.days.forEach((day) => {
        const th = document.createElement('th');
        th.textContent = `${WEEKDAY_FORMATTER.format(day.date)} ${MONTH_DAY_FORMATTER.format(day.date)}`;
        if (!day.inMonth) th.classList.add('ts-payroll-outside');
        headRow.appendChild(th);
      });
      const totalHead = document.createElement('th');
      totalHead.textContent = 'Week total';
      headRow.appendChild(totalHead);
      thead.appendChild(headRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      const row = document.createElement('tr');
      week.days.forEach((day) => {
        const td = document.createElement('td');
        if (!day.inMonth) {
          td.classList.add('ts-payroll-outside');
          td.textContent = '—';
        } else {
          const rounded = roundDuration(day.minutes || 0);
          td.textContent = formatDecimalHours(rounded / 60);
        }
        row.appendChild(td);
      });
      const totalCell = document.createElement('td');
      const roundedTotal = roundDuration(week.weekMinutes || 0);
      totalCell.textContent = formatDecimalHours(roundedTotal / 60);
      row.appendChild(totalCell);
      tbody.appendChild(row);
      table.appendChild(tbody);
      section.appendChild(table);
      myobHelperContent.appendChild(section);
    });

    const total = document.createElement('div');
    total.className = 'ts-payroll-total';
    const roundedMonthlyTotal = roundDuration(report.totalMinutes || 0);
    total.textContent = `Monthly total across all weeks: ${formatDecimalHours(roundedMonthlyTotal / 60)} hrs`;
    myobHelperContent.appendChild(total);

    if (!report.hasEntries) {
      const empty = document.createElement('p');
      empty.className = 'ts-note';
      empty.textContent = 'No income-contributing hours logged for this month yet. Weekly ranges include out-of-month days for context; in-month days show 0 hrs.';
      myobHelperContent.appendChild(empty);
    }
  }
  function updatePayrollHelperButtons() {
    if (!payrollXeroBtn && !payrollMyobBtn) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const hasEligibleEntries = payrollEligibleEntries(year, month).length > 0;
    if (payrollXeroBtn) {
      const visible = getFeatureFlag('xero_payroll_helper');
      payrollXeroBtn.style.display = visible ? 'inline-flex' : 'none';
      payrollXeroBtn.setAttribute('aria-disabled', visible && !hasEligibleEntries ? 'true' : 'false');
      payrollXeroBtn.title = visible && !hasEligibleEntries
        ? 'No income-contributing hours logged yet in this month'
        : 'Open the Xero payroll helper';
    }
    if (payrollMyobBtn) {
      const visible = getFeatureFlag('myob_payroll_helper');
      payrollMyobBtn.style.display = visible ? 'inline-flex' : 'none';
      payrollMyobBtn.setAttribute('aria-disabled', visible && !hasEligibleEntries ? 'true' : 'false');
      payrollMyobBtn.title = visible && !hasEligibleEntries
        ? 'No income-contributing hours logged yet in this month'
        : 'Open the MYOB payroll helper';
    }
    // Update actual income button visibility
    if (actualIncomeBtn) {
      const visible = getFeatureFlag('enable_actual_income');
      actualIncomeBtn.style.display = visible ? 'inline-flex' : 'none';
      actualIncomeBtn.title = 'Add or view actual income for the current month';
    }
  }

  // Actual Income Functions
  function openActualIncomeModal() {
    if (!actualIncomeModal) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const monthStr = `${year}-${String(month + 1).padStart(2, '0')}`;

    // Format month display text to match calendar (e.g., "October 2025")
    const monthDate = new Date(year, month, 1);
    const monthDisplayText = monthDate.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    if (actualIncomeMonthDisplay) actualIncomeMonthDisplay.textContent = monthDisplayText;

    // Check if there's existing data for this month
    const existing = state.actualIncome.find(item => item.month === monthStr);

    if (existing) {
      state.editingActualIncomeId = existing.id;
      if (actualIncomeTitle) actualIncomeTitle.textContent = 'Edit Actual Income';
      if (actualIncomeMonthInput) actualIncomeMonthInput.value = existing.month;
      if (actualIncomeGrossInput) actualIncomeGrossInput.value = existing.gross_income;
      if (actualIncomeSuperInput) actualIncomeSuperInput.value = existing.superannuation;
      if (actualIncomeTaxInput) actualIncomeTaxInput.value = existing.tax;
      if (actualIncomeNetInput) actualIncomeNetInput.value = existing.net_income;
      if (btnDeleteActualIncome) btnDeleteActualIncome.style.display = 'inline-flex';
    } else {
      state.editingActualIncomeId = null;
      if (actualIncomeTitle) actualIncomeTitle.textContent = 'Add Actual Income';
      if (actualIncomeMonthInput) actualIncomeMonthInput.value = monthStr;
      if (actualIncomeGrossInput) actualIncomeGrossInput.value = '';
      if (actualIncomeSuperInput) actualIncomeSuperInput.value = '';
      if (actualIncomeTaxInput) actualIncomeTaxInput.value = '';
      if (actualIncomeNetInput) actualIncomeNetInput.value = '';
      if (btnDeleteActualIncome) btnDeleteActualIncome.style.display = 'none';
    }

    showModal(actualIncomeModal);
  }

  function closeActualIncomeModal() {
    if (!actualIncomeModal) return;
    hideModal(actualIncomeModal);
    state.editingActualIncomeId = null;
  }

  async function saveActualIncome() {
    if (!actualIncomeMonthInput || !actualIncomeGrossInput || !actualIncomeSuperInput ||
        !actualIncomeTaxInput || !actualIncomeNetInput) return;

    const payload = {
      id: state.editingActualIncomeId || undefined,
      month: actualIncomeMonthInput.value,
      gross_income: Number(actualIncomeGrossInput.value) || 0,
      superannuation: Number(actualIncomeSuperInput.value) || 0,
      tax: Number(actualIncomeTaxInput.value) || 0,
      net_income: Number(actualIncomeNetInput.value) || 0
    };

    // Optimistic update
    const previousList = state.actualIncome.slice();
    if (state.editingActualIncomeId) {
      const index = state.actualIncome.findIndex(item => item.id === state.editingActualIncomeId);
      if (index !== -1) {
        state.actualIncome[index] = { ...state.actualIncome[index], ...payload };
      }
    } else {
      const tempId = 'temp_' + Date.now();
      state.actualIncome.push({ ...payload, id: tempId, created_at: '', updated_at: '' });
    }
    refreshActualIncomeMap();
    saveCache();
    renderIncomeSummary();
    closeActualIncomeModal();
    setStatus('Saving actual income...', 'warn');

    google.script.run
      .withSuccessHandler((response) => {
        if (response && response.success && response.actualIncome) {
          const updated = response.actualIncome;
          const index = state.actualIncome.findIndex(item =>
            item.id === state.editingActualIncomeId || item.id === updated.id || item.id.startsWith('temp_')
          );
          if (index !== -1) {
            state.actualIncome[index] = updated;
          } else {
            state.actualIncome.push(updated);
          }
          refreshActualIncomeMap();
          saveCache();
          renderIncomeSummary();
          setStatus('Actual income saved', 'success');
        } else {
          state.actualIncome = previousList;
          refreshActualIncomeMap();
          saveCache();
          renderIncomeSummary();
          setStatus('Actual income save failed', 'error');
        }
      })
      .withFailureHandler(() => {
        state.actualIncome = previousList;
        refreshActualIncomeMap();
        saveCache();
        renderIncomeSummary();
        setStatus('Actual income save failed', 'error');
      })
      .api_upsertActualIncome(payload);
  }

  async function deleteActualIncome() {
    if (!state.editingActualIncomeId) return;
    const confirmed = await customConfirm('Delete this actual income entry?', { danger: true });
    if (!confirmed) return;

    const previousList = state.actualIncome.slice();
    state.actualIncome = state.actualIncome.filter(item => item.id !== state.editingActualIncomeId);
    refreshActualIncomeMap();
    saveCache();
    renderIncomeSummary();
    closeActualIncomeModal();
    setStatus('Deleting actual income...', 'warn');

    google.script.run
      .withSuccessHandler(() => {
        setStatus('Actual income deleted', 'success');
      })
      .withFailureHandler(() => {
        state.actualIncome = previousList;
        refreshActualIncomeMap();
        saveCache();
        renderIncomeSummary();
        setStatus('Failed to delete actual income', 'error');
      })
      .api_deleteActualIncome(state.editingActualIncomeId);
  }

  function refreshActualIncomeMap() {
    state.actualIncomeMap = {};
    state.actualIncome.forEach(item => {
      state.actualIncomeMap[item.month] = item;
    });
  }

  function buildIncomeSummary(year, month) {
    const allEntries = entriesForMonth(year, month);
    // Filter to only include entries from hour types that contribute to income
    const entries = allEntries.filter(entry => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      const hourType = state.hourTypeMap[hourTypeId];
      return hourType ? hourType.contributes_to_income : true; // Default to true for backwards compatibility
    });
    const periodStart = new Date(year, month, 1);
    const superRate = getSuperRateSetting();
    let totalMinutes = 0;
    let totalHours = 0;
    let totalPackage = 0;
    if (entries.length) {
      totalMinutes = entries.reduce((acc, entry) => acc + (Number(entry.duration_minutes) || 0), 0);
      totalHours = totalMinutes / 60;
    }
    const validContractsUsed = entries.reduce((set, entry) => {
      const contract = state.contractMap[entry.contract_id];
      if (contract && contractIsValid(contract, entry.date)) set.add(contract.id);
      return set;
    }, new Set());
    const validContractsAcrossDates = entries.reduce((set, entry) => {
      const valids = validContractsForDate(entry.date);
      valids.forEach((contract) => set.add(contract.id));
      return set;
    }, new Set());
    if (validContractsUsed.size === 1) {
      const onlyId = Array.from(validContractsUsed)[0];
      const contract = state.contractMap[onlyId];
      const rate = contract ? Number(contract.hourly_rate || 0) : 0;
      totalPackage = totalHours * rate;
    } else if (!validContractsUsed.size && validContractsAcrossDates.size === 1) {
      const fallbackId = Array.from(validContractsAcrossDates)[0];
      const contract = state.contractMap[fallbackId];
      const rate = contract ? Number(contract.hourly_rate || 0) : 0;
      totalPackage = totalHours * rate;
    } else {
      totalPackage = entries.reduce((acc, entry) => {
        const minutes = Number(entry.duration_minutes) || 0;
        let rate = 0;
        const contract = state.contractMap[entry.contract_id];
        if (contract && contractIsValid(contract, entry.date)) {
          rate = Number(contract.hourly_rate || 0);
        } else {
          const valids = validContractsForDate(entry.date);
          if (valids.length === 1) rate = Number(valids[0].hourly_rate || 0);
        }
        return acc + (minutes / 60) * rate;
      }, 0);
    }
    const deductionTotals = computeMonthlyDeductionTotals(year, month);
    const salarySacrifice = deductionTotals.personalStandardTotal;
    const companyExpenses = deductionTotals.companyStandardTotal;
    const companyExpensesGst = deductionTotals.companyGstTotal;

    let grossIncome;
    let companyIncome = totalPackage;
    let invoiceTotal = 0;
    if (state.companyTrackingEnabled) {
      invoiceTotal = companyIncome * (1 + GST_RATE);
      grossIncome = Math.max(0, companyIncome - companyExpenses);
    } else {
      const denominator = 1 + superRate;
      grossIncome = denominator !== 0 ? totalPackage / denominator : totalPackage;
      companyIncome = 0;
      invoiceTotal = 0;
    }

    const extraSuperPercent = Math.max(0, deductionTotals.extraSuperPercentRate) * Math.max(0, grossIncome);
    const extraSuper = deductionTotals.extraSuperFlat + extraSuperPercent;
    const superBase = Math.max(0, grossIncome - salarySacrifice);
    const idealSuper = Math.max(0, grossIncome * superRate);
    const superGuarantee = Math.max(0, superBase * superRate);
    const superLostDueToDeductions = Math.max(0, idealSuper - superGuarantee);
    const taxableIncome = Math.max(0, grossIncome - extraSuper - salarySacrifice);
    const requestKey = `${monthKeyFor(year, month)}:${Math.round(taxableIncome * 100)}`;
    return {
      monthKey: monthKeyFor(year, month),
      periodStart,
      hasEntries: entries.length > 0,
      totalMinutes,
      totalHours,
      totalPackage,
      companyIncome,
      invoiceTotal,
      invoiceGst: invoiceTotal - companyIncome,
      companyExpenses,
      companyExpensesGst,
      grossIncome,
      superRate,
      superGuarantee,
      extraSuper,
      otherDeductions: salarySacrifice,
      totalSuper: superGuarantee + extraSuper,
      taxableIncome,
      superLostDueToDeductions,
      taxStatus: taxableIncome > 0 ? 'pending' : 'resolved',
      tax: taxableIncome > 0 ? null : 0,
      netIncome: taxableIncome > 0 ? null : taxableIncome,
      requestKey
    };
  }
  function applyIncomeBreakdownVisibility() {
    if (!incomeBreakdownEl) return;
    incomeBreakdownEl.hidden = !incomeBreakdownExpanded;
    if (incomeToggleBtn) {
      incomeToggleBtn.dataset.expanded = incomeBreakdownExpanded ? 'true' : 'false';
      incomeToggleBtn.setAttribute('aria-expanded', incomeBreakdownExpanded ? 'true' : 'false');
    }
  }
  function updateIncomeSummaryUI(summary) {
    if (!incomeNetBadge && !incomeBreakdownEl) return;
    if (!summary) {
      if (incomeNetBadge) incomeNetBadge.textContent = 'Net income: --';
      if (incomeNetDetailEl) incomeNetDetailEl.textContent = '--';
      if (incomeInvoiceTotalEl) incomeInvoiceTotalEl.textContent = '--';
      if (incomeCompanyIncomeEl) incomeCompanyIncomeEl.textContent = '--';
      if (incomeInvoiceTotalRow) incomeInvoiceTotalRow.style.display = 'none';
      if (incomeCompanyIncomeRow) incomeCompanyIncomeRow.style.display = 'none';
      if (incomeCompanyExpensesEl) incomeCompanyExpensesEl.textContent = '--';
      if (incomeCompanyExpensesRow) incomeCompanyExpensesRow.style.display = 'none';
      if (incomeGrossEl) incomeGrossEl.textContent = '--';
      if (incomeSuperGuaranteeEl) incomeSuperGuaranteeEl.textContent = '--';
      if (incomeSuperLostEl) incomeSuperLostEl.textContent = '--';
      if (incomeSuperLostRow) incomeSuperLostRow.style.display = 'none';
      if (incomeExtraSuperEl) incomeExtraSuperEl.textContent = '--';
      if (incomeOtherDeductionsEl) incomeOtherDeductionsEl.textContent = '--';
      if (incomeTaxableEl) incomeTaxableEl.textContent = '--';
      if (incomeTaxEl) incomeTaxEl.textContent = '--';
      if (incomeActualGrossValueEl) incomeActualGrossValueEl.textContent = '';
      if (incomeActualSuperValueEl) incomeActualSuperValueEl.textContent = '';
      if (incomeActualTaxValueEl) incomeActualTaxValueEl.textContent = '';
      if (incomeActualNetValueEl) incomeActualNetValueEl.textContent = '';
      return;
    }
    const netValue = summary.netIncome != null ? summary.netIncome : summary.taxableIncome;
    const netDisplay = (() => {
      if (summary.taxStatus === 'pending') return 'Calculating...';
      if (summary.taxStatus === 'error') return 'Tax unavailable';
      return formatCurrency(netValue);
    })();
    const taxText = (() => {
      if (summary.taxStatus === 'pending') return 'Calculating...';
      if (summary.taxStatus === 'error') return 'Tax unavailable';
      return formatCurrency(summary.tax || 0);
    })();

    // Check for actual income data - show actual if available, otherwise show estimate
    if (incomeNetBadge) {
      let displayValue = netDisplay;

      if (getFeatureFlag('enable_actual_income')) {
        const monthStr = `${state.calendar.year}-${String(state.calendar.month + 1).padStart(2, '0')}`;
        const actualData = state.actualIncomeMap[monthStr];

        // If we have actual data, show it immediately regardless of tax calculation status
        if (actualData) {
          displayValue = formatCurrency(actualData.net_income);
        }
      }

      incomeNetBadge.textContent = `Net income: ${displayValue}`;
    }
    if (incomeNetDetailEl) incomeNetDetailEl.textContent = netDisplay;
    if (incomeInvoiceTotalEl) incomeInvoiceTotalEl.textContent = formatCurrency(summary.invoiceTotal || 0);
    if (incomeCompanyIncomeEl) incomeCompanyIncomeEl.textContent = formatCurrency(summary.companyIncome || 0);
    if (incomeCompanyExpensesEl) incomeCompanyExpensesEl.textContent = formatCurrency(summary.companyExpenses || 0);
    if (incomeInvoiceTotalRow) incomeInvoiceTotalRow.hidden = !state.companyTrackingEnabled;
    if (incomeCompanyIncomeRow) incomeCompanyIncomeRow.hidden = !state.companyTrackingEnabled;
    if (incomeCompanyExpensesRow) incomeCompanyExpensesRow.hidden = !state.companyTrackingEnabled;
    if (incomeGrossEl) incomeGrossEl.textContent = formatCurrency(summary.grossIncome);
    if (incomeSuperGuaranteeEl) incomeSuperGuaranteeEl.textContent = formatCurrency(summary.superGuarantee);
    if (incomeSuperLostEl) incomeSuperLostEl.textContent = formatCurrency(summary.superLostDueToDeductions || 0);
    if (incomeSuperLostRow) {
      const shouldShowSuperLost = summary.superLostDueToDeductions && summary.superLostDueToDeductions > 0.009;
      incomeSuperLostRow.hidden = !shouldShowSuperLost;
    }
    if (incomeExtraSuperEl) incomeExtraSuperEl.textContent = formatCurrency(summary.extraSuper);
    if (incomeSuperTotalEl) {
      const estimatedSuperTotal = (summary.superGuarantee || 0) + (summary.extraSuper || 0);
      incomeSuperTotalEl.textContent = formatCurrency(estimatedSuperTotal);
    }
    if (incomeOtherDeductionsEl) incomeOtherDeductionsEl.textContent = formatCurrency(summary.otherDeductions);
    if (incomeTaxableEl) incomeTaxableEl.textContent = formatCurrency(summary.taxableIncome);
    if (incomeTaxEl) incomeTaxEl.textContent = taxText;

    // Handle actual income inline comparisons
    if (getFeatureFlag('enable_actual_income')) {
      const monthStr = `${state.calendar.year}-${String(state.calendar.month + 1).padStart(2, '0')}`;
      const actualData = state.actualIncomeMap[monthStr];

      if (actualData) {
        // Helper function to calculate and format variance display
        const formatActualWithVariance = (actual, estimated) => {
          const variance = actual - estimated;
          const absVariance = Math.abs(variance);
          if (absVariance < 0.01) {
            return `Act: ${formatCurrency(actual)}`;
          }
          const arrow = variance > 0 ? '↑' : '↓';
          const color = variance > 0 ? 'var(--success)' : 'var(--danger)';
          return `Act: ${formatCurrency(actual)} <span style="color:${color}">${arrow} ${formatCurrency(absVariance)}</span>`;
        };

        // Calculate estimated superannuation (super guarantee + extra super)
        const estimatedSuper = (summary.superGuarantee || 0) + (summary.extraSuper || 0);

        // For net income, if tax is still calculating, compare against taxable income instead
        const effectiveNetEstimate = (summary.taxStatus === 'pending' || summary.taxStatus === 'error')
          ? summary.taxableIncome
          : netValue;

        // Populate actual gross income
        if (incomeActualGrossValueEl) {
          incomeActualGrossValueEl.innerHTML = formatActualWithVariance(actualData.gross_income, summary.grossIncome);
        }

        // Populate actual superannuation
        if (incomeActualSuperValueEl) {
          incomeActualSuperValueEl.innerHTML = formatActualWithVariance(actualData.superannuation, estimatedSuper);
        }

        // Populate actual tax (only if we have a valid estimated tax)
        if (incomeActualTaxValueEl) {
          if (summary.taxStatus === 'pending') {
            incomeActualTaxValueEl.innerHTML = `Act: ${formatCurrency(actualData.tax)} <span style="color:var(--muted)">(Est pending)</span>`;
          } else if (summary.taxStatus === 'error') {
            incomeActualTaxValueEl.innerHTML = `Act: ${formatCurrency(actualData.tax)} <span style="color:var(--muted)">(Est unavailable)</span>`;
          } else {
            incomeActualTaxValueEl.innerHTML = formatActualWithVariance(actualData.tax, summary.tax || 0);
          }
        }

        // Populate actual net income
        if (incomeActualNetValueEl) {
          if (summary.taxStatus === 'pending') {
            incomeActualNetValueEl.innerHTML = `Act: ${formatCurrency(actualData.net_income)} <span style="color:var(--muted)">(Est pending)</span>`;
          } else if (summary.taxStatus === 'error') {
            incomeActualNetValueEl.innerHTML = `Act: ${formatCurrency(actualData.net_income)} <span style="color:var(--muted)">(Est unavailable)</span>`;
          } else {
            incomeActualNetValueEl.innerHTML = formatActualWithVariance(actualData.net_income, effectiveNetEstimate);
          }
        }
      } else {
        // Clear actual values if no data
        if (incomeActualGrossValueEl) incomeActualGrossValueEl.textContent = '';
        if (incomeActualSuperValueEl) incomeActualSuperValueEl.textContent = '';
        if (incomeActualTaxValueEl) incomeActualTaxValueEl.textContent = '';
        if (incomeActualNetValueEl) incomeActualNetValueEl.textContent = '';
      }
    } else {
      // Clear actual values if feature flag is disabled
      if (incomeActualGrossValueEl) incomeActualGrossValueEl.textContent = '';
      if (incomeActualSuperValueEl) incomeActualSuperValueEl.textContent = '';
      if (incomeActualTaxValueEl) incomeActualTaxValueEl.textContent = '';
      if (incomeActualNetValueEl) incomeActualNetValueEl.textContent = '';
    }
  }
  function handleTaxSuccess(requestId, taxValue) {
    if (!state.pendingTaxRequest || state.pendingTaxRequest.id !== requestId) return;
    const summary = state.incomeSummary;
    if (!summary || summary.monthKey !== state.pendingTaxRequest.monthKey) {
      state.pendingTaxRequest = null;
      return;
    }
    const computedTax = Math.max(0, Number(taxValue) || 0);
    summary.tax = computedTax;
    summary.taxStatus = 'resolved';
    summary.netIncome = summary.taxableIncome - computedTax;
    state.pendingTaxRequest = null;
    updateIncomeSummaryUI(summary);
  }
  function handleTaxFailure(requestId) {
    if (!state.pendingTaxRequest || state.pendingTaxRequest.id !== requestId) return;
    const summary = state.incomeSummary;
    if (!summary || summary.monthKey !== state.pendingTaxRequest.monthKey) {
      state.pendingTaxRequest = null;
      return;
    }
    summary.tax = 0;
    summary.taxStatus = 'error';
    summary.netIncome = summary.taxableIncome;
    state.pendingTaxRequest = null;
    updateIncomeSummaryUI(summary);
  }
  function requestTaxEstimate(summary) {
    if (!summary || summary.taxStatus !== 'pending') return;
    if (!summary.taxableIncome || summary.taxableIncome <= 0) {
      summary.taxStatus = 'resolved';
      summary.tax = 0;
      summary.netIncome = summary.taxableIncome;
      updateIncomeSummaryUI(summary);
      return;
    }
    if (state.pendingTaxRequest && state.pendingTaxRequest.key === summary.requestKey) return;
    if (typeof google === 'undefined' || !google.script || !google.script.run) {
      summary.taxStatus = 'error';
      summary.tax = 0;
      summary.netIncome = summary.taxableIncome;
      updateIncomeSummaryUI(summary);
      state.pendingTaxRequest = null;
      return;
    }
    const requestId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
    state.pendingTaxRequest = {
      id: requestId,
      key: summary.requestKey,
      monthKey: summary.monthKey
    };
    google.script.run
      .withSuccessHandler((value) => handleTaxSuccess(requestId, value))
      .withFailureHandler(() => handleTaxFailure(requestId))
      .estimateTax(Number(summary.taxableIncome) || 0, summary.periodStart.toISOString());
  }
  function renderIncomeSummary() {
    if (!incomeNetBadge && !incomeBreakdownEl) return;
    ensureCalendarState();
    const { year, month } = state.calendar;
    const summary = buildIncomeSummary(year, month);
    state.incomeSummary = summary;
    updateIncomeSummaryUI(summary);
    applyIncomeBreakdownVisibility();
    if (summary.taxStatus === 'pending') {
      requestTaxEstimate(summary);
    } else {
      state.pendingTaxRequest = null;
    }
    renderBasReporting();
  }

  function buildExpectedHoursSummary(year, month) {
    if (!getFeatureFlag('expected_monthly_hours')) return null;
    const monthEntries = entriesForMonth(year, month);
    const filteredEntries = monthEntries.filter((entry) => {
      if (!entry || !entry.contract_id || !entry.date) return false;
      if (!entryContributesToIncome(entry)) return false;
      const contract = state.contractMap[entry.contract_id];
      if (!contract) return false;
      if (!contractIsValid(contract, entry.date)) return false;
      return true;
    });
    if (!filteredEntries.length) return null;

    const contractBuckets = new Map();
    filteredEntries.forEach((entry) => {
      const contract = state.contractMap[entry.contract_id];
      if (!contract) return;
      if (!contractBuckets.has(contract.id)) {
        contractBuckets.set(contract.id, { contract, entries: [] });
      }
      contractBuckets.get(contract.id).entries.push(entry);
    });
    if (!contractBuckets.size) return null;

    const monthStartDate = startOfDay(new Date(year, month, 1));
    const monthEndDate = startOfDay(new Date(year, month + 1, 0));

    const aggregatedEvaluatedDays = new Set();
    const aggregatedMonthDays = new Set();
    let aggregatedHoursToDate = 0;
    let aggregatedExpectedMonthlyHours = 0;
    let aggregatedExpectedHoursToDate = 0;
    let aggregatedProjectedHours = 0;
    let baselineContracts = 0;

    const contractSummaries = [];

    contractBuckets.forEach(({ contract, entries }) => {
      const sortedEntries = [...entries].sort((a, b) => a.date.localeCompare(b.date));
      const contractStartRaw = contract.start_date ? parseIsoDate(contract.start_date) : null;
      if (!contractStartRaw || Number.isNaN(contractStartRaw.getTime())) return;
      const contractStart = startOfDay(contractStartRaw);
      const contractEndRaw = contract.end_date ? parseIsoDate(contract.end_date) : null;
      const includeWeekends = !!contract.include_weekends;

      const periodStart = contractStart > monthStartDate ? contractStart : monthStartDate;
      const boundedContractEnd = (contractEndRaw && !Number.isNaN(contractEndRaw.getTime())) ? startOfDay(contractEndRaw) : null;
      const periodEnd = boundedContractEnd && boundedContractEnd < monthEndDate ? boundedContractEnd : monthEndDate;
      if (periodEnd < periodStart) return;

      const periodStartIso = isoDate(periodStart);
      const periodEndIso = isoDate(periodEnd);

      const monthBusinessDaysList = collectBusinessDays(periodStart, periodEnd, includeWeekends);
      monthBusinessDaysList.forEach((day) => aggregatedMonthDays.add(day));
      const monthBusinessDays = monthBusinessDaysList.length;

      const recordedBusinessDaysSet = new Set();
      const totalMinutes = sortedEntries.reduce((acc, entry) => {
        if (!entry || !entry.date) return acc;
        if (entry.date < periodStartIso || entry.date > periodEndIso) return acc;
        const entryDateObj = parseIsoDate(entry.date);
        if (!entryDateObj || Number.isNaN(entryDateObj.getTime())) return acc;
        const minutes = Number(entry.duration_minutes) || 0;
        if (!includeWeekends && isWeekendDate(entryDateObj)) {
          return acc + minutes;
        }
        recordedBusinessDaysSet.add(isoDate(startOfDay(entryDateObj)));
        return acc + minutes;
      }, 0);

      const totalHours = totalMinutes / 60;
      const recordedBusinessDays = recordedBusinessDaysSet.size;
      if (recordedBusinessDays === 0) return;

      recordedBusinessDaysSet.forEach((day) => aggregatedEvaluatedDays.add(day));
      aggregatedHoursToDate += totalHours;

      const averageDailyHours = totalHours / recordedBusinessDays;

      const hasBaseline = Number(contract.total_hours || 0) > 0 && contract.end_date;
      let expectedDailyHours = null;
      let expectedMonthlyHours = null;
      let expectedHoursToDate = null;
      let expectedHoursRemaining = null;
      let projectedTotalHours = monthBusinessDays > 0 ? averageDailyHours * monthBusinessDays : totalHours;
      let projectedVariance = null;
      let varianceToDate = null;

      if (hasBaseline && monthBusinessDays > 0) {
        const contractBusinessDaysList = collectBusinessDays(contractStart, boundedContractEnd || periodEnd, includeWeekends);
        const contractBusinessDays = contractBusinessDaysList.length;
        if (contractBusinessDays > 0) {
          expectedDailyHours = Number(contract.total_hours || 0) / contractBusinessDays;
          expectedMonthlyHours = expectedDailyHours * monthBusinessDays;
          expectedHoursToDate = expectedDailyHours * Math.min(recordedBusinessDays, monthBusinessDays);
          expectedHoursRemaining = Math.max(0, expectedMonthlyHours - (expectedHoursToDate || 0));
          varianceToDate = totalHours - (expectedHoursToDate || 0);
        }
      }

      if (expectedMonthlyHours != null) {
        projectedVariance = projectedTotalHours - expectedMonthlyHours;
      }

      const businessDaysRemaining = Math.max(0, monthBusinessDays - Math.min(recordedBusinessDays, monthBusinessDays));

      let status = 'ontrack';
      let statusText = 'Projected on target';
      if (projectedVariance != null) {
        const roundedVariance = Math.round(projectedVariance * 100) / 100;
        const varianceMagnitude = Math.abs(roundedVariance);
        if (roundedVariance > 0.01) {
          status = 'behind';
          statusText = `Projected over by ${formatDecimalHours(varianceMagnitude)} hrs`;
        } else if (roundedVariance < -0.01) {
          status = 'ahead';
          statusText = `Projected under by ${formatDecimalHours(varianceMagnitude)} hrs`;
        }
      }
      if (expectedMonthlyHours == null) {
        status = 'ontrack';
        statusText = 'No expected hours configured';
      }

      const summary = {
        contractId: contract.id,
        contractName: contract.name || 'Untitled contract',
        includeWeekends,
        monthBusinessDays,
        recordedBusinessDays,
        businessDaysRemaining,
        totalHours,
        hoursToDate: totalHours,
        averageDailyHours,
        calculationDays: recordedBusinessDays,
        calculationLabel: 'Recorded work days',
        expectedDailyHours,
        expectedMonthlyHours,
        expectedHoursToDate,
        expectedHoursRemaining,
        varianceToDate,
        projectedTotalHours,
        projectedVariance,
        status,
        statusText
      };

      contractSummaries.push(summary);

      if (hasBaseline && expectedMonthlyHours != null) {
        baselineContracts += 1;
        aggregatedExpectedMonthlyHours += expectedMonthlyHours;
        aggregatedExpectedHoursToDate += expectedHoursToDate || 0;
        aggregatedProjectedHours += projectedTotalHours || 0;
      }
    });

    if (!contractSummaries.length) return null;

    const uniqueRecordedDays = aggregatedEvaluatedDays.size;
    if (uniqueRecordedDays <= 2) return null;

    const totalBusinessDays = aggregatedMonthDays.size || contractSummaries.reduce((max, summary) => Math.max(max, summary.monthBusinessDays), 0);
    const averageHours = aggregatedHoursToDate / uniqueRecordedDays;
    const overallProjectedVariance = baselineContracts > 0 ? (aggregatedProjectedHours - aggregatedExpectedMonthlyHours) : null;

    contractSummaries.sort((a, b) => a.contractName.localeCompare(b.contractName));

    return {
      monthKey: monthKeyFor(year, month),
      contracts: contractSummaries,
      contractCount: contractSummaries.length,
      averageHours,
      totalHoursToDate: aggregatedHoursToDate,
      daysEvaluated: uniqueRecordedDays,
      totalBusinessDays,
      totalExpectedMonthlyHours: aggregatedExpectedMonthlyHours,
      totalExpectedHoursToDate: aggregatedExpectedHoursToDate,
      totalProjectedHours: aggregatedProjectedHours,
      baselineContractCount: baselineContracts,
      overallProjectedVariance
    };

  }

  function renderExpectedHoursBreakdown(summary) {
    if (!expectedHoursContentEl) return;
    expectedHoursContentEl.innerHTML = '';
    if (!summary || !summary.contracts || !summary.contracts.length) return;

    const makeLine = (label, value) => {
      const row = document.createElement('div');
      row.className = 'ts-expected-line';
      const labelEl = document.createElement('span');
      labelEl.textContent = label;
      const valueEl = document.createElement('span');
      valueEl.textContent = value;
      row.append(labelEl, valueEl);
      return row;
    };

    const buildVarianceStatus = (variance, prefix) => {
      if (variance === null || variance === undefined) return null;
      const rounded = Math.round(variance * 100) / 100;
      const magnitude = Math.abs(rounded);
      const statusEl = document.createElement('div');
      if (rounded > 0.01) {
        statusEl.className = 'ts-expected-status behind';
        statusEl.textContent = prefix
          ? `${prefix} projected over by ${formatDecimalHours(magnitude)} hrs`
          : `Projected over by ${formatDecimalHours(magnitude)} hrs`;
      } else if (rounded < -0.01) {
        statusEl.className = 'ts-expected-status ahead';
        statusEl.textContent = prefix
          ? `${prefix} projected under by ${formatDecimalHours(magnitude)} hrs`
          : `Projected under by ${formatDecimalHours(magnitude)} hrs`;
      } else {
        statusEl.className = 'ts-expected-status ontrack';
        statusEl.textContent = prefix
          ? `${prefix} projected on target`
          : 'Projected on target';
      }
      return statusEl;
    };

    const aggregate = document.createElement('div');
    aggregate.className = 'ts-expected-aggregate';
    aggregate.appendChild(makeLine('Average daily hours to date', `${formatDecimalHours(summary.averageHours)} hrs`));
    const daysLabel = summary.totalBusinessDays > 0
      ? `${summary.daysEvaluated} of ${summary.totalBusinessDays}`
      : String(summary.daysEvaluated);
    aggregate.appendChild(makeLine('Business days evaluated', daysLabel));
    aggregate.appendChild(makeLine('Total hours logged this month', `${formatDecimalHours(summary.totalHoursToDate)} hrs`));

    const hasExpectedTotals = summary.baselineContractCount > 0 && summary.totalExpectedMonthlyHours > 0;
    let overallStatus = null;
    if (summary.contractCount > 1 && hasExpectedTotals) {
      aggregate.appendChild(makeLine('Total expected hours this month', `${formatDecimalHours(summary.totalExpectedMonthlyHours)} hrs`));
      if (summary.totalExpectedHoursToDate > 0) {
        aggregate.appendChild(makeLine('Expected hours to date', `${formatDecimalHours(summary.totalExpectedHoursToDate)} hrs`));
      }
      if (summary.overallProjectedVariance !== null) {
        aggregate.appendChild(makeLine('Projected month variance', `${formatSignedHours(summary.overallProjectedVariance)} hrs`));
        overallStatus = buildVarianceStatus(summary.overallProjectedVariance, 'Overall');
      }
    }

    if (summary.contractCount === 1) {
      const contract = summary.contracts[0];
      const hasExpected = contract.expectedMonthlyHours != null;
      const expectedMonthlyValue = hasExpected
        ? `${formatDecimalHours(contract.expectedMonthlyHours)} hrs`
        : 'Not available for unlimited contracts';
      aggregate.appendChild(makeLine('Total expected hours this month', expectedMonthlyValue));

      const expectedToDateValue = hasExpected
        ? `${formatDecimalHours(contract.expectedHoursToDate || 0)} hrs`
        : 'Not available for unlimited contracts';
      aggregate.appendChild(makeLine('Expected hours to date', expectedToDateValue));

      const projectedVarianceValue = contract.projectedVariance != null
        ? `${formatSignedHours(contract.projectedVariance)} hrs`
        : 'Not available';
      aggregate.appendChild(makeLine('Projected month variance', projectedVarianceValue));

      const varianceStatus = buildVarianceStatus(contract.projectedVariance);
      if (varianceStatus) {
        aggregate.appendChild(varianceStatus);
      } else {
        const varianceUnavailable = document.createElement('div');
        varianceUnavailable.className = 'ts-expected-status ontrack';
        varianceUnavailable.textContent = hasExpected
          ? 'Projected variance not available'
          : 'Projected variance not available for unlimited contracts';
        aggregate.appendChild(varianceUnavailable);
      }
    } else if (overallStatus) {
      aggregate.appendChild(overallStatus);
    }

    expectedHoursContentEl.appendChild(aggregate);

    if (summary.contractCount > 1) {
      summary.contracts.forEach((contract) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'ts-expected-contract';

        const header = document.createElement('div');
        header.className = 'ts-expected-contract-header';
        const nameEl = document.createElement('span');
        nameEl.textContent = contract.contractName;
        const hoursEl = document.createElement('span');
        hoursEl.textContent = `${formatDecimalHours(contract.hoursToDate)} hrs logged`;
        header.append(nameEl, hoursEl);
        wrapper.appendChild(header);

        const meta = document.createElement('div');
        meta.className = 'ts-expected-meta';
        meta.textContent = contract.includeWeekends
          ? 'Including weekends in averages'
          : 'Weekdays only (Mon-Fri)';
        wrapper.appendChild(meta);

        const lines = document.createElement('div');
        lines.className = 'ts-expected-lines';
        lines.appendChild(makeLine('Average daily hours', `${formatDecimalHours(contract.averageDailyHours)} hrs`));
        lines.appendChild(makeLine('Days in calculation', `${contract.calculationDays} (${contract.calculationLabel})`));
        if (contract.expectedMonthlyHours != null) {
          const expectedToDate = contract.expectedHoursToDate != null ? formatDecimalHours(contract.expectedHoursToDate) : '0';
          lines.appendChild(makeLine('Hours logged vs expected to date', `${formatDecimalHours(contract.hoursToDate)} / ${expectedToDate} hrs`));
          lines.appendChild(makeLine('Expected hours remaining', `${formatDecimalHours(contract.expectedHoursRemaining || 0)} hrs`));
        } else {
          lines.appendChild(makeLine('Expected hours remaining', 'Not available for unlimited contracts'));
        }
        lines.appendChild(makeLine('Projected month total', `${formatDecimalHours(contract.projectedTotalHours)} hrs`));
        if (contract.projectedVariance != null) {
          lines.appendChild(makeLine('Projected variance', `${formatSignedHours(contract.projectedVariance)} hrs`));
        }
        lines.appendChild(makeLine('Business days remaining', String(contract.businessDaysRemaining)));
        wrapper.appendChild(lines);

        const statusEl = document.createElement('div');
        statusEl.className = `ts-expected-status ${contract.status}`;
        statusEl.textContent = contract.statusText;
        wrapper.appendChild(statusEl);

        expectedHoursContentEl.appendChild(wrapper);
      });
    }
  }

  function resetExpectedHoursBadge(text) {
    if (!expectedHoursBadge) return;
    expectedHoursBadge.className = 'ts-badge ts-expected-badge';
    expectedHoursBadge.textContent = text || 'Projected variance: --';
  }

  function applyExpectedHoursBadge(summary) {
    if (!expectedHoursBadge) return;
    resetExpectedHoursBadge();
    if (!summary) return;

    let varianceValue = summary.overallProjectedVariance;
    if ((varianceValue === null || varianceValue === undefined) && summary.contractCount === 1 && summary.contracts[0]) {
      varianceValue = summary.contracts[0].projectedVariance;
    }

    const suffix = summary.contractCount > 1 ? ` (${summary.contractCount})` : '';
    if (varianceValue === null || varianceValue === undefined) {
      expectedHoursBadge.textContent = `Projected variance: --${suffix}`;
      return;
    }

    const rounded = Math.round(varianceValue * 100) / 100;
    expectedHoursBadge.textContent = `Projected variance: ${formatSignedHours(varianceValue)} hrs${suffix}`;
    if (rounded > 0.01) {
      expectedHoursBadge.classList.add('error');
    } else if (rounded < -0.01) {
      expectedHoursBadge.classList.add('success');
    }
  }

  function renderExpectedHoursSummary() {
    if (!expectedHoursBadge || !expectedHoursBreakdownEl) return;
    if (!getFeatureFlag('expected_monthly_hours')) {
      expectedHoursBadge.style.display = 'none';
      resetExpectedHoursBadge();
      state.expectedHoursSummary = null;
      expectedHoursExpanded = false;
      applyExpectedHoursVisibility();
      if (expectedHoursContentEl) expectedHoursContentEl.innerHTML = '';
      return;
    }

    ensureCalendarState();
    const { year, month } = state.calendar;
    const summary = buildExpectedHoursSummary(year, month);
    state.expectedHoursSummary = summary;

    if (!summary) {
      expectedHoursBadge.style.display = 'none';
      resetExpectedHoursBadge();
      expectedHoursExpanded = false;
      applyExpectedHoursVisibility();
      if (expectedHoursContentEl) expectedHoursContentEl.innerHTML = '';
      return;
    }

    expectedHoursBadge.style.display = 'inline-flex';
    applyExpectedHoursBadge(summary);

    applyExpectedHoursVisibility();
    if (expectedHoursExpanded) {
      renderExpectedHoursBreakdown(summary);
    } else if (expectedHoursContentEl) {
      expectedHoursContentEl.innerHTML = '';
    }
  }
  function renderEntries() {
    renderCalendar();
    renderContractsUI();
  }
  function deleteEntry(id) {
    const idx = state.entries.findIndex((e) => e.id === id);
    if (idx === -1) return;
    const backup = state.entries[idx];
    state.entries.splice(idx, 1);
    saveCache();
    renderEntries();
    setStatus('Deleting...', 'warn');
    google.script.run
      .withSuccessHandler(() => setStatus('Deleted', 'success'))
      .withFailureHandler(() => {
        state.entries.splice(idx, 0, backup);
        saveCache();
        renderEntries();
        setStatus('Delete failed', 'error');
      })
      .api_deleteEntry(id);
  }
  function editEntry(id) {
    const entry = state.entries.find((e) => e.id === id);
    if (!entry) return;
    state.selectedCalendarDate = entry.date;
    populateManualForm(entry, true);
    renderCalendar();
  }

  // Calendar rendering
  function ensureCalendarState() {
    if (!state.calendar) {
      const today = new Date();
      state.calendar = { year: today.getFullYear(), month: today.getMonth() };
    }
    if (!state.selectedCalendarDate) {
      state.selectedCalendarDate = todayIso();
      if (!state.editingEntryId) setManualDate(state.selectedCalendarDate);
    }
  }
  function calendarStartDate(year, month) {
    const first = new Date(year, month, 1);
    const offset = (first.getDay() + 6) % 7; // shift so Monday=0
    return new Date(year, month, 1 - offset);
  }
  function minutesByDate() {
    return state.entries.reduce((map, entry) => {
      if (!entry.date) return map;
      const key = entry.date;
      map[key] = (map[key] || 0) + (Number(entry.duration_minutes) || 0);
      return map;
    }, {});
  }

  function minutesByDateAndHourType() {
    return state.entries.reduce((map, entry) => {
      if (!entry.date) return map;
      const date = entry.date;
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();

      if (!map[date]) map[date] = {};
      if (!map[date][hourTypeId]) map[date][hourTypeId] = 0;

      map[date][hourTypeId] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});
  }

  function getDefaultHourType() {
    if (!state.hourTypes.length) return null;
    return state.hourTypes.find(ht => ht.is_default) || state.hourTypes[0];
  }

  function getFeatureFlag(flagKey) {
    const flag = state.featureFlags[flagKey] || DEFAULT_FEATURE_FLAGS[flagKey];
    return flag ? flag.enabled : false;
  }
  function renderCalendar() {
    ensureCalendarState();

    // Get filtered hour type IDs
    const activeHourTypeIds = state.calendarFilteredHourTypes || state.hourTypes.map(ht => ht.id);

    // Filter entries by active hour types
    const filteredEntries = state.entries.filter(entry => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      return activeHourTypeIds.includes(hourTypeId);
    });

    // Calculate totals based on filtered entries
    const totals = filteredEntries.reduce((map, entry) => {
      if (!entry.date) return map;
      if (!map[entry.date]) map[entry.date] = 0;
      map[entry.date] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});

    const hourTypeTotals = filteredEntries.reduce((map, entry) => {
      if (!entry.date) return map;
      const date = entry.date;
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      if (!map[date]) map[date] = {};
      if (!map[date][hourTypeId]) map[date][hourTypeId] = 0;
      map[date][hourTypeId] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});

    const defaultHourType = getDefaultHourType();
    const defaultHourTypeId = defaultHourType?.id || getDefaultHourTypeId();
    const grid = document.getElementById('calendar-grid');
    const label = document.getElementById('calendar-label');
    const monthTotalEl = document.getElementById('calendar-month-total');
    const activeMonth = new Date(state.calendar.year, state.calendar.month, 1);
    label.textContent = activeMonth.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
    const monthKey = `${activeMonth.getFullYear()}-${String(activeMonth.getMonth() + 1).padStart(2, '0')}`;
    const monthTotalMinutes = Object.keys(totals).reduce((acc, key) => {
      if (key.startsWith(monthKey)) {
        acc += totals[key];
      }
      return acc;
    }, 0);

    // If hour types are enabled, also calculate income-contributing hours
    let monthIncomeMinutes = 0;
    if (getFeatureFlag('hour_types') && state.hourTypes.length > 0) {
      const monthEntries = filteredEntries.filter(entry =>
        entry.date && entry.date.startsWith(monthKey)
      );
      monthIncomeMinutes = monthEntries.reduce((acc, entry) => {
        const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
        const hourType = state.hourTypeMap[hourTypeId];
        const contributesToIncome = hourType ? hourType.contributes_to_income : true;
        if (contributesToIncome) {
          acc += Number(entry.duration_minutes) || 0;
        }
        return acc;
      }, 0);
    }

    const roundedMonthTotal = roundDuration(monthTotalMinutes);
    if (getFeatureFlag('hour_types') && state.hourTypes.length > 0 && monthIncomeMinutes !== monthTotalMinutes) {
      const roundedIncomeTotal = roundDuration(monthIncomeMinutes);
      monthTotalEl.textContent = `Total hours: ${formatHours(roundedMonthTotal)} (${formatHours(roundedIncomeTotal)} billable)`;
    } else {
      monthTotalEl.textContent = `Total hours: ${formatHours(roundedMonthTotal)}`;
    }

    // Render hour types breakdown
    renderHourTypesBreakdown(filteredEntries, monthKey);

    grid.innerHTML = '';
    const start = calendarStartDate(state.calendar.year, state.calendar.month);
    for (let i = 0; i < 42; i++) {
      const current = new Date(start.getFullYear(), start.getMonth(), start.getDate() + i);
      const iso = isoDate(current);
      const cell = document.createElement('div');
      cell.className = 'ts-calendar-cell';
      if (current.getMonth() !== state.calendar.month) cell.classList.add('inactive');
      if (iso === todayIso()) cell.classList.add('today');
      const totalMinutes = totals[iso] || 0;
      if (totalMinutes > 0) cell.classList.add('has-entries');
      if (iso === state.selectedCalendarDate) cell.classList.add('selected');
      const dayEl = document.createElement('div');
      dayEl.className = 'ts-calendar-day';

      // Check for public holiday
      const holiday = state.publicHolidayMap[iso];
      if (holiday && getFeatureFlag('enable_public_holidays')) {
        const holidayName = holiday.localName || holiday.name || '';
        const truncatedName = holidayName.length > 12 ? holidayName.substring(0, 12) + '…' : holidayName;
        dayEl.innerHTML = `${current.getDate()} <span class="ts-calendar-holiday-label">${truncatedName}</span>`;
        cell.classList.add('ts-calendar-holiday');
      } else {
        dayEl.textContent = current.getDate();
      }

      // Check if hour types feature is enabled and we have multiple hour types
      const showHourTypes = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
      const dayHourTypes = hourTypeTotals[iso] || {};

      if (showHourTypes && Object.keys(dayHourTypes).length > 0) {
        const defaultMinutes = dayHourTypes[defaultHourTypeId] || 0;
        const hasDefault = defaultMinutes > 0;
        const hasMultiple = Object.keys(dayHourTypes).length > 1 || (Object.keys(dayHourTypes).length === 1 && !hasDefault);

        // When there are multiple hour types with default present: show non-default on top, default on bottom
        // When only non-default hours exist: show them on bottom
        if (hasMultiple && hasDefault) {
          // Show other hour types as small colored indicators at top
          const otherTypesEl = document.createElement('div');
          otherTypesEl.className = 'ts-calendar-hour-types';
          Object.keys(dayHourTypes).forEach(hourTypeId => {
            if (hourTypeId !== defaultHourTypeId && dayHourTypes[hourTypeId] > 0) {
              const hourType = state.hourTypeMap[hourTypeId];
              if (hourType) {
                const minutes = dayHourTypes[hourTypeId];
                const roundedMinutes = roundDuration(minutes);
                const indicator = document.createElement('span');
                indicator.className = 'ts-calendar-hour-type-indicator';
                indicator.style.color = hourType.color;
                indicator.textContent = formatHours(roundedMinutes);
                indicator.title = `${hourType.name}: ${formatHours(roundedMinutes)}`;
                otherTypesEl.appendChild(indicator);
              }
            }
          });

          // Show default hour type as main total at bottom
          const totalEl = document.createElement('div');
          totalEl.className = 'ts-calendar-total';
          const roundedMinutes = roundDuration(defaultMinutes);
          totalEl.textContent = formatHours(roundedMinutes);

          cell.append(dayEl, otherTypesEl, totalEl);
        } else if (!hasDefault) {
          // Only non-default hours exist - show them at bottom
          const otherTypesEl = document.createElement('div');
          otherTypesEl.className = 'ts-calendar-hour-types';
          Object.keys(dayHourTypes).forEach(hourTypeId => {
            if (dayHourTypes[hourTypeId] > 0) {
              const hourType = state.hourTypeMap[hourTypeId];
              if (hourType) {
                const minutes = dayHourTypes[hourTypeId];
                const roundedMinutes = roundDuration(minutes);
                const indicator = document.createElement('span');
                indicator.className = 'ts-calendar-hour-type-indicator';
                indicator.style.color = hourType.color;
                indicator.textContent = formatHours(roundedMinutes);
                indicator.title = `${hourType.name}: ${formatHours(roundedMinutes)}`;
                otherTypesEl.appendChild(indicator);
              }
            }
          });

          cell.append(dayEl, otherTypesEl);
        } else {
          // Only default hour type exists
          const totalEl = document.createElement('div');
          totalEl.className = 'ts-calendar-total';
          if (defaultMinutes === 0) totalEl.classList.add('empty');
          if (defaultMinutes === 0) {
            totalEl.textContent = state.showZeroHours ? '0' : '';
          } else {
            const roundedMinutes = roundDuration(defaultMinutes);
            totalEl.textContent = formatHours(roundedMinutes);
          }

          cell.append(dayEl, totalEl);
        }
      } else {
        // Original behavior - show total hours
        const totalEl = document.createElement('div');
        totalEl.className = 'ts-calendar-total';
        if (totalMinutes === 0) totalEl.classList.add('empty');
        if (totalMinutes === 0) {
          totalEl.textContent = state.showZeroHours ? '0' : '';
        } else {
          const roundedMinutes = roundDuration(totalMinutes);
          totalEl.textContent = formatHours(roundedMinutes);
        }
        cell.append(dayEl, totalEl);
      }

      cell.onclick = () => handleCalendarClick(iso);
    grid.appendChild(cell);
  }
  renderIncomeSummary();
  renderExpectedHoursSummary();
  updatePayrollHelperButtons();
}

  function renderHourTypesBreakdown(entries, monthKey) {
    if (!hourTypesBreakdownListEl) return;

    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;
    if (!hourTypesEnabled) {
      hourTypesBreakdownListEl.innerHTML = '';
      return;
    }

    // Calculate totals for each hour type in the month
    const monthEntries = entries.filter(entry => entry.date && entry.date.startsWith(monthKey));
    const hourTypeTotals = monthEntries.reduce((map, entry) => {
      const hourTypeId = entry.hour_type_id || getDefaultHourTypeId();
      if (!map[hourTypeId]) map[hourTypeId] = 0;
      map[hourTypeId] += Number(entry.duration_minutes) || 0;
      return map;
    }, {});

    // Sort hour types by total (descending)
    const sortedHourTypes = Object.keys(hourTypeTotals)
      .map(id => ({
        id,
        hourType: state.hourTypeMap[id],
        minutes: hourTypeTotals[id]
      }))
      .filter(item => item.hourType && item.minutes > 0)
      .sort((a, b) => b.minutes - a.minutes);

    if (sortedHourTypes.length === 0) {
      hourTypesBreakdownListEl.innerHTML = '<div class="ts-note">No hours tracked this month</div>';
      return;
    }

    const html = sortedHourTypes.map(item => {
      const roundedMinutes = roundDuration(item.minutes);
      return `
        <div class="ts-hour-type-breakdown-row">
          <div class="ts-hour-type-breakdown-color" style="background-color: ${item.hourType.color}"></div>
          <div class="ts-hour-type-breakdown-name">${item.hourType.name}</div>
          <div class="ts-hour-type-breakdown-value">${formatHours(roundedMinutes)}</div>
        </div>
      `;
    }).join('');

    hourTypesBreakdownListEl.innerHTML = html;
  }

  function handleCalendarClick(dateIso) {
    state.selectedCalendarDate = dateIso;
    setManualDate(dateIso);
    updateTabStates();
    renderCalendar();

    // Check if there's an existing entry for this date
    const existingEntries = state.entries.filter(entry => entry.date === dateIso);
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;

    if (existingEntries.length > 0) {
      const existingEntry = existingEntries[0];

      const entryType = resolveEntryType(existingEntry);

      // Prepopulate the form with the existing entry
      if (entryType === 'basic') {
        populateManualForm(existingEntry, true);
      } else {
        // For advanced entries, switch to advanced tab and populate
        state.currentTab = 'punch';
        state.editingEntryType = entryType;
        activateTab('punch');
        if (punchDate) punchDate.value = existingEntry.date;
        ensurePunchDraft(existingEntry.contract_id);
        if (state.punchDraft) {
          state.punchDraft.entryId = existingEntry.id;
          state.punchDraft.contractId = existingEntry.contract_id;
          state.punchDraft.date = existingEntry.date;
          state.punchDraft.punches = clonePunches(existingEntry.punches || []);
          state.punchDraft.dirty = false;
          renderPunchDraft();
        }
      }
    } else {
      // No existing entry, keep current tab but clear editing state
      if (state.currentTab === 'manual') {
        clearManualEditing();
      } else {
        // For advanced mode, just clear the editing state without changing tabs
        state.editingEntryId = null;
        state.editingEntryType = null;
        setPunchDate(dateIso);
        ensurePunchDraft();
      }
    }
  }
  function changeCalendarMonth(delta) {
    ensureCalendarState();
    const oldYear = state.calendar.year;
    const next = new Date(state.calendar.year, state.calendar.month + delta, 1);
    state.calendar.year = next.getFullYear();
    state.calendar.month = next.getMonth();
    if (state.selectedCalendarDate) {
      const selected = parseIsoDate(state.selectedCalendarDate);
      if (selected.getFullYear() !== state.calendar.year || selected.getMonth() !== state.calendar.month) {
        state.selectedCalendarDate = null;
      }
    }
    // Reload public holidays if year changed
    if (oldYear !== state.calendar.year && getFeatureFlag('enable_public_holidays')) {
      loadPublicHolidays(true); // Re-render after load when year changes
    }
    renderCalendar();
  }
  document.getElementById('calendar-prev').onclick = () => changeCalendarMonth(-1);
  document.getElementById('calendar-next').onclick = () => changeCalendarMonth(1);

  // Month picker modal
  const monthPickerModal = document.getElementById('modal-month-picker');
  const monthPickerJumpBtn = document.getElementById('calendar-jump');
  const monthPickerYearDisplay = document.getElementById('month-picker-year-display');
  const monthPickerYearPrev = document.getElementById('month-picker-year-prev');
  const monthPickerYearNext = document.getElementById('month-picker-year-next');
  const monthPickerGrid = document.getElementById('month-picker-grid');

  var monthPickerState = {
    year: null
  };

  const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

  function openMonthPicker() {
    if (!state.calendar) return;
    monthPickerState.year = state.calendar.year;
    renderMonthPicker();
    monthPickerModal.style.display = 'flex';
  }

  function closeMonthPicker() {
    monthPickerModal.style.display = 'none';
  }

  function renderMonthPicker() {
    if (!state.calendar) return;
    monthPickerYearDisplay.textContent = monthPickerState.year;

    const currentDate = new Date();
    const currentYear = currentDate.getFullYear();
    const currentMonth = currentDate.getMonth();
    const activeYear = state.calendar.year;
    const activeMonth = state.calendar.month;

    monthPickerGrid.innerHTML = '';

    for (var i = 0; i < 12; i++) {
      var btn = document.createElement('button');
      btn.className = 'month-picker-cell';
      btn.textContent = monthNames[i];
      btn.dataset.month = i;

      // Highlight current month
      if (i === currentMonth && monthPickerState.year === currentYear) {
        btn.classList.add('current-month');
      }

      // Highlight active month
      if (i === activeMonth && monthPickerState.year === activeYear) {
        btn.classList.add('active');
      }

      btn.onclick = function() {
        var selectedMonth = parseInt(this.dataset.month);
        state.calendar.month = selectedMonth;
        state.calendar.year = monthPickerState.year;
        renderCalendar();
        closeMonthPicker();
      };

      monthPickerGrid.appendChild(btn);
    }
  }

  monthPickerJumpBtn.onclick = openMonthPicker;

  monthPickerYearPrev.onclick = function() {
    monthPickerState.year--;
    renderMonthPicker();
  };

  monthPickerYearNext.onclick = function() {
    monthPickerState.year++;
    renderMonthPicker();
  };

  // Close modal when clicking the X or outside
  var monthPickerClose = monthPickerModal.querySelector('.ts-modal-close');
  if (monthPickerClose) {
    monthPickerClose.onclick = closeMonthPicker;
  }

  monthPickerModal.onclick = function(e) {
    if (e.target === monthPickerModal) {
      closeMonthPicker();
    }
  };

  // Calendar filtering
  const calendarFilterToggle = document.getElementById('calendar-filter-toggle');
  const calendarFilterPanel = document.getElementById('calendar-filter-panel');
  const calendarFilterList = document.getElementById('calendar-filter-list');
  const filterSelectAll = document.getElementById('filter-select-all');
  const filterSelectNone = document.getElementById('filter-select-none');
  const filterSelectIncome = document.getElementById('filter-select-income');

  function renderCalendarFilters() {
    const hourTypesEnabled = getFeatureFlag('hour_types') && state.hourTypes.length > 1;

    if (!hourTypesEnabled || !calendarFilterToggle) {
      if (calendarFilterToggle) calendarFilterToggle.style.display = 'none';
      if (calendarFilterPanel) calendarFilterPanel.style.display = 'none';
      return;
    }

    calendarFilterToggle.style.display = 'block';

    if (!calendarFilterList) return;

    // Initialize filter state if null
    if (state.calendarFilteredHourTypes === null) {
      state.calendarFilteredHourTypes = state.hourTypes.map(ht => ht.id);
    }

    calendarFilterList.innerHTML = '';
    state.hourTypes.forEach(hourType => {
      const isActive = state.calendarFilteredHourTypes.includes(hourType.id);

      const item = document.createElement('div');
      item.className = 'ts-calendar-filter-item' + (isActive ? ' active' : '');
      item.innerHTML = `
        <input type="checkbox" class="ts-calendar-filter-checkbox" ${isActive ? 'checked' : ''} data-hour-type-id="${hourType.id}" />
        <div class="ts-calendar-filter-color" style="background-color:${hourType.color};"></div>
        <span class="ts-calendar-filter-name">${hourType.name}</span>
      `;

      item.onclick = () => toggleHourTypeFilter(hourType.id);
      calendarFilterList.appendChild(item);
    });
  }

  function toggleHourTypeFilter(hourTypeId) {
    if (!state.calendarFilteredHourTypes) {
      state.calendarFilteredHourTypes = state.hourTypes.map(ht => ht.id);
    }

    const index = state.calendarFilteredHourTypes.indexOf(hourTypeId);
    if (index > -1) {
      state.calendarFilteredHourTypes.splice(index, 1);
    } else {
      state.calendarFilteredHourTypes.push(hourTypeId);
    }

    saveCache();
    renderCalendarFilters();
    renderCalendar();
  }

  if (calendarFilterToggle) {
    calendarFilterToggle.onclick = () => {
      if (calendarFilterPanel) {
        const isHidden = calendarFilterPanel.style.display === 'none';
        calendarFilterPanel.style.display = isHidden ? 'block' : 'none';
      }
    };
  }

  if (filterSelectAll) {
    filterSelectAll.onclick = () => {
      state.calendarFilteredHourTypes = state.hourTypes.map(ht => ht.id);
      saveCache();
      renderCalendarFilters();
      renderCalendar();
    };
  }

  if (filterSelectNone) {
    filterSelectNone.onclick = () => {
      state.calendarFilteredHourTypes = [];
      saveCache();
      renderCalendarFilters();
      renderCalendar();
    };
  }

  if (filterSelectIncome) {
    filterSelectIncome.onclick = () => {
      state.calendarFilteredHourTypes = state.hourTypes
        .filter(ht => ht.contributes_to_income)
        .map(ht => ht.id);
      saveCache();
      renderCalendarFilters();
      renderCalendar();
    };
  }

  // Settings dirty state tracking
  var settingsInitialState = {};

  function captureSettingsState() {
    settingsInitialState = {
      round_to_nearest: roundInput ? (parseInt(roundInput.value, 10) || 0) : 0,
      theme: themeSelect ? themeSelect.value : 'dark',
      superannuation_rate: superRateInput ? sanitizeSuperRateInputValue(superRateInput.value) : Math.round(getSuperRateSetting() * 1000) / 10,
      payg_instalment_rate: paygRateInput ? (parseFloat(paygRateInput.value) || 2) : (Number(state.settings.payg_instalment_rate) || 2),
      public_holiday_state: publicHolidayStateSelect ? publicHolidayStateSelect.value : 'ACT',
      minimum_end_time: minimumEndTimeInput ? minimumEndTimeInput.value : '17:00'
    };
  }

  function checkSettingsDirty() {
    const current = {
      round_to_nearest: roundInput ? (parseInt(roundInput.value, 10) || 0) : 0,
      theme: themeSelect ? themeSelect.value : 'dark',
      superannuation_rate: superRateInput ? sanitizeSuperRateInputValue(superRateInput.value) : Math.round(getSuperRateSetting() * 1000) / 10,
      payg_instalment_rate: paygRateInput ? (parseFloat(paygRateInput.value) || 2) : (Number(state.settings.payg_instalment_rate) || 2),
      public_holiday_state: publicHolidayStateSelect ? publicHolidayStateSelect.value : 'ACT',
      minimum_end_time: minimumEndTimeInput ? minimumEndTimeInput.value : '17:00'
    };

    const isDirty = current.round_to_nearest !== settingsInitialState.round_to_nearest ||
                    current.theme !== settingsInitialState.theme ||
                    current.superannuation_rate !== settingsInitialState.superannuation_rate ||
                    current.payg_instalment_rate !== settingsInitialState.payg_instalment_rate ||
                    current.public_holiday_state !== settingsInitialState.public_holiday_state ||
                    current.minimum_end_time !== settingsInitialState.minimum_end_time;

    if (saveSettingsBtn) saveSettingsBtn.disabled = !isDirty;
    if (discardSettingsBtn) discardSettingsBtn.style.display = isDirty ? 'inline-flex' : 'none';

    return isDirty;
  }

  function resetSettingsToInitial() {
    if (roundInput) roundInput.value = settingsInitialState.round_to_nearest || 0;
    if (themeSelect) themeSelect.value = settingsInitialState.theme || 'dark';
    if (superRateInput) superRateInput.value = String(settingsInitialState.superannuation_rate);
    if (paygRateInput) paygRateInput.value = String(settingsInitialState.payg_instalment_rate || 2);
    if (publicHolidayStateSelect) publicHolidayStateSelect.value = settingsInitialState.public_holiday_state || 'ACT';
    if (minimumEndTimeInput) minimumEndTimeInput.value = settingsInitialState.minimum_end_time || '17:00';
    applyTheme(settingsInitialState.theme || 'dark');
    checkSettingsDirty();
  }

  // Attach change listeners to settings inputs
  if (roundInput) roundInput.addEventListener('input', checkSettingsDirty);
  if (themeSelect) themeSelect.addEventListener('change', checkSettingsDirty);
  if (superRateInput) superRateInput.addEventListener('input', checkSettingsDirty);
  if (paygRateInput) paygRateInput.addEventListener('input', checkSettingsDirty);
  if (publicHolidayStateSelect) publicHolidayStateSelect.addEventListener('change', checkSettingsDirty);
  if (minimumEndTimeInput) minimumEndTimeInput.addEventListener('input', checkSettingsDirty);

  // Settings persistence
  if (saveSettingsBtn) {
    saveSettingsBtn.onclick = function () {
      const nextTheme = themeSelect ? themeSelect.value : (state.settings.theme || 'dark');
      const superRatePercent = superRateInput ? sanitizeSuperRateInputValue(superRateInput.value) : Math.round(getSuperRateSetting() * 1000) / 10;
      const paygRatePercent = paygRateInput ? (parseFloat(paygRateInput.value) || 2) : (Number(state.settings.payg_instalment_rate) || 2);
      const publicHolidayState = publicHolidayStateSelect ? publicHolidayStateSelect.value : (state.settings.public_holiday_state || 'ACT');
      const minimumEndTime = minimumEndTimeInput ? minimumEndTimeInput.value : '17:00';
      const next = {
        round_to_nearest: parseInt((roundInput && roundInput.value) || '0', 10) || 0,
        theme: nextTheme,
        superannuation_rate: superRatePercent,
        payg_instalment_rate: paygRatePercent,
        public_holiday_state: publicHolidayState,
        minimum_end_time: minimumEndTime
      };
      applyTheme(nextTheme);
      if (superRateInput) superRateInput.value = String(next.superannuation_rate);
      if (paygRateInput) paygRateInput.value = String(next.payg_instalment_rate);
      state.settings = { ...state.settings, ...next };
      saveCache();
      renderCalendar();
      setStatus('Saving settings...', 'warn');
      google.script.run
        .withSuccessHandler(() => {
          setStatus('Settings saved', 'success');
          captureSettingsState();
          checkSettingsDirty();
        })
        .withFailureHandler(() => setStatus('Settings failed', 'error'))
        .api_updateSettings(next);
    };
  }

  // Discard settings changes
  if (discardSettingsBtn) {
    discardSettingsBtn.onclick = function () {
      resetSettingsToInitial();
    };
  }

  if (themeSelect) {
    themeSelect.addEventListener('change', () => {
      applyTheme(themeSelect.value);
      saveCache();
    });
  }

  // Initial load
  function init() {
    loadCache();
    if (superRateInput) superRateInput.value = String(getSuperRatePercentage());
    if (paygRateInput) paygRateInput.value = String(Number(state.settings.payg_instalment_rate) || 2);
    renderEntries();
    if (roundInput) roundInput.value = state.settings.round_to_nearest || 0;
    if (publicHolidayStateSelect) publicHolidayStateSelect.value = state.settings.public_holiday_state || 'ACT';
    if (minimumEndTimeInput) minimumEndTimeInput.value = state.settings.minimum_end_time || '17:00';
    applyTheme(state.settings.theme || 'dark');
    captureSettingsState();
    checkSettingsDirty();
    renderContractsUI();
    renderDeductionsList();
    hideContractForm();
    refreshContractBindings();
    state.featureFlags = normalizeFeatureFlags(state.featureFlags);
    renderFeatureFlags();
    applyFeatureFlags();
    setStatus('Syncing...', 'warn');
    google.script.run
      .withSuccessHandler((entries) => {
        state.entries = (entries || []).map(sanitizeEntry);
        state.entriesLoaded = true;
        saveCache();
        renderEntries();
        updateTabStates();
        ensurePunchDraft(state.punchDraft ? state.punchDraft.contractId : undefined);
        setStatus('Synced', 'success');
        renderBasReporting();
        maybeAutoPopulatePublicHolidayEntries();
      })
      .withFailureHandler(() => setStatus('Entries sync failed', 'error'))
      .api_getEntries({});
    google.script.run
      .withSuccessHandler((settings) => {
        state.settings = settings || {};

        // Parse custom_theme_config if it's a JSON string
        if (state.settings.custom_theme_config && typeof state.settings.custom_theme_config === 'string') {
          try {
            state.settings.custom_theme_config = JSON.parse(state.settings.custom_theme_config);
          } catch (e) {
            // If parsing fails, reset to default
            state.settings.custom_theme_config = null;
          }
        }

        saveCache();
        if (roundInput) roundInput.value = state.settings.round_to_nearest || 0;
        if (superRateInput) superRateInput.value = String(getSuperRatePercentage());
        if (paygRateInput) paygRateInput.value = String(Number(state.settings.payg_instalment_rate) || 2);
        if (publicHolidayStateSelect) publicHolidayStateSelect.value = state.settings.public_holiday_state || 'ACT';
        if (minimumEndTimeInput) minimumEndTimeInput.value = state.settings.minimum_end_time || '17:00';
        applyTheme(state.settings.theme || 'dark');
        captureSettingsState();
        checkSettingsDirty();
        renderCalendar();
      })
      .withFailureHandler(() => {})
      .api_getSettings();
    google.script.run
      .withSuccessHandler((contracts) => {
        state.contracts = (contracts || []).map(sanitizeContract);
        refreshContractBindings();
        saveCache();
        renderCalendar();
      })
      .withFailureHandler(() => setStatus('Contracts sync failed', 'error'))
      .api_getContracts();
    google.script.run
      .withSuccessHandler((flags) => {
        state.featureFlags = normalizeFeatureFlags(flags);
        saveCache();
        renderFeatureFlags();
        applyFeatureFlags();
        loadPublicHolidays();
      })
      .withFailureHandler(() => {})
      .api_getFeatureFlags();
    google.script.run
      .withSuccessHandler((deductions) => {
        state.deductions = (deductions || []).map(sanitizeDeduction);
        saveCache();
        renderDeductionsList();
        renderIncomeSummary();
      })
      .withFailureHandler(() => setStatus('Deductions sync failed', 'error'))
      .api_getDeductions();
    google.script.run
      .withSuccessHandler((actualIncome) => {
        console.log('[ActualIncome] Loaded from server:', actualIncome);
        state.actualIncome = actualIncome || [];
        refreshActualIncomeMap();
        console.log('[ActualIncome] Map:', state.actualIncomeMap);
        saveCache();
        renderIncomeSummary();
      })
      .withFailureHandler((error) => {
        console.error('[ActualIncome] Failed to load:', error);
      })
      .api_getActualIncome();
    google.script.run
      .withSuccessHandler((submissions) => {
        state.basSubmissions = submissions || [];
        saveCache();
        renderBasReporting();
      })
      .withFailureHandler(() => {})
      .api_getBasSubmissions();
  }

  // Default Entries Functionality
  const state_defaults = {
    entryDefaults: { basic: [], advanced: [] },
    currentDefaultType: null,
    editingDefaultName: null
  };

  // Default entry UI elements
  const createManualDefaultBtn = document.getElementById('btn-create-manual-default');
  const enterManualDefaultBtn = document.getElementById('btn-enter-manual-default');
  const editManualDefaultsBtn = document.getElementById('btn-edit-manual-defaults');
  const createPunchDefaultBtn = document.getElementById('btn-create-punch-default');
  const enterPunchDefaultBtn = document.getElementById('btn-enter-punch-default');
  const editPunchDefaultsBtn = document.getElementById('btn-edit-punch-defaults');


  // Modal elements
  const createDefaultModal = document.getElementById('modal-create-default');
  const selectDefaultModal = document.getElementById('modal-select-default');
  const editDefaultsModal = document.getElementById('modal-edit-defaults');
  const editDefaultDetailsModal = document.getElementById('modal-edit-default-details');

  function updateDefaultButtonsVisibility() {
    const featureEnabled = state.featureFlags.default_inputs && state.featureFlags.default_inputs.enabled;

    if (!featureEnabled) {
      // Hide all default buttons if feature is disabled
      [createManualDefaultBtn, enterManualDefaultBtn, editManualDefaultsBtn,
       createPunchDefaultBtn, enterPunchDefaultBtn, editPunchDefaultsBtn].forEach(btn => {
        if (btn) btn.style.display = 'none';
      });
      return;
    }

    const defaults = state_defaults.entryDefaults;
    const hasBasicDefaults = defaults.basic.length > 0;
    const hasAdvancedDefaults = defaults.advanced.length > 0;

    // Basic/Manual tab buttons
    if (createManualDefaultBtn) createManualDefaultBtn.style.display = 'inline-flex';
    if (enterManualDefaultBtn) enterManualDefaultBtn.style.display = hasBasicDefaults ? 'inline-flex' : 'none';
    if (editManualDefaultsBtn) editManualDefaultsBtn.style.display = hasBasicDefaults ? 'inline-flex' : 'none';

    // Advanced/Punch tab buttons
    if (createPunchDefaultBtn) createPunchDefaultBtn.style.display = 'inline-flex';
    if (enterPunchDefaultBtn) enterPunchDefaultBtn.style.display = hasAdvancedDefaults ? 'inline-flex' : 'none';
    if (editPunchDefaultsBtn) editPunchDefaultsBtn.style.display = hasAdvancedDefaults ? 'inline-flex' : 'none';
  }

  function loadEntryDefaults() {
    google.script.run
      .withSuccessHandler((result) => {
        state_defaults.entryDefaults = result || { basic: [], advanced: [] };
        updateDefaultButtonsVisibility();
      })
      .withFailureHandler(() => {
        console.log('Failed to load entry defaults');
      })
      .api_getEntryDefaults();
  }

  function showModal(modal) {
    if (modal) modal.style.display = 'flex';
  }

  function hideModal(modal) {
    if (modal) modal.style.display = 'none';
  }

  // Custom confirm dialog replacement
  function customConfirm(message, options) {
    return new Promise((resolve) => {
      const opts = options || {};
      const title = opts.title || 'Confirm';
      const okText = opts.okText || 'OK';
      const cancelText = opts.cancelText || 'Cancel';
      const isDanger = opts.danger || false;

      const modal = document.getElementById('modal-confirm');
      const titleEl = document.getElementById('confirm-title');
      const messageEl = document.getElementById('confirm-message');
      const okBtn = document.getElementById('btn-confirm-ok');
      const cancelBtn = document.getElementById('btn-confirm-cancel');

      if (!modal || !titleEl || !messageEl || !okBtn || !cancelBtn) {
        // Fallback to native confirm if modal not found
        resolve(confirm(message));
        return;
      }

      titleEl.textContent = title;
      messageEl.textContent = message;
      okBtn.textContent = okText;
      cancelBtn.textContent = cancelText;

      // Apply danger styling if requested
      if (isDanger) {
        okBtn.className = 'danger';
      } else {
        okBtn.className = '';
      }

      const handleOk = () => {
        cleanup();
        resolve(true);
      };

      const handleCancel = () => {
        cleanup();
        resolve(false);
      };

      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          handleCancel();
        } else if (e.key === 'Enter' && !isDanger) {
          // Only allow Enter to confirm if not a danger action
          handleOk();
        }
      };

      const cleanup = () => {
        okBtn.removeEventListener('click', handleOk);
        cancelBtn.removeEventListener('click', handleCancel);
        document.removeEventListener('keydown', handleEscape);
        hideModal(modal);
      };

      okBtn.addEventListener('click', handleOk);
      cancelBtn.addEventListener('click', handleCancel);
      document.addEventListener('keydown', handleEscape);

      showModal(modal);
      // Focus the appropriate button
      if (isDanger) {
        cancelBtn.focus();
      } else {
        okBtn.focus();
      }
    });
  }

  // Custom alert dialog replacement
  function customAlert(message, options) {
    return new Promise((resolve) => {
      const opts = options || {};
      const title = opts.title || 'Notice';
      const okText = opts.okText || 'OK';

      const modal = document.getElementById('modal-alert');
      const titleEl = document.getElementById('alert-title');
      const messageEl = document.getElementById('alert-message');
      const okBtn = document.getElementById('btn-alert-ok');

      if (!modal || !titleEl || !messageEl || !okBtn) {
        // Fallback to native alert if modal not found
        alert(message);
        resolve();
        return;
      }

      titleEl.textContent = title;
      messageEl.textContent = message;
      okBtn.textContent = okText;

      const handleOk = () => {
        cleanup();
        resolve();
      };

      const handleEscape = (e) => {
        if (e.key === 'Escape' || e.key === 'Enter') {
          handleOk();
        }
      };

      const cleanup = () => {
        okBtn.removeEventListener('click', handleOk);
        document.removeEventListener('keydown', handleEscape);
        hideModal(modal);
      };

      okBtn.addEventListener('click', handleOk);
      document.addEventListener('keydown', handleEscape);

      showModal(modal);
      okBtn.focus();
    });
  }

  // BAS Detail Modal
  let currentBasPeriod = { fyYear: null, quarter: null, month: null };

  async function copyToClipboard(text, element) {
    try {
      await navigator.clipboard.writeText(text);
      // Visual feedback
      if (element) {
        element.classList.add('copied');
        setTimeout(() => {
          element.classList.remove('copied');
        }, 300);
      }
      return true;
    } catch (err) {
      console.error('Failed to copy:', err);
      return false;
    }
  }

  function openBasDetailModal(fyYear, quarter, month) {
    currentBasPeriod = { fyYear, quarter, month };

    const modal = document.getElementById('modal-bas-detail');
    const titleEl = document.getElementById('bas-detail-title');

    const monthRows = buildMonthlyBasRows(fyYear);
    let periodData;
    let periodLabel;

    if (quarter) {
      // Quarterly BAS
      const quarterlyRows = buildQuarterlyBasRows(monthRows);
      periodData = quarterlyRows[quarter - 1];
      periodLabel = ['Q1 (Jul–Sep)', 'Q2 (Oct–Dec)', 'Q3 (Jan–Mar)', 'Q4 (Apr–Jun)'][quarter - 1];
    } else if (month !== null && month !== undefined) {
      // Monthly BAS
      periodData = monthRows.find(r => r.month === month);
      const date = new Date(periodData.year, month, 1);
      periodLabel = MONTH_YEAR_FORMATTER.format(date);
    }

    if (!periodData) {
      customAlert('Unable to load BAS data for this period.');
      return;
    }

    // Calculate BAS fields
    const g1TotalSales = periodData.invoiceTotal;
    const field1aGstOnSales = periodData.invoiceGst;
    const field1bGstOnPurchases = periodData.companyExpensesGst;

    // Get PAYG rate from settings (default 2%)
    const paygRate = Number(state.settings.payg_instalment_rate || 2) / 100;

    // Calculate T1 based on sole trader flag
    const isSoleTrader = getFeatureFlag('is_sole_trader');
    const t1PaygIncome = isSoleTrader
      ? periodData.employeeGrossIncome // For sole traders: gross income minus expenses
      : periodData.companyIncome; // For companies: company income

    const t2InstalmentRate = paygRate * 100; // Convert back to percentage for display

    // Update modal title
    if (titleEl) {
      titleEl.textContent = `BAS Details - FY ${fyYear}-${String(fyYear + 1).slice(-2)} ${periodLabel}`;
    }

    // Update field values
    const g1El = document.getElementById('bas-g1-value');
    const field1aEl = document.getElementById('bas-1a-value');
    const field1bEl = document.getElementById('bas-1b-value');
    const t1El = document.getElementById('bas-t1-value');
    const t2El = document.getElementById('bas-t2-value');

    if (g1El) g1El.textContent = formatCurrency(g1TotalSales);
    if (field1aEl) field1aEl.textContent = formatCurrency(field1aGstOnSales);
    if (field1bEl) field1bEl.textContent = formatCurrency(field1bGstOnPurchases);
    if (t1El) t1El.textContent = formatCurrency(t1PaygIncome);
    if (t2El) t2El.textContent = t2InstalmentRate.toFixed(2) + '%';

    // Load submission status
    const submission = state.basSubmissions.find(s => {
      if (s.financial_year !== fyYear) return false;
      if (quarter) {
        return s.period_type === 'quarterly' && s.quarter === quarter;
      } else {
        return s.period_type === 'monthly' && s.month === month;
      }
    });
    const submittedToggle = document.getElementById('bas-submitted-toggle');
    if (submittedToggle) {
      submittedToggle.checked = submission ? submission.submitted : false;
    }

    // Attach click-to-copy handlers
    attachBasFieldCopyHandlers();

    showModal(modal);
  }

  function attachBasFieldCopyHandlers() {
    const fields = document.querySelectorAll('.bas-field-value[data-field]');
    fields.forEach(field => {
      const handler = async () => {
        // Extract numeric value (remove $ and ,)
        const text = field.textContent.replace(/[$,]/g, '').trim();
        const success = await copyToClipboard(text, field);
        if (success) {
          // Optional: show a toast notification
          setStatus('Copied to clipboard', 'success');
        }
      };
      // Remove existing listeners to avoid duplicates
      field.replaceWith(field.cloneNode(true));
    });
    // Re-query and attach
    document.querySelectorAll('.bas-field-value[data-field]').forEach(field => {
      field.addEventListener('click', async () => {
        const text = field.textContent.replace(/[$,]/g, '').trim();
        const success = await copyToClipboard(text, field);
        if (success) {
          setStatus('Copied to clipboard', 'success');
        }
      });
    });
  }

  // BAS Detail Modal - Close and Save handlers
  const basDetailCloseBtn = document.getElementById('btn-bas-detail-close');
  const basDetailSaveBtn = document.getElementById('btn-bas-detail-save');

  if (basDetailCloseBtn) {
    basDetailCloseBtn.addEventListener('click', () => {
      const modal = document.getElementById('modal-bas-detail');
      hideModal(modal);
    });
  }

  if (basDetailSaveBtn) {
    basDetailSaveBtn.addEventListener('click', async () => {
      const submittedToggle = document.getElementById('bas-submitted-toggle');
      const submitted = submittedToggle ? submittedToggle.checked : false;

      const { fyYear, quarter, month } = currentBasPeriod;
      if (!fyYear) return;
      if (!quarter && (month === null || month === undefined)) return;

      // Calculate all fields
      const monthRows = buildMonthlyBasRows(fyYear);
      let periodData;

      if (quarter) {
        const quarterlyRows = buildQuarterlyBasRows(monthRows);
        periodData = quarterlyRows[quarter - 1];
      } else {
        periodData = monthRows.find(r => r.month === month);
      }

      if (!periodData) return;

      const paygRate = Number(state.settings.payg_instalment_rate || 2) / 100;
      const isSoleTrader = getFeatureFlag('is_sole_trader');

      const basData = {
        financial_year: fyYear,
        period_type: quarter ? 'quarterly' : 'monthly',
        quarter: quarter || null,
        month: month !== null && month !== undefined ? month : null,
        g1_total_sales: periodData.invoiceTotal,
        g1_includes_gst: true,
        field_1a_gst_on_sales: periodData.invoiceGst,
        field_1b_gst_on_purchases: periodData.companyExpensesGst,
        t1_payg_income: isSoleTrader ? periodData.employeeGrossIncome : periodData.companyIncome,
        t2_instalment_rate: paygRate,
        submitted: submitted
      };

      // Save to backend
      setStatus('Saving BAS submission...', 'warn');
      basDetailSaveBtn.disabled = true;
      basDetailSaveBtn.textContent = 'Saving...';

      google.script.run
        .withSuccessHandler((savedSubmission) => {
          // Update local state
          const index = state.basSubmissions.findIndex(s => {
            if (s.financial_year !== fyYear) return false;
            if (quarter) {
              return s.period_type === 'quarterly' && s.quarter === quarter;
            } else {
              return s.period_type === 'monthly' && s.month === month;
            }
          });
          if (index >= 0) {
            state.basSubmissions[index] = savedSubmission;
          } else {
            state.basSubmissions.push(savedSubmission);
          }
          saveCache();

          // Close modal and refresh BAS report
          const modal = document.getElementById('modal-bas-detail');
          hideModal(modal);
          renderBasReporting();
          setStatus('BAS submission saved', 'success');
          basDetailSaveBtn.disabled = false;
          basDetailSaveBtn.textContent = 'Save';
        })
        .withFailureHandler((error) => {
          console.error('Failed to save BAS submission:', error);
          customAlert('Failed to save BAS submission: ' + error.message, { title: 'Error' });
          basDetailSaveBtn.disabled = false;
          basDetailSaveBtn.textContent = 'Save';
          setStatus('Failed to save', 'error');
        })
        .api_upsertBasSubmission(basData);
    });
  }

  function getCurrentFormData(type) {
    if (type === 'basic') {
      const hours = Number(manualHoursInput ? manualHoursInput.value : '');
      return {
        duration_minutes: Math.round(hours * 60)
      };
    } else if (type === 'advanced') {
      const draft = state.punchDraft;
      if (!draft || !draft.punches) return { punches: [] };
      return {
        punches: draft.punches.filter(p => p.in && p.out) // Only include closed punches
      };
    }
    return null;
  }

  function applyDefaultToForm(defaultData, type) {
    if (type === 'basic') {
      const hours = (defaultData.duration_minutes || 0) / 60;
      if (manualHoursInput) manualHoursInput.value = hours > 0 ? hours.toString() : '';
      updateBasicSaveEnabled();
    } else if (type === 'advanced') {
      // Apply punches to advanced form
      ensurePunchDraft();
      if (state.punchDraft) {
        state.punchDraft.punches = [...(defaultData.punches || [])];
        setPunchDraftDirty();
        renderPunchDraft();
        updatePunchSummary();
      }
    }
  }

  function handleCreateDefault(type) {
    const formData = getCurrentFormData(type);
    if (!formData) {
      setStatus('Please enter some time data first', 'warn');
      return;
    }

    if (type === 'basic' && (!formData.duration_minutes || formData.duration_minutes <= 0)) {
      setStatus('Please enter a valid number of hours', 'warn');
      return;
    }

    if (type === 'advanced' && (!formData.punches || formData.punches.length === 0)) {
      setStatus('Please add some punch times first', 'warn');
      return;
    }

    state_defaults.currentDefaultType = type;
    state_defaults.currentFormData = formData;

    const nameInput = document.getElementById('default-name');
    if (nameInput) nameInput.value = '';
    showModal(createDefaultModal);
    if (nameInput) nameInput.focus();
  }

  function handleEnterDefault(type) {
    const defaults = state_defaults.entryDefaults[type] || [];

    if (defaults.length === 0) {
      setStatus('No defaults available', 'warn');
      return;
    }

    if (defaults.length === 1) {
      // Single default - apply directly and submit
      applyDefaultToForm(defaults[0], type);

      // Trigger the appropriate save handler
      setTimeout(() => {
        if (type === 'basic' && manualSaveBtn) {
          manualSaveBtn.click();
        } else if (type === 'advanced' && punchSaveBtn) {
          punchSaveBtn.click();
        }
      }, 100);
    } else {
      // Multiple defaults - show selection modal
      state_defaults.currentDefaultType = type;
      renderDefaultSelection(defaults);
      showModal(selectDefaultModal);
    }
  }

  function renderDefaultSelection(defaults) {
    const listEl = document.getElementById('default-selection-list');
    if (!listEl) return;

    listEl.innerHTML = '';
    defaults.forEach((defaultData, index) => {
      const item = document.createElement('div');
      item.className = 'ts-default-item';
      item.style.cssText = 'padding: 12px; margin: 8px 0; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; transition: background-color 0.2s;';

      const title = document.createElement('div');
      title.style.fontWeight = 'bold';
      title.textContent = defaultData.name;

      const details = document.createElement('div');
      details.style.fontSize = '0.9em';
      details.style.color = 'var(--text-secondary)';
      details.style.marginTop = '4px';

      if (state_defaults.currentDefaultType === 'basic') {
        const hours = (defaultData.duration_minutes || 0) / 60;
        details.textContent = `${hours} hours`;
      } else {
        const punchCount = (defaultData.punches || []).length;
        details.textContent = `${punchCount} punch ${punchCount === 1 ? 'range' : 'ranges'}`;
      }

      item.appendChild(title);
      item.appendChild(details);

      item.addEventListener('click', () => {
        applyDefaultToForm(defaultData, state_defaults.currentDefaultType);
        hideModal(selectDefaultModal);

        // Trigger the appropriate save handler
        setTimeout(() => {
          if (state_defaults.currentDefaultType === 'basic' && manualSaveBtn) {
            manualSaveBtn.click();
          } else if (state_defaults.currentDefaultType === 'advanced' && punchSaveBtn) {
            punchSaveBtn.click();
          }
        }, 100);
      });

      item.addEventListener('mouseenter', () => {
        item.style.backgroundColor = 'var(--hover-bg)';
      });

      item.addEventListener('mouseleave', () => {
        item.style.backgroundColor = '';
      });

      listEl.appendChild(item);
    });
  }

  function handleEditDefaults(type) {
    state_defaults.currentDefaultType = type;
    renderEditDefaultsList();
    showModal(editDefaultsModal);
  }

  function renderEditDefaultsList() {
    const listEl = document.getElementById('edit-defaults-list');
    if (!listEl) return;

    const defaults = state_defaults.entryDefaults[state_defaults.currentDefaultType] || [];

    listEl.innerHTML = '';

    if (defaults.length === 0) {
      listEl.innerHTML = '<div class="ts-note">No defaults created yet.</div>';
      return;
    }

    defaults.forEach((defaultData, index) => {
      const item = document.createElement('div');
      item.className = 'ts-edit-default-item';
      item.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 12px; margin: 8px 0; border: 1px solid var(--border-color); border-radius: 4px;';

      const content = document.createElement('div');
      content.style.flex = '1';
      content.style.cursor = 'pointer';

      const title = document.createElement('div');
      title.style.fontWeight = 'bold';
      title.textContent = defaultData.name;

      const details = document.createElement('div');
      details.style.fontSize = '0.9em';
      details.style.color = 'var(--text-secondary)';
      details.style.marginTop = '4px';

      if (state_defaults.currentDefaultType === 'basic') {
        const hours = (defaultData.duration_minutes || 0) / 60;
        details.textContent = `${hours} hours`;
      } else {
        const punchCount = (defaultData.punches || []).length;
        details.textContent = `${punchCount} punch ${punchCount === 1 ? 'range' : 'ranges'}`;
      }

      content.appendChild(title);
      content.appendChild(details);

      content.addEventListener('click', () => {
        openEditDefaultDetails(defaultData);
      });

      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Delete';
      deleteBtn.className = 'ghost';
      deleteBtn.style.marginLeft = '12px';
      deleteBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const confirmed = await customConfirm(`Delete the "${defaultData.name}" default?`, { danger: true });
        if (confirmed) {
          deleteEntryDefault(defaultData.name, deleteBtn);
        }
      });

      item.appendChild(content);
      item.appendChild(deleteBtn);
      listEl.appendChild(item);
    });
  }

  function openEditDefaultDetails(defaultData) {
    state_defaults.editingDefaultName = defaultData.name;

    const nameInput = document.getElementById('edit-default-name');
    if (nameInput) nameInput.value = defaultData.name;

    const formEl = document.getElementById('edit-default-form');
    if (!formEl) return;

    formEl.innerHTML = '';

    if (state_defaults.currentDefaultType === 'basic') {
      const hours = (defaultData.duration_minutes || 0) / 60;

      formEl.innerHTML = `
        <div class="ts-row">
          <div class="ts-col">
            <label>Total hours</label>
            <input type="number" id="edit-default-hours" min="0" step="0.01" value="${hours}" />
          </div>
        </div>
      `;
    } else {
      const punchesHtml = (defaultData.punches || []).map((punch, i) => `
        <div class="ts-row" style="margin-top: 8px;">
          <div class="ts-col">
            <label>Punch ${i + 1} In</label>
            <input type="time" id="edit-punch-${i}-in" value="${punch.in || ''}" />
          </div>
          <div class="ts-col">
            <label>Punch ${i + 1} Out</label>
            <input type="time" id="edit-punch-${i}-out" value="${punch.out || ''}" />
          </div>
          <div class="ts-col" style="display:flex; align-items:flex-end;">
            <button type="button" class="ghost" onclick="removePunchRow(${i})">Remove</button>
          </div>
        </div>
      `).join('');

      formEl.innerHTML = `
        <div id="edit-punch-rows">
          ${punchesHtml}
        </div>
        <div style="margin-top: 12px;">
          <button type="button" class="ghost" onclick="addEditPunchRow()">Add Punch Range</button>
        </div>
      `;
    }

    hideModal(editDefaultsModal);
    showModal(editDefaultDetailsModal);
  }

  // Global functions for punch editing (needed for onclick handlers)
  window.addEditPunchRow = function() {
    const container = document.getElementById('edit-punch-rows');
    if (!container) return;

    const existingRows = container.children.length;
    const newRow = document.createElement('div');
    newRow.className = 'ts-row';
    newRow.style.marginTop = '8px';
    newRow.innerHTML = `
      <div class="ts-col">
        <label>Punch ${existingRows + 1} In</label>
        <input type="time" id="edit-punch-${existingRows}-in" />
      </div>
      <div class="ts-col">
        <label>Punch ${existingRows + 1} Out</label>
        <input type="time" id="edit-punch-${existingRows}-out" />
      </div>
      <div class="ts-col" style="display:flex; align-items:flex-end;">
        <button type="button" class="ghost" onclick="removePunchRow(${existingRows})">Remove</button>
      </div>
    `;
    container.appendChild(newRow);
  };

  window.removePunchRow = function(index) {
    const container = document.getElementById('edit-punch-rows');
    if (!container || container.children.length <= 1) return;

    if (container.children[index]) {
      container.removeChild(container.children[index]);

      // Update labels and IDs
      Array.from(container.children).forEach((row, i) => {
        const labels = row.querySelectorAll('label');
        const inputs = row.querySelectorAll('input');
        const button = row.querySelector('button');

        if (labels[0]) labels[0].textContent = `Punch ${i + 1} In`;
        if (labels[1]) labels[1].textContent = `Punch ${i + 1} Out`;
        if (inputs[0]) inputs[0].id = `edit-punch-${i}-in`;
        if (inputs[1]) inputs[1].id = `edit-punch-${i}-out`;
        if (button) button.setAttribute('onclick', `removePunchRow(${i})`);
      });
    }
  };

  function saveDefaultFromModal() {
    const nameInput = document.getElementById('default-name');
    const name = nameInput ? nameInput.value.trim() : '';
    const saveBtn = document.getElementById('btn-save-default');

    if (!name) {
      setStatus('Please enter a name for the default', 'warn');
      return;
    }

    const type = state_defaults.currentDefaultType;
    const formData = state_defaults.currentFormData;

    if (!type || !formData) {
      setStatus('Invalid default data', 'error');
      return;
    }

    // Disable save button and show saving state
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }
    setStatus('Saving default...', 'warn');

    google.script.run
      .withSuccessHandler((result) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Default';
        }

        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          hideModal(createDefaultModal);
          setStatus(`Default "${name}" created`, 'success');
        } else {
          setStatus('Failed to create default', 'error');
        }
      })
      .withFailureHandler((error) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Default';
        }
        setStatus('Failed to create default: ' + error.message, 'error');
      })
      .api_saveEntryDefault(type, name, formData);
  }

  function saveDefaultDetails() {
    const nameInput = document.getElementById('edit-default-name');
    const newName = nameInput ? nameInput.value.trim() : '';

    if (!newName) {
      setStatus('Please enter a name for the default', 'warn');
      return;
    }

    const type = state_defaults.currentDefaultType;
    const oldName = state_defaults.editingDefaultName;

    let formData;
    if (type === 'basic') {
      const hoursInput = document.getElementById('edit-default-hours');
      const hours = Number(hoursInput ? hoursInput.value : '');

      if (!Number.isFinite(hours) || hours <= 0) {
        setStatus('Please enter valid hours', 'warn');
        return;
      }

      formData = {
        duration_minutes: Math.round(hours * 60)
      };
    } else {
      const container = document.getElementById('edit-punch-rows');
      if (!container) return;

      const punches = [];
      Array.from(container.children).forEach((row, i) => {
        const inInput = document.getElementById(`edit-punch-${i}-in`);
        const outInput = document.getElementById(`edit-punch-${i}-out`);
        const inTime = inInput ? inInput.value : '';
        const outTime = outInput ? outInput.value : '';

        if (inTime && outTime) {
          punches.push({ in: inTime, out: outTime });
        }
      });

      if (punches.length === 0) {
        setStatus('Please add at least one complete punch range', 'warn');
        return;
      }

      formData = { punches };
    }

    // Disable save button and show saving state
    const saveBtn = document.getElementById('btn-save-default-details');
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }
    setStatus('Updating default...', 'warn');

    google.script.run
      .withSuccessHandler((result) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Changes';
        }

        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          hideModal(editDefaultDetailsModal);
          setStatus(`Default "${newName}" updated`, 'success');
          // Refresh the edit list if still open
          if (editDefaultsModal && editDefaultsModal.style.display !== 'none') {
            renderEditDefaultsList();
            showModal(editDefaultsModal);
          }
        } else {
          setStatus('Failed to update default', 'error');
        }
      })
      .withFailureHandler((error) => {
        // Re-enable save button
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save Changes';
        }
        setStatus('Failed to update default: ' + error.message, 'error');
      })
      .api_updateEntryDefault(type, oldName, newName, formData);
  }

  function deleteEntryDefault(name, deleteBtn) {
    const type = state_defaults.currentDefaultType;

    // Disable delete button and show deleting state
    if (deleteBtn) {
      deleteBtn.disabled = true;
      deleteBtn.textContent = 'Deleting...';
    }
    setStatus('Deleting default...', 'warn');

    google.script.run
      .withSuccessHandler((result) => {
        // Re-enable delete button
        if (deleteBtn) {
          deleteBtn.disabled = false;
          deleteBtn.textContent = 'Delete';
        }

        if (result && result.success) {
          state_defaults.entryDefaults = result.defaults;
          updateDefaultButtonsVisibility();
          renderEditDefaultsList();
          setStatus(`Default "${name}" deleted`, 'success');
        } else {
          setStatus('Failed to delete default', 'error');
        }
      })
      .withFailureHandler((error) => {
        // Re-enable delete button
        if (deleteBtn) {
          deleteBtn.disabled = false;
          deleteBtn.textContent = 'Delete';
        }
        setStatus('Failed to delete default: ' + error.message, 'error');
      })
      .api_deleteEntryDefault(type, name);
  }

  // Event handlers for default entry buttons
  if (createManualDefaultBtn) {
    createManualDefaultBtn.addEventListener('click', () => handleCreateDefault('basic'));
  }

  if (enterManualDefaultBtn) {
    enterManualDefaultBtn.addEventListener('click', () => handleEnterDefault('basic'));
  }

  if (editManualDefaultsBtn) {
    editManualDefaultsBtn.addEventListener('click', () => handleEditDefaults('basic'));
  }

  if (createPunchDefaultBtn) {
    createPunchDefaultBtn.addEventListener('click', () => handleCreateDefault('advanced'));
  }

  if (enterPunchDefaultBtn) {
    enterPunchDefaultBtn.addEventListener('click', () => handleEnterDefault('advanced'));
  }

  if (editPunchDefaultsBtn) {
    editPunchDefaultsBtn.addEventListener('click', () => handleEditDefaults('advanced'));
  }

  // Modal event handlers
  function setupModalHandlers() {
    // Close buttons
    document.querySelectorAll('.ts-modal-close').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const modal = e.target.closest('.ts-modal');
        if (modal === deductionFormModal) {
          closeDeductionForm();
        } else if (modal === actualIncomeModal) {
          closeActualIncomeModal();
        } else {
          hideModal(modal);
        }
      });
    });

    // Click outside to close
    document.querySelectorAll('.ts-modal').forEach(modal => {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          if (modal === deductionFormModal) {
            closeDeductionForm();
          } else if (modal === actualIncomeModal) {
            closeActualIncomeModal();
          } else {
            hideModal(modal);
          }
        }
      });
    });

    // Specific button handlers
    const cancelCreateBtn = document.getElementById('btn-cancel-create-default');
    if (cancelCreateBtn) {
      cancelCreateBtn.addEventListener('click', () => hideModal(createDefaultModal));
    }

    const closeXeroHelperBtn = document.getElementById('btn-close-xero-helper');
    if (closeXeroHelperBtn && xeroHelperModal) {
      closeXeroHelperBtn.addEventListener('click', () => hideModal(xeroHelperModal));
    }

    const closeMyobHelperBtn = document.getElementById('btn-close-myob-helper');
    if (closeMyobHelperBtn && myobHelperModal) {
      closeMyobHelperBtn.addEventListener('click', () => hideModal(myobHelperModal));
    }

    const saveDefaultBtn = document.getElementById('btn-save-default');
    if (saveDefaultBtn) {
      saveDefaultBtn.addEventListener('click', saveDefaultFromModal);
    }

    const cancelSelectBtn = document.getElementById('btn-cancel-select-default');
    if (cancelSelectBtn) {
      cancelSelectBtn.addEventListener('click', () => hideModal(selectDefaultModal));
    }

    const closeEditBtn = document.getElementById('btn-close-edit-defaults');
    if (closeEditBtn) {
      closeEditBtn.addEventListener('click', () => hideModal(editDefaultsModal));
    }

    const cancelEditDetailsBtn = document.getElementById('btn-cancel-edit-default-details');
    if (cancelEditDetailsBtn) {
      cancelEditDetailsBtn.addEventListener('click', () => {
        hideModal(editDefaultDetailsModal);
        if (editDefaultsModal) showModal(editDefaultsModal);
      });
    }

    const saveDetailsBtn = document.getElementById('btn-save-default-details');
    if (saveDetailsBtn) {
      saveDetailsBtn.addEventListener('click', saveDefaultDetails);
    }

    // Enter key handlers
    const defaultNameInput = document.getElementById('default-name');
    if (defaultNameInput) {
      defaultNameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          saveDefaultFromModal();
        }
      });
    }
  }

  setupModalHandlers();

  // Initialize default entries after all functions are defined
  updateDefaultButtonsVisibility();
  loadEntryDefaults();

  // Hour Types Management
  function generateRandomColor() {
    const colors = [
      '#ef4444', '#f97316', '#f59e0b', '#eab308', '#84cc16', '#22c55e',
      '#10b981', '#14b8a6', '#06b6d4', '#0ea5e9', '#3b82f6', '#6366f1',
      '#8b5cf6', '#a855f7', '#d946ef', '#ec4899', '#f43f5e'
    ];
    return colors[Math.floor(Math.random() * colors.length)];
  }

  function loadHourTypes() {
    if (!state.featureFlags.hour_types) return;

    setStatus('Loading hour types...', 'warn');
    google.script.run
      .withSuccessHandler((hourTypes) => {
        state.hourTypes = Array.isArray(hourTypes) ? hourTypes.map(sanitizeHourType) : [];
        updateHourTypeMap();
        renderHourTypes();
        updateHourTypeFormVisibility();
        renderCalendarFilters();
        renderCalendar();
        saveCache();
        setStatus('Idle');
        maybeAutoPopulatePublicHolidayEntries();
      })
      .withFailureHandler((error) => {
        console.error('Failed to load hour types:', error);
        setStatus('Error loading hour types', 'error');
      })
      .api_getHourTypes();
  }

  function renderHourTypes() {
    const container = document.getElementById('hour-types-list');
    if (!container) return;

    if (state.hourTypes.length === 0) {
      container.innerHTML = '<div class="ts-note">No hour types configured. Click "Add Hour Type" to create your first one.</div>';
      return;
    }

    const html = state.hourTypes.map(hourType => {
      const badges = [];
      if (hourType.is_default) badges.push('<span class="ts-hour-type-badge default">Default</span>');
      if (hourType.contributes_to_income) badges.push('<span class="ts-hour-type-badge income">Income</span>');
      if (hourType.auto_populate_public_holidays) {
        const hoursValue = Number(hourType.auto_populate_hours) || 0;
        const hoursLabel = hoursValue % 1 === 0 ? hoursValue.toFixed(0) : hoursValue.toFixed(2).replace(/0$/, '');
        badges.push(`<span class="ts-hour-type-badge holiday">Public holiday auto (${hoursLabel}h)</span>`);
      }

      const isWork = hourType.slug === 'work';

      return `
        <div class="ts-hour-type-item ${isWork ? 'work' : ''}" data-id="${hourType.id}">
          <div class="ts-hour-type-color" style="background-color: ${hourType.color}"></div>
          <div class="ts-hour-type-info">
            <h4 class="ts-hour-type-name">${hourType.name}${isWork ? ' (Built-in)' : ''}</h4>
            <p class="ts-hour-type-details">Slug: ${hourType.slug}</p>
            <div class="ts-hour-type-badges">${badges.join('')}</div>
          </div>
          <div class="ts-hour-type-actions">
            <button class="ghost small" onclick="editHourType('${hourType.id}')">Edit</button>
            <button class="ghost small danger" onclick="deleteHourType('${hourType.id}')" ${isWork ? 'style="display:none;"' : ''}>Delete</button>
          </div>
        </div>
      `;
    }).join('');

    container.innerHTML = html;
  }

  function loadPublicHolidays(renderAfterLoad = false) {
    if (!state.featureFlags.enable_public_holidays || !state.featureFlags.enable_public_holidays.enabled) return;

    ensureCalendarState();
    const year = state.calendar.year;

    // Background sync with backend
    google.script.run
      .withSuccessHandler((holidays) => {
        const newHolidays = Array.isArray(holidays) ? holidays : [];
        // Only update and re-render if data actually changed
        const oldJson = JSON.stringify(state.publicHolidays);
        const newJson = JSON.stringify(newHolidays);

        if (oldJson !== newJson) {
          state.publicHolidays = newHolidays;
          updatePublicHolidayMap();
          saveCache();
          renderCalendar();
        } else if (renderAfterLoad) {
          renderCalendar();
        }
        maybeAutoPopulatePublicHolidayEntries();
      })
      .withFailureHandler((error) => {
        console.error('Failed to load public holidays:', error);
      })
      .api_getPublicHolidays({ year: year });
  }

  function updatePublicHolidayMap() {
    const map = {};
    state.publicHolidays.forEach(holiday => {
      const normalizedDate = normalizeHolidayDate(holiday.date);
      if (!normalizedDate) return;
      if (holiday.date !== normalizedDate) holiday.date = normalizedDate;
      map[normalizedDate] = holiday;
    });
    state.publicHolidayMap = map;
  }

  function maybeAutoPopulatePublicHolidayEntries() {
    if (state.isAutoPopulatingPublicHolidays) return;
    if (!state.entriesLoaded) return;
    const publicHolidayFeature = getFeatureFlag('enable_public_holidays');
    const hourTypesFeature = getFeatureFlag('hour_types');
    if (!publicHolidayFeature || !hourTypesFeature) return;
    if (!state.publicHolidays.length || !state.hourTypes.length) return;

    const eligibleHourTypes = state.hourTypes.filter(ht => ht.auto_populate_public_holidays && Number(ht.auto_populate_hours) > 0);
    if (!eligibleHourTypes.length) return;

    const entryKeys = new Set(state.entries.map(entry => `${entry.date}__${entry.hour_type_id || getDefaultHourTypeId()}`));

    const queue = [];
    state.publicHolidays.forEach(holiday => {
      const iso = normalizeHolidayDate(holiday.date);
      if (!iso) return;
      const dateObj = parseIsoDate(iso);
      if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) return;
      const day = dateObj.getDay();
      if (day === 0 || day === 6) return; // Skip weekends

      eligibleHourTypes.forEach(hourType => {
        if (hourType.requires_contract) return;
        const key = `${iso}__${hourType.id}`;
        if (entryKeys.has(key)) return;
        entryKeys.add(key);
        queue.push({
          date: iso,
          hourTypeId: hourType.id,
          hours: Number(hourType.auto_populate_hours) || 0
        });
      });
    });

    if (!queue.length) return;

    state.isAutoPopulatingPublicHolidays = true;
    processHolidayAutoPopulateQueue(queue, []);
  }

  function processHolidayAutoPopulateQueue(queue, createdEntries) {
    if (!queue.length) {
      if (createdEntries.length) {
        createdEntries.forEach(entry => {
          state.entries.push(entry);
        });
        saveCache();
        renderEntries();
        updateTabStates();
      }
      state.isAutoPopulatingPublicHolidays = false;
      return;
    }

    const next = queue.shift();
    const minutes = Math.round(next.hours * 60);
    if (!minutes || minutes <= 0) {
      processHolidayAutoPopulateQueue(queue, createdEntries);
      return;
    }

    google.script.run
      .withSuccessHandler((res) => {
        if (res && res.success && res.entry) {
          const sanitized = sanitizeEntry(res.entry);
          createdEntries.push(sanitized);
        }
        processHolidayAutoPopulateQueue(queue, createdEntries);
      })
      .withFailureHandler((error) => {
        processHolidayAutoPopulateQueue(queue, createdEntries);
      })
      .api_addEntry({
        date: next.date,
        duration_minutes: minutes,
        entry_type: 'basic',
        hour_type_id: next.hourTypeId,
        contract_id: ''
      });
  }

  function showHourTypeModal(hourType = null) {
    const modal = document.getElementById('modal-hour-type');
    const title = document.getElementById('hour-type-modal-title');
    const nameInput = document.getElementById('hour-type-name');
    const slugInput = document.getElementById('hour-type-slug');
    const colorInput = document.getElementById('hour-type-color');
    const contributesInput = document.getElementById('hour-type-contributes-income');
    const defaultInput = document.getElementById('hour-type-is-default');

    if (!modal) return;

    state.editingHourTypeId = hourType ? hourType.id : null;
    const isWork = hourType && hourType.slug === 'work';
    const publicHolidayFlag = getFeatureFlag('enable_public_holidays');

    title.textContent = isWork ? 'Work Hour Type Settings' : (hourType ? 'Edit Hour Type' : 'Add Hour Type');
    nameInput.value = hourType ? hourType.name : '';
    slugInput.value = hourType ? hourType.slug : '';
    colorInput.value = hourType ? hourType.color : generateRandomColor();
    contributesInput.checked = hourType ? hourType.contributes_to_income : false;
    defaultInput.checked = hourType ? hourType.is_default : false;

    if (hourTypeAutoHolidayToggle) {
      hourTypeAutoHolidayToggle.checked = hourType ? !!hourType.auto_populate_public_holidays : false;
      hourTypeAutoHolidayToggle.disabled = !publicHolidayFlag;
    }
    if (hourTypeAutoHolidayHoursInput) {
      const hoursValue = hourType && Number(hourType.auto_populate_hours) > 0 ? Number(hourType.auto_populate_hours) : 7.5;
      hourTypeAutoHolidayHoursInput.value = hoursValue;
    }
    if (hourTypeAutoHolidayRow) {
      hourTypeAutoHolidayRow.style.display = publicHolidayFlag ? 'flex' : 'none';
    }
    if (!publicHolidayFlag && hourTypeAutoHolidayHoursRow) {
      hourTypeAutoHolidayHoursRow.style.display = 'none';
    } else {
      syncHourTypeHolidayHoursVisibility();
    }

    // Disable editing core properties of work hour type
    nameInput.disabled = isWork;
    slugInput.disabled = isWork;
    contributesInput.disabled = isWork;

    // For work hour type, only allow changing default status and color
    if (isWork) {
      nameInput.style.opacity = '0.6';
      slugInput.style.opacity = '0.6';
      contributesInput.parentElement.style.opacity = '0.6';
    } else {
      nameInput.style.opacity = '1';
      slugInput.style.opacity = '1';
      contributesInput.parentElement.style.opacity = '1';
    }

    modal.style.display = 'flex';

    // Validate color when modal opens
    setTimeout(function() {
      if (typeof validateHourTypeColor === 'function') {
        validateHourTypeColor();
      }
    }, 50);
  }

  function hideHourTypeModal() {
    const modal = document.getElementById('modal-hour-type');
    if (modal) modal.style.display = 'none';
    state.editingHourTypeId = null;
  }

  function saveHourType() {
    const nameInput = document.getElementById('hour-type-name');
    const slugInput = document.getElementById('hour-type-slug');
    const colorInput = document.getElementById('hour-type-color');
    const contributesInput = document.getElementById('hour-type-contributes-income');
    const defaultInput = document.getElementById('hour-type-is-default');
    const saveBtn = document.getElementById('btn-save-hour-type');

    const name = nameInput.value.trim();
    const slug = slugInput.value.trim().toLowerCase();
    const color = colorInput.value;
    const contributesToIncome = contributesInput.checked;
    const isDefault = defaultInput.checked;

    if (!name || !slug) {
      customAlert('Name and slug are required');
      return;
    }

    // Check slug uniqueness
    const existingType = state.hourTypes.find(ht => ht.slug === slug && ht.id !== state.editingHourTypeId);
    if (existingType) {
      customAlert('A hour type with this slug already exists');
      return;
    }

    const publicHolidayFeatureEnabled = getFeatureFlag('enable_public_holidays');
    const autoPopulateHolidays = publicHolidayFeatureEnabled && hourTypeAutoHolidayToggle && hourTypeAutoHolidayToggle.checked;
    let autoHolidayHours = hourTypeAutoHolidayHoursInput ? parseFloat(hourTypeAutoHolidayHoursInput.value) : 7.5;
    if (Number.isNaN(autoHolidayHours) || autoHolidayHours < 0) autoHolidayHours = 0;
    if (autoPopulateHolidays && autoHolidayHours <= 0) {
      customAlert('Please enter a positive number of hours to apply on public holidays.');
      return;
    }

    saveBtn.textContent = 'Saving...';
    saveBtn.disabled = true;

    const data = {
      name,
      slug,
      color,
      contributes_to_income: contributesToIncome,
      is_default: isDefault,
      auto_populate_public_holidays: autoPopulateHolidays,
      auto_populate_hours: autoPopulateHolidays ? autoHolidayHours : 0
    };

    if (state.editingHourTypeId) {
      // Optimistically update the UI if setting as default
      if (isDefault) {
        // Unset default on all other hour types
        state.hourTypes.forEach(ht => {
          if (ht.id !== state.editingHourTypeId) {
            ht.is_default = false;
          }
        });
        // Set default on this hour type
        const index = state.hourTypes.findIndex(ht => ht.id === state.editingHourTypeId);
        if (index !== -1) {
          state.hourTypes[index] = {
            ...state.hourTypes[index],
            name,
            slug,
            color,
            contributes_to_income: contributesToIncome,
            is_default: true,
            auto_populate_public_holidays: autoPopulateHolidays,
            auto_populate_hours: autoPopulateHolidays ? autoHolidayHours : 0
          };
        }
        updateHourTypeMap();
        renderHourTypes();
      }

      // Update existing
      google.script.run
        .withSuccessHandler((result) => {
          const index = state.hourTypes.findIndex(ht => ht.id === state.editingHourTypeId);
          if (index !== -1) {
            state.hourTypes[index] = sanitizeHourType(result);
          }
          updateHourTypeMap();
          renderHourTypes();
          updateHourTypeFormVisibility();
          renderCalendarFilters();
          renderCalendar();
          saveCache();
          maybeAutoPopulatePublicHolidayEntries();
          hideHourTypeModal();
          setStatus('Hour type updated');
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .withFailureHandler((error) => {
          console.error('Failed to update hour type:', error);
          customAlert('Failed to update hour type: ' + error.message, { title: 'Error' });
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
          // Reload hour types to revert optimistic update
          loadHourTypes();
        })
        .api_updateHourType(state.editingHourTypeId, data);
    } else {
      // Create new
      google.script.run
        .withSuccessHandler((result) => {
          const newHourType = sanitizeHourType(result);
          state.hourTypes.push(newHourType);

          // Add new hour type to calendar filter so it's immediately visible
          if (state.calendarFilteredHourTypes) {
            state.calendarFilteredHourTypes.push(newHourType.id);
          }

          updateHourTypeMap();
          renderHourTypes();
          updateHourTypeFormVisibility();
          renderCalendarFilters();
          renderCalendar();
          saveCache();
          maybeAutoPopulatePublicHolidayEntries();
          hideHourTypeModal();
          setStatus('Hour type created');
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .withFailureHandler((error) => {
          console.error('Failed to create hour type:', error);
          customAlert('Failed to create hour type: ' + error.message, { title: 'Error' });
          saveBtn.textContent = 'Save Hour Type';
          saveBtn.disabled = false;
        })
        .api_createHourType(data);
    }
  }

  function editHourType(id) {
    const hourType = state.hourTypes.find(ht => ht.id === id);
    if (hourType) {
      showHourTypeModal(hourType);
    }
  }

  function deleteHourType(id) {
    const hourType = state.hourTypes.find(ht => ht.id === id);
    if (!hourType) return;

    const modal = document.getElementById('modal-delete-hour-type');
    const nameSpan = document.getElementById('delete-hour-type-name');

    if (!modal || !nameSpan) return;

    nameSpan.textContent = hourType.name;
    modal.style.display = 'flex';

    // Store the ID for the confirm handler
    modal.dataset.hourTypeId = id;
  }

  function confirmDeleteHourType() {
    const modal = document.getElementById('modal-delete-hour-type');
    const confirmBtn = document.getElementById('btn-confirm-delete-hour-type');
    const id = modal.dataset.hourTypeId;

    if (!id) return;

    confirmBtn.textContent = 'Deleting...';
    confirmBtn.disabled = true;

    google.script.run
      .withSuccessHandler(() => {
        state.hourTypes = state.hourTypes.filter(ht => ht.id !== id);

        // Remove from calendar filter
        if (state.calendarFilteredHourTypes) {
          state.calendarFilteredHourTypes = state.calendarFilteredHourTypes.filter(htId => htId !== id);
        }

        updateHourTypeMap();
        renderHourTypes();
        updateHourTypeFormVisibility();
        renderCalendarFilters();
        renderCalendar();
        saveCache();
        modal.style.display = 'none';
        setStatus('Hour type deleted');
        confirmBtn.textContent = 'Delete Hour Type';
        confirmBtn.disabled = false;
      })
      .withFailureHandler((error) => {
        console.error('Failed to delete hour type:', error);
        customAlert('Failed to delete hour type: ' + error.message, { title: 'Error' });
        confirmBtn.textContent = 'Delete Hour Type';
        confirmBtn.disabled = false;
      })
      .api_deleteHourType(id);
  }

  // Hour Types Event Listeners
  const btnAddHourType = document.getElementById('btn-add-hour-type');
  const btnSaveHourType = document.getElementById('btn-save-hour-type');
  const btnCancelHourType = document.getElementById('btn-cancel-hour-type');
  const btnConfirmDeleteHourType = document.getElementById('btn-confirm-delete-hour-type');
  const btnCancelDeleteHourType = document.getElementById('btn-cancel-delete-hour-type');

  if (btnAddHourType) {
    btnAddHourType.addEventListener('click', () => showHourTypeModal());
  }

  if (btnSaveHourType) {
    btnSaveHourType.addEventListener('click', saveHourType);
  }

  if (btnCancelHourType) {
    btnCancelHourType.addEventListener('click', hideHourTypeModal);
  }

  if (btnConfirmDeleteHourType) {
    btnConfirmDeleteHourType.addEventListener('click', confirmDeleteHourType);
  }

  if (btnCancelDeleteHourType) {
    btnCancelDeleteHourType.addEventListener('click', () => {
      document.getElementById('modal-delete-hour-type').style.display = 'none';
    });
  }

  // Custom Theme Event Listeners
  const btnConfigureTheme = document.getElementById('btn-configure-theme');
  const btnSaveCustomTheme = document.getElementById('btn-save-custom-theme');
  const btnCancelCustomTheme = document.getElementById('btn-cancel-custom-theme');
  const modalCustomTheme = document.getElementById('modal-custom-theme');

  function showCustomThemeModal() {
    if (!modalCustomTheme) return;

    // Load saved config or use defaults
    var config = state.settings.custom_theme_config || {
      bg: '#0b1220',
      primary: '#3b82f6',
      text: '#e2e8f0',
      success: '#10b981'
    };

    // Populate inputs with saved values
    const bgInput = document.getElementById('custom-theme-bg');
    const primaryInput = document.getElementById('custom-theme-primary');
    const textInput = document.getElementById('custom-theme-text');
    const successInput = document.getElementById('custom-theme-success');

    if (bgInput) bgInput.value = config.bg;
    if (primaryInput) primaryInput.value = config.primary;
    if (textInput) textInput.value = config.text;
    if (successInput) successInput.value = config.success;

    modalCustomTheme.style.display = 'flex';
  }

  function hideCustomThemeModal() {
    if (modalCustomTheme) {
      modalCustomTheme.style.display = 'none';
    }
  }

  function saveCustomTheme() {
    const bgInput = document.getElementById('custom-theme-bg');
    const primaryInput = document.getElementById('custom-theme-primary');
    const textInput = document.getElementById('custom-theme-text');
    const successInput = document.getElementById('custom-theme-success');

    if (!bgInput || !primaryInput || !textInput || !successInput) return;

    const config = {
      bg: bgInput.value,
      primary: primaryInput.value,
      text: textInput.value,
      success: successInput.value
    };

    // Save to state
    state.settings.custom_theme_config = config;

    // Apply the theme immediately
    applyCustomTheme();

    // Persist to backend
    google.script.run
      .withSuccessHandler(function() {
        showNotification('Custom theme saved successfully', 'success');
        hideCustomThemeModal();
      })
      .withFailureHandler(function(error) {
        showNotification('Failed to save custom theme: ' + error.message, 'danger');
      })
      .api_updateSettings([
        { key: 'custom_theme_config', value: JSON.stringify(config), type: 'string' }
      ]);
  }

  if (btnConfigureTheme) {
    btnConfigureTheme.addEventListener('click', showCustomThemeModal);
  }

  if (btnSaveCustomTheme) {
    btnSaveCustomTheme.addEventListener('click', saveCustomTheme);
  }

  if (btnCancelCustomTheme) {
    btnCancelCustomTheme.addEventListener('click', hideCustomThemeModal);
  }

  // Close modal when clicking outside
  if (modalCustomTheme) {
    modalCustomTheme.addEventListener('click', function(e) {
      if (e.target === modalCustomTheme) {
        hideCustomThemeModal();
      }
    });

    // Close modal on X button
    const closeBtn = modalCustomTheme.querySelector('.ts-modal-close');
    if (closeBtn) {
      closeBtn.addEventListener('click', hideCustomThemeModal);
    }
  }

  // Auto-generate slug from name
  const hourTypeNameInput = document.getElementById('hour-type-name');
  const hourTypeSlugInput = document.getElementById('hour-type-slug');
  const hourTypeAutoHolidayRow = document.getElementById('hour-type-holiday-toggle-row');
  const hourTypeAutoHolidayHoursRow = document.getElementById('hour-type-holiday-hours-row');
  const hourTypeAutoHolidayToggle = document.getElementById('hour-type-auto-public-holidays');
  const hourTypeAutoHolidayHoursInput = document.getElementById('hour-type-holiday-hours');

  function syncHourTypeHolidayHoursVisibility() {
    if (!hourTypeAutoHolidayHoursRow) return;
    const shouldShow = hourTypeAutoHolidayToggle && hourTypeAutoHolidayToggle.checked;
    hourTypeAutoHolidayHoursRow.style.display = shouldShow ? 'flex' : 'none';
  }

  if (hourTypeNameInput && hourTypeSlugInput) {
    hourTypeNameInput.addEventListener('input', () => {
      if (!state.editingHourTypeId) { // Only auto-generate for new hour types
        const slug = hourTypeNameInput.value
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, '')
          .replace(/\s+/g, '-')
          .replace(/-+/g, '-')
          .replace(/^-|-$/g, '');
        hourTypeSlugInput.value = slug;
      }
    });
  }

  if (hourTypeAutoHolidayToggle) {
    hourTypeAutoHolidayToggle.addEventListener('change', syncHourTypeHolidayHoursVisibility);
  }

  // Colorblind color validation
  function isColorProblematicForColorblindness(hexColor) {
    // Convert hex to RGB
    var r = parseInt(hexColor.substr(1, 2), 16);
    var g = parseInt(hexColor.substr(3, 2), 16);
    var b = parseInt(hexColor.substr(5, 2), 16);

    // Problematic colors for colorblindness are typically:
    // 1. Pure or near-pure reds (high R, low G and B)
    // 2. Pure or near-pure greens (high G, low R and B)
    // 3. Red-green combinations or similar values for R and G with low B
    // 4. Browns and muddy colors (R and G similar, relatively low B)

    var maxComponent = Math.max(r, g, b);
    var minComponent = Math.min(r, g, b);
    var range = maxComponent - minComponent;

    // Pure or near-pure red
    if (r > 150 && g < 100 && b < 100) return true;

    // Pure or near-pure green
    if (g > 150 && r < 100 && b < 100) return true;

    // Red-green similar with low blue (brown/muddy colors)
    if (Math.abs(r - g) < 50 && r > 80 && g > 80 && b < 100) return true;

    // Low saturation colors in the red-green range
    if (range < 60 && r > 60 && g > 60 && Math.abs(r - g) < 40) return true;

    return false;
  }

  function validateHourTypeColor() {
    var colorblindFlag = state.featureFlags.enable_colorblind_themes || DEFAULT_FEATURE_FLAGS.enable_colorblind_themes || { enabled: false };
    if (!colorblindFlag.enabled) return;

    var colorInput = document.getElementById('hour-type-color');
    var warningEl = document.getElementById('hour-type-color-warning');

    if (!colorInput || !warningEl) return;

    var color = colorInput.value;
    var isProblematic = isColorProblematicForColorblindness(color);

    warningEl.style.display = isProblematic ? 'flex' : 'none';
  }

  var hourTypeColorInput = document.getElementById('hour-type-color');
  if (hourTypeColorInput) {
    hourTypeColorInput.addEventListener('input', validateHourTypeColor);
    hourTypeColorInput.addEventListener('change', validateHourTypeColor);
  }

  // Close modals when clicking close button or outside
  document.addEventListener('click', (event) => {
    if (event.target.classList.contains('ts-modal-close')) {
      const modal = event.target.closest('.ts-modal');
      if (modal) modal.style.display = 'none';
    }
    if (event.target.classList.contains('ts-modal')) {
      event.target.style.display = 'none';
    }
  });

  // Hour Type Form Management
  function updateHourTypeFormVisibility() {
    const hourTypesEnabled = !!(state.featureFlags.hour_types && state.featureFlags.hour_types.enabled);
    const hasMultipleTypes = state.hourTypes.length > 1;
    const shouldShow = hourTypesEnabled && hasMultipleTypes;

    if (manualHourTypeCol) {
      manualHourTypeCol.style.display = shouldShow ? 'block' : 'none';
    }
    if (punchHourTypeCol) {
      punchHourTypeCol.style.display = shouldShow ? 'block' : 'none';
    }

    if (shouldShow) {
      populateHourTypeOptions();
    }
  }

  function populateHourTypeOptions() {
    if (!state.hourTypes.length) return;

    [manualHourType, punchHourType].forEach(select => {
      if (!select) return;

      const currentValue = select.value;
      select.innerHTML = '';

      state.hourTypes.forEach(hourType => {
        const option = document.createElement('option');
        option.value = hourType.id;
        option.textContent = hourType.name;
        if (hourType.is_default && !currentValue) {
          option.selected = true;
        }
        select.appendChild(option);
      });

      // Restore previous selection if it still exists
      if (currentValue && state.hourTypeMap[currentValue]) {
        select.value = currentValue;
      }

      // Update contract visibility when hour type changes
      if (select === manualHourType) {
        updateManualContractVisibility();
      } else if (select === punchHourType) {
        updatePunchContractVisibility();
      }
    });
  }

  function updateManualContractVisibility() {
    if (!manualHourType || !manualContract) return;

    const selectedHourType = state.hourTypeMap[manualHourType.value];
    if (selectedHourType && !selectedHourType.requires_contract) {
      // Show "Not required" for non-contract hour types
      manualContract.innerHTML = '<option value="">Not required (optional)</option>';
      const validContracts = validContractsForDate(manualDate ? manualDate.value : todayIso());
      validContracts.forEach(contract => {
        const option = document.createElement('option');
        option.value = contract.id;
        option.textContent = contract.name;
        manualContract.appendChild(option);
      });
      manualContract.value = '';
      manualContract.disabled = false;
      manualContract.style.fontStyle = 'italic';
      manualContract.style.opacity = '0.8';
      if (manualContractWarning) manualContractWarning.style.display = 'none';
    } else {
      // Normal contract requirement
      manualContract.style.fontStyle = 'normal';
      manualContract.style.opacity = '1';
      updateManualContractOptions();
    }
    updateBasicSaveEnabled();
  }

  function updatePunchContractVisibility() {
    if (!punchHourType || !punchContract) return;

    const selectedHourType = state.hourTypeMap[punchHourType.value];
    if (selectedHourType && !selectedHourType.requires_contract) {
      // Show "Not required" for non-contract hour types
      punchContract.innerHTML = '<option value="">Not required (optional)</option>';
      const validContracts = validContractsForDate(punchDate ? punchDate.value : todayIso());
      validContracts.forEach(contract => {
        const option = document.createElement('option');
        option.value = contract.id;
        option.textContent = contract.name;
        punchContract.appendChild(option);
      });
      punchContract.value = '';
      punchContract.disabled = false;
      punchContract.style.fontStyle = 'italic';
      punchContract.style.opacity = '0.8';
      if (punchContractWarning) punchContractWarning.style.display = 'none';
    } else {
      // Normal contract requirement
      punchContract.style.fontStyle = 'normal';
      punchContract.style.opacity = '1';
      updatePunchContractOptions();
    }
  }

  function getDefaultHourTypeId() {
    if (!state.hourTypes.length) return null;
    const defaultType = state.hourTypes.find(ht => ht.is_default);
    return defaultType ? defaultType.id : state.hourTypes[0].id;
  }

  function findEntryForDateAndHourType(dateIso, hourTypeId) {
    if (!dateIso) return null;
    const fallbackHourTypeId = getDefaultHourTypeId();
    const targetHourTypeId = hourTypeId || fallbackHourTypeId;
    return state.entries.find(entry => {
      if (entry.date !== dateIso) return false;
      const entryHourTypeId = entry.hour_type_id || fallbackHourTypeId;
      return entryHourTypeId === targetHourTypeId;
    }) || null;
  }

  // Event listeners for hour type changes
  if (manualHourType) {
    manualHourType.addEventListener('change', () => {
      updateManualContractVisibility();
      handleManualHourTypeChange();
    });
  }

  if (punchHourType) {
    punchHourType.addEventListener('change', () => {
      updatePunchContractVisibility();
      handlePunchHourTypeChange();
    });
  }

  function handleManualHourTypeChange() {
    if (!manualHourType || !manualDate) return;

    const selectedHourTypeId = manualHourType.value || getDefaultHourTypeId();
    const currentDate = manualDate.value;

    if (!currentDate) return;

    const existingEntry = findEntryForDateAndHourType(currentDate, selectedHourTypeId);

    if (existingEntry) {
      const entryType = resolveEntryType(existingEntry);

      if (entryType === 'advanced') {
        if (punchHourType) punchHourType.value = selectedHourTypeId;
        if (punchDate) punchDate.value = currentDate;
        state.selectedCalendarDate = currentDate;
        activateTab('punch');
        return;
      }

      populateManualForm(existingEntry, true);
    } else {
      // Clear the form for new entry but keep date and hour type
      const currentHourType = manualHourType.value;
      clearManualEditing();
      if (manualDate) manualDate.value = currentDate;
      if (manualHourType) manualHourType.value = currentHourType;
      updateManualContractVisibility();
    }

    // Update tab states to enable/disable the other tab
    updateTabStates();
  }

  function handlePunchHourTypeChange() {
    if (!punchHourType || !punchDate || !punchContract) return;

    const selectedHourTypeId = punchHourType.value || getDefaultHourTypeId();
    const currentDate = punchDate.value;

    if (!currentDate) return;

    const existingEntry = findEntryForDateAndHourType(currentDate, selectedHourTypeId);

    if (existingEntry) {
      const entryType = resolveEntryType(existingEntry);

      if (entryType === 'basic') {
        if (manualDate) manualDate.value = currentDate;
        if (manualHourType) manualHourType.value = selectedHourTypeId;
        state.selectedCalendarDate = currentDate;
        activateTab('manual');
        return;
      }

      // Load the existing advanced entry
      state.editingEntryId = existingEntry.id;
      state.editingEntryType = entryType;

      if (punchContract) {
        updatePunchContractOptions(existingEntry.contract_id);
        punchContract.value = existingEntry.contract_id || '';
      }

      state.punchDraft = {
        entryId: existingEntry.id,
        contractId: existingEntry.contract_id || '',
        date: existingEntry.date,
        punches: clonePunches(existingEntry.punches || []),
        dirty: false
      };

      renderPunchDraft();
      updatePunchSummary();
    } else {
      // Clear for new entry but keep date and hour type
      const currentHourType = punchHourType.value;
      state.editingEntryId = null;
      state.editingEntryType = null;

      updatePunchContractOptions();

      state.punchDraft = {
        entryId: null,
        contractId: punchContract.value || '',
        date: currentDate,
        punches: [{ in: '', out: '' }],
        dirty: false
      };

      if (punchHourType) punchHourType.value = currentHourType;
      renderPunchDraft();
      updatePunchSummary();
    }

    updatePunchContractVisibility();

    // Update tab states to enable/disable the other tab
    updateTabStates();
  }

  // Call the main init function
  init();
</script>
