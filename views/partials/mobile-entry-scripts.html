<script>
  (function () {
    const {
      clampRoundInterval,
      contractIsValid,
      entryCompositeKey,
      isoDateTime,
      minutesToTime,
      normalizePunchList,
      roundDuration,
      sanitizeEntry,
      summarizePunches,
      timeToMinutes,
      todayIso
    } = window.entryCore || {};

    const mobileShell = window.mobileShell || {};
    const run = mobileShell.run || ((fn, payload) => new Promise((resolve) => {
      const handler = (res) => resolve(res);
      const runner = google.script.run.withSuccessHandler(handler).withFailureHandler(() => resolve(null));
      if (typeof runner[fn] === 'function') runner[fn](payload);
      else resolve(null);
    }));

    const CACHE_KEY = 'ts_mobile_entry_cache_v1';
    const CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24h

    const dom = {
      status: document.getElementById('mobile-status'),
      date: document.getElementById('mobile-date'),
      dateLabel: document.getElementById('mobile-date-label'),
      datePrev: document.getElementById('mobile-date-prev'),
      dateNext: document.getElementById('mobile-date-next'),
      dayCard: document.getElementById('mobile-day-card'),
      dayNumber: document.getElementById('mobile-day-number'),
      dayTotal: document.getElementById('mobile-day-total'),
      dayHourTypes: document.getElementById('mobile-day-hour-types'),
      datePicker: document.getElementById('mobile-date-picker'),
      datePickerClose: document.getElementById('mobile-date-picker-close'),
      dateMonthPrev: document.getElementById('mobile-date-month-prev'),
      dateMonthNext: document.getElementById('mobile-date-month-next'),
      dateMonthLabel: document.getElementById('mobile-date-month-label'),
      dateWeekdays: document.getElementById('mobile-day-picker-weekdays'),
      dateGrid: document.getElementById('mobile-day-picker-grid'),
      tabManual: document.getElementById('mobile-tab-manual'),
      tabPunch: document.getElementById('mobile-tab-punch'),
      manualHourType: document.getElementById('mobile-manual-hour-type'),
      manualHourTypeCol: document.getElementById('mobile-manual-hour-type-col'),
      manualContract: document.getElementById('mobile-manual-contract'),
      manualContractWarning: document.getElementById('mobile-manual-contract-warning'),
      punchHourType: document.getElementById('mobile-punch-hour-type'),
      punchHourTypeCol: document.getElementById('mobile-punch-hour-type-col'),
      punchContract: document.getElementById('mobile-punch-contract'),
      punchContractWarning: document.getElementById('mobile-punch-contract-warning'),
      panelManual: document.getElementById('mobile-panel-manual'),
      panelPunch: document.getElementById('mobile-panel-punch'),
      hours: document.getElementById('mobile-hours'),
      punchList: document.getElementById('mobile-punch-list'),
      punchSummary: document.getElementById('mobile-punch-summary'),
      punchWarning: document.getElementById('mobile-punch-warning'),
      punchSuggestion: document.getElementById('mobile-punch-suggestion'),
      punchToggle: document.getElementById('mobile-punch-toggle'),
      punchSave: document.getElementById('mobile-punch-save'),
      punchDiscard: document.getElementById('mobile-punch-discard'),
      punchDelete: document.getElementById('mobile-delete-punch'),
      manualSave: document.getElementById('mobile-save'),
      manualDelete: document.getElementById('mobile-delete'),
      manualCancel: document.getElementById('mobile-cancel-edit')
    };

    const state = {
      currentDate: todayIso(),
      mode: 'manual',
      settings: {},
      featureFlags: {},
      contracts: [],
      hourTypes: [],
      hourTypeMap: {},
      entryCache: {},
      entries: [],
      draftHours: '',
      draftPunches: [{ in: '', out: '' }],
      currentEntry: null,
      selectedHourTypeId: '',
      loading: false,
      staticLoaded: false,
      prefetchedRange: null,
      cacheHydrated: false,
      punchDirty: false,
      datePicker: { year: null, month: null }
    };

    const setStatus = (message, tone = 'info') => {
      if (!dom.status) return;
      dom.status.textContent = message || '';
      dom.status.className = 'ts-mobile-row ts-mobile-status';
      if (tone === 'error') dom.status.classList.add('ts-warning');
      else dom.status.classList.add('ts-note');
    };

    const formatDateLabel = (iso) => {
      if (!iso) return '--/--/----';
      const parts = iso.split('-');
      if (parts.length !== 3) return '--/--/----';
      return `${parts[2]}/${parts[1]}/${parts[0]}`;
    };

    const formatDayNumber = (iso) => {
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return '--';
      return String(d.getDate());
    };

    const shiftIso = (iso, deltaDays) => {
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return todayIso();
      d.setDate(d.getDate() + deltaDays);
      return d.toISOString().slice(0, 10);
    };

    const daysInMonth = (year, month) => new Date(year, month + 1, 0).getDate();
    const weekdayLabels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

    const defaultHourTypeId = () => {
      if (!state.hourTypes.length) return '';
      const preferred = state.hourTypes.find((ht) => ht.is_default);
      return (preferred || state.hourTypes[0]).id;
    };

    const hourTypesEnabled = () => {
      const flag = state.featureFlags.hour_types || {};
      return !!flag.enabled && state.hourTypes.length > 1;
    };

    const roundInterval = () => clampRoundInterval(state.settings ? state.settings.round_to_nearest : 0);

    const formatHours = (minutes) => {
      const total = Math.max(0, Math.round(Number(minutes) || 0));
      return (total / 60).toFixed(2);
    };

    const validContractsForDate = (dateIso) => state.contracts.filter((c) => contractIsValid(c, dateIso));

    const renderHourTypeSelect = (select) => {
      if (!select) return;
      select.innerHTML = '';
      state.hourTypes.forEach((ht) => {
        const opt = document.createElement('option');
        opt.value = ht.id;
        opt.textContent = ht.name || 'Work';
        select.appendChild(opt);
      });
    };

    const syncHourTypeSelects = (hourTypeId) => {
      const target = hourTypeId || defaultHourTypeId();
      if (dom.manualHourType) dom.manualHourType.value = target;
      if (dom.punchHourType) dom.punchHourType.value = target;
    };

    const renderHourTypes = () => {
      renderHourTypeSelect(dom.manualHourType);
      renderHourTypeSelect(dom.punchHourType);
      const shouldShow = hourTypesEnabled();
      if (!shouldShow) state.selectedHourTypeId = defaultHourTypeId();
      const selected = state.selectedHourTypeId || defaultHourTypeId();
      syncHourTypeSelects(selected);
      if (dom.manualHourTypeCol) dom.manualHourTypeCol.style.display = shouldShow ? 'block' : 'none';
      if (dom.punchHourTypeCol) dom.punchHourTypeCol.style.display = shouldShow ? 'block' : 'none';
    };

    const renderContractsForSelect = (select, warningEl, hourTypeId, preferredContractId) => {
      if (!select) return;
      const dateIso = state.currentDate;
      const hourType = state.hourTypeMap[hourTypeId || defaultHourTypeId()] || {};
      const requiresContract = !!hourType.requires_contract;
      const valid = validContractsForDate(dateIso);
      select.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = requiresContract ? 'Select contract' : (valid.length ? 'Not required (optional)' : 'Not required');
      select.appendChild(placeholder);
      valid.forEach((c) => {
        const option = document.createElement('option');
        option.value = c.id;
        option.textContent = c.name;
        select.appendChild(option);
      });
      const preferred = preferredContractId || '';
      const fallback = preferred && valid.some((c) => c.id === preferred) ? preferred : '';
      select.value = fallback || (valid[0] ? valid[0].id : '');
      select.disabled = requiresContract && !valid.length;
      if (warningEl) warningEl.style.display = requiresContract && !select.value ? 'block' : 'none';
    };

    const renderContracts = (opts = {}) => {
      const hourTypeId = state.selectedHourTypeId || defaultHourTypeId();
      const manualPreferred = opts.manualPreferred != null
        ? opts.manualPreferred
        : (dom.manualContract ? dom.manualContract.value : (state.currentEntry?.contract_id || ''));
      const punchPreferred = opts.punchPreferred != null
        ? opts.punchPreferred
        : (dom.punchContract ? dom.punchContract.value : (state.currentEntry?.contract_id || ''));
      renderContractsForSelect(dom.manualContract, dom.manualContractWarning, hourTypeId, manualPreferred);
      renderContractsForSelect(dom.punchContract, dom.punchContractWarning, hourTypeId, punchPreferred);
    };

    const entryTypeForMode = (mode) => (mode === 'punch' ? 'advanced' : 'basic');

    const findExistingForHourType = () => {
      const hourTypeId = state.selectedHourTypeId || defaultHourTypeId();
      return state.entries.find((e) => (e.hour_type_id || defaultHourTypeId()) === hourTypeId && e.date === state.currentDate) || null;
    };

    const syncTabAvailability = () => {
      const entry = findExistingForHourType();
      const entryType = entry ? (entry.entry_type || 'basic') : null;
      const basicAllowed = !entryType || entryType === 'basic';
      const punchAllowed = !entryType || entryType === 'advanced';
      if (dom.tabManual) dom.tabManual.classList.toggle('disabled', !basicAllowed);
      if (dom.tabPunch) dom.tabPunch.classList.toggle('disabled', !punchAllowed);
    };

    const updateManualActions = () => {
      if (!dom.manualSave) return;
      const isEdit = !!state.currentEntry && entryTypeForMode('manual') === (state.currentEntry.entry_type || 'basic');
      dom.manualSave.textContent = isEdit ? 'Update Entry' : 'Add Entry';
      if (dom.manualDelete) dom.manualDelete.style.display = isEdit ? 'inline-flex' : 'none';
      if (dom.manualCancel) dom.manualCancel.style.display = isEdit ? 'inline-flex' : 'none';
    };

    const updatePunchActions = () => {
      if (dom.punchSave) dom.punchSave.textContent = state.currentEntry ? 'Update Entry' : 'Add Entry';
      if (dom.punchDelete) dom.punchDelete.style.display = state.currentEntry ? 'inline-flex' : 'none';
      if (dom.punchDiscard) dom.punchDiscard.style.display = state.punchDirty ? 'inline-flex' : 'none';
    };

    const setMode = (mode, opts = {}) => {
      const targetMode = mode === 'punch' ? 'punch' : 'manual';
      const targetEntryType = entryTypeForMode(targetMode);
      if (!opts.force) {
        const entry = findExistingForHourType();
        const entryType = entry ? (entry.entry_type || 'basic') : null;
        if (entryType && entryType !== targetEntryType) {
          const label = entryType === 'advanced' ? 'Advanced' : 'Basic';
          setStatus(`This hour type uses ${label} entry. Switch hour type to change input mode.`, 'error');
          syncTabAvailability();
          return;
        }
      }
      state.mode = targetMode;
      if (dom.tabManual) dom.tabManual.classList.toggle('active', state.mode === 'manual');
      if (dom.tabPunch) dom.tabPunch.classList.toggle('active', state.mode === 'punch');
      if (dom.panelManual) dom.panelManual.style.display = state.mode === 'manual' ? 'block' : 'none';
      if (dom.panelPunch) dom.panelPunch.style.display = state.mode === 'punch' ? 'block' : 'none';
      updateManualActions();
      updatePunchActions();
      syncTabAvailability();
    };

    const sortHourTypeIds = (ids) => {
      const order = state.hourTypes.reduce((map, ht, idx) => {
        if (ht && ht.id) map[ht.id] = idx;
        return map;
      }, {});
      return ids.slice().sort((a, b) => {
        const orderA = Number.isInteger(order[a]) ? order[a] : Number.MAX_SAFE_INTEGER;
        const orderB = Number.isInteger(order[b]) ? order[b] : Number.MAX_SAFE_INTEGER;
        if (orderA !== orderB) return orderA - orderB;
        const nameA = state.hourTypeMap[a]?.name || '';
        const nameB = state.hourTypeMap[b]?.name || '';
        return nameA.localeCompare(nameB);
      });
    };

    const renderDayCard = () => {
      if (dom.dayNumber) dom.dayNumber.textContent = formatDayNumber(state.currentDate);
      if (!dom.dayTotal || !dom.dayHourTypes) return;
      dom.dayHourTypes.innerHTML = '';
      dom.dayTotal.textContent = '';
      if (!dom.dayCard) return;
      dom.dayCard.classList.remove('has-entries');
      const totals = state.entries.reduce((map, entry) => {
        if (!entry || entry.date !== state.currentDate) return map;
        const hourTypeId = entry.hour_type_id || defaultHourTypeId();
        map[hourTypeId] = (map[hourTypeId] || 0) + (Number(entry.duration_minutes) || 0);
        return map;
      }, {});
      const totalMinutes = Object.keys(totals).reduce((acc, key) => acc + totals[key], 0);
      if (totalMinutes > 0) dom.dayCard.classList.add('has-entries');
      if (!hourTypesEnabled() || !Object.keys(totals).length) {
        if (totalMinutes > 0) {
          dom.dayTotal.textContent = formatHours(roundDuration(totalMinutes, roundInterval()));
        }
        return;
      }
      const defaultId = defaultHourTypeId();
      const defaultMinutes = totals[defaultId] || 0;
      const otherIds = sortHourTypeIds(Object.keys(totals).filter((id) => id !== defaultId && totals[id] > 0));
      otherIds.forEach((hourTypeId) => {
        const hourType = state.hourTypeMap[hourTypeId];
        if (!hourType) return;
        const chip = document.createElement('span');
        chip.className = 'ts-calendar-hour-type-indicator';
        if (hourTypeId === state.selectedHourTypeId) chip.classList.add('active');
        chip.style.color = hourType.color;
        chip.textContent = formatHours(roundDuration(totals[hourTypeId], roundInterval()));
        chip.title = `${hourType.name}: ${chip.textContent}`;
        chip.dataset.hourTypeId = hourTypeId;
        chip.addEventListener('click', (event) => {
          event.stopPropagation();
          selectHourType(hourTypeId);
        });
        dom.dayHourTypes.appendChild(chip);
      });
      if (defaultMinutes > 0 || !otherIds.length) {
        dom.dayTotal.textContent = defaultMinutes > 0
          ? formatHours(roundDuration(defaultMinutes, roundInterval()))
          : '';
      }
    };

    const openDatePicker = () => {
      const current = new Date(state.currentDate);
      if (Number.isNaN(current.getTime())) return;
      state.datePicker.year = current.getFullYear();
      state.datePicker.month = current.getMonth();
      renderDatePicker();
      if (dom.datePicker) dom.datePicker.style.display = 'flex';
    };

    const closeDatePicker = () => {
      if (dom.datePicker) dom.datePicker.style.display = 'none';
    };

    const renderDatePicker = () => {
      if (!dom.dateGrid || !dom.dateMonthLabel) return;
      const year = state.datePicker.year;
      const month = state.datePicker.month;
      if (year == null || month == null) return;
      const labelDate = new Date(year, month, 1);
      dom.dateMonthLabel.textContent = labelDate.toLocaleDateString(undefined, { month: 'long', year: 'numeric' });
      dom.dateGrid.innerHTML = '';
      if (dom.dateWeekdays) {
        dom.dateWeekdays.innerHTML = '';
        weekdayLabels.forEach((label) => {
          const el = document.createElement('div');
          el.className = 'ts-day-picker-weekday';
          el.textContent = label;
          dom.dateWeekdays.appendChild(el);
        });
      }
      const totalDays = daysInMonth(year, month);
      const firstDay = new Date(year, month, 1);
      const offset = (firstDay.getDay() + 6) % 7; // Monday start
      for (let i = 0; i < offset; i += 1) {
        const empty = document.createElement('div');
        empty.className = 'ts-day-picker-cell empty';
        dom.dateGrid.appendChild(empty);
      }
      for (let day = 1; day <= totalDays; day += 1) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'ts-day-picker-cell';
        btn.textContent = String(day);
        const iso = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        if (iso === state.currentDate) btn.classList.add('active');
        btn.onclick = () => {
          closeDatePicker();
          hydrateDate(iso);
        };
        dom.dateGrid.appendChild(btn);
      }
    };

    const renderPunchList = () => {
      if (!dom.punchList) return;
      const punches = state.draftPunches || [];
      dom.punchList.innerHTML = '';
      const ensureRow = () => {
        if (!state.draftPunches.length) state.draftPunches.push({ in: '', out: '' });
      };
      if (!punches.length || (punches.length === 1 && !punches[0].in && !punches[0].out)) {
        ensureRow();
      }
      state.draftPunches.forEach((punch, index) => {
        const row = document.createElement('div');
        row.className = 'ts-punch-row';

        const start = document.createElement('input');
        start.type = 'time';
        start.value = punch.in || '';
        start.className = 'ts-punch-input';
        start.onchange = () => {
          state.draftPunches[index].in = start.value;
          state.punchDirty = true;
          updatePunchSummary();
        };

        const end = document.createElement('input');
        end.type = 'time';
        end.value = punch.out || '';
        end.className = 'ts-punch-input';
        end.onchange = () => {
          state.draftPunches[index].out = end.value;
          state.punchDirty = true;
          updatePunchSummary();
        };

        const add = document.createElement('button');
        add.type = 'button';
        add.className = 'ghost';
        add.textContent = 'Add';
        add.onclick = () => {
          state.draftPunches.splice(index + 1, 0, { in: '', out: '' });
          state.punchDirty = true;
          renderPunchList();
        };

        const remove = document.createElement('button');
        remove.type = 'button';
        remove.className = 'ghost';
        remove.textContent = 'Remove';
        remove.onclick = () => {
          state.draftPunches.splice(index, 1);
          if (!state.draftPunches.length) state.draftPunches.push({ in: '', out: '' });
          state.punchDirty = true;
          renderPunchList();
        };

        row.appendChild(start);
        row.appendChild(document.createTextNode(' to '));
        row.appendChild(end);
        row.appendChild(add);
        row.appendChild(remove);
        dom.punchList.appendChild(row);
      });
      updatePunchSummary();
    };

    const togglePunch = () => {
      const now = new Date();
      const nowTime = now.toTimeString().slice(0, 5);
      const punches = state.draftPunches || [];
      const open = punches.find((p) => p.in && !p.out);
      if (open) {
        open.out = nowTime;
      } else {
        punches.push({ in: nowTime, out: '' });
      }
      state.draftPunches = punches;
      state.punchDirty = true;
      renderPunchList();
    };

    const validatePunches = (punches) => {
      const sorted = normalizePunchList(punches);
      let lastEnd = null;
      for (let i = 0; i < sorted.length; i += 1) {
        const punch = sorted[i];
        const startMinutes = timeToMinutes(punch.in);
        if (startMinutes === null) return 'Each punch needs a start time.';
        const endMinutes = timeToMinutes(punch.out);
        if (endMinutes !== null && endMinutes <= startMinutes) return 'Punch end must be after start.';
        if (lastEnd !== null && startMinutes < lastEnd) return 'Punches cannot overlap.';
        if (endMinutes !== null) lastEnd = endMinutes;
      }
      return '';
    };

    const updatePunchSummary = () => {
      const punches = normalizePunchList(state.draftPunches);
      const summary = summarizePunches(punches);
      if (dom.punchSummary) {
        const rounded = roundDuration(summary.totalMinutes, roundInterval());
        dom.punchSummary.textContent = punches.length ? `Recorded: ${formatHours(rounded)} hours` : '';
      }
      if (dom.punchWarning) {
        dom.punchWarning.style.display = summary.openCount > 0 ? 'block' : 'none';
        dom.punchWarning.textContent = summary.openCount > 0 ? 'Open punch detected. Remember to punch out.' : '';
      }
      if (dom.punchSuggestion) dom.punchSuggestion.style.display = 'none';
      if (dom.punchToggle) dom.punchToggle.textContent = summary.openCount > 0 ? 'Punch Out' : 'Punch In';
      const requiresContract = (state.hourTypeMap[state.selectedHourTypeId] || {}).requires_contract;
      const hasContract = dom.punchContract ? !!dom.punchContract.value : true;
      const hasPunches = punches.some((p) => p.in);
      if (dom.punchToggle) dom.punchToggle.disabled = requiresContract && !hasContract;
      if (dom.punchSave) dom.punchSave.disabled = (requiresContract && !hasContract) || !hasPunches;
      updatePunchActions();
    };

    const getCachedEntriesForDate = (dateIso) => state.entryCache[dateIso] || [];

    const storeEntries = (entries) => {
      (entries || []).forEach((entry) => {
        if (!entry || !entry.date) return;
        const existing = getCachedEntriesForDate(entry.date).filter((e) => e.id !== entry.id);
        existing.push(entry);
        state.entryCache[entry.date] = existing;
      });
      persistCache();
    };

    const persistCache = () => {
      try {
        const payload = {
          savedAt: Date.now(),
          entries: state.entryCache,
          prefetchedRange: state.prefetchedRange,
          hourTypes: state.hourTypes,
          contracts: state.contracts
        };
        localStorage.setItem(CACHE_KEY, JSON.stringify(payload));
      } catch (err) {
        state.cacheHydrated = false;
      }
    };

    const derivePrefetchedRangeFromCache = () => {
      const dates = Object.keys(state.entryCache || {}).filter(Boolean).sort();
      if (!dates.length) return null;
      return { start: dates[0], end: dates[dates.length - 1] };
    };

    const hydrateCacheFromStorage = () => {
      if (state.cacheHydrated) return;
      try {
        const raw = localStorage.getItem(CACHE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (!parsed || !parsed.savedAt) return;
        const age = Date.now() - parsed.savedAt;
        if (age > CACHE_TTL_MS) {
          localStorage.removeItem(CACHE_KEY);
          return;
        }
        state.entryCache = parsed.entries || {};
        state.prefetchedRange = parsed.prefetchedRange || derivePrefetchedRangeFromCache();
        state.hourTypes = Array.isArray(parsed.hourTypes) ? parsed.hourTypes : state.hourTypes;
        state.hourTypeMap = (state.hourTypes || []).reduce((map, ht) => { map[ht.id] = ht; return map; }, {});
        state.contracts = Array.isArray(parsed.contracts) ? parsed.contracts : state.contracts;
        state.cacheHydrated = true;
      } catch (err) {
        console.log('[mobile] cache hydrate failed', err);
      }
    };

    const hydrateFromDesktopCache = () => {
      if (state.cacheHydrated) return;
      try {
        const raw = localStorage.getItem('ts_cache');
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (!parsed || !Array.isArray(parsed.entries)) return;
        const map = {};
        let minDate = null;
        let maxDate = null;
        parsed.entries.map((e) => sanitizeEntry(e)).forEach((entry) => {
          if (!entry || !entry.date) return;
          if (!map[entry.date]) map[entry.date] = [];
          map[entry.date].push(entry);
          if (!minDate || entry.date < minDate) minDate = entry.date;
          if (!maxDate || entry.date > maxDate) maxDate = entry.date;
        });
        state.entryCache = map;
        state.hourTypes = Array.isArray(parsed.hourTypes) ? parsed.hourTypes.map((ht) => ({ ...ht })) : state.hourTypes;
        state.hourTypeMap = (state.hourTypes || []).reduce((m, ht) => { m[ht.id] = ht; return m; }, {});
        state.contracts = Array.isArray(parsed.contracts) ? parsed.contracts.map((c) => ({ ...c })) : state.contracts;
        state.prefetchedRange = minDate && maxDate ? { start: minDate, end: maxDate } : derivePrefetchedRangeFromCache();
        state.cacheHydrated = true;
        persistCache();
      } catch (err) {
        console.log('[mobile] desktop cache hydrate failed', err);
      }
      if (!state.cacheHydrated) state.cacheHydrated = true;
    };

    const fetchEntriesRange = async (startDate, endDate) => {
      const entries = await run('api_getEntries', { startDate, endDate }) || [];
      const sanitized = entries.map(sanitizeEntry);
      storeEntries(sanitized);
    };

    const rangeCovered = (range, startIso, endIso) => {
      return range && range.start && range.end && range.start <= startIso && range.end >= endIso;
    };

    const cacheCoverageRange = () => derivePrefetchedRangeFromCache() || state.prefetchedRange || null;

    const prefetchRangeForDate = async (centerIso) => {
      const startIso = shiftIso(centerIso, -14);
      const endIso = shiftIso(centerIso, 14);
      const cachedRange = cacheCoverageRange();
      if (rangeCovered(cachedRange, startIso, endIso)) {
        state.prefetchedRange = cachedRange;
        return;
      }
      await fetchEntriesRange(startIso, endIso);
      const currentRange = cacheCoverageRange() || { start: startIso, end: endIso };
      const mergedStart = currentRange.start && currentRange.start < startIso ? currentRange.start : startIso;
      const mergedEnd = currentRange.end && currentRange.end > endIso ? currentRange.end : endIso;
      state.prefetchedRange = { start: mergedStart, end: mergedEnd };
      persistCache();
    };

    const loadEntriesForDate = async (dateIso) => {
      await prefetchRangeForDate(dateIso);
      const cached = getCachedEntriesForDate(dateIso);
      if (cached.length) {
        state.entries = cached;
        return;
      }
      await fetchEntriesRange(dateIso, dateIso);
      state.entries = getCachedEntriesForDate(dateIso);
    };

    const pickEntryForHourType = (hourTypeId) => {
      if (!state.entries.length) return null;
      const targetId = hourTypeId || defaultHourTypeId();
      return state.entries.find((e) => (e.hour_type_id || defaultHourTypeId()) === targetId) || null;
    };

    const selectHourType = (hourTypeId) => {
      state.selectedHourTypeId = hourTypeId || defaultHourTypeId();
      syncHourTypeSelects(state.selectedHourTypeId);
      const entry = pickEntryForHourType(state.selectedHourTypeId);
      hydrateDraftFromEntry(entry, { preserveMode: true });
      renderDayCard();
      syncTabAvailability();
    };

    const hydrateDraftFromEntry = (entry, opts = {}) => {
      state.currentEntry = entry || null;
      const hourTypeId = entry?.hour_type_id || state.selectedHourTypeId || defaultHourTypeId();
      state.selectedHourTypeId = hourTypeId;
      syncHourTypeSelects(hourTypeId);
      const preferredContract = entry?.contract_id || '';
      renderContracts({ manualPreferred: preferredContract, punchPreferred: preferredContract });
      if (entry) {
        if (entry.entry_type === 'advanced') {
          state.mode = 'punch';
          state.draftPunches = entry.punches && entry.punches.length ? entry.punches.map((p) => ({ ...p })) : [{ in: '', out: '' }];
          state.draftHours = '';
          state.punchDirty = false;
        } else {
          state.mode = 'manual';
          const summary = summarizePunches(entry.punches || []);
          const minutes = summary.totalMinutes || Number(entry.duration_minutes) || 0;
          state.draftHours = minutes ? (minutes / 60).toFixed(2) : '';
          state.draftPunches = [{ in: '', out: '' }];
          state.punchDirty = false;
        }
      } else {
        state.draftHours = '';
        state.draftPunches = [{ in: '', out: '' }];
        state.punchDirty = false;
        if (!opts.preserveMode) state.mode = 'manual';
      }
      if (dom.hours) dom.hours.value = state.draftHours;
      renderPunchList();
      setMode(state.mode, { force: true });
    };

    const loadStaticData = async () => {
      if (state.staticLoaded) return true;
      let base = { settings: {}, featureFlags: {} };
      if (mobileShell.loadBaseState) {
        base = await mobileShell.loadBaseState();
      }
      state.settings = base.settings || {};
      state.featureFlags = base.featureFlags || {};
      if (!state.hourTypes.length || !state.contracts.length) {
        const [hourTypes, contracts] = await Promise.all([
          state.hourTypes.length ? Promise.resolve(state.hourTypes) : run('api_getHourTypes'),
          state.contracts.length ? Promise.resolve(state.contracts) : run('api_getContracts')
        ]);
        state.hourTypes = Array.isArray(hourTypes) ? hourTypes : [];
        state.hourTypeMap = state.hourTypes.reduce((map, ht) => { map[ht.id] = ht; return map; }, {});
        state.contracts = Array.isArray(contracts) ? contracts : [];
        persistCache();
      } else {
        state.hourTypeMap = state.hourTypes.reduce((map, ht) => { map[ht.id] = ht; return map; }, {});
      }
      renderHourTypes();
      renderContracts();
      state.staticLoaded = true;
      return true;
    };

    const hydrateDate = async (dateIso) => {
      state.currentDate = dateIso || todayIso();
      if (dom.date) dom.date.value = state.currentDate;
      if (dom.dateLabel) dom.dateLabel.textContent = formatDateLabel(state.currentDate);
      setStatus('Loading...', 'info');
      hydrateCacheFromStorage();
      hydrateFromDesktopCache();
      if (!state.prefetchedRange) state.prefetchedRange = derivePrefetchedRangeFromCache();
      if (!state.cacheHydrated) state.cacheHydrated = true;
      await loadStaticData();
      await loadEntriesForDate(state.currentDate);
      renderHourTypes();
      renderDayCard();
      const entry = pickEntryForHourType(state.selectedHourTypeId || defaultHourTypeId());
      hydrateDraftFromEntry(entry, { preserveMode: true });
      setStatus(state.currentEntry ? 'Loaded existing entry.' : 'Ready to add entry.');
    };

    const findDuplicate = (payload) => {
      const key = entryCompositeKey(payload.date, payload.hour_type_id, payload.contract_id);
      return state.entries.find((e) => entryCompositeKey(e.date, e.hour_type_id, e.contract_id) === key && e.id !== payload.id) || null;
    };

    const getManualPayload = () => {
      const hoursRaw = dom.hours ? dom.hours.value.trim() : '';
      const totalHours = Number(hoursRaw);
      if (!Number.isFinite(totalHours) || totalHours <= 0) {
        setStatus('Enter total hours greater than zero.', 'error');
        return null;
      }
      const minutes = Math.round(totalHours * 60);
      if (minutes > 24 * 60) {
        setStatus('Hours must be within a single day.', 'error');
        return null;
      }
      const hourTypeId = state.selectedHourTypeId || defaultHourTypeId();
      const hourType = state.hourTypeMap[hourTypeId] || {};
      const contractId = dom.manualContract ? dom.manualContract.value : '';
      if (hourType.requires_contract) {
        if (!contractId) {
          setStatus('Select a contract for this hour type.', 'error');
          return null;
        }
        const contract = state.contracts.find((c) => c.id === contractId);
        if (!contract || !contractIsValid(contract, state.currentDate)) {
          setStatus('Selected contract is not valid for this date.', 'error');
          return null;
        }
      }
      const rounded = roundDuration(minutes, roundInterval());
      return {
        id: state.currentEntry ? state.currentEntry.id : undefined,
        date: state.currentDate,
        punches: [{ in: '00:00', out: minutesToTime(rounded) }],
        duration_minutes: rounded,
        contract_id: contractId,
        hour_type_id: hourTypeId,
        round_interval: roundInterval(),
        entry_type: 'basic'
      };
    };

    const getPunchPayload = () => {
      const punches = normalizePunchList(state.draftPunches);
      if (!punches.length) {
        setStatus('Add at least one punch.', 'error');
        return null;
      }
      const validationError = validatePunches(punches);
      if (validationError) {
        setStatus(validationError, 'error');
        return null;
      }
      const hourTypeId = state.selectedHourTypeId || defaultHourTypeId();
      const hourType = state.hourTypeMap[hourTypeId] || {};
      const contractId = dom.punchContract ? dom.punchContract.value : '';
      if (hourType.requires_contract) {
        if (!contractId) {
          setStatus('Select a contract for this hour type.', 'error');
          return null;
        }
        const contract = state.contracts.find((c) => c.id === contractId);
        if (!contract || !contractIsValid(contract, state.currentDate)) {
          setStatus('Selected contract is not valid for this date.', 'error');
          return null;
        }
      }
      const summary = summarizePunches(punches);
      const rounded = roundDuration(summary.totalMinutes, roundInterval());
      return {
        id: state.currentEntry ? state.currentEntry.id : undefined,
        date: state.currentDate,
        punches,
        duration_minutes: rounded,
        contract_id: contractId,
        hour_type_id: hourTypeId,
        round_interval: roundInterval(),
        entry_type: 'advanced'
      };
    };

    const setLoading = (flag) => {
      state.loading = flag;
      [dom.manualSave, dom.manualDelete, dom.manualCancel, dom.punchToggle, dom.punchSave, dom.punchDelete, dom.punchDiscard, dom.datePrev, dom.dateNext].forEach((el) => {
        if (!el) return;
        el.disabled = flag;
      });
    };

    const saveEntry = async () => {
      if (state.loading) return;
      const payload = state.mode === 'punch' ? getPunchPayload() : getManualPayload();
      if (!payload) return;
      const duplicate = findDuplicate(payload);
      if (duplicate) {
        setStatus('An entry for this date/hour type already exists.', 'error');
        hydrateDraftFromEntry(duplicate);
        return;
      }
      setLoading(true);
      setStatus('Saving...', 'info');
      const isUpdate = !!payload.id;
      const fn = isUpdate ? 'api_updateEntry' : 'api_addEntry';
      const optimisticId = payload.id || ('temp_' + Date.now());
      const optimistic = sanitizeEntry({ ...payload, id: optimisticId, created_at: isoDateTime(new Date()) });
      if (!isUpdate) {
        state.entries.push(optimistic);
        storeEntries([optimistic]);
      }
      const res = await run(fn, payload);
      if (res && res.success && res.entry) {
        const confirmed = sanitizeEntry(res.entry);
        storeEntries([confirmed]);
        state.entries = getCachedEntriesForDate(state.currentDate);
        hydrateDraftFromEntry(confirmed);
        renderDayCard();
        setStatus('Saved.', 'success');
      } else {
        if (!isUpdate) {
          const filtered = getCachedEntriesForDate(state.currentDate).filter((e) => e.id !== optimisticId);
          state.entryCache[state.currentDate] = filtered;
          state.entries = filtered;
        }
        setStatus('Save failed. Please try again.', 'error');
      }
      setLoading(false);
    };

    const deleteEntry = async () => {
      if (state.loading) return;
      if (!state.currentEntry) {
        setStatus('Nothing to delete.', 'error');
        return;
      }
      setLoading(true);
      setStatus('Deleting...', 'info');
      const id = state.currentEntry.id;
      const res = await run('api_deleteEntry', id);
      if (res === null) {
        setStatus('Delete failed. Please try again.', 'error');
      } else {
        const filtered = getCachedEntriesForDate(state.currentDate).filter((e) => e.id !== id);
        state.entryCache[state.currentDate] = filtered;
        state.entries = filtered;
        state.currentEntry = null;
        state.draftHours = '';
        state.draftPunches = [{ in: '', out: '' }];
        state.punchDirty = false;
        hydrateDraftFromEntry(null, { preserveMode: true });
        renderDayCard();
        setStatus('Deleted.', 'success');
      }
      setLoading(false);
    };

    const cancelManualEdit = () => {
      state.currentEntry = null;
      state.draftHours = '';
      state.draftPunches = [{ in: '', out: '' }];
      state.punchDirty = false;
      renderContracts();
      renderPunchList();
      if (dom.hours) dom.hours.value = '';
      setMode('manual');
      setStatus('Ready to add entry.', 'info');
    };

    const discardPunchChanges = () => {
      if (state.currentEntry) {
        hydrateDraftFromEntry(state.currentEntry, { preserveMode: true });
      } else {
        state.draftPunches = [{ in: '', out: '' }];
        state.punchDirty = false;
        renderPunchList();
      }
    };

    const changeDate = (deltaDays) => {
      hydrateDate(shiftIso(state.currentDate, deltaDays));
    };

    const bindEvents = () => {
      if (dom.tabManual) dom.tabManual.onclick = () => setMode('manual');
      if (dom.tabPunch) dom.tabPunch.onclick = () => setMode('punch');
      if (dom.punchToggle) dom.punchToggle.onclick = togglePunch;
      if (dom.punchSave) dom.punchSave.onclick = saveEntry;
      if (dom.punchDelete) dom.punchDelete.onclick = deleteEntry;
      if (dom.punchDiscard) dom.punchDiscard.onclick = discardPunchChanges;
      if (dom.manualSave) dom.manualSave.onclick = saveEntry;
      if (dom.manualDelete) dom.manualDelete.onclick = deleteEntry;
      if (dom.manualCancel) dom.manualCancel.onclick = cancelManualEdit;
      if (dom.datePrev) dom.datePrev.onclick = () => changeDate(-1);
      if (dom.dateNext) dom.dateNext.onclick = () => changeDate(1);
      if (dom.dateLabel) dom.dateLabel.onclick = openDatePicker;
      if (dom.datePickerClose) dom.datePickerClose.onclick = closeDatePicker;
      if (dom.dateMonthPrev) dom.dateMonthPrev.onclick = () => {
        if (state.datePicker.year == null || state.datePicker.month == null) return;
        const prev = new Date(state.datePicker.year, state.datePicker.month - 1, 1);
        state.datePicker.year = prev.getFullYear();
        state.datePicker.month = prev.getMonth();
        renderDatePicker();
      };
      if (dom.dateMonthNext) dom.dateMonthNext.onclick = () => {
        if (state.datePicker.year == null || state.datePicker.month == null) return;
        const next = new Date(state.datePicker.year, state.datePicker.month + 1, 1);
        state.datePicker.year = next.getFullYear();
        state.datePicker.month = next.getMonth();
        renderDatePicker();
      };
      if (dom.datePicker) {
        dom.datePicker.addEventListener('click', (event) => {
          if (event.target === dom.datePicker) closeDatePicker();
        });
      }
      if (dom.manualHourType) dom.manualHourType.onchange = () => selectHourType(dom.manualHourType.value);
      if (dom.punchHourType) dom.punchHourType.onchange = () => selectHourType(dom.punchHourType.value);
      if (dom.manualContract) dom.manualContract.onchange = () => renderContracts({ manualPreferred: dom.manualContract.value });
      if (dom.punchContract) dom.punchContract.onchange = () => renderContracts({ punchPreferred: dom.punchContract.value });
      if (dom.hours) dom.hours.oninput = () => { state.draftHours = dom.hours.value; };
    };

    const init = async () => {
      run('api_getWebAppUrl').then((url) => {
        const desktopLink = document.getElementById('mobile-view-desktop-link');
        const viewSwitch = document.getElementById('mobile-view-switch');
        if (desktopLink && url) {
          desktopLink.href = url;
          if (viewSwitch) viewSwitch.style.display = 'flex';
        }
      });
      bindEvents();
      await hydrateDate(todayIso());
      if (mobileShell.applyTheme && state.settings && state.settings.theme) {
        mobileShell.applyTheme(state.settings.theme);
      }
      syncTabAvailability();
    };

    init();
  })();
</script>
