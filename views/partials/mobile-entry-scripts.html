<script>
  (function () {
    const {
      clampRoundInterval,
      contractIsValid,
      entryCompositeKey,
      isoDateTime,
      minutesToTime,
      normalizePunchList,
      roundDuration,
      sanitizeEntry,
      summarizePunches,
      timeToMinutes,
      todayIso
    } = window.entryCore || {};

    const mobileShell = window.mobileShell || {};
    const run = mobileShell.run || ((fn, payload) => new Promise((resolve) => {
      const handler = (res) => resolve(res);
      const runner = google.script.run.withSuccessHandler(handler).withFailureHandler(() => resolve(null));
      if (typeof runner[fn] === 'function') runner[fn](payload);
      else resolve(null);
    }));

    const CACHE_KEY = 'ts_mobile_entry_cache_v1';
    const CACHE_TTL_MS = 24 * 60 * 60 * 1000; // 24h

    const dom = {
      status: document.getElementById('mobile-status'),
      date: document.getElementById('mobile-date'),
      datePrev: document.getElementById('mobile-date-prev'),
      dateNext: document.getElementById('mobile-date-next'),
      dateToday: document.getElementById('mobile-date-today'),
      tabManual: document.getElementById('mobile-tab-manual'),
      tabPunch: document.getElementById('mobile-tab-punch'),
      hourType: document.getElementById('mobile-hour-type'),
      contract: document.getElementById('mobile-contract'),
      contractWarning: document.getElementById('mobile-contract-warning'),
      panelManual: document.getElementById('mobile-panel-manual'),
      panelPunch: document.getElementById('mobile-panel-punch'),
      hours: document.getElementById('mobile-hours'),
      punchList: document.getElementById('mobile-punch-list'),
      punchSummary: document.getElementById('mobile-punch-summary'),
      punchWarning: document.getElementById('mobile-punch-warning'),
      punchSuggestion: document.getElementById('mobile-punch-suggestion'),
      addPunch: document.getElementById('mobile-add-punch'),
      reset: document.getElementById('mobile-reset'),
      save: document.getElementById('mobile-save'),
      deleteBtn: document.getElementById('mobile-delete'),
      desktopLink: document.getElementById('mobile-desktop-link')
    };

    const state = {
      currentDate: todayIso(),
      mode: 'manual',
      settings: {},
      featureFlags: {},
      contracts: [],
      hourTypes: [],
      hourTypeMap: {},
      entryCache: {},
      entries: [],
      draftHours: '',
      draftPunches: [{ in: '', out: '' }],
      currentEntry: null,
      loading: false,
      staticLoaded: false,
      prefetchedRange: null,
      cacheHydrated: false
    };

    const setStatus = (message, tone = 'info') => {
      if (!dom.status) return;
      dom.status.textContent = message || '';
      dom.status.className = 'ts-mobile-row ts-mobile-status';
      if (tone === 'error') dom.status.classList.add('ts-warning');
      else dom.status.classList.add('ts-note');
    };

    const shiftIso = (iso, deltaDays) => {
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return todayIso();
      d.setDate(d.getDate() + deltaDays);
      return d.toISOString().slice(0, 10);
    };

    const defaultHourTypeId = () => {
      if (!state.hourTypes.length) return '';
      const preferred = state.hourTypes.find((ht) => ht.is_default);
      return (preferred || state.hourTypes[0]).id;
    };

    const roundInterval = () => clampRoundInterval(state.settings ? state.settings.round_to_nearest : 0);

    const renderHourTypes = () => {
      if (!dom.hourType) return;
      dom.hourType.innerHTML = '';
      state.hourTypes.forEach((ht) => {
        const opt = document.createElement('option');
        opt.value = ht.id;
        opt.textContent = ht.name || 'Work';
        dom.hourType.appendChild(opt);
      });
      dom.hourType.value = state.currentEntry?.hour_type_id || defaultHourTypeId();
    };

    const validContractsForDate = (dateIso) => state.contracts.filter((c) => contractIsValid(c, dateIso));

    const renderContracts = () => {
      if (!dom.contract) return;
      const dateIso = state.currentDate;
      const hourType = state.hourTypeMap[dom.hourType.value] || {};
      const requiresContract = !!hourType.requires_contract;
      const valid = validContractsForDate(dateIso);
      dom.contract.innerHTML = '';
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = requiresContract ? 'Select contract' : (valid.length ? 'No contract (optional)' : 'Not required');
      dom.contract.appendChild(opt);
      valid.forEach((c) => {
        const option = document.createElement('option');
        option.value = c.id;
        option.textContent = c.name;
        dom.contract.appendChild(option);
      });
      const preferred = state.currentEntry ? state.currentEntry.contract_id : '';
      dom.contract.value = preferred || (valid[0] ? valid[0].id : '');
      dom.contract.disabled = requiresContract && !valid.length;
      if (dom.contractWarning) dom.contractWarning.style.display = requiresContract && !dom.contract.value ? 'block' : 'none';
    };

    const setMode = (mode) => {
      state.mode = mode === 'punch' ? 'punch' : 'manual';
      if (dom.tabManual) dom.tabManual.classList.toggle('active', state.mode === 'manual');
      if (dom.tabPunch) dom.tabPunch.classList.toggle('active', state.mode === 'punch');
      if (dom.panelManual) dom.panelManual.style.display = state.mode === 'manual' ? 'block' : 'none';
      if (dom.panelPunch) dom.panelPunch.style.display = state.mode === 'punch' ? 'block' : 'none';
      if (dom.save) dom.save.textContent = state.currentEntry ? 'Update' : 'Save';
      if (dom.deleteBtn) dom.deleteBtn.style.display = state.currentEntry ? 'inline-flex' : 'none';
    };

    const renderPunchList = () => {
      if (!dom.punchList) return;
      const punches = state.draftPunches || [];
      dom.punchList.innerHTML = '';
      punches.forEach((punch, index) => {
        const row = document.createElement('div');
        row.className = 'ts-punch-row';

        const start = document.createElement('input');
        start.type = 'time';
        start.value = punch.in || '';
        start.className = 'ts-punch-input';
        start.onchange = () => {
          state.draftPunches[index].in = start.value;
          updatePunchSummary();
        };

        const end = document.createElement('input');
        end.type = 'time';
        end.value = punch.out || '';
        end.className = 'ts-punch-input';
        end.onchange = () => {
          state.draftPunches[index].out = end.value;
          updatePunchSummary();
        };

        const remove = document.createElement('button');
        remove.type = 'button';
        remove.className = 'ghost';
        remove.textContent = 'Remove';
        remove.onclick = () => {
          state.draftPunches.splice(index, 1);
          if (!state.draftPunches.length) state.draftPunches.push({ in: '', out: '' });
          renderPunchList();
          updatePunchSummary();
        };

        row.appendChild(start);
        row.appendChild(document.createTextNode(' to '));
        row.appendChild(end);
        row.appendChild(remove);
        dom.punchList.appendChild(row);
      });
      updatePunchSummary();
    };

    const addPunchRow = () => {
      state.draftPunches.push({ in: '', out: '' });
      renderPunchList();
    };

    const validatePunches = (punches) => {
      const sorted = normalizePunchList(punches);
      let lastEnd = null;
      for (let i = 0; i < sorted.length; i += 1) {
        const punch = sorted[i];
        const startMinutes = timeToMinutes(punch.in);
        if (startMinutes === null) return 'Each punch needs a start time.';
        const endMinutes = timeToMinutes(punch.out);
        if (endMinutes !== null && endMinutes <= startMinutes) return 'Punch end must be after start.';
        if (lastEnd !== null && startMinutes < lastEnd) return 'Punches cannot overlap.';
        if (endMinutes !== null) lastEnd = endMinutes;
      }
      return '';
    };

    const updatePunchSummary = () => {
      const punches = normalizePunchList(state.draftPunches);
      const summary = summarizePunches(punches);
      if (dom.punchSummary) {
        const rounded = roundDuration(summary.totalMinutes, roundInterval());
        dom.punchSummary.textContent = punches.length ? `Recorded: ${(rounded / 60).toFixed(2)}h` : '';
      }
      if (dom.punchWarning) {
        dom.punchWarning.style.display = summary.openCount > 0 ? 'block' : 'none';
        dom.punchWarning.textContent = summary.openCount > 0 ? 'You have an open punch. Add an end time before saving.' : '';
      }
      if (dom.punchSuggestion) dom.punchSuggestion.style.display = 'none';
    };

    const getCachedEntriesForDate = (dateIso) => state.entryCache[dateIso] || [];

    const storeEntries = (entries) => {
      (entries || []).forEach((entry) => {
        if (!entry || !entry.date) return;
        const existing = getCachedEntriesForDate(entry.date).filter((e) => e.id !== entry.id);
        existing.push(entry);
        state.entryCache[entry.date] = existing;
      });
      console.log('[mobile] cache store', { dates: (entries || []).map((e) => e.date) });
      persistCache();
    };

    const persistCache = () => {
      try {
        const payload = {
          savedAt: Date.now(),
          entries: state.entryCache,
          prefetchedRange: state.prefetchedRange,
          hourTypes: state.hourTypes,
          contracts: state.contracts
        };
        localStorage.setItem(CACHE_KEY, JSON.stringify(payload));
        console.log('[mobile] cache persist', {
          dates: Object.keys(state.entryCache || {}).length,
          hourTypes: (state.hourTypes || []).length,
          contracts: (state.contracts || []).length
        });
      } catch (err) {
        console.log('[mobile] cache persist failed', err);
      }
    };

    const hydrateCacheFromStorage = () => {
      if (state.cacheHydrated) return;
      state.cacheHydrated = true;
      try {
        const raw = localStorage.getItem(CACHE_KEY);
        if (!raw) {
          console.log('[mobile] cache hydrate: empty');
          return;
        }
        const parsed = JSON.parse(raw);
        if (!parsed || !parsed.savedAt) {
          console.log('[mobile] cache hydrate: invalid');
          return;
        }
        const age = Date.now() - parsed.savedAt;
        if (age > CACHE_TTL_MS) {
          console.log('[mobile] cache hydrate: expired', { ageMs: age });
          return;
        }
        state.entryCache = parsed.entries || {};
        state.prefetchedRange = parsed.prefetchedRange || null;
        state.hourTypes = Array.isArray(parsed.hourTypes) ? parsed.hourTypes : state.hourTypes;
        state.hourTypeMap = (state.hourTypes || []).reduce((map, ht) => { map[ht.id] = ht; return map; }, {});
        state.contracts = Array.isArray(parsed.contracts) ? parsed.contracts : state.contracts;
        console.log('[mobile] cache hydrate: restored', {
          dates: Object.keys(state.entryCache || {}).length,
          prefetchedRange: state.prefetchedRange,
          hourTypes: (state.hourTypes || []).length,
          contracts: (state.contracts || []).length
        });
      } catch (err) {
        console.log('[mobile] cache hydrate failed', err);
      }
    };

    const fetchEntriesRange = async (startDate, endDate) => {
      console.log('[mobile] fetchEntriesRange', { startDate, endDate });
      const entries = await run('api_getEntries', { startDate, endDate }) || [];
      const sanitized = entries.map(sanitizeEntry);
      storeEntries(sanitized);
    };

    const prefetchRangeForDate = async (centerIso) => {
      const startIso = shiftIso(centerIso, -14);
      const endIso = shiftIso(centerIso, 14);
      if (state.prefetchedRange && state.prefetchedRange.start <= startIso && state.prefetchedRange.end >= endIso) return;
      console.log('[mobile] prefetchRangeForDate start', { centerIso, startIso, endIso });
      await fetchEntriesRange(startIso, endIso);
      state.prefetchedRange = { start: startIso, end: endIso };
      console.log('[mobile] prefetchRangeForDate done', state.prefetchedRange);
      persistCache();
    };

    const loadEntriesForDate = async (dateIso) => {
      const cached = getCachedEntriesForDate(dateIso);
      if (cached.length) {
        state.entries = cached;
        console.log('[mobile] loadEntriesForDate cache hit', { dateIso, count: cached.length });
        return;
      }
      console.log('[mobile] loadEntriesForDate cache miss', { dateIso });
      await fetchEntriesRange(dateIso, dateIso);
      state.entries = getCachedEntriesForDate(dateIso);
      console.log('[mobile] loadEntriesForDate loaded', { dateIso, count: state.entries.length });
    };

    const pickEntryForHourType = (hourTypeId) => {
      if (!state.entries.length) return null;
      const targetId = hourTypeId || defaultHourTypeId();
      return state.entries.find((e) => (e.hour_type_id || defaultHourTypeId()) === targetId) || state.entries[0];
    };

    const hydrateDraftFromEntry = (entry) => {
      state.currentEntry = entry || null;
      if (entry) {
        if (entry.entry_type === 'advanced') {
          state.mode = 'punch';
          state.draftPunches = entry.punches && entry.punches.length ? entry.punches.map((p) => ({ ...p })) : [{ in: '', out: '' }];
          state.draftHours = '';
        } else {
          state.mode = 'manual';
          const summary = summarizePunches(entry.punches || []);
          const minutes = summary.totalMinutes || Number(entry.duration_minutes) || 0;
          state.draftHours = minutes ? (minutes / 60).toFixed(2) : '';
          state.draftPunches = [{ in: '', out: '' }];
        }
        if (dom.hourType && entry.hour_type_id) dom.hourType.value = entry.hour_type_id;
      } else {
        state.mode = 'manual';
        state.draftHours = '';
        state.draftPunches = [{ in: '', out: '' }];
        if (dom.hourType) dom.hourType.value = defaultHourTypeId();
      }
      renderContracts();
      renderPunchList();
      if (dom.hours) dom.hours.value = state.draftHours;
      setMode(state.mode);
    };

    const loadStaticData = async () => {
      if (state.staticLoaded) return true;
      let base = { settings: {}, featureFlags: {} };
      if (mobileShell.loadBaseState) {
        base = await mobileShell.loadBaseState();
      }
      state.settings = base.settings || {};
      state.featureFlags = base.featureFlags || {};
      if (!state.hourTypes.length || !state.contracts.length) {
        const [hourTypes, contracts] = await Promise.all([
          state.hourTypes.length ? Promise.resolve(state.hourTypes) : run('api_getHourTypes'),
          state.contracts.length ? Promise.resolve(state.contracts) : run('api_getContracts')
        ]);
        state.hourTypes = Array.isArray(hourTypes) ? hourTypes : [];
        state.hourTypeMap = state.hourTypes.reduce((map, ht) => { map[ht.id] = ht; return map; }, {});
        state.contracts = Array.isArray(contracts) ? contracts : [];
        persistCache();
      } else {
        state.hourTypeMap = state.hourTypes.reduce((map, ht) => { map[ht.id] = ht; return map; }, {});
      }
      renderHourTypes();
      renderContracts();
      state.staticLoaded = true;
      return true;
    };

    const hydrateDate = async (dateIso) => {
      state.currentDate = dateIso || todayIso();
      if (dom.date) dom.date.value = state.currentDate;
      setStatus('Loading...', 'info');
      hydrateCacheFromStorage();
      await loadStaticData();
      await loadEntriesForDate(state.currentDate);
      renderHourTypes();
      const chosen = pickEntryForHourType(dom.hourType ? dom.hourType.value : defaultHourTypeId());
      hydrateDraftFromEntry(chosen);
      setStatus(state.currentEntry ? 'Loaded existing entry.' : 'Ready to add entry.');
      prefetchRangeForDate(state.currentDate).catch((err) => console.log('[mobile] prefetch error', err));
    };

    const findDuplicate = (payload) => {
      const key = entryCompositeKey(payload.date, payload.hour_type_id, payload.contract_id);
      return state.entries.find((e) => entryCompositeKey(e.date, e.hour_type_id, e.contract_id) === key && e.id !== payload.id) || null;
    };

    const getManualPayload = () => {
      const hoursRaw = dom.hours ? dom.hours.value.trim() : '';
      const totalHours = Number(hoursRaw);
      if (!Number.isFinite(totalHours) || totalHours <= 0) {
        setStatus('Enter total hours greater than zero.', 'error');
        return null;
      }
      const minutes = Math.round(totalHours * 60);
      if (minutes > 24 * 60) {
        setStatus('Hours must be within a single day.', 'error');
        return null;
      }
      const hourTypeId = dom.hourType ? dom.hourType.value || defaultHourTypeId() : defaultHourTypeId();
      const hourType = state.hourTypeMap[hourTypeId] || {};
      const contractId = dom.contract ? dom.contract.value : '';
      if (hourType.requires_contract) {
        if (!contractId) {
          setStatus('Select a contract for this hour type.', 'error');
          return null;
        }
        const contract = state.contracts.find((c) => c.id === contractId);
        if (!contract || !contractIsValid(contract, state.currentDate)) {
          setStatus('Selected contract is not valid for this date.', 'error');
          return null;
        }
      }
      const rounded = roundDuration(minutes, roundInterval());
      return {
        id: state.currentEntry ? state.currentEntry.id : undefined,
        date: state.currentDate,
        punches: [{ in: '00:00', out: minutesToTime(rounded) }],
        duration_minutes: rounded,
        contract_id: contractId,
        hour_type_id: hourTypeId,
        round_interval: roundInterval(),
        entry_type: 'basic'
      };
    };

    const getPunchPayload = () => {
      const punches = normalizePunchList(state.draftPunches);
      if (!punches.length) {
        setStatus('Add at least one punch.', 'error');
        return null;
      }
      const validationError = validatePunches(punches);
      if (validationError) {
        setStatus(validationError, 'error');
        return null;
      }
      const hourTypeId = dom.hourType ? dom.hourType.value || defaultHourTypeId() : defaultHourTypeId();
      const hourType = state.hourTypeMap[hourTypeId] || {};
      const contractId = dom.contract ? dom.contract.value : '';
      if (hourType.requires_contract) {
        if (!contractId) {
          setStatus('Select a contract for this hour type.', 'error');
          return null;
        }
        const contract = state.contracts.find((c) => c.id === contractId);
        if (!contract || !contractIsValid(contract, state.currentDate)) {
          setStatus('Selected contract is not valid for this date.', 'error');
          return null;
        }
      }
      const summary = summarizePunches(punches);
      const rounded = roundDuration(summary.totalMinutes, roundInterval());
      return {
        id: state.currentEntry ? state.currentEntry.id : undefined,
        date: state.currentDate,
        punches,
        duration_minutes: rounded,
        contract_id: contractId,
        hour_type_id: hourTypeId,
        round_interval: roundInterval(),
        entry_type: 'advanced'
      };
    };

    const setLoading = (flag) => {
      state.loading = flag;
      [dom.save, dom.deleteBtn, dom.reset, dom.addPunch, dom.datePrev, dom.dateNext, dom.dateToday].forEach((el) => {
        if (!el) return;
        el.disabled = flag;
      });
    };

    const saveEntry = async () => {
      if (state.loading) return;
      const payload = state.mode === 'punch' ? getPunchPayload() : getManualPayload();
      if (!payload) return;
      const duplicate = findDuplicate(payload);
      if (duplicate) {
        setStatus('An entry for this date/hour type already exists.', 'error');
        hydrateDraftFromEntry(duplicate);
        return;
      }
      setLoading(true);
      setStatus('Saving...', 'info');
      const isUpdate = !!payload.id;
      const fn = isUpdate ? 'api_updateEntry' : 'api_addEntry';
      const optimisticId = payload.id || ('temp_' + Date.now());
      const optimistic = sanitizeEntry({ ...payload, id: optimisticId, created_at: isoDateTime(new Date()) });
      if (!isUpdate) {
        state.entries.push(optimistic);
        storeEntries([optimistic]);
      }
      const res = await run(fn, payload);
      if (res && res.success && res.entry) {
        const confirmed = sanitizeEntry(res.entry);
        storeEntries([confirmed]);
        state.entries = getCachedEntriesForDate(state.currentDate);
        hydrateDraftFromEntry(confirmed);
        renderCalendar();
        setStatus('Saved.', 'success');
      } else {
        if (!isUpdate) {
          const filtered = getCachedEntriesForDate(state.currentDate).filter((e) => e.id !== optimisticId);
          state.entryCache[state.currentDate] = filtered;
          state.entries = filtered;
        }
        setStatus('Save failed. Please try again.', 'error');
      }
      setLoading(false);
    };

    const deleteEntry = async () => {
      if (state.loading) return;
      if (!state.currentEntry) {
        setStatus('Nothing to delete.', 'error');
        return;
      }
      setLoading(true);
      setStatus('Deleting...', 'info');
      const id = state.currentEntry.id;
      const res = await run('api_deleteEntry', id);
      if (res === null) {
        setStatus('Delete failed. Please try again.', 'error');
      } else {
        const filtered = getCachedEntriesForDate(state.currentDate).filter((e) => e.id !== id);
        state.entryCache[state.currentDate] = filtered;
        state.entries = filtered;
        state.currentEntry = null;
        state.draftHours = '';
        state.draftPunches = [{ in: '', out: '' }];
        hydrateDraftFromEntry(null);
        renderCalendar();
        setStatus('Deleted.', 'success');
      }
      setLoading(false);
    };

    const resetDraft = () => {
      state.currentEntry = null;
      state.draftHours = '';
      state.draftPunches = [{ in: '', out: '' }];
      renderContracts();
      renderPunchList();
      if (dom.hours) dom.hours.value = '';
      setMode('manual');
      setStatus('Reset. Ready to add.', 'info');
    };

    const changeDate = (deltaDays) => {
      hydrateDate(shiftIso(state.currentDate, deltaDays));
    };

    const bindEvents = () => {
      if (dom.tabManual) dom.tabManual.onclick = () => setMode('manual');
      if (dom.tabPunch) dom.tabPunch.onclick = () => setMode('punch');
      if (dom.addPunch) dom.addPunch.onclick = addPunchRow;
      if (dom.save) dom.save.onclick = saveEntry;
      if (dom.deleteBtn) dom.deleteBtn.onclick = deleteEntry;
      if (dom.reset) dom.reset.onclick = resetDraft;
      if (dom.date) dom.date.onchange = () => hydrateDate(dom.date.value || todayIso());
      if (dom.datePrev) dom.datePrev.onclick = () => changeDate(-1);
      if (dom.dateNext) dom.dateNext.onclick = () => changeDate(1);
      if (dom.dateToday) dom.dateToday.onclick = () => hydrateDate(todayIso());
      if (dom.hourType) dom.hourType.onchange = () => {
        renderContracts();
        const entry = pickEntryForHourType(dom.hourType.value);
        hydrateDraftFromEntry(entry);
      };
      if (dom.contract) dom.contract.onchange = () => renderContracts();
      if (dom.hours) dom.hours.oninput = () => { state.draftHours = dom.hours.value; };
      if (dom.desktopLink) {
        dom.desktopLink.addEventListener('click', (e) => {
          e.preventDefault();
          const target = window.location.origin + window.location.pathname;
          window.location.href = target;
        });
      }
    };

    const init = async () => {
      bindEvents();
      await hydrateDate(todayIso());
      if (mobileShell.applyTheme && state.settings && state.settings.theme) {
        mobileShell.applyTheme(state.settings.theme);
      }
    };

    init();
  })();
</script>
